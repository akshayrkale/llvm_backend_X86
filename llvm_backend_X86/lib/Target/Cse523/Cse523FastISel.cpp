//===-- Cse523FastISel.cpp - Cse523 FastISel implementation ---------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines the Cse523-specific support for the FastISel class. Much
// of the target-specific code is generated by tablegen in the file
// Cse523GenFastISel.inc, which is #included here.
//
//===----------------------------------------------------------------------===//

#include "Cse523.h"
#include "Cse523CallingConv.h"
#include "Cse523ISelLowering.h"
#include "Cse523InstrBuilder.h"
#include "Cse523RegisterInfo.h"
#include "Cse523Subtarget.h"
#include "Cse523TargetMachine.h"
#include "llvm/CodeGen/Analysis.h"
#include "llvm/CodeGen/FastISel.h"
#include "llvm/CodeGen/FunctionLoweringInfo.h"
#include "llvm/CodeGen/MachineConstantPool.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/IR/CallingConv.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/GlobalAlias.h"
#include "llvm/IR/GlobalVariable.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/IR/Operator.h"
#include "llvm/Support/CallSite.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/GetElementPtrTypeIterator.h"
#include "llvm/Target/TargetOptions.h"
using namespace llvm;

namespace {

    class Cse523FastISel : public FastISel {
        /// Subtarget - Keep a pointer to the Cse523Subtarget around so that we can
        /// make the right decision when generating code for different targets.
        const Cse523Subtarget *Subtarget;

        /// Cse523ScalarSSEf32, Cse523ScalarSSEf64 - Select between SSE or x87
        /// floating point ops.
        /// When SSE is available, use it for f32 operations.
        /// When SSE2 is available, use it for f64 operations.
        bool Cse523ScalarSSEf64;
        bool Cse523ScalarSSEf32;

        public:
        explicit Cse523FastISel(FunctionLoweringInfo &funcInfo,
                const TargetLibraryInfo *libInfo)
            : FastISel(funcInfo, libInfo) {
                Subtarget = &TM.getSubtarget<Cse523Subtarget>();
                Cse523ScalarSSEf64 = Subtarget->hasSSE2();
                Cse523ScalarSSEf32 = Subtarget->hasSSE1();
            }

        virtual bool TargetSelectInstruction(const Instruction *I);

        /// \brief The specified machine instr operand is a vreg, and that
        /// vreg is being provided by the specified load instruction.  If possible,
        /// try to fold the load as an operand to the instruction, returning true if
        /// possible.
        virtual bool tryToFoldLoadIntoMI(MachineInstr *MI, unsigned OpNo,
                const LoadInst *LI);

        virtual bool FastLowerArguments();

#include "Cse523GenFastISel.inc"

        private:
        bool Cse523FastEmitCompare(const Value *LHS, const Value *RHS, EVT VT);

        bool Cse523FastEmitLoad(EVT VT, const Cse523AddressMode &AM, unsigned &RR);

        bool Cse523FastEmitStore(EVT VT, const Value *Val, const Cse523AddressMode &AM,
                bool Aligned = false);
        bool Cse523FastEmitStore(EVT VT, unsigned ValReg, const Cse523AddressMode &AM,
                bool Aligned = false);

        bool Cse523FastEmitExtend(ISD::NodeType Opc, EVT DstVT, unsigned Src, EVT SrcVT,
                unsigned &ResultReg);

        bool Cse523SelectAddress(const Value *V, Cse523AddressMode &AM);
        bool Cse523SelectCallAddress(const Value *V, Cse523AddressMode &AM);

        bool Cse523SelectLoad(const Instruction *I);

        bool Cse523SelectStore(const Instruction *I);

        bool Cse523SelectRet(const Instruction *I);

        bool Cse523SelectCmp(const Instruction *I);

        bool Cse523SelectZExt(const Instruction *I);

        bool Cse523SelectBranch(const Instruction *I);

        bool Cse523SelectShift(const Instruction *I);

        bool Cse523SelectDivRem(const Instruction *I);

        bool Cse523SelectSelect(const Instruction *I);

        bool Cse523SelectTrunc(const Instruction *I);

        bool Cse523SelectFPExt(const Instruction *I);
        bool Cse523SelectFPTrunc(const Instruction *I);

        bool Cse523VisitIntrinsicCall(const IntrinsicInst &I);
        bool Cse523SelectCall(const Instruction *I);

        bool DoSelectCall(const Instruction *I, const char *MemIntName);

        const Cse523InstrInfo *getInstrInfo() const {
            return getTargetMachine()->getInstrInfo();
        }
        const Cse523TargetMachine *getTargetMachine() const {
            return static_cast<const Cse523TargetMachine *>(&TM);
        }

        bool handleConstantAddresses(const Value *V, Cse523AddressMode &AM);

        unsigned TargetMaterializeConstant(const Constant *C);

        unsigned TargetMaterializeAlloca(const AllocaInst *C);

        unsigned TargetMaterializeFloatZero(const ConstantFP *CF);

        /// isScalarFPTypeInSSEReg - Return true if the specified scalar FP type is
        /// computed in an SSE register, not on the X87 floating point stack.
        bool isScalarFPTypeInSSEReg(EVT VT) const {
            return (VT == MVT::f64 && Cse523ScalarSSEf64) || // f64 is when SSE2
                (VT == MVT::f32 && Cse523ScalarSSEf32);   // f32 is when SSE1
        }

        bool isTypeLegal(Type *Ty, MVT &VT, bool AllowI1 = false);

        bool IsMemcpySmall(uint64_t Len);

        bool TryEmitSmallMemcpy(Cse523AddressMode DestAM,
                Cse523AddressMode SrcAM, uint64_t Len);
    };

} // end anonymous namespace.

bool Cse523FastISel::isTypeLegal(Type *Ty, MVT &VT, bool AllowI1) {
    EVT evt = TLI.getValueType(Ty, /*HandleUnknown=*/true);
    if (evt == MVT::Other || !evt.isSimple())
        // Unhandled type. Halt "fast" selection and bail.
        return false;

    VT = evt.getSimpleVT();
    // For now, require SSE/SSE2 for performing floating-point operations,
    // since x87 requires additional work.
    if (VT == MVT::f64 && !Cse523ScalarSSEf64)
        return false;
    if (VT == MVT::f32 && !Cse523ScalarSSEf32)
        return false;
    // Similarly, no f80 support yet.
    if (VT == MVT::f80)
        return false;
    // We only handle legal types. For example, on cse523-32 the instruction
    // selector contains all of the 64-bit instructions from cse523-64,
    // under the assumption that i64 won't be used if the target doesn't
    // support it.
    return (AllowI1 && VT == MVT::i1) || TLI.isTypeLegal(VT);
}

#include "Cse523GenCallingConv.inc"

/// Cse523FastEmitLoad - Emit a machine instruction to load a value of type VT.
/// The address is either pre-computed, i.e. Ptr, or a GlobalAddress, i.e. GV.
/// Return true and the result register by reference if it is possible.
bool Cse523FastISel::Cse523FastEmitLoad(EVT VT, const Cse523AddressMode &AM,
        unsigned &ResultReg) {
    // Get opcode and regclass of the output for the given load instruction.
    unsigned Opc = 0;
    const TargetRegisterClass *RC = NULL;
    switch (VT.getSimpleVT().SimpleTy) {
        default: return false;
        case MVT::i1:
        case MVT::i8:
        case MVT::i16:
        case MVT::i32:
        case MVT::f32:
        case MVT::f64:
        case MVT::f80:
                 assert(0);
                 return false;

        case MVT::i64:
                 // Must be in cse523-64 mode.
                 Opc = Cse523::MOV64rm;
                 RC  = &Cse523::GR64RegClass;
                 break;
    }

    ResultReg = createResultReg(RC);
    addFullAddress(BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt,
                DbgLoc, TII.get(Opc), ResultReg), AM);
    return true;
}

/// Cse523FastEmitStore - Emit a machine instruction to store a value Val of
/// type VT. The address is either pre-computed, consisted of a base ptr, Ptr
/// and a displacement offset, or a GlobalAddress,
/// i.e. V. Return true if it is possible.
bool
Cse523FastISel::Cse523FastEmitStore(EVT VT, unsigned ValReg,
        const Cse523AddressMode &AM, bool Aligned) {
    // Get opcode and regclass of the output for the given store instruction.
    unsigned Opc = 0;
    switch (VT.getSimpleVT().SimpleTy) {
        case MVT::f80: // No f80 support yet.
        default: return false;
        case MVT::i1: 
        case MVT::i8: 
        case MVT::i16:
        case MVT::i32:
            assert(0);
            break;

        case MVT::i64: Opc = Cse523::MOV64mr; break; // Must be in cse523-64 mode.
        case MVT::f32:
        case MVT::f64:
        case MVT::v4f32:
        case MVT::v2f64:
        case MVT::v4i32:
        case MVT::v2i64:
        case MVT::v8i16:
        case MVT::v16i8:
            assert(0);
            break;
    }

    addFullAddress(BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt,
                DbgLoc, TII.get(Opc)), AM).addReg(ValReg);
    return true;
}

bool Cse523FastISel::Cse523FastEmitStore(EVT VT, const Value *Val,
        const Cse523AddressMode &AM, bool Aligned) {
    // Handle 'null' like i32/i64 0.
    if (isa<ConstantPointerNull>(Val))
        Val = Constant::getNullValue(DL.getIntPtrType(Val->getContext()));

    // If this is a store of a simple constant, fold the constant into the store.
    if (const ConstantInt *CI = dyn_cast<ConstantInt>(Val)) {
        unsigned Opc = 0;
        bool Signed = true;
        switch (VT.getSimpleVT().SimpleTy) {
            default: break;
            case MVT::i1:
            case MVT::i8: 
            case MVT::i16:
            case MVT::i32:
                     assert(0);
                     break;
            case MVT::i64:
                     // Must be a 32-bit sign extended value.
                     if (isInt<32>(CI->getSExtValue()))
                         Opc = Cse523::MOV64mi32;
                     break;
        }

        if (Opc) {
            addFullAddress(BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt,
                        DbgLoc, TII.get(Opc)), AM)
                .addImm(Signed ? (uint64_t) CI->getSExtValue() :
                        CI->getZExtValue());
            return true;
        }
    }

    unsigned ValReg = getRegForValue(Val);
    if (ValReg == 0)
        return false;

    return Cse523FastEmitStore(VT, ValReg, AM, Aligned);
}

/// Cse523FastEmitExtend - Emit a machine instruction to extend a value Src of
/// type SrcVT to type DstVT using the specified extension opcode Opc (e.g.
/// ISD::SIGN_EXTEND).
bool Cse523FastISel::Cse523FastEmitExtend(ISD::NodeType Opc, EVT DstVT,
        unsigned Src, EVT SrcVT,
        unsigned &ResultReg) {
    unsigned RR = FastEmit_r(SrcVT.getSimpleVT(), DstVT.getSimpleVT(), Opc,
            Src, /*TODO: Kill=*/false);
    if (RR == 0)
        return false;

    ResultReg = RR;
    return true;
}

bool Cse523FastISel::handleConstantAddresses(const Value *V, Cse523AddressMode &AM) {
    // Handle constant address.
    if (const GlobalValue *GV = dyn_cast<GlobalValue>(V)) {
        // Can't handle alternate code models yet.
        if (TM.getCodeModel() != CodeModel::Small)
            return false;

        // Can't handle TLS yet.
        if (const GlobalVariable *GVar = dyn_cast<GlobalVariable>(GV))
            if (GVar->isThreadLocal())
                return false;

        // Can't handle TLS yet, part 2 (this is slightly crazy, but this is how
        // it works...).
        if (const GlobalAlias *GA = dyn_cast<GlobalAlias>(GV))
            if (const GlobalVariable *GVar =
                    dyn_cast_or_null<GlobalVariable>(GA->resolveAliasedGlobal(false)))
                if (GVar->isThreadLocal())
                    return false;

        // RIP-relative addresses can't have additional register operands, so if
        // we've already folded stuff into the addressing mode, just force the
        // global value into its own register, which we can use as the basereg.
        if (!Subtarget->isPICStyleRIPRel() ||
                (AM.Base.Reg == 0 && AM.IndexReg == 0)) {
            // Okay, we've committed to selecting this global. Set up the address.
            AM.GV = GV;

            // Allow the subtarget to classify the global.
            unsigned char GVFlags = Subtarget->ClassifyGlobalReference(GV, TM);

            // If this reference is relative to the pic base, set it now.
            if (isGlobalRelativeToPICBase(GVFlags)) {
                // FIXME: How do we know Base.Reg is free??
                AM.Base.Reg = getInstrInfo()->getGlobalBaseReg(FuncInfo.MF);
            }

            // Unless the ABI requires an extra load, return a direct reference to
            // the global.
            if (!isGlobalStubReference(GVFlags)) {
                if (Subtarget->isPICStyleRIPRel()) {
                    // Use rip-relative addressing if we can.  Above we verified that the
                    // base and index registers are unused.
                    assert(AM.Base.Reg == 0 && AM.IndexReg == 0);
                    AM.Base.Reg = Cse523::RIP;
                }
                AM.GVOpFlags = GVFlags;
                return true;
            }

            // Ok, we need to do a load from a stub.  If we've already loaded from
            // this stub, reuse the loaded pointer, otherwise emit the load now.
            DenseMap<const Value*, unsigned>::iterator I = LocalValueMap.find(V);
            unsigned LoadReg;
            if (I != LocalValueMap.end() && I->second != 0) {
                LoadReg = I->second;
            } else {
                // Issue load from stub.
                unsigned Opc = 0;
                const TargetRegisterClass *RC = NULL;
                Cse523AddressMode StubAM;
                StubAM.Base.Reg = AM.Base.Reg;
                StubAM.GV = GV;
                StubAM.GVOpFlags = GVFlags;

                // Prepare for inserting code in the local-value area.
                SavePoint SaveInsertPt = enterLocalValueArea();

                if (TLI.getPointerTy() == MVT::i64) {
                    Opc = Cse523::MOV64rm;
                    RC  = &Cse523::GR64RegClass;

                    if (Subtarget->isPICStyleRIPRel())
                        StubAM.Base.Reg = Cse523::RIP;
                } else {
                    assert(0);
                }

                LoadReg = createResultReg(RC);
                MachineInstrBuilder LoadMI =
                    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Opc), LoadReg);
                addFullAddress(LoadMI, StubAM);

                // Ok, back to normal mode.
                leaveLocalValueArea(SaveInsertPt);

                // Prevent loading GV stub multiple times in same MBB.
                LocalValueMap[V] = LoadReg;
            }

            // Now construct the final address. Note that the Disp, Scale,
            // and Index values may already be set here.
            AM.Base.Reg = LoadReg;
            AM.GV = 0;
            return true;
        }
    }

    // If all else fails, try to materialize the value in a register.
    if (!AM.GV || !Subtarget->isPICStyleRIPRel()) {
        if (AM.Base.Reg == 0) {
            AM.Base.Reg = getRegForValue(V);
            return AM.Base.Reg != 0;
        }
        if (AM.IndexReg == 0) {
            assert(AM.Scale == 1 && "Scale with no index!");
            AM.IndexReg = getRegForValue(V);
            return AM.IndexReg != 0;
        }
    }

    return false;
}

/// Cse523SelectAddress - Attempt to fill in an address from the given value.
///
bool Cse523FastISel::Cse523SelectAddress(const Value *V, Cse523AddressMode &AM) {
    SmallVector<const Value *, 32> GEPs;
redo_gep:
    const User *U = NULL;
    unsigned Opcode = Instruction::UserOp1;
    if (const Instruction *I = dyn_cast<Instruction>(V)) {
        // Don't walk into other basic blocks; it's possible we haven't
        // visited them yet, so the instructions may not yet be assigned
        // virtual registers.
        if (FuncInfo.StaticAllocaMap.count(static_cast<const AllocaInst *>(V)) ||
                FuncInfo.MBBMap[I->getParent()] == FuncInfo.MBB) {
            Opcode = I->getOpcode();
            U = I;
        }
    } else if (const ConstantExpr *C = dyn_cast<ConstantExpr>(V)) {
        Opcode = C->getOpcode();
        U = C;
    }

    if (PointerType *Ty = dyn_cast<PointerType>(V->getType()))
        if (Ty->getAddressSpace() > 255)
            // Fast instruction selection doesn't support the special
            // address spaces.
            return false;

    switch (Opcode) {
        default: break;
        case Instruction::BitCast:
                 // Look past bitcasts.
                 return Cse523SelectAddress(U->getOperand(0), AM);

        case Instruction::IntToPtr:
                 // Look past no-op inttoptrs.
                 if (TLI.getValueType(U->getOperand(0)->getType()) == TLI.getPointerTy())
                     return Cse523SelectAddress(U->getOperand(0), AM);
                 break;

        case Instruction::PtrToInt:
                 // Look past no-op ptrtoints.
                 if (TLI.getValueType(U->getType()) == TLI.getPointerTy())
                     return Cse523SelectAddress(U->getOperand(0), AM);
                 break;

        case Instruction::Alloca: {
                                      // Do static allocas.
                                      const AllocaInst *A = cast<AllocaInst>(V);
                                      DenseMap<const AllocaInst*, int>::iterator SI =
                                          FuncInfo.StaticAllocaMap.find(A);
                                      if (SI != FuncInfo.StaticAllocaMap.end()) {
                                          AM.BaseType = Cse523AddressMode::FrameIndexBase;
                                          AM.Base.FrameIndex = SI->second;
                                          return true;
                                      }
                                      break;
                                  }

        case Instruction::Add: {
                                   // Adds of constants are common and easy enough.
                                   if (const ConstantInt *CI = dyn_cast<ConstantInt>(U->getOperand(1))) {
                                       uint64_t Disp = (int32_t)AM.Disp + (uint64_t)CI->getSExtValue();
                                       // They have to fit in the 32-bit signed displacement field though.
                                       if (isInt<32>(Disp)) {
                                           AM.Disp = (uint32_t)Disp;
                                           return Cse523SelectAddress(U->getOperand(0), AM);
                                       }
                                   }
                                   break;
                               }

        case Instruction::GetElementPtr: {
                                             Cse523AddressMode SavedAM = AM;

                                             // Pattern-match simple GEPs.
                                             uint64_t Disp = (int32_t)AM.Disp;
                                             unsigned IndexReg = AM.IndexReg;
                                             unsigned Scale = AM.Scale;
                                             gep_type_iterator GTI = gep_type_begin(U);
                                             // Iterate through the indices, folding what we can. Constants can be
                                             // folded, and one dynamic index can be handled, if the scale is supported.
                                             for (User::const_op_iterator i = U->op_begin() + 1, e = U->op_end();
                                                     i != e; ++i, ++GTI) {
                                                 const Value *Op = *i;
                                                 if (StructType *STy = dyn_cast<StructType>(*GTI)) {
                                                     const StructLayout *SL = DL.getStructLayout(STy);
                                                     Disp += SL->getElementOffset(cast<ConstantInt>(Op)->getZExtValue());
                                                     continue;
                                                 }

                                                 // A array/variable index is always of the form i*S where S is the
                                                 // constant scale size.  See if we can push the scale into immediates.
                                                 uint64_t S = DL.getTypeAllocSize(GTI.getIndexedType());
                                                 for (;;) {
                                                     if (const ConstantInt *CI = dyn_cast<ConstantInt>(Op)) {
                                                         // Constant-offset addressing.
                                                         Disp += CI->getSExtValue() * S;
                                                         break;
                                                     }
                                                     if (canFoldAddIntoGEP(U, Op)) {
                                                         // A compatible add with a constant operand. Fold the constant.
                                                         ConstantInt *CI =
                                                             cast<ConstantInt>(cast<AddOperator>(Op)->getOperand(1));
                                                         Disp += CI->getSExtValue() * S;
                                                         // Iterate on the other operand.
                                                         Op = cast<AddOperator>(Op)->getOperand(0);
                                                         continue;
                                                     }
                                                     if (IndexReg == 0 &&
                                                             (!AM.GV || !Subtarget->isPICStyleRIPRel()) &&
                                                             (S == 1 || S == 2 || S == 4 || S == 8)) {
                                                         // Scaled-index addressing.
                                                         Scale = S;
                                                         IndexReg = getRegForGEPIndex(Op).first;
                                                         if (IndexReg == 0)
                                                             return false;
                                                         break;
                                                     }
                                                     // Unsupported.
                                                     goto unsupported_gep;
                                                 }
                                             }

                                             // Check for displacement overflow.
                                             if (!isInt<32>(Disp))
                                                 break;

                                             AM.IndexReg = IndexReg;
                                             AM.Scale = Scale;
                                             AM.Disp = (uint32_t)Disp;
                                             GEPs.push_back(V);

                                             if (const GetElementPtrInst *GEP =
                                                     dyn_cast<GetElementPtrInst>(U->getOperand(0))) {
                                                 // Ok, the GEP indices were covered by constant-offset and scaled-index
                                                 // addressing. Update the address state and move on to examining the base.
                                                 V = GEP;
                                                 goto redo_gep;
                                             } else if (Cse523SelectAddress(U->getOperand(0), AM)) {
                                                 return true;
                                             }

                                             // If we couldn't merge the gep value into this addr mode, revert back to
                                             // our address and just match the value instead of completely failing.
                                             AM = SavedAM;

                                             for (SmallVectorImpl<const Value *>::reverse_iterator
                                                     I = GEPs.rbegin(), E = GEPs.rend(); I != E; ++I)
                                                 if (handleConstantAddresses(*I, AM))
                                                     return true;

                                             return false;
unsupported_gep:
                                             // Ok, the GEP indices weren't all covered.
                                             break;
                                         }
    }

    return handleConstantAddresses(V, AM);
}

/// Cse523SelectCallAddress - Attempt to fill in an address from the given value.
///
bool Cse523FastISel::Cse523SelectCallAddress(const Value *V, Cse523AddressMode &AM) {
    const User *U = NULL;
    unsigned Opcode = Instruction::UserOp1;
    const Instruction *I = dyn_cast<Instruction>(V);
    // Record if the value is defined in the same basic block.
    //
    // This information is crucial to know whether or not folding an
    // operand is valid.
    // Indeed, FastISel generates or reuses a virtual register for all
    // operands of all instructions it selects. Obviously, the definition and
    // its uses must use the same virtual register otherwise the produced
    // code is incorrect.
    // Before instruction selection, FunctionLoweringInfo::set sets the virtual
    // registers for values that are alive across basic blocks. This ensures
    // that the values are consistently set between across basic block, even
    // if different instruction selection mechanisms are used (e.g., a mix of
    // SDISel and FastISel).
    // For values local to a basic block, the instruction selection process
    // generates these virtual registers with whatever method is appropriate
    // for its needs. In particular, FastISel and SDISel do not share the way
    // local virtual registers are set.
    // Therefore, this is impossible (or at least unsafe) to share values
    // between basic blocks unless they use the same instruction selection
    // method, which is not guarantee for Cse523.
    // Moreover, things like hasOneUse could not be used accurately, if we
    // allow to reference values across basic blocks whereas they are not
    // alive across basic blocks initially.
    bool InMBB = true;
    if (I) {
        Opcode = I->getOpcode();
        U = I;
        InMBB = I->getParent() == FuncInfo.MBB->getBasicBlock();
    } else if (const ConstantExpr *C = dyn_cast<ConstantExpr>(V)) {
        Opcode = C->getOpcode();
        U = C;
    }

    switch (Opcode) {
        default: break;
        case Instruction::BitCast:
                 // Look past bitcasts if its operand is in the same BB.
                 if (InMBB)
                     return Cse523SelectCallAddress(U->getOperand(0), AM);
                 break;

        case Instruction::IntToPtr:
                 // Look past no-op inttoptrs if its operand is in the same BB.
                 if (InMBB &&
                         TLI.getValueType(U->getOperand(0)->getType()) == TLI.getPointerTy())
                     return Cse523SelectCallAddress(U->getOperand(0), AM);
                 break;

        case Instruction::PtrToInt:
                 // Look past no-op ptrtoints if its operand is in the same BB.
                 if (InMBB &&
                         TLI.getValueType(U->getType()) == TLI.getPointerTy())
                     return Cse523SelectCallAddress(U->getOperand(0), AM);
                 break;
    }

    // Handle constant address.
    if (const GlobalValue *GV = dyn_cast<GlobalValue>(V)) {
        // Can't handle alternate code models yet.
        if (TM.getCodeModel() != CodeModel::Small)
            return false;

        // RIP-relative addresses can't have additional register operands.
        if (Subtarget->isPICStyleRIPRel() &&
                (AM.Base.Reg != 0 || AM.IndexReg != 0))
            return false;

        // Can't handle DbgLocLImport.
        if (GV->hasDLLImportStorageClass())
            return false;

        // Can't handle TLS.
        if (const GlobalVariable *GVar = dyn_cast<GlobalVariable>(GV))
            if (GVar->isThreadLocal())
                return false;

        // Okay, we've committed to selecting this global. Set up the basic address.
        AM.GV = GV;

        // No ABI requires an extra load for anything other than DLLImport, which
        // we rejected above. Return a direct reference to the global.
        if (Subtarget->isPICStyleRIPRel()) {
            // Use rip-relative addressing if we can.  Above we verified that the
            // base and index registers are unused.
            assert(AM.Base.Reg == 0 && AM.IndexReg == 0);
            AM.Base.Reg = Cse523::RIP;
        } else if (Subtarget->isPICStyleStubPIC()) {
            AM.GVOpFlags = Cse523II::MO_PIC_BASE_OFFSET;
        } else if (Subtarget->isPICStyleGOT()) {
            AM.GVOpFlags = Cse523II::MO_GOTOFF;
        }

        return true;
    }

    // If all else fails, try to materialize the value in a register.
    if (!AM.GV || !Subtarget->isPICStyleRIPRel()) {
        if (AM.Base.Reg == 0) {
            AM.Base.Reg = getRegForValue(V);
            return AM.Base.Reg != 0;
        }
        if (AM.IndexReg == 0) {
            assert(AM.Scale == 1 && "Scale with no index!");
            AM.IndexReg = getRegForValue(V);
            return AM.IndexReg != 0;
        }
    }

    return false;
}


/// Cse523SelectStore - Select and emit code to implement store instructions.
bool Cse523FastISel::Cse523SelectStore(const Instruction *I) {
    // Atomic stores need special handling.
    const StoreInst *S = cast<StoreInst>(I);

    if (S->isAtomic())
        return false;

    unsigned SABIAlignment =
        DL.getABITypeAlignment(S->getValueOperand()->getType());
    bool Aligned = S->getAlignment() == 0 || S->getAlignment() >= SABIAlignment;

    MVT VT;
    if (!isTypeLegal(I->getOperand(0)->getType(), VT, /*AllowI1=*/true))
        return false;

    Cse523AddressMode AM;
    if (!Cse523SelectAddress(I->getOperand(1), AM))
        return false;

    return Cse523FastEmitStore(VT, I->getOperand(0), AM, Aligned);
}

/// Cse523SelectRet - Select and emit code to implement ret instructions.
bool Cse523FastISel::Cse523SelectRet(const Instruction *I) {
    const ReturnInst *Ret = cast<ReturnInst>(I);
    const Function &F = *I->getParent()->getParent();
    const Cse523MachineFunctionInfo *Cse523MFInfo =
        FuncInfo.MF->getInfo<Cse523MachineFunctionInfo>();

    if (!FuncInfo.CanLowerReturn)
        return false;

    CallingConv::ID CC = F.getCallingConv();
    if (CC != CallingConv::C &&
            CC != CallingConv::Fast &&
            CC != CallingConv::X86_FastCall &&
            CC != CallingConv::X86_64_SysV)
        return false;

    if (Subtarget->isCallingConvWin64(CC))
        return false;

    // Don't handle popping bytes on return for now.
    if (Cse523MFInfo->getBytesToPopOnReturn() != 0)
        return false;

    // fastcc with -tailcallopt is intended to provide a guaranteed
    // tail call optimization. Fastisel doesn't know how to do that.
    if (CC == CallingConv::Fast && TM.Options.GuaranteedTailCallOpt)
        return false;

    // Let SDISel handle vararg functions.
    if (F.isVarArg())
        return false;

    // Build a list of return value registers.
    SmallVector<unsigned, 4> RetRegs;

    if (Ret->getNumOperands() > 0) {
        SmallVector<ISD::OutputArg, 4> Outs;
        GetReturnInfo(F.getReturnType(), F.getAttributes(), Outs, TLI);

        // Analyze operands of the call, assigning locations to each operand.
        SmallVector<CCValAssign, 16> ValLocs;
        CCState CCInfo(CC, F.isVarArg(), *FuncInfo.MF, TM, ValLocs,
                I->getContext());
        CCInfo.AnalyzeReturn(Outs, RetCC_Cse523);

        const Value *RV = Ret->getOperand(0);
        unsigned Reg = getRegForValue(RV);
        if (Reg == 0)
            return false;

        // Only handle a single return value for now.
        if (ValLocs.size() != 1)
            return false;

        CCValAssign &VA = ValLocs[0];

        // Don't bother handling odd stuff for now.
        if (VA.getLocInfo() != CCValAssign::Full)
            return false;
        // Only handle register returns for now.
        if (!VA.isRegLoc())
            return false;

        unsigned SrcReg = Reg + VA.getValNo();
        EVT SrcVT = TLI.getValueType(RV->getType());
        EVT DstVT = VA.getValVT();
        // Special handling for extended integers.
        if (SrcVT != DstVT) {
            if (SrcVT != MVT::i1 && SrcVT != MVT::i8 && SrcVT != MVT::i16)
                return false;

            if (!Outs[0].Flags.isZExt() && !Outs[0].Flags.isSExt())
                return false;

            assert(DstVT == MVT::i32 && "Cse523 should always ext to i32");

            if (SrcVT == MVT::i1) {
                if (Outs[0].Flags.isSExt())
                    return false;
                SrcReg = FastEmitZExtFromI1(MVT::i8, SrcReg, /*TODO: Kill=*/false);
                SrcVT = MVT::i8;
            }
            unsigned Op = Outs[0].Flags.isZExt() ? ISD::ZERO_EXTEND :
                ISD::SIGN_EXTEND;
            SrcReg = FastEmit_r(SrcVT.getSimpleVT(), DstVT.getSimpleVT(), Op,
                    SrcReg, /*TODO: Kill=*/false);
        }

        // Make the copy.
        unsigned DstReg = VA.getLocReg();
        const TargetRegisterClass* SrcRC = MRI.getRegClass(SrcReg);
        // Avoid a cross-class copy. This is very unlikely.
        if (!SrcRC->contains(DstReg))
            return false;
        BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(TargetOpcode::COPY),
                DstReg).addReg(SrcReg);

        // Add register to return instruction.
        RetRegs.push_back(VA.getLocReg());
    }

    // The cse523-64 ABI for returning structs by value requires that we copy
    // the sret argument into %rax for the return. We saved the argument into
    // a virtual register in the entry block, so now we copy the value out
    // and into %rax. We also do the same with %eax for Win32.
    if (F.hasStructRetAttr() &&
            (Subtarget->is64Bit() || Subtarget->isTargetWindows())) {
        unsigned Reg = Cse523MFInfo->getSRetReturnReg();
        assert(Reg &&
                "SRetReturnReg should have been set in LowerFormalArguments()!");
        unsigned RetReg = Cse523::RAX;
        BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(TargetOpcode::COPY),
                RetReg).addReg(Reg);
        RetRegs.push_back(RetReg);
    }

    // Now emit the RET.
    MachineInstrBuilder MIB =
        BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Cse523::RETQ));
    for (unsigned i = 0, e = RetRegs.size(); i != e; ++i)
        MIB.addReg(RetRegs[i], RegState::Implicit);
    return true;
}

/// Cse523SelectLoad - Select and emit code to implement load instructions.
///
bool Cse523FastISel::Cse523SelectLoad(const Instruction *I)  {
    // Atomic loads need special handling.
    if (cast<LoadInst>(I)->isAtomic())
        return false;

    MVT VT;
    if (!isTypeLegal(I->getType(), VT, /*AllowI1=*/true))
        return false;

    Cse523AddressMode AM;
    if (!Cse523SelectAddress(I->getOperand(0), AM))
        return false;

    unsigned ResultReg = 0;
    if (Cse523FastEmitLoad(VT, AM, ResultReg)) {
        UpdateValueMap(I, ResultReg);
        return true;
    }
    return false;
}

static unsigned Cse523ChooseCmpOpcode(EVT VT, const Cse523Subtarget *Subtarget) {
    bool HasAVX = Subtarget->hasAVX();
    bool Cse523ScalarSSEf32 = Subtarget->hasSSE1();
    bool Cse523ScalarSSEf64 = Subtarget->hasSSE2();

    switch (VT.getSimpleVT().SimpleTy) {
        default:       return 0;
        case MVT::i8: 
        case MVT::i16:
        case MVT::i32:
        case MVT::f32:
        case MVT::f64:
                       assert(0);
        case MVT::i64: return Cse523::CMP64rr;
    }
}

/// Cse523ChooseCmpImmediateOpcode - If we have a comparison with RHS as the RHS
/// of the comparison, return an opcode that works for the compare (e.g.
/// CMP32ri) otherwise return 0.
static unsigned Cse523ChooseCmpImmediateOpcode(EVT VT, const ConstantInt *RHSC) {
    switch (VT.getSimpleVT().SimpleTy) {
        // Otherwise, we can't fold the immediate into this comparison.
        default: return 0;
        case MVT::i8: 
        case MVT::i16:
        case MVT::i32:
                 assert(0);
        case MVT::i64:
                 // 64-bit comparisons are only valid if the immediate fits in a 32-bit sext
                 // field.
                 if ((int)RHSC->getSExtValue() == RHSC->getSExtValue())
                     return Cse523::CMP64ri32;
                 return 0;
    }
}

bool Cse523FastISel::Cse523FastEmitCompare(const Value *Op0, const Value *Op1,
        EVT VT) {
    unsigned Op0Reg = getRegForValue(Op0);
    if (Op0Reg == 0) return false;

    // Handle 'null' like i32/i64 0.
    if (isa<ConstantPointerNull>(Op1))
        Op1 = Constant::getNullValue(DL.getIntPtrType(Op0->getContext()));

    // We have two options: compare with register or immediate.  If the RHS of
    // the compare is an immediate that we can fold into this compare, use
    // CMPri, otherwise use CMPrr.
    if (const ConstantInt *Op1C = dyn_cast<ConstantInt>(Op1)) {
        if (unsigned CompareImmOpc = Cse523ChooseCmpImmediateOpcode(VT, Op1C)) {
            BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(CompareImmOpc))
                .addReg(Op0Reg)
                .addImm(Op1C->getSExtValue());
            return true;
        }
    }

    unsigned CompareOpc = Cse523ChooseCmpOpcode(VT, Subtarget);
    if (CompareOpc == 0) return false;

    unsigned Op1Reg = getRegForValue(Op1);
    if (Op1Reg == 0) return false;
    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(CompareOpc))
        .addReg(Op0Reg)
        .addReg(Op1Reg);

    return true;
}

bool Cse523FastISel::Cse523SelectCmp(const Instruction *I) {
    const CmpInst *CI = cast<CmpInst>(I);

    MVT VT;
    if (!isTypeLegal(I->getOperand(0)->getType(), VT))
        return false;

    assert(0);

    //unsigned ResultReg = createResultReg(&Cse523::GR8RegClass);
    //unsigned SetCCOpc;
    //bool SwapArgs;  // false -> compare Op0, Op1.  true -> compare Op1, Op0.
    //switch (CI->getPredicate()) {
    //    case CmpInst::FCMP_OEQ: {
    //                                if (!Cse523FastEmitCompare(CI->getOperand(0), CI->getOperand(1), VT))
    //                                    return false;

    //                                unsigned EReg = createResultReg(&Cse523::GR8RegClass);
    //                                unsigned NPReg = createResultReg(&Cse523::GR8RegClass);
    //                                BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Cse523::SETEr), EReg);
    //                                BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
    //                                        TII.get(Cse523::SETNPr), NPReg);
    //                                BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
    //                                        TII.get(Cse523::AND8rr), ResultReg).addReg(NPReg).addReg(EReg);
    //                                UpdateValueMap(I, ResultReg);
    //                                return true;
    //                            }
    //    case CmpInst::FCMP_UNE: {
    //                                if (!Cse523FastEmitCompare(CI->getOperand(0), CI->getOperand(1), VT))
    //                                    return false;

    //                                unsigned NEReg = createResultReg(&Cse523::GR8RegClass);
    //                                unsigned PReg = createResultReg(&Cse523::GR8RegClass);
    //                                BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Cse523::SETNEr), NEReg);
    //                                BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Cse523::SETPr), PReg);
    //                                BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Cse523::OR8rr),ResultReg)
    //                                    .addReg(PReg).addReg(NEReg);
    //                                UpdateValueMap(I, ResultReg);
    //                                return true;
    //                            }
    //    case CmpInst::FCMP_OGT: SwapArgs = false; SetCCOpc = Cse523::SETAr;  break;
    //    case CmpInst::FCMP_OGE: SwapArgs = false; SetCCOpc = Cse523::SETAEr; break;
    //    case CmpInst::FCMP_OLT: SwapArgs = true;  SetCCOpc = Cse523::SETAr;  break;
    //    case CmpInst::FCMP_OLE: SwapArgs = true;  SetCCOpc = Cse523::SETAEr; break;
    //    case CmpInst::FCMP_ONE: SwapArgs = false; SetCCOpc = Cse523::SETNEr; break;
    //    case CmpInst::FCMP_ORD: SwapArgs = false; SetCCOpc = Cse523::SETNPr; break;
    //    case CmpInst::FCMP_UNO: SwapArgs = false; SetCCOpc = Cse523::SETPr;  break;
    //    case CmpInst::FCMP_UEQ: SwapArgs = false; SetCCOpc = Cse523::SETEr;  break;
    //    case CmpInst::FCMP_UGT: SwapArgs = true;  SetCCOpc = Cse523::SETBr;  break;
    //    case CmpInst::FCMP_UGE: SwapArgs = true;  SetCCOpc = Cse523::SETBEr; break;
    //    case CmpInst::FCMP_ULT: SwapArgs = false; SetCCOpc = Cse523::SETBr;  break;
    //    case CmpInst::FCMP_ULE: SwapArgs = false; SetCCOpc = Cse523::SETBEr; break;

    //    case CmpInst::ICMP_EQ:  SwapArgs = false; SetCCOpc = Cse523::SETEr;  break;
    //    case CmpInst::ICMP_NE:  SwapArgs = false; SetCCOpc = Cse523::SETNEr; break;
    //    case CmpInst::ICMP_UGT: SwapArgs = false; SetCCOpc = Cse523::SETAr;  break;
    //    case CmpInst::ICMP_UGE: SwapArgs = false; SetCCOpc = Cse523::SETAEr; break;
    //    case CmpInst::ICMP_ULT: SwapArgs = false; SetCCOpc = Cse523::SETBr;  break;
    //    case CmpInst::ICMP_ULE: SwapArgs = false; SetCCOpc = Cse523::SETBEr; break;
    //    case CmpInst::ICMP_SGT: SwapArgs = false; SetCCOpc = Cse523::SETGr;  break;
    //    case CmpInst::ICMP_SGE: SwapArgs = false; SetCCOpc = Cse523::SETGEr; break;
    //    case CmpInst::ICMP_SLT: SwapArgs = false; SetCCOpc = Cse523::SETLr;  break;
    //    case CmpInst::ICMP_SLE: SwapArgs = false; SetCCOpc = Cse523::SETLEr; break;
    //    default:
    //                            return false;
    //}

    //const Value *Op0 = CI->getOperand(0), *Op1 = CI->getOperand(1);
    //if (SwapArgs)
    //    std::swap(Op0, Op1);

    //// Emit a compare of Op0/Op1.
    //if (!Cse523FastEmitCompare(Op0, Op1, VT))
    //    return false;

    //BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(SetCCOpc), ResultReg);
    //UpdateValueMap(I, ResultReg);
    //return true;
}

bool Cse523FastISel::Cse523SelectZExt(const Instruction *I) {
    EVT DstVT = TLI.getValueType(I->getType());
    if (!TLI.isTypeLegal(DstVT))
        return false;

    unsigned ResultReg = getRegForValue(I->getOperand(0));
    if (ResultReg == 0)
        return false;

    // Handle zero-extension from i1 to i8, which is common.
    MVT SrcVT = TLI.getSimpleValueType(I->getOperand(0)->getType());
    if (SrcVT.SimpleTy == MVT::i1) {
        // Set the high bits to zero.
        ResultReg = FastEmitZExtFromI1(MVT::i8, ResultReg, /*TODO: Kill=*/false);
        SrcVT = MVT::i8;

        if (ResultReg == 0)
            return false;
    }

    if (DstVT == MVT::i64) {
        assert(0);
        // Handle extension to 64-bits via sub-register shenanigans.
        //unsigned MovInst;

        //switch (SrcVT.SimpleTy) {
        //    case MVT::i8:  MovInst = Cse523::MOVZX32rr8;  break;
        //    case MVT::i16: MovInst = Cse523::MOVZX32rr16; break;
        //    case MVT::i32: MovInst = Cse523::MOV32rr;     break;
        //    default: llvm_unreachable("Unexpected zext to i64 source type");
        //}

        //unsigned Result32 = createResultReg(&Cse523::GR32RegClass);
        //BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(MovInst), Result32)
        //    .addReg(ResultReg);

        //ResultReg = createResultReg(&Cse523::GR64RegClass);
        //BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(TargetOpcode::SUBREG_TO_REG),
        //        ResultReg)
        //    .addImm(0).addReg(Result32).addImm(Cse523::sub_32bit);
    } else if (DstVT != MVT::i8) {
        ResultReg = FastEmit_r(MVT::i8, DstVT.getSimpleVT(), ISD::ZERO_EXTEND,
                ResultReg, /*Kill=*/true);
        if (ResultReg == 0)
            return false;
    }

    UpdateValueMap(I, ResultReg);
    return true;
}


bool Cse523FastISel::Cse523SelectBranch(const Instruction *I) {
    // Unconditional branches are selected by tablegen-generated code.
    // Handle a conditional branch.
    const BranchInst *BI = cast<BranchInst>(I);
    MachineBasicBlock *TrueMBB = FuncInfo.MBBMap[BI->getSuccessor(0)];
    MachineBasicBlock *FalseMBB = FuncInfo.MBBMap[BI->getSuccessor(1)];

    // Fold the common case of a conditional branch with a comparison
    // in the same block (values defined on other blocks may not have
    // initialized registers).
    if (const CmpInst *CI = dyn_cast<CmpInst>(BI->getCondition())) {
        if (CI->hasOneUse() && CI->getParent() == I->getParent()) {
            EVT VT = TLI.getValueType(CI->getOperand(0)->getType());

            // Try to take advantage of fallthrough opportunities.
            CmpInst::Predicate Predicate = CI->getPredicate();
            if (FuncInfo.MBB->isLayoutSuccessor(TrueMBB)) {
                std::swap(TrueMBB, FalseMBB);
                Predicate = CmpInst::getInversePredicate(Predicate);
            }

            bool SwapArgs;  // false -> compare Op0, Op1.  true -> compare Op1, Op0.
            unsigned BranchOpc; // Opcode to jump on, e.g. "Cse523::JA"

            switch (Predicate) {
                case CmpInst::FCMP_OEQ:
                    std::swap(TrueMBB, FalseMBB);
                    Predicate = CmpInst::FCMP_UNE;
                    // FALL THROUGH
                case CmpInst::FCMP_UNE: SwapArgs = false; BranchOpc = Cse523::JNE_4; break;
                case CmpInst::FCMP_OGT: SwapArgs = false; BranchOpc = Cse523::JA_4;  break;
                case CmpInst::FCMP_OGE: SwapArgs = false; BranchOpc = Cse523::JAE_4; break;
                case CmpInst::FCMP_OLT: SwapArgs = true;  BranchOpc = Cse523::JA_4;  break;
                case CmpInst::FCMP_OLE: SwapArgs = true;  BranchOpc = Cse523::JAE_4; break;
                case CmpInst::FCMP_ONE: SwapArgs = false; BranchOpc = Cse523::JNE_4; break;
                case CmpInst::FCMP_ORD: SwapArgs = false; BranchOpc = Cse523::JNP_4; break;
                case CmpInst::FCMP_UNO: SwapArgs = false; BranchOpc = Cse523::JP_4;  break;
                case CmpInst::FCMP_UEQ: SwapArgs = false; BranchOpc = Cse523::JE_4;  break;
                case CmpInst::FCMP_UGT: SwapArgs = true;  BranchOpc = Cse523::JB_4;  break;
                case CmpInst::FCMP_UGE: SwapArgs = true;  BranchOpc = Cse523::JBE_4; break;
                case CmpInst::FCMP_ULT: SwapArgs = false; BranchOpc = Cse523::JB_4;  break;
                case CmpInst::FCMP_ULE: SwapArgs = false; BranchOpc = Cse523::JBE_4; break;

                case CmpInst::ICMP_EQ:  SwapArgs = false; BranchOpc = Cse523::JE_4;  break;
                case CmpInst::ICMP_NE:  SwapArgs = false; BranchOpc = Cse523::JNE_4; break;
                case CmpInst::ICMP_UGT: SwapArgs = false; BranchOpc = Cse523::JA_4;  break;
                case CmpInst::ICMP_UGE: SwapArgs = false; BranchOpc = Cse523::JAE_4; break;
                case CmpInst::ICMP_ULT: SwapArgs = false; BranchOpc = Cse523::JB_4;  break;
                case CmpInst::ICMP_ULE: SwapArgs = false; BranchOpc = Cse523::JBE_4; break;
                case CmpInst::ICMP_SGT: SwapArgs = false; BranchOpc = Cse523::JG_4;  break;
                case CmpInst::ICMP_SGE: SwapArgs = false; BranchOpc = Cse523::JGE_4; break;
                case CmpInst::ICMP_SLT: SwapArgs = false; BranchOpc = Cse523::JL_4;  break;
                case CmpInst::ICMP_SLE: SwapArgs = false; BranchOpc = Cse523::JLE_4; break;
                default:
                                        return false;
            }

            const Value *Op0 = CI->getOperand(0), *Op1 = CI->getOperand(1);
            if (SwapArgs)
                std::swap(Op0, Op1);

            // Emit a compare of the LHS and RHS, setting the flags.
            if (!Cse523FastEmitCompare(Op0, Op1, VT))
                return false;

            BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(BranchOpc))
                .addMBB(TrueMBB);

            if (Predicate == CmpInst::FCMP_UNE) {
                // Cse523 requires a second branch to handle UNE (and OEQ,
                // which is mapped to UNE above).
                BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Cse523::JP_4))
                    .addMBB(TrueMBB);
            }

            FastEmitBranch(FalseMBB, DbgLoc);
            FuncInfo.MBB->addSuccessor(TrueMBB);
            return true;
        }
    } else if (TruncInst *TI = dyn_cast<TruncInst>(BI->getCondition())) {
        // Handle things like "%cond = trunc i32 %X to i1 / br i1 %cond", which
        // typically happen for _Bool and C++ bools.
        MVT SourceVT;
        if (TI->hasOneUse() && TI->getParent() == I->getParent() &&
                isTypeLegal(TI->getOperand(0)->getType(), SourceVT)) {
            unsigned TestOpc = 0;
            switch (SourceVT.SimpleTy) {
                default: break;
                case MVT::i8: 
                case MVT::i16:
                case MVT::i32:
                    assert(0);
                case MVT::i64: TestOpc = Cse523::TEST64ri32; break;
            }
            if (TestOpc) {
                unsigned OpReg = getRegForValue(TI->getOperand(0));
                if (OpReg == 0) return false;
                BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(TestOpc))
                    .addReg(OpReg).addImm(1);

                unsigned JmpOpc = Cse523::JNE_4;
                if (FuncInfo.MBB->isLayoutSuccessor(TrueMBB)) {
                    std::swap(TrueMBB, FalseMBB);
                    JmpOpc = Cse523::JE_4;
                }

                BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(JmpOpc))
                    .addMBB(TrueMBB);
                FastEmitBranch(FalseMBB, DbgLoc);
                FuncInfo.MBB->addSuccessor(TrueMBB);
                return true;
            }
        }
    }

    // Otherwise do a clumsy setcc and re-test it.
    // Note that i1 essentially gets ANY_EXTEND'ed to i8 where it isn't used
    // in an explicit cast, so make sure to handle that correctly.
    unsigned OpReg = getRegForValue(BI->getCondition());
    if (OpReg == 0) return false;

    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Cse523::TEST64ri32))
        .addReg(OpReg).addImm(1);
    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Cse523::JNE_4))
        .addMBB(TrueMBB);
    FastEmitBranch(FalseMBB, DbgLoc);
    FuncInfo.MBB->addSuccessor(TrueMBB);
    return true;
}

bool Cse523FastISel::Cse523SelectShift(const Instruction *I) {
    unsigned CReg = 0, OpReg = 0;
    const TargetRegisterClass *RC = NULL;
    if (I->getType()->isIntegerTy(8)) {
        assert(0);
    } else if (I->getType()->isIntegerTy(16)) {
        assert(0);
    } else if (I->getType()->isIntegerTy(32)) {
        assert(0);
    } else if (I->getType()->isIntegerTy(64)) {
        CReg = Cse523::RCX;
        RC = &Cse523::GR64RegClass;
        switch (I->getOpcode()) {
            case Instruction::LShr: OpReg = Cse523::SHR64rCL; break;
            case Instruction::AShr: OpReg = Cse523::SAR64rCL; break;
            case Instruction::Shl:  OpReg = Cse523::SHL64rCL; break;
            default: return false;
        }
    } else {
        return false;
    }

    MVT VT;
    if (!isTypeLegal(I->getType(), VT))
        return false;

    unsigned Op0Reg = getRegForValue(I->getOperand(0));
    if (Op0Reg == 0) return false;

    unsigned Op1Reg = getRegForValue(I->getOperand(1));
    if (Op1Reg == 0) return false;
    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(TargetOpcode::COPY),
            CReg).addReg(Op1Reg);

    // The shift instruction uses Cse523::RCX. If we defined a super-register
    // of Cse523::RCX, emit a subreg KILL to precisely describe what we're doing here.
    if (CReg != Cse523::RCX)
        BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
                TII.get(TargetOpcode::KILL), Cse523::RCX)
            .addReg(CReg, RegState::Kill);

    unsigned ResultReg = createResultReg(RC);
    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(OpReg), ResultReg)
        .addReg(Op0Reg);
    UpdateValueMap(I, ResultReg);
    return true;
}

bool Cse523FastISel::Cse523SelectDivRem(const Instruction *I) {
    const static unsigned NumTypes = 4; // i8, i16, i32, i64
    const static unsigned NumOps   = 4; // SDiv, SRem, UDiv, URem
    const static bool S = true;  // IsSigned
    const static bool U = false; // !IsSigned
    const static unsigned Copy = TargetOpcode::COPY;
    // For the Cse523 DIV/IDIV instruction, in most cases the dividend
    // (numerator) must be in a specific register pair highreg:lowreg,
    // producing the quotient in lowreg and the remainder in highreg.
    // For most data types, to set up the instruction, the dividend is
    // copied into lowreg, and lowreg is sign-extended or zero-extended
    // into highreg.  The exception is i8, where the dividend is defined
    // as a single register rather than a register pair, and we
    // therefore directly sign-extend or zero-extend the dividend into
    // lowreg, instead of copying, and ignore the highreg.
    const static struct DivRemEntry {
        // The following portion depends only on the data type.
        const TargetRegisterClass *RC;
        unsigned LowInReg;  // low part of the register pair
        unsigned HighInReg; // high part of the register pair
        // The following portion depends on both the data type and the operation.
        struct DivRemResult {
            unsigned OpDivRem;        // The specific DIV/IDIV opcode to use.
            unsigned OpSignExtend;    // Opcode for sign-extending lowreg into
            // highreg, or copying a zero into highreg.
            unsigned OpCopy;          // Opcode for copying dividend into lowreg, or
            // zero/sign-extending into lowreg for i8.
            unsigned DivRemResultReg; // Register containing the desired result.
            bool IsOpSigned;          // Whether to use signed or unsigned form.
        } ResultTable[NumOps];
    } OpTable[NumTypes] = {
        { &Cse523::GR64RegClass, Cse523::RAX, Cse523::RDX, {
                                                               //{ Cse523::IDIV64r, Cse523::CQO,     Copy,            Cse523::RAX, S }, // SDiv
                                                               //{ Cse523::IDIV64r, Cse523::CQO,     Copy,            Cse523::RDX, S }, // SRem
                                                               { Cse523::DIV64r,  Cse523::MOV64r0, Copy,            Cse523::RAX, U }, // UDiv
                                                               { Cse523::DIV64r,  Cse523::MOV64r0, Copy,            Cse523::RDX, U } // URem
                                                           }
        }, // i64
    };

    MVT VT;
    if (!isTypeLegal(I->getType(), VT))
        return false;

    unsigned TypeIndex, OpIndex;
    switch (VT.SimpleTy) {
        default: return false;
        case MVT::i8:  TypeIndex = 0; break;
        case MVT::i16: TypeIndex = 1; break;
        case MVT::i32: TypeIndex = 2; break;
        case MVT::i64: TypeIndex = 3;
                       if (!Subtarget->is64Bit())
                           return false;
                       break;
    }

    switch (I->getOpcode()) {
        default: llvm_unreachable("Unexpected div/rem opcode");
        case Instruction::SDiv: OpIndex = 0; break;
        case Instruction::SRem: OpIndex = 1; break;
        case Instruction::UDiv: OpIndex = 2; break;
        case Instruction::URem: OpIndex = 3; break;
    }

    const DivRemEntry &TypeEntry = OpTable[TypeIndex];
    const DivRemEntry::DivRemResult &OpEntry = TypeEntry.ResultTable[OpIndex];
    unsigned Op0Reg = getRegForValue(I->getOperand(0));
    if (Op0Reg == 0)
        return false;
    unsigned Op1Reg = getRegForValue(I->getOperand(1));
    if (Op1Reg == 0)
        return false;

    // Move op0 into low-order input register.
    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
            TII.get(OpEntry.OpCopy), TypeEntry.LowInReg).addReg(Op0Reg);
    // Zero-extend or sign-extend into high-order input register.
    if (OpEntry.OpSignExtend) {
        if (OpEntry.IsOpSigned)
            BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
                    TII.get(OpEntry.OpSignExtend));
        else {
            assert(0);
            //unsigned Zero32 = createResultReg(&Cse523::GR32RegClass);
            //BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
            //        TII.get(Cse523::MOV32r0), Zero32);

            //// Copy the zero into the appropriate sub/super/identical physical
            //// register. Unfortunately the operations needed are not uniform enough to
            //// fit neatly into the table above.
            //if (VT.SimpleTy == MVT::i16) {
            //    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
            //            TII.get(Copy), TypeEntry.HighInReg)
            //        .addReg(Zero32, 0, Cse523::sub_16bit);
            //} else if (VT.SimpleTy == MVT::i32) {
            //    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
            //            TII.get(Copy), TypeEntry.HighInReg)
            //        .addReg(Zero32);
            //} else if (VT.SimpleTy == MVT::i64) {
            //    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
            //            TII.get(TargetOpcode::SUBREG_TO_REG), TypeEntry.HighInReg)
            //        .addImm(0).addReg(Zero32).addImm(Cse523::sub_32bit);
            //}
        }
    }
    // Generate the DIV/IDIV instruction.
    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
            TII.get(OpEntry.OpDivRem)).addReg(Op1Reg);
    // For i8 remainder, we can't reference AH directly, as we'll end
    // up with bogus copies like %R9B = COPY %AH. Reference AX
    // instead to prevent AH references in a REX instruction.
    //
    // The current assumption of the fast register allocator is that isel
    // won't generate explicit references to the GPR8_NOREX registers. If
    // the allocator and/or the backend get enhanced to be more robust in
    // that regard, this can be, and should be, removed.
    assert(0);
    unsigned ResultReg = 0;
    //if ((I->getOpcode() == Instruction::SRem ||
    //            I->getOpcode() == Instruction::URem) &&
    //        OpEntry.DivRemResultReg == Cse523::AH && Subtarget->is64Bit()) {
    //    unsigned SourceSuperReg = createResultReg(&Cse523::GR16RegClass);
    //    unsigned ResultSuperReg = createResultReg(&Cse523::GR16RegClass);
    //    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
    //            TII.get(Copy), SourceSuperReg).addReg(Cse523::AX);

    //    // Shift AX right by 8 bits instead of using AH.
    //    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Cse523::SHR16ri),
    //            ResultSuperReg).addReg(SourceSuperReg).addImm(8);

    //    // Now reference the 8-bit subreg of the result.
    //    ResultReg = FastEmitInst_extractsubreg(MVT::i8, ResultSuperReg,
    //            /*Kill=*/true, Cse523::sub_8bit);
    //}
    // Copy the result out of the physreg if we haven't already.
    if (!ResultReg) {
        ResultReg = createResultReg(TypeEntry.RC);
        BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Copy), ResultReg)
            .addReg(OpEntry.DivRemResultReg);
    }
    UpdateValueMap(I, ResultReg);

    return true;
}

bool Cse523FastISel::Cse523SelectSelect(const Instruction *I) {
    MVT VT;
    if (!isTypeLegal(I->getType(), VT))
        return false;

    // We only use cmov here, if we don't have a cmov instruction bail.
    if (!Subtarget->hasCMov()) return false;

    unsigned Opc = 0;
    const TargetRegisterClass *RC = NULL;
    if (VT == MVT::i16) {
        assert(0);
    } else if (VT == MVT::i32) {
        assert(0);
    } else if (VT == MVT::i64) {
        assert(0);
        //Opc = Cse523::CMOVE64rr;
        RC = &Cse523::GR64RegClass;
    } else {
        return false;
    }

    unsigned Op0Reg = getRegForValue(I->getOperand(0));
    if (Op0Reg == 0) return false;
    unsigned Op1Reg = getRegForValue(I->getOperand(1));
    if (Op1Reg == 0) return false;
    unsigned Op2Reg = getRegForValue(I->getOperand(2));
    if (Op2Reg == 0) return false;

    // Selects operate on i1, however, Op0Reg is 8 bits width and may contain
    // garbage. Indeed, only the less significant bit is supposed to be accurate.
    // If we read more than the lsb, we may see non-zero values whereas lsb
    // is zero. Therefore, we have to truncate Op0Reg to i1 for the select.
    // This is achieved by performing TEST against 1.
    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Cse523::TEST64ri32))
        .addReg(Op0Reg).addImm(1);
    unsigned ResultReg = createResultReg(RC);
    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Opc), ResultReg)
        .addReg(Op1Reg).addReg(Op2Reg);
    UpdateValueMap(I, ResultReg);
    return true;
}

bool Cse523FastISel::Cse523SelectFPExt(const Instruction *I) {
    // fpext from float to double.
    assert(0);
    return false;
}

bool Cse523FastISel::Cse523SelectFPTrunc(const Instruction *I) {
    assert(0);
    return false;
}

bool Cse523FastISel::Cse523SelectTrunc(const Instruction *I) {
    EVT SrcVT = TLI.getValueType(I->getOperand(0)->getType());
    EVT DstVT = TLI.getValueType(I->getType());

    // This code only handles truncation to byte.
    if (DstVT != MVT::i8 && DstVT != MVT::i1)
        return false;
    if (!TLI.isTypeLegal(SrcVT))
        return false;

    unsigned InputReg = getRegForValue(I->getOperand(0));
    if (!InputReg)
        // Unhandled operand.  Halt "fast" selection and bail.
        return false;

    if (SrcVT == MVT::i8) {
        // Truncate from i8 to i1; no code needed.
        UpdateValueMap(I, InputReg);
        return true;
    }

    assert(0);
    // Issue an extract_subreg.
    //unsigned ResultReg = FastEmitInst_extractsubreg(MVT::i8,
    //        InputReg, /*Kill=*/true,
    //        Cse523::sub_8bit);
    //if (!ResultReg)
    //    return false;

    //UpdateValueMap(I, ResultReg);
    return true;
}

bool Cse523FastISel::IsMemcpySmall(uint64_t Len) {
    return Len <= 32;
}

bool Cse523FastISel::TryEmitSmallMemcpy(Cse523AddressMode DestAM,
        Cse523AddressMode SrcAM, uint64_t Len) {

    // Make sure we don't bloat code by inlining very large memcpy's.
    if (!IsMemcpySmall(Len))
        return false;

    bool i64Legal = Subtarget->is64Bit();

    // We don't care about alignment here since we just emit integer accesses.
    while (Len) {
        MVT VT;
        if (Len >= 8 && i64Legal)
            VT = MVT::i64;
        else if (Len >= 4)
            VT = MVT::i32;
        else if (Len >= 2)
            VT = MVT::i16;
        else {
            VT = MVT::i8;
        }

        unsigned Reg;
        bool RV = Cse523FastEmitLoad(VT, SrcAM, Reg);
        RV &= Cse523FastEmitStore(VT, Reg, DestAM);
        assert(RV && "Failed to emit load or store??");

        unsigned Size = VT.getSizeInBits()/8;
        Len -= Size;
        DestAM.Disp += Size;
        SrcAM.Disp += Size;
    }

    return true;
}

bool Cse523FastISel::Cse523VisitIntrinsicCall(const IntrinsicInst &I) {
    // FIXME: Handle more intrinsics.
    switch (I.getIntrinsicID()) {
        default: return false;
        case Intrinsic::memcpy: {
                                    const MemCpyInst &MCI = cast<MemCpyInst>(I);
                                    // Don't handle volatile or variable length memcpys.
                                    if (MCI.isVolatile())
                                        return false;

                                    if (isa<ConstantInt>(MCI.getLength())) {
                                        // Small memcpy's are common enough that we want to do them
                                        // without a call if possible.
                                        uint64_t Len = cast<ConstantInt>(MCI.getLength())->getZExtValue();
                                        if (IsMemcpySmall(Len)) {
                                            Cse523AddressMode DestAM, SrcAM;
                                            if (!Cse523SelectAddress(MCI.getRawDest(), DestAM) ||
                                                    !Cse523SelectAddress(MCI.getRawSource(), SrcAM))
                                                return false;
                                            TryEmitSmallMemcpy(DestAM, SrcAM, Len);
                                            return true;
                                        }
                                    }

                                    unsigned SizeWidth = Subtarget->is64Bit() ? 64 : 32;
                                    if (!MCI.getLength()->getType()->isIntegerTy(SizeWidth))
                                        return false;

                                    if (MCI.getSourceAddressSpace() > 255 || MCI.getDestAddressSpace() > 255)
                                        return false;

                                    return DoSelectCall(&I, "memcpy");
                                }
        case Intrinsic::memset: {
                                    const MemSetInst &MSI = cast<MemSetInst>(I);

                                    if (MSI.isVolatile())
                                        return false;

                                    unsigned SizeWidth = Subtarget->is64Bit() ? 64 : 32;
                                    if (!MSI.getLength()->getType()->isIntegerTy(SizeWidth))
                                        return false;

                                    if (MSI.getDestAddressSpace() > 255)
                                        return false;

                                    return DoSelectCall(&I, "memset");
                                }
        case Intrinsic::stackprotector: {
                                            // Emit code to store the stack guard onto the stack.
                                            EVT PtrTy = TLI.getPointerTy();

                                            const Value *Op1 = I.getArgOperand(0); // The guard's value.
                                            const AllocaInst *Slot = cast<AllocaInst>(I.getArgOperand(1));

                                            MFI.setStackProtectorIndex(FuncInfo.StaticAllocaMap[Slot]);

                                            // Grab the frame index.
                                            Cse523AddressMode AM;
                                            if (!Cse523SelectAddress(Slot, AM)) return false;
                                            if (!Cse523FastEmitStore(PtrTy, Op1, AM)) return false;
                                            return true;
                                        }
        case Intrinsic::dbg_declare: {
                                         const DbgDeclareInst *DI = cast<DbgDeclareInst>(&I);
                                         Cse523AddressMode AM;
                                         assert(DI->getAddress() && "Null address should be checked earlier!");
                                         if (!Cse523SelectAddress(DI->getAddress(), AM))
                                             return false;
                                         const MCInstrDesc &II = TII.get(TargetOpcode::DBG_VALUE);
                                         // FIXME may need to add RegState::Debug to any registers produced,
                                         // although ESP/EBP should be the only ones at the moment.
                                         addFullAddress(BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, II), AM).
                                             addImm(0).addMetadata(DI->getVariable());
                                         return true;
                                     }
        case Intrinsic::trap: {
                                  BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Cse523::TRAP));
                                  return true;
                              }
        case Intrinsic::sadd_with_overflow:
        case Intrinsic::uadd_with_overflow: {
                                                // FIXME: Should fold immediates.

                                                // Replace "add with overflow" intrinsics with an "add" instruction followed
                                                // by a seto/setc instruction.
                                                const Function *Callee = I.getCalledFunction();
                                                Type *RetTy =
                                                    cast<StructType>(Callee->getReturnType())->getTypeAtIndex(unsigned(0));

                                                MVT VT;
                                                if (!isTypeLegal(RetTy, VT))
                                                    return false;

                                                const Value *Op1 = I.getArgOperand(0);
                                                const Value *Op2 = I.getArgOperand(1);
                                                unsigned Reg1 = getRegForValue(Op1);
                                                unsigned Reg2 = getRegForValue(Op2);

                                                if (Reg1 == 0 || Reg2 == 0)
                                                    // FIXME: Handle values *not* in registers.
                                                    return false;

                                                unsigned OpC = 0;
                                                if (VT == MVT::i32)
                                                    assert(0);
                                                else if (VT == MVT::i64)
                                                    OpC = Cse523::ADD64rr;
                                                else
                                                    return false;

                                                // The call to CreateRegs builds two sequential registers, to store the
                                                // both the returned values.
                                                unsigned ResultReg = FuncInfo.CreateRegs(I.getType());
                                                BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(OpC), ResultReg)
                                                    .addReg(Reg1).addReg(Reg2);

                                                assert(0);
                                                //unsigned Opc = Cse523::SETBr;
                                                //if (I.getIntrinsicID() == Intrinsic::sadd_with_overflow)
                                                //    Opc = Cse523::SETOr;
                                                //BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Opc),
                                                //        ResultReg + 1);

                                                UpdateValueMap(&I, ResultReg, 2);
                                                return true;
                                            }
    }
}

bool Cse523FastISel::FastLowerArguments() {
    if (!FuncInfo.CanLowerReturn)
        return false;

    const Function *F = FuncInfo.Fn;
    if (F->isVarArg())
        return false;

    CallingConv::ID CC = F->getCallingConv();
    if (CC != CallingConv::C)
        return false;

    if (Subtarget->isCallingConvWin64(CC))
        return false;

    if (!Subtarget->is64Bit())
        return false;

    // Only handle simple cases. i.e. Up to 6 i32/i64 scalar arguments.
    unsigned Idx = 1;
    for (Function::const_arg_iterator I = F->arg_begin(), E = F->arg_end();
            I != E; ++I, ++Idx) {
        if (Idx > 6)
            return false;

        if (F->getAttributes().hasAttribute(Idx, Attribute::ByVal) ||
                F->getAttributes().hasAttribute(Idx, Attribute::InReg) ||
                F->getAttributes().hasAttribute(Idx, Attribute::StructRet) ||
                F->getAttributes().hasAttribute(Idx, Attribute::Nest))
            return false;

        Type *ArgTy = I->getType();
        if (ArgTy->isStructTy() || ArgTy->isArrayTy() || ArgTy->isVectorTy())
            return false;

        EVT ArgVT = TLI.getValueType(ArgTy);
        if (!ArgVT.isSimple()) return false;
        switch (ArgVT.getSimpleVT().SimpleTy) {
            case MVT::i32:
            case MVT::i64:
                break;
            default:
                return false;
        }
    }

    static const uint16_t GPR64ArgRegs[] = {
        Cse523::RDI, Cse523::RSI, Cse523::RDX, Cse523::RCX, Cse523::R8 , Cse523::R9
    };

    Idx = 0;
    const TargetRegisterClass *RC64 = TLI.getRegClassFor(MVT::i64);
    for (Function::const_arg_iterator I = F->arg_begin(), E = F->arg_end();
            I != E; ++I, ++Idx) {
        bool is32Bit = TLI.getValueType(I->getType()) == MVT::i32;
        const TargetRegisterClass *RC = RC64;
        unsigned SrcReg = GPR64ArgRegs[Idx];
        unsigned DstReg = FuncInfo.MF->addLiveIn(SrcReg, RC);
        // FIXME: Unfortunately it's necessary to emit a copy from the livein copy.
        // Without this, EmitLiveInCopies may eliminate the livein if its only
        // use is a bitcast (which isn't turned into an instruction).
        unsigned ResultReg = createResultReg(RC);

        assert(!is32Bit);

        BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
                TII.get(TargetOpcode::COPY),
                ResultReg).addReg(DstReg, getKillRegState(true));
        UpdateValueMap(I, ResultReg);
    }
    return true;
}

bool Cse523FastISel::Cse523SelectCall(const Instruction *I) {
    const CallInst *CI = cast<CallInst>(I);
    const Value *Callee = CI->getCalledValue();

    // Can't handle inline asm yet.
    if (isa<InlineAsm>(Callee))
        return false;

    // Handle intrinsic calls.
    if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(CI))
        return Cse523VisitIntrinsicCall(*II);

    // Allow SelectionDAG isel to handle tail calls.
    if (cast<CallInst>(I)->isTailCall())
        return false;

    return DoSelectCall(I, 0);
}

static unsigned computeBytesPoppedByCallee(const Cse523Subtarget &Subtarget,
        const ImmutableCallSite &CS) {
    if (Subtarget.is64Bit())
        return 0;
    if (Subtarget.getTargetTriple().isOSMSVCRT())
        return 0;
    CallingConv::ID CC = CS.getCallingConv();
    if (CC == CallingConv::Fast || CC == CallingConv::GHC)
        return 0;
    if (!CS.paramHasAttr(1, Attribute::StructRet))
        return 0;
    if (CS.paramHasAttr(1, Attribute::InReg))
        return 0;
    return 4;
}

// Select either a call, or an llvm.memcpy/memmove/memset intrinsic
bool Cse523FastISel::DoSelectCall(const Instruction *I, const char *MemIntName) {
    const CallInst *CI = cast<CallInst>(I);
    const Value *Callee = CI->getCalledValue();

    // Handle only C and fastcc calling conventions for now.
    ImmutableCallSite CS(CI);
    CallingConv::ID CC = CS.getCallingConv();
    bool isWin64 = Subtarget->isCallingConvWin64(CC);
    if (CC != CallingConv::C && CC != CallingConv::Fast &&
            CC != CallingConv::X86_FastCall && CC != CallingConv::X86_64_Win64 &&
            CC != CallingConv::X86_64_SysV)
        return false;

    // fastcc with -tailcallopt is intended to provide a guaranteed
    // tail call optimization. Fastisel doesn't know how to do that.
    if (CC == CallingConv::Fast && TM.Options.GuaranteedTailCallOpt)
        return false;

    PointerType *PT = cast<PointerType>(CS.getCalledValue()->getType());
    FunctionType *FTy = cast<FunctionType>(PT->getElementType());
    bool isVarArg = FTy->isVarArg();

    // Don't know how to handle Win64 varargs yet.  Nothing special needed for
    // cse523-32.  Special handling for cse523-64 is implemented.
    if (isVarArg && isWin64)
        return false;

    // Don't know about inalloca yet.
    if (CS.hasInAllocaArgument())
        return false;

    // Fast-isel doesn't know about callee-pop yet.
    if (Cse523::isCalleePop(CC, Subtarget->is64Bit(), isVarArg,
                TM.Options.GuaranteedTailCallOpt))
        return false;

    // Check whether the function can return without sret-demotion.
    SmallVector<ISD::OutputArg, 4> Outs;
    GetReturnInfo(I->getType(), CS.getAttributes(), Outs, TLI);
    bool CanLowerReturn = TLI.CanLowerReturn(CS.getCallingConv(),
            *FuncInfo.MF, FTy->isVarArg(),
            Outs, FTy->getContext());
    if (!CanLowerReturn)
        return false;

    // Materialize callee address in a register. FIXME: GV address can be
    // handled with a CALLpcrel32 instead.
    Cse523AddressMode CalleeAM;
    if (!Cse523SelectCallAddress(Callee, CalleeAM))
        return false;
    unsigned CalleeOp = 0;
    const GlobalValue *GV = 0;
    if (CalleeAM.GV != 0) {
        GV = CalleeAM.GV;
    } else if (CalleeAM.Base.Reg != 0) {
        CalleeOp = CalleeAM.Base.Reg;
    } else
        return false;

    // Deal with call operands first.
    SmallVector<const Value *, 8> ArgVals;
    SmallVector<unsigned, 8> Args;
    SmallVector<MVT, 8> ArgVTs;
    SmallVector<ISD::ArgFlagsTy, 8> ArgFlags;
    unsigned arg_size = CS.arg_size();
    Args.reserve(arg_size);
    ArgVals.reserve(arg_size);
    ArgVTs.reserve(arg_size);
    ArgFlags.reserve(arg_size);
    for (ImmutableCallSite::arg_iterator i = CS.arg_begin(), e = CS.arg_end();
            i != e; ++i) {
        // If we're lowering a mem intrinsic instead of a regular call, skip the
        // last two arguments, which should not passed to the underlying functions.
        if (MemIntName && e-i <= 2)
            break;
        Value *ArgVal = *i;
        ISD::ArgFlagsTy Flags;
        unsigned AttrInd = i - CS.arg_begin() + 1;
        if (CS.paramHasAttr(AttrInd, Attribute::SExt))
            Flags.setSExt();
        if (CS.paramHasAttr(AttrInd, Attribute::ZExt))
            Flags.setZExt();

        if (CS.paramHasAttr(AttrInd, Attribute::ByVal)) {
            PointerType *Ty = cast<PointerType>(ArgVal->getType());
            Type *ElementTy = Ty->getElementType();
            unsigned FrameSize = DL.getTypeAllocSize(ElementTy);
            unsigned FrameAlign = CS.getParamAlignment(AttrInd);
            if (!FrameAlign)
                FrameAlign = TLI.getByValTypeAlignment(ElementTy);
            Flags.setByVal();
            Flags.setByValSize(FrameSize);
            Flags.setByValAlign(FrameAlign);
            if (!IsMemcpySmall(FrameSize))
                return false;
        }

        if (CS.paramHasAttr(AttrInd, Attribute::InReg))
            Flags.setInReg();
        if (CS.paramHasAttr(AttrInd, Attribute::Nest))
            Flags.setNest();

        // If this is an i1/i8/i16 argument, promote to i32 to avoid an extra
        // instruction.  This is safe because it is common to all fastisel supported
        // calling conventions on cse523.
        if (ConstantInt *CI = dyn_cast<ConstantInt>(ArgVal)) {
            if (CI->getBitWidth() == 1 || CI->getBitWidth() == 8 ||
                    CI->getBitWidth() == 16) {
                if (Flags.isSExt())
                    ArgVal = ConstantExpr::getSExt(CI,Type::getInt32Ty(CI->getContext()));
                else
                    ArgVal = ConstantExpr::getZExt(CI,Type::getInt32Ty(CI->getContext()));
            }
        }

        unsigned ArgReg;

        // Passing bools around ends up doing a trunc to i1 and passing it.
        // Codegen this as an argument + "and 1".
        if (ArgVal->getType()->isIntegerTy(1) && isa<TruncInst>(ArgVal) &&
                cast<TruncInst>(ArgVal)->getParent() == I->getParent() &&
                ArgVal->hasOneUse()) {
            ArgVal = cast<TruncInst>(ArgVal)->getOperand(0);
            ArgReg = getRegForValue(ArgVal);
            if (ArgReg == 0) return false;

            MVT ArgVT;
            if (!isTypeLegal(ArgVal->getType(), ArgVT)) return false;

            ArgReg = FastEmit_ri(ArgVT, ArgVT, ISD::AND, ArgReg,
                    ArgVal->hasOneUse(), 1);
        } else {
            ArgReg = getRegForValue(ArgVal);
        }

        if (ArgReg == 0) return false;

        Type *ArgTy = ArgVal->getType();
        MVT ArgVT;
        if (!isTypeLegal(ArgTy, ArgVT))
            return false;
        unsigned OriginalAlignment = DL.getABITypeAlignment(ArgTy);
        Flags.setOrigAlign(OriginalAlignment);

        Args.push_back(ArgReg);
        ArgVals.push_back(ArgVal);
        ArgVTs.push_back(ArgVT);
        ArgFlags.push_back(Flags);
    }

    // Analyze operands of the call, assigning locations to each operand.
    SmallVector<CCValAssign, 16> ArgLocs;
    CCState CCInfo(CC, isVarArg, *FuncInfo.MF, TM, ArgLocs,
            I->getParent()->getContext());

    // Allocate shadow area for Win64
    if (isWin64)
        CCInfo.AllocateStack(32, 8);

    CCInfo.AnalyzeCallOperands(ArgVTs, ArgFlags, CC_Cse523);

    // Get a count of how many bytes are to be pushed on the stack.
    unsigned NumBytes = CCInfo.getNextStackOffset();

    // Issue CALLSEQ_START
    unsigned AdjStackDown = TII.getCallFrameSetupOpcode();
    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(AdjStackDown))
        .addImm(NumBytes);

    // Process argument: walk the register/memloc assignments, inserting
    // copies / loads.
    SmallVector<unsigned, 4> RegArgs;
    for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
        CCValAssign &VA = ArgLocs[i];
        unsigned Arg = Args[VA.getValNo()];
        EVT ArgVT = ArgVTs[VA.getValNo()];

        // Promote the value if needed.
        switch (VA.getLocInfo()) {
            case CCValAssign::Full: break;
            case CCValAssign::SExt: {
                                        assert(VA.getLocVT().isInteger() && !VA.getLocVT().isVector() &&
                                                "Unexpected extend");
                                        bool Emitted = Cse523FastEmitExtend(ISD::SIGN_EXTEND, VA.getLocVT(),
                                                Arg, ArgVT, Arg);
                                        assert(Emitted && "Failed to emit a sext!"); (void)Emitted;
                                        ArgVT = VA.getLocVT();
                                        break;
                                    }
            case CCValAssign::ZExt: {
                                        assert(VA.getLocVT().isInteger() && !VA.getLocVT().isVector() &&
                                                "Unexpected extend");
                                        bool Emitted = Cse523FastEmitExtend(ISD::ZERO_EXTEND, VA.getLocVT(),
                                                Arg, ArgVT, Arg);
                                        assert(Emitted && "Failed to emit a zext!"); (void)Emitted;
                                        ArgVT = VA.getLocVT();
                                        break;
                                    }
            case CCValAssign::AExt: {
                                        assert(VA.getLocVT().isInteger() && !VA.getLocVT().isVector() &&
                                                "Unexpected extend");
                                        bool Emitted = Cse523FastEmitExtend(ISD::ANY_EXTEND, VA.getLocVT(),
                                                Arg, ArgVT, Arg);
                                        if (!Emitted)
                                            Emitted = Cse523FastEmitExtend(ISD::ZERO_EXTEND, VA.getLocVT(),
                                                    Arg, ArgVT, Arg);
                                        if (!Emitted)
                                            Emitted = Cse523FastEmitExtend(ISD::SIGN_EXTEND, VA.getLocVT(),
                                                    Arg, ArgVT, Arg);

                                        assert(Emitted && "Failed to emit a aext!"); (void)Emitted;
                                        ArgVT = VA.getLocVT();
                                        break;
                                    }
            case CCValAssign::BCvt: {
                                        unsigned BC = FastEmit_r(ArgVT.getSimpleVT(), VA.getLocVT(),
                                                ISD::BITCAST, Arg, /*TODO: Kill=*/false);
                                        assert(BC != 0 && "Failed to emit a bitcast!");
                                        Arg = BC;
                                        ArgVT = VA.getLocVT();
                                        break;
                                    }
            case CCValAssign::VExt: 
                                    // VExt has not been implemented, so this should be impossible to reach
                                    // for now.  However, fallback to Selection DAG isel once implemented.
                                    return false;
            case CCValAssign::Indirect:
                                    // FIXME: Indirect doesn't need extending, but fast-isel doesn't fully
                                    // support this.
                                    return false;
            case CCValAssign::FPExt:
                                    llvm_unreachable("Unexpected loc info!");
        }

        if (VA.isRegLoc()) {
            BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
                    TII.get(TargetOpcode::COPY), VA.getLocReg()).addReg(Arg);
            RegArgs.push_back(VA.getLocReg());
        } else {
            unsigned LocMemOffset = VA.getLocMemOffset();
            Cse523AddressMode AM;
            const Cse523RegisterInfo *RegInfo = static_cast<const Cse523RegisterInfo*>(
                    getTargetMachine()->getRegisterInfo());
            AM.Base.Reg = RegInfo->getStackRegister();
            AM.Disp = LocMemOffset;
            const Value *ArgVal = ArgVals[VA.getValNo()];
            ISD::ArgFlagsTy Flags = ArgFlags[VA.getValNo()];

            if (Flags.isByVal()) {
                Cse523AddressMode SrcAM;
                SrcAM.Base.Reg = Arg;
                bool Res = TryEmitSmallMemcpy(AM, SrcAM, Flags.getByValSize());
                assert(Res && "memcpy length already checked!"); (void)Res;
            } else if (isa<ConstantInt>(ArgVal) || isa<ConstantPointerNull>(ArgVal)) {
                // If this is a really simple value, emit this with the Value* version
                // of Cse523FastEmitStore.  If it isn't simple, we don't want to do this,
                // as it can cause us to reevaluate the argument.
                if (!Cse523FastEmitStore(ArgVT, ArgVal, AM))
                    return false;
            } else {
                if (!Cse523FastEmitStore(ArgVT, Arg, AM))
                    return false;
            }
        }
    }

    // ELF / PIC requires GOT in the EBX register before function calls via PLT
    // GOT pointer.
    if (Subtarget->isPICStyleGOT()) {
        assert(0);
        //unsigned Base = getInstrInfo()->getGlobalBaseReg(FuncInfo.MF);
        //BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
        //        TII.get(TargetOpcode::COPY), Cse523::EBX).addReg(Base);
    }

    if (Subtarget->is64Bit() && isVarArg && !isWin64) {
        // Count the number of XMM registers allocated.
        assert(0);
    }

    // Issue the call.
    MachineInstrBuilder MIB;
    if (CalleeOp) {
        // Register-indirect call.
        unsigned CallOpc = Cse523::CALL64r;
        MIB = BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(CallOpc))
            .addReg(CalleeOp);

    } else {
        // Direct call.
        assert(GV && "Not a direct call");
        unsigned CallOpc = Cse523::CALL64pcrel32;

        // See if we need any target-specific flags on the GV operand.
        unsigned char OpFlags = 0;

        // On ELF targets, in both Cse523-64 and Cse523-32 mode, direct calls to
        // external symbols most go through the PLT in PIC mode.  If the symbol
        // has hidden or protected visibility, or if it is static or local, then
        // we don't need to use the PLT - we can directly call it.
        if (Subtarget->isTargetELF() &&
                TM.getRelocationModel() == Reloc::PIC_ &&
                GV->hasDefaultVisibility() && !GV->hasLocalLinkage()) {
            OpFlags = Cse523II::MO_PLT;
        } else if (Subtarget->isPICStyleStubAny() &&
                (GV->isDeclaration() || GV->isWeakForLinker()) &&
                (!Subtarget->getTargetTriple().isMacOSX() ||
                 Subtarget->getTargetTriple().isMacOSXVersionLT(10, 5))) {
            // PC-relative references to external symbols should go through $stub,
            // unless we're building with the leopard linker or later, which
            // automatically synthesizes these stubs.
            OpFlags = Cse523II::MO_DARWIN_STUB;
        }


        MIB = BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(CallOpc));
        if (MemIntName)
            MIB.addExternalSymbol(MemIntName, OpFlags);
        else
            MIB.addGlobalAddress(GV, 0, OpFlags);
    }

    // Add a register mask with the call-preserved registers.
    // Proper defs for return values will be added by setPhysRegsDeadExcept().
    MIB.addRegMask(TRI.getCallPreservedMask(CS.getCallingConv()));

    // Add an implicit use GOT pointer in EBX.
    if (Subtarget->isPICStyleGOT()) {
        assert(0);
        //MIB.addReg(Cse523::EBX, RegState::Implicit);
    }

    if (Subtarget->is64Bit() && isVarArg && !isWin64) {
        assert(0);
        //MIB.addReg(Cse523::AL, RegState::Implicit);
    }

    // Add implicit physical register uses to the call.
    for (unsigned i = 0, e = RegArgs.size(); i != e; ++i)
        MIB.addReg(RegArgs[i], RegState::Implicit);

    // Issue CALLSEQ_END
    unsigned AdjStackUp = TII.getCallFrameDestroyOpcode();
    const unsigned NumBytesCallee = computeBytesPoppedByCallee(*Subtarget, CS);
    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(AdjStackUp))
        .addImm(NumBytes).addImm(NumBytesCallee);

    // Build info for return calling conv lowering code.
    // FIXME: This is practically a copy-paste from TargetLowering::LowerCallTo.
    SmallVector<ISD::InputArg, 32> Ins;
    SmallVector<EVT, 4> RetTys;
    ComputeValueVTs(TLI, I->getType(), RetTys);
    for (unsigned i = 0, e = RetTys.size(); i != e; ++i) {
        EVT VT = RetTys[i];
        MVT RegisterVT = TLI.getRegisterType(I->getParent()->getContext(), VT);
        unsigned NumRegs = TLI.getNumRegisters(I->getParent()->getContext(), VT);
        for (unsigned j = 0; j != NumRegs; ++j) {
            ISD::InputArg MyFlags;
            MyFlags.VT = RegisterVT;
            MyFlags.Used = !CS.getInstruction()->use_empty();
            if (CS.paramHasAttr(0, Attribute::SExt))
                MyFlags.Flags.setSExt();
            if (CS.paramHasAttr(0, Attribute::ZExt))
                MyFlags.Flags.setZExt();
            if (CS.paramHasAttr(0, Attribute::InReg))
                MyFlags.Flags.setInReg();
            Ins.push_back(MyFlags);
        }
    }

    // Now handle call return values.
    SmallVector<unsigned, 4> UsedRegs;
    SmallVector<CCValAssign, 16> RVLocs;
    CCState CCRetInfo(CC, false, *FuncInfo.MF, TM, RVLocs,
            I->getParent()->getContext());
    unsigned ResultReg = FuncInfo.CreateRegs(I->getType());
    CCRetInfo.AnalyzeCallResult(Ins, RetCC_Cse523);
    for (unsigned i = 0; i != RVLocs.size(); ++i) {
        EVT CopyVT = RVLocs[i].getValVT();
        unsigned CopyReg = ResultReg + i;
        assert(0);

        // If this is a call to a function that returns an fp value on the x87 fp
        // stack, but where we prefer to use the value in xmm registers, copy it
        // out as F80 and use a truncate to move it from fp stack reg to xmm reg.
        //if ((RVLocs[i].getLocReg() == Cse523::ST0 ||
        //            RVLocs[i].getLocReg() == Cse523::ST1)) {
        //    if (isScalarFPTypeInSSEReg(RVLocs[i].getValVT())) {
        //        CopyVT = MVT::f80;
        //        CopyReg = createResultReg(&Cse523::RFP80RegClass);
        //    }
        //    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
        //            TII.get(Cse523::FpPOP_RETVAL), CopyReg);
        //} else {
        //    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
        //            TII.get(TargetOpcode::COPY),
        //            CopyReg).addReg(RVLocs[i].getLocReg());
        //    UsedRegs.push_back(RVLocs[i].getLocReg());
        //}

        //if (CopyVT != RVLocs[i].getValVT()) {
        //    // Round the F80 the right size, which also moves to the appropriate xmm
        //    // register. This is accomplished by storing the F80 value in memory and
        //    // then loading it back. Ewww...
        //    EVT ResVT = RVLocs[i].getValVT();
        //    unsigned Opc = ResVT == MVT::f32 ? Cse523::ST_Fp80m32 : Cse523::ST_Fp80m64;
        //    unsigned MemSize = ResVT.getSizeInBits()/8;
        //    int FI = MFI.CreateStackObject(MemSize, MemSize, false);
        //    addFrameReference(BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
        //                TII.get(Opc)), FI)
        //        .addReg(CopyReg);
        //    Opc = ResVT == MVT::f32 ? Cse523::MOVSSrm : Cse523::MOVSDrm;
        //    addFrameReference(BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
        //                TII.get(Opc), ResultReg + i), FI);
        //}
    }

    if (RVLocs.size())
        UpdateValueMap(I, ResultReg, RVLocs.size());

    // Set all unused physreg defs as dead.
    static_cast<MachineInstr *>(MIB)->setPhysRegsDeadExcept(UsedRegs, TRI);

    return true;
}


bool
Cse523FastISel::TargetSelectInstruction(const Instruction *I)  {
    switch (I->getOpcode()) {
        default: break;
        case Instruction::Load:
                 return Cse523SelectLoad(I);
        case Instruction::Store:
                 return Cse523SelectStore(I);
        case Instruction::Ret:
                 return Cse523SelectRet(I);
        case Instruction::ICmp:
        case Instruction::FCmp:
                 return Cse523SelectCmp(I);
        case Instruction::ZExt:
                 return Cse523SelectZExt(I);
        case Instruction::Br:
                 return Cse523SelectBranch(I);
        case Instruction::Call:
                 return Cse523SelectCall(I);
        case Instruction::LShr:
        case Instruction::AShr:
        case Instruction::Shl:
                 return Cse523SelectShift(I);
        case Instruction::SDiv:
        case Instruction::UDiv:
        case Instruction::SRem:
        case Instruction::URem:
                 return Cse523SelectDivRem(I);
        case Instruction::Select:
                 return Cse523SelectSelect(I);
        case Instruction::Trunc:
                 return Cse523SelectTrunc(I);
        case Instruction::FPExt:
                 return Cse523SelectFPExt(I);
        case Instruction::FPTrunc:
                 return Cse523SelectFPTrunc(I);
        case Instruction::IntToPtr: // Deliberate fall-through.
        case Instruction::PtrToInt: {
                                        EVT SrcVT = TLI.getValueType(I->getOperand(0)->getType());
                                        EVT DstVT = TLI.getValueType(I->getType());
                                        if (DstVT.bitsGT(SrcVT))
                                            return Cse523SelectZExt(I);
                                        if (DstVT.bitsLT(SrcVT))
                                            return Cse523SelectTrunc(I);
                                        unsigned Reg = getRegForValue(I->getOperand(0));
                                        if (Reg == 0) return false;
                                        UpdateValueMap(I, Reg);
                                        return true;
                                    }
    }

    return false;
}

unsigned Cse523FastISel::TargetMaterializeConstant(const Constant *C) {
    MVT VT;
    if (!isTypeLegal(C->getType(), VT))
        return 0;

    // Can't handle alternate code models yet.
    if (TM.getCodeModel() != CodeModel::Small)
        return 0;

    // Get opcode and regclass of the output for the given load instruction.
    unsigned Opc = 0;
    const TargetRegisterClass *RC = NULL;
    switch (VT.SimpleTy) {
        default: return 0;
        case MVT::i8:
        case MVT::i16:
        case MVT::i32:
            assert(0);
        case MVT::i64:
                 // Must be in cse523-64 mode.
                 Opc = Cse523::MOV64rm;
                 RC  = &Cse523::GR64RegClass;
                 break;
        case MVT::f32:
        case MVT::f64:
            assert(0);
        case MVT::f80:
                 return 0;
    }

    // Materialize addresses with LEA instructions.
    if (isa<GlobalValue>(C)) {
        Cse523AddressMode AM;
        if (Cse523SelectAddress(C, AM)) {
            // If the expression is just a basereg, then we're done, otherwise we need
            // to emit an LEA.
            if (AM.BaseType == Cse523AddressMode::RegBase &&
                    AM.IndexReg == 0 && AM.Disp == 0 && AM.GV == 0)
                return AM.Base.Reg;

            Opc = Cse523::LEA64r;
            unsigned ResultReg = createResultReg(RC);
            addFullAddress(BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
                        TII.get(Opc), ResultReg), AM);
            return ResultReg;
        }
        return 0;
    }

    // MachineConstantPool wants an explicit alignment.
    unsigned Align = DL.getPrefTypeAlignment(C->getType());
    if (Align == 0) {
        // Alignment of vector types.  FIXME!
        Align = DL.getTypeAllocSize(C->getType());
    }

    // cse523-32 PIC requires a PIC base register for constant pools.
    unsigned PICBase = 0;
    unsigned char OpFlag = 0;
    if (Subtarget->isPICStyleStubPIC()) { // Not dynamic-no-pic
        OpFlag = Cse523II::MO_PIC_BASE_OFFSET;
        PICBase = getInstrInfo()->getGlobalBaseReg(FuncInfo.MF);
    } else if (Subtarget->isPICStyleGOT()) {
        OpFlag = Cse523II::MO_GOTOFF;
        PICBase = getInstrInfo()->getGlobalBaseReg(FuncInfo.MF);
    } else if (Subtarget->isPICStyleRIPRel() &&
            TM.getCodeModel() == CodeModel::Small) {
        PICBase = Cse523::RIP;
    }

    // Create the load from the constant pool.
    unsigned MCPOffset = MCP.getConstantPoolIndex(C, Align);
    unsigned ResultReg = createResultReg(RC);
    addConstantPoolReference(BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
                TII.get(Opc), ResultReg),
            MCPOffset, PICBase, OpFlag);

    return ResultReg;
}

unsigned Cse523FastISel::TargetMaterializeAlloca(const AllocaInst *C) {
    // Fail on dynamic allocas. At this point, getRegForValue has already
    // checked its CSE maps, so if we're here trying to handle a dynamic
    // alloca, we're not going to succeed. Cse523SelectAddress has a
    // check for dynamic allocas, because it's called directly from
    // various places, but TargetMaterializeAlloca also needs a check
    // in order to avoid recursion between getRegForValue,
    // Cse523SelectAddrss, and TargetMaterializeAlloca.
    if (!FuncInfo.StaticAllocaMap.count(C))
        return 0;
    assert(C->isStaticAlloca() && "dynamic alloca in the static alloca map?");

    Cse523AddressMode AM;
    if (!Cse523SelectAddress(C, AM))
        return 0;
    unsigned Opc =  Cse523::LEA64r;
    const TargetRegisterClass* RC = TLI.getRegClassFor(TLI.getPointerTy());
    unsigned ResultReg = createResultReg(RC);
    addFullAddress(BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
                TII.get(Opc), ResultReg), AM);
    return ResultReg;
}

unsigned Cse523FastISel::TargetMaterializeFloatZero(const ConstantFP *CF) {
    MVT VT;
    if (!isTypeLegal(CF->getType(), VT))
        return 0;

    // Get opcode and regclass for the given zero.
    unsigned Opc = 0;
    const TargetRegisterClass *RC = NULL;
    switch (VT.SimpleTy) {
        default: return 0;
        case MVT::f32:
        case MVT::f64:
            assert(0);
        case MVT::f80:
                 // No f80 support yet.
                 return 0;
    }

    unsigned ResultReg = createResultReg(RC);
    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc, TII.get(Opc), ResultReg);
    return ResultReg;
}


bool Cse523FastISel::tryToFoldLoadIntoMI(MachineInstr *MI, unsigned OpNo,
        const LoadInst *LI) {
    Cse523AddressMode AM;
    if (!Cse523SelectAddress(LI->getOperand(0), AM))
        return false;

    const Cse523InstrInfo &XII = (const Cse523InstrInfo&)TII;

    unsigned Size = DL.getTypeAllocSize(LI->getType());
    unsigned Alignment = LI->getAlignment();

    SmallVector<MachineOperand, 8> AddrOps;
    AM.getFullAddress(AddrOps);

    MachineInstr *Result =
        XII.foldMemoryOperandImpl(*FuncInfo.MF, MI, OpNo, AddrOps, Size, Alignment);
    if (Result == 0) return false;

    FuncInfo.MBB->insert(FuncInfo.InsertPt, Result);
    MI->eraseFromParent();
    return true;
}


namespace llvm {
    FastISel *Cse523::createFastISel(FunctionLoweringInfo &funcInfo,
            const TargetLibraryInfo *libInfo) {
        return new Cse523FastISel(funcInfo, libInfo);
    }
}
