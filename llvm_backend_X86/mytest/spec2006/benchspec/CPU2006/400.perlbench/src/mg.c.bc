; ModuleID = 'mg.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.sv = type { i8*, i64, i64 }
%union.any = type { i8* }
%struct.cop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, i8*, %struct.hv*, %struct.gv*, i64, i64, i64, %struct.sv*, %struct.sv* }
%struct.op = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8 }
%struct.hv = type { %struct.xpvhv*, i64, i64 }
%struct.xpvhv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, i64, %struct.he*, %struct.pmop*, i8* }
%struct.magic = type { %struct.magic*, %struct.mgvtbl*, i16, i8, i8, %struct.sv*, i8*, i64 }
%struct.mgvtbl = type { i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i64 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)*, i32 (%struct.magic*, %struct.clone_params*)* }
%struct.clone_params = type { %struct.av*, i64, %struct.interpreter* }
%struct.av = type { %struct.xpvav*, i64, i64 }
%struct.xpvav = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.sv**, %struct.sv*, i8 }
%struct.interpreter = type { i8 }
%struct.he = type { %struct.he*, %struct.hek*, %struct.sv* }
%struct.hek = type { i64, i64, [1 x i8] }
%struct.pmop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.pmop*, %struct.regexp*, i64, i64, i8, %struct.hv* }
%struct.regexp = type { i64*, i64*, %struct.regnode*, %struct.reg_substr_data*, i8*, %struct.reg_data*, i8*, i64*, i64, i64, i64, i64, i64, i64, i64, i64, [1 x %struct.regnode] }
%struct.regnode = type { i8, i8, i16 }
%struct.reg_substr_data = type opaque
%struct.reg_data = type opaque
%struct.gv = type { %struct.xpvgv*, i64, i64 }
%struct.xpvgv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.gp*, i8*, i64, %struct.hv*, i8 }
%struct.gp = type { %struct.sv*, i64, %struct.io*, %struct.cv*, %struct.av*, %struct.hv*, %struct.gv*, %struct.cv*, i64, i64, i64, i8* }
%struct.io = type { %struct.xpvio*, i64, i64 }
%struct.xpvio = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct._PerlIO**, %struct._PerlIO**, %union.anon, i64, i64, i64, i64, i8*, %struct.gv*, i8*, %struct.gv*, i8*, %struct.gv*, i16, i8, i8 }
%struct._PerlIO = type opaque
%union.anon = type { %struct.__dirstream* }
%struct.__dirstream = type opaque
%struct.cv = type { %struct.xpvcv*, i64, i64 }
%struct.xpvcv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.hv*, %struct.op*, %struct.op*, void (%struct.cv*)*, %union.any, %struct.gv*, i8*, i64, %struct.av*, %struct.cv*, i16, i64 }
%struct.stackinfo = type { %struct.av*, %struct.context*, i64, i64, i64, %struct.stackinfo*, %struct.stackinfo*, i64 }
%struct.context = type { i64, %union.anon.0 }
%union.anon.0 = type { %struct.block }
%struct.block = type { i64, %struct.cop*, i64, i64, i64, %struct.pmop*, i8, %union.anon.1 }
%union.anon.1 = type { %struct.block_loop }
%struct.block_loop = type { i8*, i64, %struct.op*, %struct.op*, %struct.op*, %struct.sv**, %struct.sv*, %struct.sv*, %struct.av*, i64, i64 }
%struct.xpv = type { i8*, i64, i64 }
%struct.stat = type { i64, i64, i64, i32, i32, i32, i32, i64, i64, i64, i64, %struct.timespec, %struct.timespec, %struct.timespec, [3 x i64] }
%struct.timespec = type { i64, i64 }

@PL_Sv = external global %struct.sv*
@PL_savestack = external global %union.any*
@PL_curcop = external global %struct.cop*
@.str = private unnamed_addr constant [27 x i8] c"Size magic not implemented\00", align 1
@PL_curpm = external global %struct.pmop*
@PL_no_modify = external constant [0 x i8]
@.str1 = private unnamed_addr constant [22 x i8] c"panic: magic_len: %ld\00", align 1
@PL_dowarn = external global i8
@PL_bodytarget = external global %struct.sv*
@PL_minus_c = external global i8
@PL_debug = external global i64
@.str2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str3 = private unnamed_addr constant [8 x i8] c"NCODING\00", align 1
@PL_encoding = external global %struct.sv*
@PL_maxsysfd = external global i64
@PL_hints = external global i64
@PL_inplace = external global i8*
@PL_sv_undef = external global %struct.sv
@PL_osname = external global i8*
@PL_tainting = external global i8
@.str4 = private unnamed_addr constant [5 x i8] c"\0FPEN\00", align 1
@PL_compiling = external global %struct.cop
@PL_perldb = external global i64
@PL_lex_state = external global i64
@PL_in_eval = external global i32
@PL_basetime = external global i64
@.str5 = private unnamed_addr constant [6 x i8] c"\14AINT\00", align 1
@PL_taint_warn = external global i8
@PL_unsafe = external global i8
@.str6 = private unnamed_addr constant [8 x i8] c"\15NICODE\00", align 1
@PL_unicode = external global i64
@.str7 = private unnamed_addr constant [11 x i8] c"\15TF8LOCALE\00", align 1
@PL_utf8locale = external global i8
@.str8 = private unnamed_addr constant [12 x i8] c"ARNING_BITS\00", align 1
@.str9 = private unnamed_addr constant [13 x i8] zeroinitializer, align 1
@.str10 = private unnamed_addr constant [15 x i8] c"warnings::Bits\00", align 1
@.str11 = private unnamed_addr constant [4 x i8] c"all\00", align 1
@.str12 = private unnamed_addr constant [13 x i8] c"UUUUUUUUUUUU\00", align 1
@PL_tainted = external global i8
@PL_last_in_gv = external global %struct.gv*
@PL_statusvalue = external global i64
@PL_defoutgv = external global %struct.gv*
@.str13 = private unnamed_addr constant [5 x i8] c"_TOP\00", align 1
@PL_ors_sv = external global %struct.sv*
@PL_ofmt = external global i8*
@PL_uid = external global i32
@PL_euid = external global i32
@PL_gid = external global i32
@PL_egid = external global i32
@.str14 = private unnamed_addr constant [5 x i8] c"PATH\00", align 1
@PL_localizing = external global i32
@PL_use_safe_putenv = external global i32
@environ = external global i8**
@PL_origenviron = external global i8**
@PL_psig_ptr = external global %struct.sv**
@.str15 = private unnamed_addr constant [7 x i8] c"IGNORE\00", align 1
@.str16 = private unnamed_addr constant [8 x i8] c"__DIE__\00", align 1
@PL_diehook = external global %struct.sv*
@.str17 = private unnamed_addr constant [9 x i8] c"__WARN__\00", align 1
@PL_warnhook = external global %struct.sv*
@.str18 = private unnamed_addr constant [17 x i8] c"No such hook: %s\00", align 1
@PL_sig_pending = external global i32
@PL_psig_name = external global %struct.sv**
@PL_psig_pend = external global i32*
@PL_signals = external global i64
@PL_sighandlerp = external global void (i32)*
@.str19 = private unnamed_addr constant [22 x i8] c"No such signal: SIG%s\00", align 1
@PL_csighandlerp = external global void (i32)*
@.str20 = private unnamed_addr constant [8 x i8] c"DEFAULT\00", align 1
@.str21 = private unnamed_addr constant [7 x i8] c"main::\00", align 1
@PL_sub_generation = external global i64
@PL_amagic_generation = external global i64
@.str22 = private unnamed_addr constant [6 x i8] c"FETCH\00", align 1
@PL_stack_sp = external global %struct.sv**
@PL_curstackinfo = external global %struct.stackinfo*
@PL_stack_base = external global %struct.sv**
@PL_curstack = external global %struct.av*
@PL_stack_max = external global %struct.sv**
@.str23 = private unnamed_addr constant [6 x i8] c"STORE\00", align 1
@PL_stderrgv = external global %struct.gv*
@.str24 = private unnamed_addr constant [17 x i8] c"panic: POPSTACK\0A\00", align 1
@.str25 = private unnamed_addr constant [7 x i8] c"DELETE\00", align 1
@PL_tmps_floor = external global i64
@PL_tmps_ix = external global i64
@.str26 = private unnamed_addr constant [10 x i8] c"FETCHSIZE\00", align 1
@PL_markstack_ptr = external global i64*
@PL_markstack_max = external global i64*
@.str27 = private unnamed_addr constant [6 x i8] c"CLEAR\00", align 1
@.str28 = private unnamed_addr constant [8 x i8] c"NEXTKEY\00", align 1
@.str29 = private unnamed_addr constant [9 x i8] c"FIRSTKEY\00", align 1
@.str30 = private unnamed_addr constant [7 x i8] c"EXISTS\00", align 1
@.str31 = private unnamed_addr constant [7 x i8] c"SCALAR\00", align 1
@PL_sv_yes = external global %struct.sv
@PL_sv_no = external global %struct.sv
@PL_DBline = external global %struct.gv*
@PL_Xpv = external global %struct.xpv*
@.str32 = private unnamed_addr constant [2 x i8] c"*\00", align 1
@PL_no_helem = external constant [0 x i8]
@PL_no_aelem = external constant [0 x i8]
@.str33 = private unnamed_addr constant [26 x i8] c"panic: magic_killbackrefs\00", align 1
@PL_regfree = external global void (%struct.regexp*)*
@.str34 = private unnamed_addr constant [17 x i8] c"assigning to $^O\00", align 1
@PL_DBsingle = external global %struct.sv*
@PL_multiline = external global i32
@PL_rs = external global %struct.sv*
@PL_ofs_sv = external global %struct.sv*
@PL_delaymagic = external global i32
@.str35 = private unnamed_addr constant [26 x i8] c"setruid() not implemented\00", align 1
@.str36 = private unnamed_addr constant [26 x i8] c"seteuid() not implemented\00", align 1
@.str37 = private unnamed_addr constant [26 x i8] c"setrgid() not implemented\00", align 1
@.str38 = private unnamed_addr constant [26 x i8] c"setegid() not implemented\00", align 1
@PL_chopset = external global i8*
@PL_origalen = external global i64
@PL_origargv = external global i8**
@PL_origargc = external global i32
@PL_sig_name = external global [0 x i8*]
@PL_sig_num = external global [0 x i32]
@.str39 = private unnamed_addr constant [4 x i8] c"CLD\00", align 1
@PL_op = external global %struct.op*
@PL_savestack_ix = external global i64
@PL_savestack_max = external global i64
@PL_retstack_ix = external global i64
@PL_retstack_max = external global i64
@PL_scopestack_ix = external global i64
@PL_scopestack_max = external global i64
@.str40 = private unnamed_addr constant [51 x i8] c"Signal SIG%s received, but no signal handler set.\0A\00", align 1
@PL_retstack = external global %struct.op**
@.str41 = private unnamed_addr constant [33 x i8] c"SIG%s handler \22%s\22 not defined.\0A\00", align 1
@.str42 = private unnamed_addr constant [9 x i8] c"__ANON__\00", align 1
@sig_sv = internal unnamed_addr global %struct.sv* null, align 8
@PL_errgv = external global %struct.gv*

; Function Attrs: nounwind uwtable
define void @Perl_mg_magical(%struct.sv* nocapture %sv) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xmg_magic = getelementptr inbounds i8* %0, i64 40
  %1 = bitcast i8* %xmg_magic to %struct.magic**
  %mg.029 = load %struct.magic** %1, align 8
  %tobool30 = icmp eq %struct.magic* %mg.029, null
  br i1 %tobool30, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %sv_flags10 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %mg.031 = phi %struct.magic* [ %mg.029, %for.body.lr.ph ], [ %mg.0, %for.inc ]
  %mg_virtual = getelementptr inbounds %struct.magic* %mg.031, i64 0, i32 1
  %2 = load %struct.mgvtbl** %mg_virtual, align 8, !tbaa !7
  %tobool1 = icmp eq %struct.mgvtbl* %2, null
  br i1 %tobool1, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %svt_get = getelementptr inbounds %struct.mgvtbl* %2, i64 0, i32 0
  %3 = load i32 (%struct.sv*, %struct.magic*)** %svt_get, align 8, !tbaa !10
  %tobool2 = icmp eq i32 (%struct.sv*, %struct.magic*)* %3, null
  br i1 %tobool2, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %mg_flags = getelementptr inbounds %struct.magic* %mg.031, i64 0, i32 4
  %4 = load i8* %mg_flags, align 1, !tbaa !12
  %and = and i8 %4, 4
  %tobool3 = icmp eq i8 %and, 0
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %land.lhs.true
  %5 = load i64* %sv_flags10, align 8, !tbaa !13
  %or = or i64 %5, 8192
  store i64 %or, i64* %sv_flags10, align 8, !tbaa !13
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %if.then, %if.then4
  %svt_set = getelementptr inbounds %struct.mgvtbl* %2, i64 0, i32 1
  %6 = load i32 (%struct.sv*, %struct.magic*)** %svt_set, align 8, !tbaa !14
  %tobool5 = icmp eq i32 (%struct.sv*, %struct.magic*)* %6, null
  %.pre = load i64* %sv_flags10, align 8, !tbaa !13
  br i1 %tobool5, label %if.end9, label %if.then6

if.then6:                                         ; preds = %if.end
  %or8 = or i64 %.pre, 16384
  store i64 %or8, i64* %sv_flags10, align 8, !tbaa !13
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then6
  %7 = phi i64 [ %or8, %if.then6 ], [ %.pre, %if.end ]
  %and11 = and i64 %7, 24576
  %tobool12 = icmp eq i64 %and11, 0
  br i1 %tobool12, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end9
  %svt_clear = getelementptr inbounds %struct.mgvtbl* %2, i64 0, i32 3
  %8 = load i32 (%struct.sv*, %struct.magic*)** %svt_clear, align 8, !tbaa !15
  %tobool13 = icmp eq i32 (%struct.sv*, %struct.magic*)* %8, null
  br i1 %tobool13, label %for.inc, label %if.then14

if.then14:                                        ; preds = %lor.lhs.false, %if.end9
  %or16 = or i64 %7, 32768
  store i64 %or16, i64* %sv_flags10, align 8, !tbaa !13
  br label %for.inc

for.inc:                                          ; preds = %lor.lhs.false, %for.body, %if.then14
  %mg_moremagic = getelementptr inbounds %struct.magic* %mg.031, i64 0, i32 0
  %mg.0 = load %struct.magic** %mg_moremagic, align 8
  %tobool = icmp eq %struct.magic* %mg.0, null
  br i1 %tobool, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @Perl_mg_get(%struct.sv* %sv) #0 {
entry:
  %call = tail call i64 @Perl_save_alloc(i64 24, i64 0) #4
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !13
  store %struct.sv* %sv, %struct.sv** @PL_Sv, align 8, !tbaa !16
  %tobool = icmp eq %struct.sv* %sv, null
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %sv_refcnt = getelementptr inbounds %struct.sv* %sv, i64 0, i32 1
  %1 = load i64* %sv_refcnt, align 8, !tbaa !17
  %inc = add i64 %1, 1
  store i64 %inc, i64* %sv_refcnt, align 8, !tbaa !17
  br label %land.end

land.end:                                         ; preds = %entry, %land.rhs
  %call2 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %sv) #4
  %conv = and i64 %0, 2048
  %tobool3 = icmp eq i64 %conv, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  %2 = load i64* %sv_flags, align 8, !tbaa !13
  %and5 = and i64 %2, -2049
  store i64 %and5, i64* %sv_flags, align 8, !tbaa !13
  br label %if.end

if.end:                                           ; preds = %land.end, %if.then
  %call6 = tail call i32 (i64, %struct.sv*, ...)* bitcast (i32 (...)* @save_magic to i32 (i64, %struct.sv*, ...)*)(i64 %call, %struct.sv* %sv) #4
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %3 = load i8** %sv_any, align 8, !tbaa !1
  %xmg_magic = getelementptr inbounds i8* %3, i64 40
  %4 = bitcast i8* %xmg_magic to %struct.magic**
  %5 = load %struct.magic** %4, align 8, !tbaa !18
  %add.ptr.sum = add i64 %call, 8
  br label %while.cond.outer

while.cond.outer:                                 ; preds = %land.lhs.true36, %if.end
  %6 = phi i8* [ %3, %if.end ], [ %18, %land.lhs.true36 ]
  %cur.0.ph = phi %struct.magic* [ %5, %if.end ], [ %cur.0.mg.1, %land.lhs.true36 ]
  %mg.0.ph = phi %struct.magic* [ %5, %if.end ], [ %mg.1., %land.lhs.true36 ]
  %head.0.ph = phi %struct.magic* [ %5, %if.end ], [ %head.1, %land.lhs.true36 ]
  %newmg.0.ph = phi %struct.magic* [ %5, %if.end ], [ %21, %land.lhs.true36 ]
  %have_new.0.ph = phi i32 [ 0, %if.end ], [ %have_new.1., %land.lhs.true36 ]
  br label %while.cond

while.cond:                                       ; preds = %while.cond.outer, %if.end28
  %7 = phi i8* [ %18, %if.end28 ], [ %6, %while.cond.outer ]
  %mg.0 = phi %struct.magic* [ %mg.1, %if.end28 ], [ %mg.0.ph, %while.cond.outer ]
  %head.0 = phi %struct.magic* [ %head.1, %if.end28 ], [ %head.0.ph, %while.cond.outer ]
  %have_new.0 = phi i32 [ %have_new.1, %if.end28 ], [ %have_new.0.ph, %while.cond.outer ]
  %tobool7 = icmp eq %struct.magic* %mg.0, null
  br i1 %tobool7, label %while.end, label %while.body

while.body:                                       ; preds = %while.cond
  %mg_virtual = getelementptr inbounds %struct.magic* %mg.0, i64 0, i32 1
  %8 = load %struct.mgvtbl** %mg_virtual, align 8, !tbaa !7
  %mg_flags = getelementptr inbounds %struct.magic* %mg.0, i64 0, i32 4
  %9 = load i8* %mg_flags, align 1, !tbaa !12
  %and9 = and i8 %9, 4
  %tobool10 = icmp eq i8 %and9, 0
  %tobool11 = icmp ne %struct.mgvtbl* %8, null
  %or.cond = and i1 %tobool10, %tobool11
  br i1 %or.cond, label %land.lhs.true12, label %if.end28

land.lhs.true12:                                  ; preds = %while.body
  %svt_get = getelementptr inbounds %struct.mgvtbl* %8, i64 0, i32 0
  %10 = load i32 (%struct.sv*, %struct.magic*)** %svt_get, align 8, !tbaa !10
  %tobool13 = icmp eq i32 (%struct.sv*, %struct.magic*)* %10, null
  br i1 %tobool13, label %if.end28, label %if.then14

if.then14:                                        ; preds = %land.lhs.true12
  %call16 = tail call i32 %10(%struct.sv* %sv, %struct.magic* %mg.0) #4
  %11 = load i8** %sv_any, align 8, !tbaa !1
  %xmg_magic18 = getelementptr inbounds i8* %11, i64 40
  %12 = bitcast i8* %xmg_magic18 to %struct.magic**
  %13 = load %struct.magic** %12, align 8, !tbaa !18
  %tobool19 = icmp eq %struct.magic* %13, null
  br i1 %tobool19, label %while.end, label %if.end21

if.end21:                                         ; preds = %if.then14
  %14 = load i8* %mg_flags, align 1, !tbaa !12
  %and24 = and i8 %14, 4
  %tobool25 = icmp eq i8 %and24, 0
  br i1 %tobool25, label %if.end28, label %if.then26

if.then26:                                        ; preds = %if.end21
  %15 = load %union.any** @PL_savestack, align 8, !tbaa !16
  %16 = bitcast %union.any* %15 to i8*
  %mgs_flags = getelementptr inbounds i8* %16, i64 %add.ptr.sum
  %17 = bitcast i8* %mgs_flags to i64*
  store i64 0, i64* %17, align 8, !tbaa !21
  br label %if.end28

if.end28:                                         ; preds = %if.end21, %land.lhs.true12, %if.then26, %while.body
  %18 = phi i8* [ %11, %if.end21 ], [ %7, %land.lhs.true12 ], [ %11, %if.then26 ], [ %7, %while.body ]
  %mg_moremagic = getelementptr inbounds %struct.magic* %mg.0, i64 0, i32 0
  %19 = load %struct.magic** %mg_moremagic, align 8, !tbaa !23
  %tobool29 = icmp ne i32 %have_new.0, 0
  %cmp = icmp eq %struct.magic* %19, %head.0
  %or.cond83 = and i1 %tobool29, %cmp
  %mg.1 = select i1 %or.cond83, %struct.magic* %cur.0.ph, %struct.magic* %19
  %head.1 = select i1 %or.cond83, %struct.magic* %newmg.0.ph, %struct.magic* %head.0
  %have_new.1 = select i1 %or.cond83, i32 0, i32 %have_new.0
  %tobool35 = icmp eq i32 %have_new.1, 0
  br i1 %tobool35, label %land.lhs.true36, label %while.cond

land.lhs.true36:                                  ; preds = %if.end28
  %xmg_magic38 = getelementptr inbounds i8* %18, i64 40
  %20 = bitcast i8* %xmg_magic38 to %struct.magic**
  %21 = load %struct.magic** %20, align 8, !tbaa !18
  %cmp39 = icmp eq %struct.magic* %21, %head.1
  %cur.0.mg.1 = select i1 %cmp39, %struct.magic* %cur.0.ph, %struct.magic* %mg.1
  %mg.1. = select i1 %cmp39, %struct.magic* %mg.1, %struct.magic* %21
  %22 = zext i1 %cmp39 to i32
  %have_new.1. = xor i32 %22, 1
  br label %while.cond.outer

while.end:                                        ; preds = %if.then14, %while.cond
  %23 = load %union.any** @PL_savestack, align 8, !tbaa !16
  %24 = bitcast %union.any* %23 to i8*
  %add.ptr.i = getelementptr inbounds i8* %24, i64 %call
  %mgs_sv.i = bitcast i8* %add.ptr.i to %struct.sv**
  %25 = load %struct.sv** %mgs_sv.i, align 8, !tbaa !24
  %tobool.i = icmp eq %struct.sv* %25, null
  br i1 %tobool.i, label %restore_magic.exit, label %if.end.i

if.end.i:                                         ; preds = %while.end
  %sv_flags.i = getelementptr inbounds %struct.sv* %25, i64 0, i32 2
  %26 = load i64* %sv_flags.i, align 8, !tbaa !13
  %and.i = and i64 %26, 255
  %cmp.i = icmp ugt i64 %and.i, 6
  br i1 %cmp.i, label %land.lhs.true.i, label %if.end15.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %sv_any.i = getelementptr inbounds %struct.sv* %25, i64 0, i32 0
  %27 = load i8** %sv_any.i, align 8, !tbaa !1
  %xmg_magic.i = getelementptr inbounds i8* %27, i64 40
  %28 = bitcast i8* %xmg_magic.i to %struct.magic**
  %29 = load %struct.magic** %28, align 8, !tbaa !18
  %tobool1.i = icmp eq %struct.magic* %29, null
  br i1 %tobool1.i, label %if.end15.i, label %if.then2.i

if.then2.i:                                       ; preds = %land.lhs.true.i
  %mgs_flags.i = getelementptr inbounds i8* %24, i64 %add.ptr.sum
  %30 = bitcast i8* %mgs_flags.i to i64*
  %31 = load i64* %30, align 8, !tbaa !21
  %tobool3.i = icmp eq i64 %31, 0
  br i1 %tobool3.i, label %for.body.i, label %if.then4.i

if.then4.i:                                       ; preds = %if.then2.i
  %or.i = or i64 %31, %26
  store i64 %or.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end7.i

for.body.i:                                       ; preds = %if.then2.i, %for.inc.i
  %32 = phi i64 [ %.pre.i, %for.inc.i ], [ %26, %if.then2.i ]
  %mg.031.i = phi %struct.magic* [ %mg.0.i, %for.inc.i ], [ %29, %if.then2.i ]
  %mg_virtual.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 1
  %33 = load %struct.mgvtbl** %mg_virtual.i, align 8, !tbaa !7
  %tobool1.i86 = icmp eq %struct.mgvtbl* %33, null
  br i1 %tobool1.i86, label %for.inc.i, label %if.then.i

if.then.i:                                        ; preds = %for.body.i
  %svt_get.i = getelementptr inbounds %struct.mgvtbl* %33, i64 0, i32 0
  %34 = load i32 (%struct.sv*, %struct.magic*)** %svt_get.i, align 8, !tbaa !10
  %tobool2.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %34, null
  br i1 %tobool2.i, label %if.end.i93, label %land.lhs.true.i89

land.lhs.true.i89:                                ; preds = %if.then.i
  %mg_flags.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 4
  %35 = load i8* %mg_flags.i, align 1, !tbaa !12
  %and.i87 = and i8 %35, 4
  %tobool3.i88 = icmp eq i8 %and.i87, 0
  br i1 %tobool3.i88, label %if.then4.i91, label %if.end.i93

if.then4.i91:                                     ; preds = %land.lhs.true.i89
  %or.i90 = or i64 %32, 8192
  store i64 %or.i90, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end.i93

if.end.i93:                                       ; preds = %if.then4.i91, %land.lhs.true.i89, %if.then.i
  %.pre.i92 = phi i64 [ %or.i90, %if.then4.i91 ], [ %32, %land.lhs.true.i89 ], [ %32, %if.then.i ]
  %svt_set.i = getelementptr inbounds %struct.mgvtbl* %33, i64 0, i32 1
  %36 = load i32 (%struct.sv*, %struct.magic*)** %svt_set.i, align 8, !tbaa !14
  %tobool5.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %36, null
  br i1 %tobool5.i, label %if.end9.i, label %if.then6.i

if.then6.i:                                       ; preds = %if.end.i93
  %or8.i = or i64 %.pre.i92, 16384
  store i64 %or8.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end9.i

if.end9.i:                                        ; preds = %if.then6.i, %if.end.i93
  %37 = phi i64 [ %or8.i, %if.then6.i ], [ %.pre.i92, %if.end.i93 ]
  %and11.i = and i64 %37, 24576
  %tobool12.i = icmp eq i64 %and11.i, 0
  br i1 %tobool12.i, label %if.then14.i, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end9.i
  %svt_clear.i = getelementptr inbounds %struct.mgvtbl* %33, i64 0, i32 3
  %38 = load i32 (%struct.sv*, %struct.magic*)** %svt_clear.i, align 8, !tbaa !15
  %tobool13.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %38, null
  br i1 %tobool13.i, label %for.inc.i, label %if.then14.i

if.then14.i:                                      ; preds = %lor.lhs.false.i, %if.end9.i
  %or16.i = or i64 %37, 32768
  store i64 %or16.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then14.i, %lor.lhs.false.i, %for.body.i
  %.pre.i = phi i64 [ %or16.i, %if.then14.i ], [ %37, %lor.lhs.false.i ], [ %32, %for.body.i ]
  %mg_moremagic.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 0
  %mg.0.i = load %struct.magic** %mg_moremagic.i, align 8
  %tobool.i94 = icmp eq %struct.magic* %mg.0.i, null
  br i1 %tobool.i94, label %if.end7.i, label %for.body.i

if.end7.i:                                        ; preds = %for.inc.i, %if.then4.i
  %39 = phi i64 [ %or.i, %if.then4.i ], [ %.pre.i, %for.inc.i ]
  %and9.i = and i64 %39, 8192
  %tobool10.i = icmp eq i64 %and9.i, 0
  br i1 %tobool10.i, label %if.end15.i, label %if.then11.i

if.then11.i:                                      ; preds = %if.end7.i
  %and13.i = and i64 %39, -458753
  store i64 %and13.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end15.i

if.end15.i:                                       ; preds = %if.then11.i, %if.end7.i, %land.lhs.true.i, %if.end.i
  store %struct.sv* null, %struct.sv** %mgs_sv.i, align 8, !tbaa !24
  %40 = load i64* @PL_savestack_ix, align 8, !tbaa !25
  %add.ptr.sum.i = add i64 %call, 16
  %mgs_ss_ix.i = getelementptr inbounds i8* %24, i64 %add.ptr.sum.i
  %41 = bitcast i8* %mgs_ss_ix.i to i64*
  %42 = load i64* %41, align 8, !tbaa !26
  %cmp17.i = icmp eq i64 %40, %42
  br i1 %cmp17.i, label %if.then18.i, label %restore_magic.exit

if.then18.i:                                      ; preds = %if.end15.i
  %dec22.i = add nsw i64 %40, -5
  store i64 %dec22.i, i64* @PL_savestack_ix, align 8, !tbaa !25
  %43 = load %union.any** @PL_savestack, align 8, !tbaa !16
  %arrayidx23.i = getelementptr inbounds %union.any* %43, i64 %dec22.i
  %any_i3224.i = bitcast %union.any* %arrayidx23.i to i64*
  %44 = load i64* %any_i3224.i, align 8, !tbaa !25
  %sub25.i = sub nsw i64 %dec22.i, %44
  store i64 %sub25.i, i64* @PL_savestack_ix, align 8, !tbaa !25
  br label %restore_magic.exit

restore_magic.exit:                               ; preds = %while.end, %if.end15.i, %if.then18.i
  %sv_refcnt43 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 1
  %45 = load i64* %sv_refcnt43, align 8, !tbaa !17
  %cmp44 = icmp eq i64 %45, 1
  br i1 %cmp44, label %if.then46, label %if.end57

if.then46:                                        ; preds = %restore_magic.exit
  %46 = load i64* %sv_flags, align 8, !tbaa !13
  %and48 = and i64 %46, 1223753727
  store i64 %and48, i64* %sv_flags, align 8, !tbaa !13
  %and50 = and i64 %46, 2097152
  %tobool51 = icmp eq i64 %and50, 0
  br i1 %tobool51, label %if.end57, label %land.rhs52

land.rhs52:                                       ; preds = %if.then46
  %call53 = tail call i32 @Perl_sv_backoff(%struct.sv* %sv) #4
  br label %if.end57

if.end57:                                         ; preds = %land.rhs52, %if.then46, %restore_magic.exit
  ret i32 0
}

declare i64 @Perl_save_alloc(i64, i64) #1

declare %struct.sv* @Perl_sv_2mortal(%struct.sv*) #1

declare i32 @save_magic(...) #1

declare i32 @Perl_sv_backoff(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_mg_set(%struct.sv* %sv) #0 {
entry:
  %call = tail call i64 @Perl_save_alloc(i64 24, i64 0) #4
  %call1 = tail call i32 (i64, %struct.sv*, ...)* bitcast (i32 (...)* @save_magic to i32 (i64, %struct.sv*, ...)*)(i64 %call, %struct.sv* %sv) #4
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xmg_magic = getelementptr inbounds i8* %0, i64 40
  %1 = bitcast i8* %xmg_magic to %struct.magic**
  %2 = load %struct.magic** %1, align 8, !tbaa !18
  %tobool35 = icmp eq %struct.magic* %2, null
  br i1 %tobool35, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %add.ptr.sum = add i64 %call, 8
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.cond.backedge
  %mg.036 = phi %struct.magic* [ %2, %for.body.lr.ph ], [ %4, %for.cond.backedge ]
  %mg_virtual = getelementptr inbounds %struct.magic* %mg.036, i64 0, i32 1
  %3 = load %struct.mgvtbl** %mg_virtual, align 8, !tbaa !7
  %mg_moremagic = getelementptr inbounds %struct.magic* %mg.036, i64 0, i32 0
  %4 = load %struct.magic** %mg_moremagic, align 8, !tbaa !23
  %mg_flags = getelementptr inbounds %struct.magic* %mg.036, i64 0, i32 4
  %5 = load i8* %mg_flags, align 1, !tbaa !12
  %and = and i8 %5, 4
  %tobool2 = icmp eq i8 %and, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %and5 = and i8 %5, -5
  store i8 %and5, i8* %mg_flags, align 1, !tbaa !12
  %6 = load %union.any** @PL_savestack, align 8, !tbaa !16
  %7 = bitcast %union.any* %6 to i8*
  %mgs_flags = getelementptr inbounds i8* %7, i64 %add.ptr.sum
  %8 = bitcast i8* %mgs_flags to i64*
  store i64 0, i64* %8, align 8, !tbaa !21
  br label %if.end

if.end:                                           ; preds = %for.body, %if.then
  %tobool7 = icmp eq %struct.mgvtbl* %3, null
  br i1 %tobool7, label %for.cond.backedge, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %svt_set = getelementptr inbounds %struct.mgvtbl* %3, i64 0, i32 1
  %9 = load i32 (%struct.sv*, %struct.magic*)** %svt_set, align 8, !tbaa !14
  %tobool8 = icmp eq i32 (%struct.sv*, %struct.magic*)* %9, null
  br i1 %tobool8, label %for.cond.backedge, label %if.then9

for.cond.backedge:                                ; preds = %land.lhs.true, %if.end, %if.then9
  %tobool = icmp eq %struct.magic* %4, null
  br i1 %tobool, label %for.end, label %for.body

if.then9:                                         ; preds = %land.lhs.true
  %call11 = tail call i32 %9(%struct.sv* %sv, %struct.magic* %mg.036) #4
  br label %for.cond.backedge

for.end:                                          ; preds = %for.cond.backedge, %entry
  %10 = load %union.any** @PL_savestack, align 8, !tbaa !16
  %11 = bitcast %union.any* %10 to i8*
  %add.ptr.i = getelementptr inbounds i8* %11, i64 %call
  %mgs_sv.i = bitcast i8* %add.ptr.i to %struct.sv**
  %12 = load %struct.sv** %mgs_sv.i, align 8, !tbaa !24
  %tobool.i = icmp eq %struct.sv* %12, null
  br i1 %tobool.i, label %restore_magic.exit, label %if.end.i

if.end.i:                                         ; preds = %for.end
  %sv_flags.i = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i64* %sv_flags.i, align 8, !tbaa !13
  %and.i = and i64 %13, 255
  %cmp.i = icmp ugt i64 %and.i, 6
  br i1 %cmp.i, label %land.lhs.true.i, label %if.end15.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %sv_any.i = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %14 = load i8** %sv_any.i, align 8, !tbaa !1
  %xmg_magic.i = getelementptr inbounds i8* %14, i64 40
  %15 = bitcast i8* %xmg_magic.i to %struct.magic**
  %16 = load %struct.magic** %15, align 8, !tbaa !18
  %tobool1.i = icmp eq %struct.magic* %16, null
  br i1 %tobool1.i, label %if.end15.i, label %if.then2.i

if.then2.i:                                       ; preds = %land.lhs.true.i
  %add.ptr.sum37.i = add i64 %call, 8
  %mgs_flags.i = getelementptr inbounds i8* %11, i64 %add.ptr.sum37.i
  %17 = bitcast i8* %mgs_flags.i to i64*
  %18 = load i64* %17, align 8, !tbaa !21
  %tobool3.i = icmp eq i64 %18, 0
  br i1 %tobool3.i, label %for.body.i, label %if.then4.i

if.then4.i:                                       ; preds = %if.then2.i
  %or.i = or i64 %18, %13
  store i64 %or.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end7.i

for.body.i:                                       ; preds = %if.then2.i, %for.inc.i
  %19 = phi i64 [ %.pre.i, %for.inc.i ], [ %13, %if.then2.i ]
  %mg.031.i = phi %struct.magic* [ %mg.0.i, %for.inc.i ], [ %16, %if.then2.i ]
  %mg_virtual.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 1
  %20 = load %struct.mgvtbl** %mg_virtual.i, align 8, !tbaa !7
  %tobool1.i26 = icmp eq %struct.mgvtbl* %20, null
  br i1 %tobool1.i26, label %for.inc.i, label %if.then.i

if.then.i:                                        ; preds = %for.body.i
  %svt_get.i = getelementptr inbounds %struct.mgvtbl* %20, i64 0, i32 0
  %21 = load i32 (%struct.sv*, %struct.magic*)** %svt_get.i, align 8, !tbaa !10
  %tobool2.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %21, null
  br i1 %tobool2.i, label %if.end.i33, label %land.lhs.true.i29

land.lhs.true.i29:                                ; preds = %if.then.i
  %mg_flags.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 4
  %22 = load i8* %mg_flags.i, align 1, !tbaa !12
  %and.i27 = and i8 %22, 4
  %tobool3.i28 = icmp eq i8 %and.i27, 0
  br i1 %tobool3.i28, label %if.then4.i31, label %if.end.i33

if.then4.i31:                                     ; preds = %land.lhs.true.i29
  %or.i30 = or i64 %19, 8192
  store i64 %or.i30, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end.i33

if.end.i33:                                       ; preds = %if.then4.i31, %land.lhs.true.i29, %if.then.i
  %.pre.i32 = phi i64 [ %or.i30, %if.then4.i31 ], [ %19, %land.lhs.true.i29 ], [ %19, %if.then.i ]
  %svt_set.i = getelementptr inbounds %struct.mgvtbl* %20, i64 0, i32 1
  %23 = load i32 (%struct.sv*, %struct.magic*)** %svt_set.i, align 8, !tbaa !14
  %tobool5.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %23, null
  br i1 %tobool5.i, label %if.end9.i, label %if.then6.i

if.then6.i:                                       ; preds = %if.end.i33
  %or8.i = or i64 %.pre.i32, 16384
  store i64 %or8.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end9.i

if.end9.i:                                        ; preds = %if.then6.i, %if.end.i33
  %24 = phi i64 [ %or8.i, %if.then6.i ], [ %.pre.i32, %if.end.i33 ]
  %and11.i = and i64 %24, 24576
  %tobool12.i = icmp eq i64 %and11.i, 0
  br i1 %tobool12.i, label %if.then14.i, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end9.i
  %svt_clear.i = getelementptr inbounds %struct.mgvtbl* %20, i64 0, i32 3
  %25 = load i32 (%struct.sv*, %struct.magic*)** %svt_clear.i, align 8, !tbaa !15
  %tobool13.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %25, null
  br i1 %tobool13.i, label %for.inc.i, label %if.then14.i

if.then14.i:                                      ; preds = %lor.lhs.false.i, %if.end9.i
  %or16.i = or i64 %24, 32768
  store i64 %or16.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then14.i, %lor.lhs.false.i, %for.body.i
  %.pre.i = phi i64 [ %or16.i, %if.then14.i ], [ %24, %lor.lhs.false.i ], [ %19, %for.body.i ]
  %mg_moremagic.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 0
  %mg.0.i = load %struct.magic** %mg_moremagic.i, align 8
  %tobool.i34 = icmp eq %struct.magic* %mg.0.i, null
  br i1 %tobool.i34, label %if.end7.i, label %for.body.i

if.end7.i:                                        ; preds = %for.inc.i, %if.then4.i
  %26 = phi i64 [ %or.i, %if.then4.i ], [ %.pre.i, %for.inc.i ]
  %and9.i = and i64 %26, 8192
  %tobool10.i = icmp eq i64 %and9.i, 0
  br i1 %tobool10.i, label %if.end15.i, label %if.then11.i

if.then11.i:                                      ; preds = %if.end7.i
  %and13.i = and i64 %26, -458753
  store i64 %and13.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end15.i

if.end15.i:                                       ; preds = %if.then11.i, %if.end7.i, %land.lhs.true.i, %if.end.i
  store %struct.sv* null, %struct.sv** %mgs_sv.i, align 8, !tbaa !24
  %27 = load i64* @PL_savestack_ix, align 8, !tbaa !25
  %add.ptr.sum.i = add i64 %call, 16
  %mgs_ss_ix.i = getelementptr inbounds i8* %11, i64 %add.ptr.sum.i
  %28 = bitcast i8* %mgs_ss_ix.i to i64*
  %29 = load i64* %28, align 8, !tbaa !26
  %cmp17.i = icmp eq i64 %27, %29
  br i1 %cmp17.i, label %if.then18.i, label %restore_magic.exit

if.then18.i:                                      ; preds = %if.end15.i
  %dec22.i = add nsw i64 %27, -5
  store i64 %dec22.i, i64* @PL_savestack_ix, align 8, !tbaa !25
  %30 = load %union.any** @PL_savestack, align 8, !tbaa !16
  %arrayidx23.i = getelementptr inbounds %union.any* %30, i64 %dec22.i
  %any_i3224.i = bitcast %union.any* %arrayidx23.i to i64*
  %31 = load i64* %any_i3224.i, align 8, !tbaa !25
  %sub25.i = sub nsw i64 %dec22.i, %31
  store i64 %sub25.i, i64* @PL_savestack_ix, align 8, !tbaa !25
  br label %restore_magic.exit

restore_magic.exit:                               ; preds = %for.end, %if.end15.i, %if.then18.i
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i64 @Perl_mg_length(%struct.sv* %sv) #0 {
entry:
  %len = alloca i64, align 8
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xmg_magic = getelementptr inbounds i8* %0, i64 40
  %1 = bitcast i8* %xmg_magic to %struct.magic**
  %mg.060 = load %struct.magic** %1, align 8
  %tobool61 = icmp eq %struct.magic* %mg.060, null
  br i1 %tobool61, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %mg.062 = phi %struct.magic* [ %mg.0, %for.inc ], [ %mg.060, %entry ]
  %mg_virtual = getelementptr inbounds %struct.magic* %mg.062, i64 0, i32 1
  %2 = load %struct.mgvtbl** %mg_virtual, align 8, !tbaa !7
  %tobool1 = icmp eq %struct.mgvtbl* %2, null
  br i1 %tobool1, label %for.inc, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %svt_len = getelementptr inbounds %struct.mgvtbl* %2, i64 0, i32 2
  %3 = load i64 (%struct.sv*, %struct.magic*)** %svt_len, align 8, !tbaa !27
  %tobool2 = icmp eq i64 (%struct.sv*, %struct.magic*)* %3, null
  br i1 %tobool2, label %for.inc, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %call = call i64 @Perl_save_alloc(i64 24, i64 0) #4
  %call3 = call i32 (i64, %struct.sv*, ...)* bitcast (i32 (...)* @save_magic to i32 (i64, %struct.sv*, ...)*)(i64 %call, %struct.sv* %sv) #4
  %4 = load i64 (%struct.sv*, %struct.magic*)** %svt_len, align 8, !tbaa !27
  %call5 = call i64 %4(%struct.sv* %sv, %struct.magic* %mg.062) #4
  store i64 %call5, i64* %len, align 8, !tbaa !25
  %5 = load %union.any** @PL_savestack, align 8, !tbaa !16
  %6 = bitcast %union.any* %5 to i8*
  %add.ptr.i = getelementptr inbounds i8* %6, i64 %call
  %mgs_sv.i = bitcast i8* %add.ptr.i to %struct.sv**
  %7 = load %struct.sv** %mgs_sv.i, align 8, !tbaa !24
  %tobool.i = icmp eq %struct.sv* %7, null
  br i1 %tobool.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.then
  %sv_flags.i = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i64* %sv_flags.i, align 8, !tbaa !13
  %and.i = and i64 %8, 255
  %cmp.i = icmp ugt i64 %and.i, 6
  br i1 %cmp.i, label %land.lhs.true.i, label %if.end15.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %sv_any.i = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %9 = load i8** %sv_any.i, align 8, !tbaa !1
  %xmg_magic.i = getelementptr inbounds i8* %9, i64 40
  %10 = bitcast i8* %xmg_magic.i to %struct.magic**
  %11 = load %struct.magic** %10, align 8, !tbaa !18
  %tobool1.i = icmp eq %struct.magic* %11, null
  br i1 %tobool1.i, label %if.end15.i, label %if.then2.i

if.then2.i:                                       ; preds = %land.lhs.true.i
  %add.ptr.sum37.i = add i64 %call, 8
  %mgs_flags.i = getelementptr inbounds i8* %6, i64 %add.ptr.sum37.i
  %12 = bitcast i8* %mgs_flags.i to i64*
  %13 = load i64* %12, align 8, !tbaa !21
  %tobool3.i = icmp eq i64 %13, 0
  br i1 %tobool3.i, label %for.body.i, label %if.then4.i

if.then4.i:                                       ; preds = %if.then2.i
  %or.i = or i64 %13, %8
  store i64 %or.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end7.i

for.body.i:                                       ; preds = %if.then2.i, %for.inc.i
  %14 = phi i64 [ %.pre.i, %for.inc.i ], [ %8, %if.then2.i ]
  %mg.031.i = phi %struct.magic* [ %mg.0.i, %for.inc.i ], [ %11, %if.then2.i ]
  %mg_virtual.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 1
  %15 = load %struct.mgvtbl** %mg_virtual.i, align 8, !tbaa !7
  %tobool1.i50 = icmp eq %struct.mgvtbl* %15, null
  br i1 %tobool1.i50, label %for.inc.i, label %if.then.i

if.then.i:                                        ; preds = %for.body.i
  %svt_get.i = getelementptr inbounds %struct.mgvtbl* %15, i64 0, i32 0
  %16 = load i32 (%struct.sv*, %struct.magic*)** %svt_get.i, align 8, !tbaa !10
  %tobool2.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %16, null
  br i1 %tobool2.i, label %if.end.i57, label %land.lhs.true.i53

land.lhs.true.i53:                                ; preds = %if.then.i
  %mg_flags.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 4
  %17 = load i8* %mg_flags.i, align 1, !tbaa !12
  %and.i51 = and i8 %17, 4
  %tobool3.i52 = icmp eq i8 %and.i51, 0
  br i1 %tobool3.i52, label %if.then4.i55, label %if.end.i57

if.then4.i55:                                     ; preds = %land.lhs.true.i53
  %or.i54 = or i64 %14, 8192
  store i64 %or.i54, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end.i57

if.end.i57:                                       ; preds = %if.then4.i55, %land.lhs.true.i53, %if.then.i
  %.pre.i56 = phi i64 [ %or.i54, %if.then4.i55 ], [ %14, %land.lhs.true.i53 ], [ %14, %if.then.i ]
  %svt_set.i = getelementptr inbounds %struct.mgvtbl* %15, i64 0, i32 1
  %18 = load i32 (%struct.sv*, %struct.magic*)** %svt_set.i, align 8, !tbaa !14
  %tobool5.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %18, null
  br i1 %tobool5.i, label %if.end9.i, label %if.then6.i

if.then6.i:                                       ; preds = %if.end.i57
  %or8.i = or i64 %.pre.i56, 16384
  store i64 %or8.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end9.i

if.end9.i:                                        ; preds = %if.then6.i, %if.end.i57
  %19 = phi i64 [ %or8.i, %if.then6.i ], [ %.pre.i56, %if.end.i57 ]
  %and11.i = and i64 %19, 24576
  %tobool12.i = icmp eq i64 %and11.i, 0
  br i1 %tobool12.i, label %if.then14.i, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end9.i
  %svt_clear.i = getelementptr inbounds %struct.mgvtbl* %15, i64 0, i32 3
  %20 = load i32 (%struct.sv*, %struct.magic*)** %svt_clear.i, align 8, !tbaa !15
  %tobool13.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %20, null
  br i1 %tobool13.i, label %for.inc.i, label %if.then14.i

if.then14.i:                                      ; preds = %lor.lhs.false.i, %if.end9.i
  %or16.i = or i64 %19, 32768
  store i64 %or16.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then14.i, %lor.lhs.false.i, %for.body.i
  %.pre.i = phi i64 [ %or16.i, %if.then14.i ], [ %19, %lor.lhs.false.i ], [ %14, %for.body.i ]
  %mg_moremagic.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 0
  %mg.0.i = load %struct.magic** %mg_moremagic.i, align 8
  %tobool.i58 = icmp eq %struct.magic* %mg.0.i, null
  br i1 %tobool.i58, label %if.end7.i, label %for.body.i

if.end7.i:                                        ; preds = %for.inc.i, %if.then4.i
  %21 = phi i64 [ %or.i, %if.then4.i ], [ %.pre.i, %for.inc.i ]
  %and9.i = and i64 %21, 8192
  %tobool10.i = icmp eq i64 %and9.i, 0
  br i1 %tobool10.i, label %if.end15.i, label %if.then11.i

if.then11.i:                                      ; preds = %if.end7.i
  %and13.i = and i64 %21, -458753
  store i64 %and13.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end15.i

if.end15.i:                                       ; preds = %if.then11.i, %if.end7.i, %land.lhs.true.i, %if.end.i
  store %struct.sv* null, %struct.sv** %mgs_sv.i, align 8, !tbaa !24
  %22 = load i64* @PL_savestack_ix, align 8, !tbaa !25
  %add.ptr.sum.i = add i64 %call, 16
  %mgs_ss_ix.i = getelementptr inbounds i8* %6, i64 %add.ptr.sum.i
  %23 = bitcast i8* %mgs_ss_ix.i to i64*
  %24 = load i64* %23, align 8, !tbaa !26
  %cmp17.i = icmp eq i64 %22, %24
  br i1 %cmp17.i, label %if.then18.i, label %return

if.then18.i:                                      ; preds = %if.end15.i
  %dec22.i = add nsw i64 %22, -5
  store i64 %dec22.i, i64* @PL_savestack_ix, align 8, !tbaa !25
  %25 = load %union.any** @PL_savestack, align 8, !tbaa !16
  %arrayidx23.i = getelementptr inbounds %union.any* %25, i64 %dec22.i
  %any_i3224.i = bitcast %union.any* %arrayidx23.i to i64*
  %26 = load i64* %any_i3224.i, align 8, !tbaa !25
  %sub25.i = sub nsw i64 %dec22.i, %26
  store i64 %sub25.i, i64* @PL_savestack_ix, align 8, !tbaa !25
  br label %return

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %mg_moremagic = getelementptr inbounds %struct.magic* %mg.062, i64 0, i32 0
  %mg.0 = load %struct.magic** %mg_moremagic, align 8
  %tobool = icmp eq %struct.magic* %mg.0, null
  br i1 %tobool, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %entry
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %27 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %27, 536870912
  %tobool6 = icmp eq i64 %and, 0
  br i1 %tobool6, label %if.else, label %land.lhs.true7

land.lhs.true7:                                   ; preds = %for.end
  %28 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %op_private = getelementptr inbounds %struct.cop* %28, i64 0, i32 7
  %29 = load i8* %op_private, align 1, !tbaa !28
  %and8 = and i8 %29, 8
  %tobool9 = icmp eq i8 %and8, 0
  br i1 %tobool9, label %if.then10, label %land.lhs.true7.if.else_crit_edge

land.lhs.true7.if.else_crit_edge:                 ; preds = %land.lhs.true7
  %.pre = load i64* %sv_flags, align 8, !tbaa !13
  br label %if.else

if.then10:                                        ; preds = %land.lhs.true7
  %and12 = and i64 %27, 262144
  %cmp = icmp eq i64 %and12, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then10
  %30 = load i8** %sv_any, align 8, !tbaa !1
  %xpv_cur = getelementptr inbounds i8* %30, i64 8
  %31 = bitcast i8* %xpv_cur to i64*
  %32 = load i64* %31, align 8, !tbaa !30
  store i64 %32, i64* %len, align 8, !tbaa !25
  %xpv_pv = bitcast i8* %30 to i8**
  %33 = load i8** %xpv_pv, align 8, !tbaa !32
  br label %cond.end

cond.false:                                       ; preds = %if.then10
  %call16 = call i8* @Perl_sv_2pv_flags(%struct.sv* %sv, i64* %len, i64 2) #4
  %.pre64 = load i64* %len, align 8, !tbaa !25
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %34 = phi i64 [ %32, %cond.true ], [ %.pre64, %cond.false ]
  %cond = phi i8* [ %33, %cond.true ], [ %call16, %cond.false ]
  %add.ptr = getelementptr inbounds i8* %cond, i64 %34
  %call17 = call i64 @Perl_utf8_length(i8* %cond, i8* %add.ptr) #4
  store i64 %call17, i64* %len, align 8, !tbaa !25
  br label %return

if.else:                                          ; preds = %land.lhs.true7.if.else_crit_edge, %for.end
  %35 = phi i64 [ %.pre, %land.lhs.true7.if.else_crit_edge ], [ %27, %for.end ]
  %and19 = and i64 %35, 262144
  %cmp20 = icmp eq i64 %and19, 0
  br i1 %cmp20, label %cond.false27, label %cond.true22

cond.true22:                                      ; preds = %if.else
  %36 = load i8** %sv_any, align 8, !tbaa !1
  %xpv_cur24 = getelementptr inbounds i8* %36, i64 8
  %37 = bitcast i8* %xpv_cur24 to i64*
  %38 = load i64* %37, align 8, !tbaa !30
  store i64 %38, i64* %len, align 8, !tbaa !25
  br label %return

cond.false27:                                     ; preds = %if.else
  %call28 = call i8* @Perl_sv_2pv_flags(%struct.sv* %sv, i64* %len, i64 2) #4
  br label %return

return:                                           ; preds = %if.then18.i, %if.end15.i, %if.then, %cond.end, %cond.false27, %cond.true22
  %retval.0 = load i64* %len, align 8
  ret i64 %retval.0
}

declare i8* @Perl_sv_2pv_flags(%struct.sv*, i64*, i64) #1

declare i64 @Perl_utf8_length(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define i64 @Perl_mg_size(%struct.sv* %sv) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xmg_magic = getelementptr inbounds i8* %0, i64 40
  %1 = bitcast i8* %xmg_magic to %struct.magic**
  %mg.031 = load %struct.magic** %1, align 8
  %tobool32 = icmp eq %struct.magic* %mg.031, null
  br i1 %tobool32, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %mg.033 = phi %struct.magic* [ %mg.0, %for.inc ], [ %mg.031, %entry ]
  %mg_virtual = getelementptr inbounds %struct.magic* %mg.033, i64 0, i32 1
  %2 = load %struct.mgvtbl** %mg_virtual, align 8, !tbaa !7
  %tobool1 = icmp eq %struct.mgvtbl* %2, null
  br i1 %tobool1, label %for.inc, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %svt_len = getelementptr inbounds %struct.mgvtbl* %2, i64 0, i32 2
  %3 = load i64 (%struct.sv*, %struct.magic*)** %svt_len, align 8, !tbaa !27
  %tobool2 = icmp eq i64 (%struct.sv*, %struct.magic*)* %3, null
  br i1 %tobool2, label %for.inc, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %call = tail call i64 @Perl_save_alloc(i64 24, i64 0) #4
  %call3 = tail call i32 (i64, %struct.sv*, ...)* bitcast (i32 (...)* @save_magic to i32 (i64, %struct.sv*, ...)*)(i64 %call, %struct.sv* %sv) #4
  %4 = load i64 (%struct.sv*, %struct.magic*)** %svt_len, align 8, !tbaa !27
  %call5 = tail call i64 %4(%struct.sv* %sv, %struct.magic* %mg.033) #4
  %5 = load %union.any** @PL_savestack, align 8, !tbaa !16
  %6 = bitcast %union.any* %5 to i8*
  %add.ptr.i = getelementptr inbounds i8* %6, i64 %call
  %mgs_sv.i = bitcast i8* %add.ptr.i to %struct.sv**
  %7 = load %struct.sv** %mgs_sv.i, align 8, !tbaa !24
  %tobool.i = icmp eq %struct.sv* %7, null
  br i1 %tobool.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.then
  %sv_flags.i = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i64* %sv_flags.i, align 8, !tbaa !13
  %and.i = and i64 %8, 255
  %cmp.i = icmp ugt i64 %and.i, 6
  br i1 %cmp.i, label %land.lhs.true.i, label %if.end15.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %sv_any.i = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %9 = load i8** %sv_any.i, align 8, !tbaa !1
  %xmg_magic.i = getelementptr inbounds i8* %9, i64 40
  %10 = bitcast i8* %xmg_magic.i to %struct.magic**
  %11 = load %struct.magic** %10, align 8, !tbaa !18
  %tobool1.i = icmp eq %struct.magic* %11, null
  br i1 %tobool1.i, label %if.end15.i, label %if.then2.i

if.then2.i:                                       ; preds = %land.lhs.true.i
  %add.ptr.sum37.i = add i64 %call, 8
  %mgs_flags.i = getelementptr inbounds i8* %6, i64 %add.ptr.sum37.i
  %12 = bitcast i8* %mgs_flags.i to i64*
  %13 = load i64* %12, align 8, !tbaa !21
  %tobool3.i = icmp eq i64 %13, 0
  br i1 %tobool3.i, label %for.body.i, label %if.then4.i

if.then4.i:                                       ; preds = %if.then2.i
  %or.i = or i64 %13, %8
  store i64 %or.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end7.i

for.body.i:                                       ; preds = %if.then2.i, %for.inc.i
  %14 = phi i64 [ %.pre.i, %for.inc.i ], [ %8, %if.then2.i ]
  %mg.031.i = phi %struct.magic* [ %mg.0.i, %for.inc.i ], [ %11, %if.then2.i ]
  %mg_virtual.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 1
  %15 = load %struct.mgvtbl** %mg_virtual.i, align 8, !tbaa !7
  %tobool1.i21 = icmp eq %struct.mgvtbl* %15, null
  br i1 %tobool1.i21, label %for.inc.i, label %if.then.i

if.then.i:                                        ; preds = %for.body.i
  %svt_get.i = getelementptr inbounds %struct.mgvtbl* %15, i64 0, i32 0
  %16 = load i32 (%struct.sv*, %struct.magic*)** %svt_get.i, align 8, !tbaa !10
  %tobool2.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %16, null
  br i1 %tobool2.i, label %if.end.i28, label %land.lhs.true.i24

land.lhs.true.i24:                                ; preds = %if.then.i
  %mg_flags.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 4
  %17 = load i8* %mg_flags.i, align 1, !tbaa !12
  %and.i22 = and i8 %17, 4
  %tobool3.i23 = icmp eq i8 %and.i22, 0
  br i1 %tobool3.i23, label %if.then4.i26, label %if.end.i28

if.then4.i26:                                     ; preds = %land.lhs.true.i24
  %or.i25 = or i64 %14, 8192
  store i64 %or.i25, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end.i28

if.end.i28:                                       ; preds = %if.then4.i26, %land.lhs.true.i24, %if.then.i
  %.pre.i27 = phi i64 [ %or.i25, %if.then4.i26 ], [ %14, %land.lhs.true.i24 ], [ %14, %if.then.i ]
  %svt_set.i = getelementptr inbounds %struct.mgvtbl* %15, i64 0, i32 1
  %18 = load i32 (%struct.sv*, %struct.magic*)** %svt_set.i, align 8, !tbaa !14
  %tobool5.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %18, null
  br i1 %tobool5.i, label %if.end9.i, label %if.then6.i

if.then6.i:                                       ; preds = %if.end.i28
  %or8.i = or i64 %.pre.i27, 16384
  store i64 %or8.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end9.i

if.end9.i:                                        ; preds = %if.then6.i, %if.end.i28
  %19 = phi i64 [ %or8.i, %if.then6.i ], [ %.pre.i27, %if.end.i28 ]
  %and11.i = and i64 %19, 24576
  %tobool12.i = icmp eq i64 %and11.i, 0
  br i1 %tobool12.i, label %if.then14.i, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end9.i
  %svt_clear.i = getelementptr inbounds %struct.mgvtbl* %15, i64 0, i32 3
  %20 = load i32 (%struct.sv*, %struct.magic*)** %svt_clear.i, align 8, !tbaa !15
  %tobool13.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %20, null
  br i1 %tobool13.i, label %for.inc.i, label %if.then14.i

if.then14.i:                                      ; preds = %lor.lhs.false.i, %if.end9.i
  %or16.i = or i64 %19, 32768
  store i64 %or16.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then14.i, %lor.lhs.false.i, %for.body.i
  %.pre.i = phi i64 [ %or16.i, %if.then14.i ], [ %19, %lor.lhs.false.i ], [ %14, %for.body.i ]
  %mg_moremagic.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 0
  %mg.0.i = load %struct.magic** %mg_moremagic.i, align 8
  %tobool.i29 = icmp eq %struct.magic* %mg.0.i, null
  br i1 %tobool.i29, label %if.end7.i, label %for.body.i

if.end7.i:                                        ; preds = %for.inc.i, %if.then4.i
  %21 = phi i64 [ %or.i, %if.then4.i ], [ %.pre.i, %for.inc.i ]
  %and9.i = and i64 %21, 8192
  %tobool10.i = icmp eq i64 %and9.i, 0
  br i1 %tobool10.i, label %if.end15.i, label %if.then11.i

if.then11.i:                                      ; preds = %if.end7.i
  %and13.i = and i64 %21, -458753
  store i64 %and13.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end15.i

if.end15.i:                                       ; preds = %if.then11.i, %if.end7.i, %land.lhs.true.i, %if.end.i
  store %struct.sv* null, %struct.sv** %mgs_sv.i, align 8, !tbaa !24
  %22 = load i64* @PL_savestack_ix, align 8, !tbaa !25
  %add.ptr.sum.i = add i64 %call, 16
  %mgs_ss_ix.i = getelementptr inbounds i8* %6, i64 %add.ptr.sum.i
  %23 = bitcast i8* %mgs_ss_ix.i to i64*
  %24 = load i64* %23, align 8, !tbaa !26
  %cmp17.i = icmp eq i64 %22, %24
  br i1 %cmp17.i, label %if.then18.i, label %return

if.then18.i:                                      ; preds = %if.end15.i
  %dec22.i = add nsw i64 %22, -5
  store i64 %dec22.i, i64* @PL_savestack_ix, align 8, !tbaa !25
  %25 = load %union.any** @PL_savestack, align 8, !tbaa !16
  %arrayidx23.i = getelementptr inbounds %union.any* %25, i64 %dec22.i
  %any_i3224.i = bitcast %union.any* %arrayidx23.i to i64*
  %26 = load i64* %any_i3224.i, align 8, !tbaa !25
  %sub25.i = sub nsw i64 %dec22.i, %26
  store i64 %sub25.i, i64* @PL_savestack_ix, align 8, !tbaa !25
  br label %return

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %mg_moremagic = getelementptr inbounds %struct.magic* %mg.033, i64 0, i32 0
  %mg.0 = load %struct.magic** %mg_moremagic, align 8
  %tobool = icmp eq %struct.magic* %mg.0, null
  br i1 %tobool, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %entry
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %27 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %27, 255
  %cond = icmp eq i64 %and, 10
  br i1 %cond, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %for.end
  %xav_fill = getelementptr inbounds i8* %0, i64 8
  %28 = bitcast i8* %xav_fill to i64*
  %29 = load i64* %28, align 8, !tbaa !33
  br label %return

sw.default:                                       ; preds = %for.end
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([27 x i8]* @.str, i64 0, i64 0)) #4
  br label %return

return:                                           ; preds = %if.then18.i, %if.end15.i, %if.then, %sw.default, %sw.bb
  %retval.0 = phi i64 [ %29, %sw.bb ], [ 0, %sw.default ], [ %call5, %if.then ], [ %call5, %if.end15.i ], [ %call5, %if.then18.i ]
  ret i64 %retval.0
}

declare void @Perl_croak(i8*, ...) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_mg_clear(%struct.sv* %sv) #0 {
entry:
  %call = tail call i64 @Perl_save_alloc(i64 24, i64 0) #4
  %call1 = tail call i32 (i64, %struct.sv*, ...)* bitcast (i32 (...)* @save_magic to i32 (i64, %struct.sv*, ...)*)(i64 %call, %struct.sv* %sv) #4
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xmg_magic = getelementptr inbounds i8* %0, i64 40
  %1 = bitcast i8* %xmg_magic to %struct.magic**
  %mg.025 = load %struct.magic** %1, align 8
  %tobool26 = icmp eq %struct.magic* %mg.025, null
  br i1 %tobool26, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %mg.027 = phi %struct.magic* [ %mg.0, %for.inc ], [ %mg.025, %entry ]
  %mg_virtual = getelementptr inbounds %struct.magic* %mg.027, i64 0, i32 1
  %2 = load %struct.mgvtbl** %mg_virtual, align 8, !tbaa !7
  %tobool2 = icmp eq %struct.mgvtbl* %2, null
  br i1 %tobool2, label %for.inc, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %svt_clear = getelementptr inbounds %struct.mgvtbl* %2, i64 0, i32 3
  %3 = load i32 (%struct.sv*, %struct.magic*)** %svt_clear, align 8, !tbaa !15
  %tobool3 = icmp eq i32 (%struct.sv*, %struct.magic*)* %3, null
  br i1 %tobool3, label %for.inc, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %call5 = tail call i32 %3(%struct.sv* %sv, %struct.magic* %mg.027) #4
  br label %for.inc

for.inc:                                          ; preds = %land.lhs.true, %for.body, %if.then
  %mg_moremagic = getelementptr inbounds %struct.magic* %mg.027, i64 0, i32 0
  %mg.0 = load %struct.magic** %mg_moremagic, align 8
  %tobool = icmp eq %struct.magic* %mg.0, null
  br i1 %tobool, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %entry
  %4 = load %union.any** @PL_savestack, align 8, !tbaa !16
  %5 = bitcast %union.any* %4 to i8*
  %add.ptr.i = getelementptr inbounds i8* %5, i64 %call
  %mgs_sv.i = bitcast i8* %add.ptr.i to %struct.sv**
  %6 = load %struct.sv** %mgs_sv.i, align 8, !tbaa !24
  %tobool.i = icmp eq %struct.sv* %6, null
  br i1 %tobool.i, label %restore_magic.exit, label %if.end.i

if.end.i:                                         ; preds = %for.end
  %sv_flags.i = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i64* %sv_flags.i, align 8, !tbaa !13
  %and.i = and i64 %7, 255
  %cmp.i = icmp ugt i64 %and.i, 6
  br i1 %cmp.i, label %land.lhs.true.i, label %if.end15.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %sv_any.i = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %8 = load i8** %sv_any.i, align 8, !tbaa !1
  %xmg_magic.i = getelementptr inbounds i8* %8, i64 40
  %9 = bitcast i8* %xmg_magic.i to %struct.magic**
  %10 = load %struct.magic** %9, align 8, !tbaa !18
  %tobool1.i = icmp eq %struct.magic* %10, null
  br i1 %tobool1.i, label %if.end15.i, label %if.then2.i

if.then2.i:                                       ; preds = %land.lhs.true.i
  %add.ptr.sum37.i = add i64 %call, 8
  %mgs_flags.i = getelementptr inbounds i8* %5, i64 %add.ptr.sum37.i
  %11 = bitcast i8* %mgs_flags.i to i64*
  %12 = load i64* %11, align 8, !tbaa !21
  %tobool3.i = icmp eq i64 %12, 0
  br i1 %tobool3.i, label %for.body.i, label %if.then4.i

if.then4.i:                                       ; preds = %if.then2.i
  %or.i = or i64 %12, %7
  store i64 %or.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end7.i

for.body.i:                                       ; preds = %if.then2.i, %for.inc.i
  %13 = phi i64 [ %.pre.i, %for.inc.i ], [ %7, %if.then2.i ]
  %mg.031.i = phi %struct.magic* [ %mg.0.i, %for.inc.i ], [ %10, %if.then2.i ]
  %mg_virtual.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 1
  %14 = load %struct.mgvtbl** %mg_virtual.i, align 8, !tbaa !7
  %tobool1.i16 = icmp eq %struct.mgvtbl* %14, null
  br i1 %tobool1.i16, label %for.inc.i, label %if.then.i

if.then.i:                                        ; preds = %for.body.i
  %svt_get.i = getelementptr inbounds %struct.mgvtbl* %14, i64 0, i32 0
  %15 = load i32 (%struct.sv*, %struct.magic*)** %svt_get.i, align 8, !tbaa !10
  %tobool2.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %15, null
  br i1 %tobool2.i, label %if.end.i23, label %land.lhs.true.i19

land.lhs.true.i19:                                ; preds = %if.then.i
  %mg_flags.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 4
  %16 = load i8* %mg_flags.i, align 1, !tbaa !12
  %and.i17 = and i8 %16, 4
  %tobool3.i18 = icmp eq i8 %and.i17, 0
  br i1 %tobool3.i18, label %if.then4.i21, label %if.end.i23

if.then4.i21:                                     ; preds = %land.lhs.true.i19
  %or.i20 = or i64 %13, 8192
  store i64 %or.i20, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end.i23

if.end.i23:                                       ; preds = %if.then4.i21, %land.lhs.true.i19, %if.then.i
  %.pre.i22 = phi i64 [ %or.i20, %if.then4.i21 ], [ %13, %land.lhs.true.i19 ], [ %13, %if.then.i ]
  %svt_set.i = getelementptr inbounds %struct.mgvtbl* %14, i64 0, i32 1
  %17 = load i32 (%struct.sv*, %struct.magic*)** %svt_set.i, align 8, !tbaa !14
  %tobool5.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %17, null
  br i1 %tobool5.i, label %if.end9.i, label %if.then6.i

if.then6.i:                                       ; preds = %if.end.i23
  %or8.i = or i64 %.pre.i22, 16384
  store i64 %or8.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end9.i

if.end9.i:                                        ; preds = %if.then6.i, %if.end.i23
  %18 = phi i64 [ %or8.i, %if.then6.i ], [ %.pre.i22, %if.end.i23 ]
  %and11.i = and i64 %18, 24576
  %tobool12.i = icmp eq i64 %and11.i, 0
  br i1 %tobool12.i, label %if.then14.i, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end9.i
  %svt_clear.i = getelementptr inbounds %struct.mgvtbl* %14, i64 0, i32 3
  %19 = load i32 (%struct.sv*, %struct.magic*)** %svt_clear.i, align 8, !tbaa !15
  %tobool13.i = icmp eq i32 (%struct.sv*, %struct.magic*)* %19, null
  br i1 %tobool13.i, label %for.inc.i, label %if.then14.i

if.then14.i:                                      ; preds = %lor.lhs.false.i, %if.end9.i
  %or16.i = or i64 %18, 32768
  store i64 %or16.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then14.i, %lor.lhs.false.i, %for.body.i
  %.pre.i = phi i64 [ %or16.i, %if.then14.i ], [ %18, %lor.lhs.false.i ], [ %13, %for.body.i ]
  %mg_moremagic.i = getelementptr inbounds %struct.magic* %mg.031.i, i64 0, i32 0
  %mg.0.i = load %struct.magic** %mg_moremagic.i, align 8
  %tobool.i24 = icmp eq %struct.magic* %mg.0.i, null
  br i1 %tobool.i24, label %if.end7.i, label %for.body.i

if.end7.i:                                        ; preds = %for.inc.i, %if.then4.i
  %20 = phi i64 [ %or.i, %if.then4.i ], [ %.pre.i, %for.inc.i ]
  %and9.i = and i64 %20, 8192
  %tobool10.i = icmp eq i64 %and9.i, 0
  br i1 %tobool10.i, label %if.end15.i, label %if.then11.i

if.then11.i:                                      ; preds = %if.end7.i
  %and13.i = and i64 %20, -458753
  store i64 %and13.i, i64* %sv_flags.i, align 8, !tbaa !13
  br label %if.end15.i

if.end15.i:                                       ; preds = %if.then11.i, %if.end7.i, %land.lhs.true.i, %if.end.i
  store %struct.sv* null, %struct.sv** %mgs_sv.i, align 8, !tbaa !24
  %21 = load i64* @PL_savestack_ix, align 8, !tbaa !25
  %add.ptr.sum.i = add i64 %call, 16
  %mgs_ss_ix.i = getelementptr inbounds i8* %5, i64 %add.ptr.sum.i
  %22 = bitcast i8* %mgs_ss_ix.i to i64*
  %23 = load i64* %22, align 8, !tbaa !26
  %cmp17.i = icmp eq i64 %21, %23
  br i1 %cmp17.i, label %if.then18.i, label %restore_magic.exit

if.then18.i:                                      ; preds = %if.end15.i
  %dec22.i = add nsw i64 %21, -5
  store i64 %dec22.i, i64* @PL_savestack_ix, align 8, !tbaa !25
  %24 = load %union.any** @PL_savestack, align 8, !tbaa !16
  %arrayidx23.i = getelementptr inbounds %union.any* %24, i64 %dec22.i
  %any_i3224.i = bitcast %union.any* %arrayidx23.i to i64*
  %25 = load i64* %any_i3224.i, align 8, !tbaa !25
  %sub25.i = sub nsw i64 %dec22.i, %25
  store i64 %sub25.i, i64* @PL_savestack_ix, align 8, !tbaa !25
  br label %restore_magic.exit

restore_magic.exit:                               ; preds = %for.end, %if.end15.i, %if.then18.i
  ret i32 0
}

; Function Attrs: nounwind readonly uwtable
define %struct.magic* @Perl_mg_find(%struct.sv* readonly %sv, i32 %type) #2 {
entry:
  %tobool = icmp eq %struct.sv* %sv, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xmg_magic = getelementptr inbounds i8* %0, i64 40
  %1 = bitcast i8* %xmg_magic to %struct.magic**
  %mg.08 = load %struct.magic** %1, align 8
  %tobool19 = icmp eq %struct.magic* %mg.08, null
  br i1 %tobool19, label %return, label %for.body

for.cond:                                         ; preds = %for.body
  %mg_moremagic = getelementptr inbounds %struct.magic* %mg.010, i64 0, i32 0
  %mg.0 = load %struct.magic** %mg_moremagic, align 8
  %tobool1 = icmp eq %struct.magic* %mg.0, null
  br i1 %tobool1, label %return, label %for.body

for.body:                                         ; preds = %if.end, %for.cond
  %mg.010 = phi %struct.magic* [ %mg.0, %for.cond ], [ %mg.08, %if.end ]
  %mg_type = getelementptr inbounds %struct.magic* %mg.010, i64 0, i32 3
  %2 = load i8* %mg_type, align 1, !tbaa !35
  %conv = sext i8 %2 to i32
  %cmp = icmp eq i32 %conv, %type
  br i1 %cmp, label %return, label %for.cond

return:                                           ; preds = %for.body, %for.cond, %if.end, %entry
  %retval.0 = phi %struct.magic* [ null, %entry ], [ null, %if.end ], [ %mg.010, %for.body ], [ null, %for.cond ]
  ret %struct.magic* %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_mg_copy(%struct.sv* %sv, %struct.sv* %nsv, i8* %key, i64 %klen) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xmg_magic = getelementptr inbounds i8* %0, i64 40
  %1 = bitcast i8* %xmg_magic to %struct.magic**
  %mg.082 = load %struct.magic** %1, align 8
  %tobool83 = icmp eq %struct.magic* %mg.082, null
  br i1 %tobool83, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %conv4 = trunc i64 %klen to i32
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %mg.085 = phi %struct.magic* [ %mg.082, %for.body.lr.ph ], [ %mg.0, %for.inc ]
  %count.084 = phi i32 [ 0, %for.body.lr.ph ], [ %count.1, %for.inc ]
  %mg_flags = getelementptr inbounds %struct.magic* %mg.085, i64 0, i32 4
  %2 = load i8* %mg_flags, align 1, !tbaa !12
  %and = and i8 %2, 8
  %tobool1 = icmp eq i8 %and, 0
  br i1 %tobool1, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %mg_virtual = getelementptr inbounds %struct.magic* %mg.085, i64 0, i32 1
  %3 = load %struct.mgvtbl** %mg_virtual, align 8, !tbaa !7
  %svt_copy = getelementptr inbounds %struct.mgvtbl* %3, i64 0, i32 5
  %4 = load i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)** %svt_copy, align 8, !tbaa !36
  %tobool2 = icmp eq i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)* %4, null
  br i1 %tobool2, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %call = tail call i32 %4(%struct.sv* %sv, %struct.magic* %mg.085, %struct.sv* %nsv, i8* %key, i32 %conv4) #4
  %add = add nsw i32 %call, %count.084
  br label %for.inc

if.else:                                          ; preds = %land.lhs.true, %for.body
  %mg_type = getelementptr inbounds %struct.magic* %mg.085, i64 0, i32 3
  %5 = load i8* %mg_type, align 1, !tbaa !35
  %.off = add i8 %5, -65
  %6 = icmp ult i8 %.off, 26
  br i1 %6, label %if.then12, label %for.inc

if.then12:                                        ; preds = %if.else
  switch i8 %5, label %if.then12.cond.false31_crit_edge [
    i8 80, label %cond.true
    i8 68, label %land.lhs.true27
  ]

if.then12.cond.false31_crit_edge:                 ; preds = %if.then12
  %mg_obj32.phi.trans.insert = getelementptr inbounds %struct.magic* %mg.085, i64 0, i32 5
  %.pre = load %struct.sv** %mg_obj32.phi.trans.insert, align 8, !tbaa !37
  br label %cond.false31

cond.true:                                        ; preds = %if.then12
  %mg_obj = getelementptr inbounds %struct.magic* %mg.085, i64 0, i32 5
  %7 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  %tobool17 = icmp eq %struct.sv* %7, null
  br i1 %tobool17, label %cond.false, label %cond.end35

cond.false:                                       ; preds = %cond.true
  %call20 = tail call %struct.sv* @Perl_newRV(%struct.sv* %sv) #4
  %call21 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call20) #4
  %.pre86 = load i8* %mg_type, align 1, !tbaa !35
  br label %cond.end35

land.lhs.true27:                                  ; preds = %if.then12
  %mg_obj28 = getelementptr inbounds %struct.magic* %mg.085, i64 0, i32 5
  %8 = load %struct.sv** %mg_obj28, align 8, !tbaa !37
  %tobool29 = icmp eq %struct.sv* %8, null
  br i1 %tobool29, label %cond.false31, label %cond.end35

cond.false31:                                     ; preds = %if.then12.cond.false31_crit_edge, %land.lhs.true27
  %9 = phi %struct.sv* [ %.pre, %if.then12.cond.false31_crit_edge ], [ null, %land.lhs.true27 ]
  br label %cond.end35

cond.end35:                                       ; preds = %land.lhs.true27, %cond.true, %cond.false31, %cond.false
  %10 = phi i8 [ %.pre86, %cond.false ], [ %5, %cond.false31 ], [ 80, %cond.true ], [ 68, %land.lhs.true27 ]
  %cond36 = phi %struct.sv* [ %call21, %cond.false ], [ %9, %cond.false31 ], [ %7, %cond.true ], [ %sv, %land.lhs.true27 ]
  %conv38 = sext i8 %10 to i32
  %.off81 = add i8 %10, -65
  %11 = icmp ult i8 %.off81, 26
  %add49 = add nsw i32 %conv38, 32
  %add49.conv38 = select i1 %11, i32 %add49, i32 %conv38
  tail call void @Perl_sv_magic(%struct.sv* %nsv, %struct.sv* %cond36, i32 %add49.conv38, i8* %key, i64 %klen) #4
  %inc = add nsw i32 %count.084, 1
  br label %for.inc

for.inc:                                          ; preds = %if.then, %cond.end35, %if.else
  %count.1 = phi i32 [ %add, %if.then ], [ %inc, %cond.end35 ], [ %count.084, %if.else ]
  %mg_moremagic = getelementptr inbounds %struct.magic* %mg.085, i64 0, i32 0
  %mg.0 = load %struct.magic** %mg_moremagic, align 8
  %tobool = icmp eq %struct.magic* %mg.0, null
  br i1 %tobool, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %entry
  %count.0.lcssa = phi i32 [ 0, %entry ], [ %count.1, %for.inc ]
  ret i32 %count.0.lcssa
}

declare void @Perl_sv_magic(%struct.sv*, %struct.sv*, i32, i8*, i64) #1

declare %struct.sv* @Perl_newRV(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_mg_free(%struct.sv* %sv) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xmg_magic = getelementptr inbounds i8* %0, i64 40
  %1 = bitcast i8* %xmg_magic to %struct.magic**
  %2 = load %struct.magic** %1, align 8, !tbaa !18
  %tobool47 = icmp eq %struct.magic* %2, null
  br i1 %tobool47, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %if.end27
  %mg.048 = phi %struct.magic* [ %4, %if.end27 ], [ %2, %entry ]
  %mg_virtual = getelementptr inbounds %struct.magic* %mg.048, i64 0, i32 1
  %3 = load %struct.mgvtbl** %mg_virtual, align 8, !tbaa !7
  %mg_moremagic = getelementptr inbounds %struct.magic* %mg.048, i64 0, i32 0
  %4 = load %struct.magic** %mg_moremagic, align 8, !tbaa !23
  %tobool1 = icmp eq %struct.mgvtbl* %3, null
  br i1 %tobool1, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %svt_free = getelementptr inbounds %struct.mgvtbl* %3, i64 0, i32 4
  %5 = load i32 (%struct.sv*, %struct.magic*)** %svt_free, align 8, !tbaa !38
  %tobool2 = icmp eq i32 (%struct.sv*, %struct.magic*)* %5, null
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %call = tail call i32 %5(%struct.sv* %sv, %struct.magic* %mg.048) #4
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %for.body, %if.then
  %mg_ptr = getelementptr inbounds %struct.magic* %mg.048, i64 0, i32 6
  %6 = load i8** %mg_ptr, align 8, !tbaa !39
  %tobool4 = icmp eq i8* %6, null
  br i1 %tobool4, label %if.end23, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %if.end
  %mg_type = getelementptr inbounds %struct.magic* %mg.048, i64 0, i32 3
  %7 = load i8* %mg_type, align 1, !tbaa !35
  %cmp = icmp eq i8 %7, 103
  br i1 %cmp, label %if.end23, label %if.then7

if.then7:                                         ; preds = %land.lhs.true5
  %mg_len = getelementptr inbounds %struct.magic* %mg.048, i64 0, i32 7
  %8 = load i64* %mg_len, align 8, !tbaa !40
  %cmp8 = icmp sgt i64 %8, 0
  %cmp12 = icmp eq i8 %7, 119
  %or.cond = or i1 %cmp8, %cmp12
  br i1 %or.cond, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.then7
  tail call void @Perl_safesysfree(i8* %6) #4
  br label %if.end23

if.else:                                          ; preds = %if.then7
  %cmp17 = icmp eq i64 %8, -2
  br i1 %cmp17, label %if.then19, label %if.end23

if.then19:                                        ; preds = %if.else
  %9 = bitcast i8* %6 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %9) #4
  br label %if.end23

if.end23:                                         ; preds = %land.lhs.true5, %if.end, %if.then14, %if.then19, %if.else
  %mg_flags = getelementptr inbounds %struct.magic* %mg.048, i64 0, i32 4
  %10 = load i8* %mg_flags, align 1, !tbaa !12
  %and = and i8 %10, 2
  %tobool25 = icmp eq i8 %and, 0
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %if.end23
  %mg_obj = getelementptr inbounds %struct.magic* %mg.048, i64 0, i32 5
  %11 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  tail call void @Perl_sv_free(%struct.sv* %11) #4
  br label %if.end27

if.end27:                                         ; preds = %if.end23, %if.then26
  %12 = bitcast %struct.magic* %mg.048 to i8*
  tail call void @Perl_safesysfree(i8* %12) #4
  %tobool = icmp eq %struct.magic* %4, null
  br i1 %tobool, label %for.cond.for.end_crit_edge, label %for.body

for.cond.for.end_crit_edge:                       ; preds = %if.end27
  %.pre = load i8** %sv_any, align 8, !tbaa !1
  br label %for.end

for.end:                                          ; preds = %for.cond.for.end_crit_edge, %entry
  %13 = phi i8* [ %.pre, %for.cond.for.end_crit_edge ], [ %0, %entry ]
  %xmg_magic29 = getelementptr inbounds i8* %13, i64 40
  %14 = bitcast i8* %xmg_magic29 to %struct.magic**
  store %struct.magic* null, %struct.magic** %14, align 8, !tbaa !18
  ret i32 0
}

declare void @Perl_safesysfree(i8*) #1

declare void @Perl_sv_free(%struct.sv*) #1

; Function Attrs: nounwind readonly uwtable
define i64 @Perl_magic_regdata_cnt(%struct.sv* nocapture readnone %sv, %struct.magic* nocapture readonly %mg) #2 {
entry:
  %0 = load %struct.pmop** @PL_curpm, align 8, !tbaa !16
  %tobool = icmp eq %struct.pmop* %0, null
  br i1 %tobool, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_pmregexp = getelementptr inbounds %struct.pmop* %0, i64 0, i32 13
  %1 = load %struct.regexp** %op_pmregexp, align 8, !tbaa !41
  %tobool1 = icmp eq %struct.regexp* %1, null
  br i1 %tobool1, label %return, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %mg_obj = getelementptr inbounds %struct.magic* %mg, i64 0, i32 5
  %2 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  %tobool2 = icmp eq %struct.sv* %2, null
  br i1 %tobool2, label %if.else, label %if.then3

if.then3:                                         ; preds = %if.then
  %nparens = getelementptr inbounds %struct.regexp* %1, i64 0, i32 12
  %3 = load i64* %nparens, align 8, !tbaa !43
  br label %return

if.else:                                          ; preds = %if.then
  %lastparen = getelementptr inbounds %struct.regexp* %1, i64 0, i32 13
  %4 = load i64* %lastparen, align 8, !tbaa !45
  br label %return

return:                                           ; preds = %entry, %land.lhs.true, %if.else, %if.then3
  %retval.0 = phi i64 [ %3, %if.then3 ], [ %4, %if.else ], [ -1, %land.lhs.true ], [ -1, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_regdatum_get(%struct.sv* %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %0 = load %struct.pmop** @PL_curpm, align 8, !tbaa !16
  %tobool = icmp eq %struct.pmop* %0, null
  br i1 %tobool, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_pmregexp = getelementptr inbounds %struct.pmop* %0, i64 0, i32 13
  %1 = load %struct.regexp** %op_pmregexp, align 8, !tbaa !41
  %tobool1 = icmp eq %struct.regexp* %1, null
  br i1 %tobool1, label %return, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %mg_len = getelementptr inbounds %struct.magic* %mg, i64 0, i32 7
  %2 = load i64* %mg_len, align 8, !tbaa !40
  %cmp = icmp slt i64 %2, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %if.then
  %nparens = getelementptr inbounds %struct.regexp* %1, i64 0, i32 12
  %3 = load i64* %nparens, align 8, !tbaa !43
  %cmp3 = icmp sgt i64 %2, %3
  br i1 %cmp3, label %return, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %if.end
  %startp = getelementptr inbounds %struct.regexp* %1, i64 0, i32 0
  %4 = load i64** %startp, align 8, !tbaa !46
  %arrayidx = getelementptr inbounds i64* %4, i64 %2
  %5 = load i64* %arrayidx, align 8, !tbaa !25
  %cmp5 = icmp eq i64 %5, -1
  br i1 %cmp5, label %return, label %land.lhs.true6

land.lhs.true6:                                   ; preds = %land.lhs.true4
  %endp = getelementptr inbounds %struct.regexp* %1, i64 0, i32 1
  %6 = load i64** %endp, align 8, !tbaa !47
  %arrayidx7 = getelementptr inbounds i64* %6, i64 %2
  %7 = load i64* %arrayidx7, align 8, !tbaa !25
  %cmp8 = icmp eq i64 %7, -1
  br i1 %cmp8, label %return, label %if.then9

if.then9:                                         ; preds = %land.lhs.true6
  %mg_obj = getelementptr inbounds %struct.magic* %mg, i64 0, i32 5
  %8 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  %tobool10 = icmp eq %struct.sv* %8, null
  %. = select i1 %tobool10, i64 %5, i64 %7
  %cmp13 = icmp sgt i64 %., 0
  br i1 %cmp13, label %land.lhs.true14, label %if.end20

land.lhs.true14:                                  ; preds = %if.then9
  %reganch = getelementptr inbounds %struct.regexp* %1, i64 0, i32 15
  %9 = load i64* %reganch, align 8, !tbaa !48
  %and = and i64 %9, 268435456
  %tobool15 = icmp eq i64 %and, 0
  br i1 %tobool15, label %if.end20, label %if.then16

if.then16:                                        ; preds = %land.lhs.true14
  %subbeg = getelementptr inbounds %struct.regexp* %1, i64 0, i32 6
  %10 = load i8** %subbeg, align 8, !tbaa !49
  %tobool17 = icmp eq i8* %10, null
  br i1 %tobool17, label %if.end20, label %if.then18

if.then18:                                        ; preds = %if.then16
  %add.ptr = getelementptr inbounds i8* %10, i64 %.
  %call = tail call i64 @Perl_utf8_length(i8* %10, i8* %add.ptr) #4
  br label %if.end20

if.end20:                                         ; preds = %if.then16, %land.lhs.true14, %if.then18, %if.then9
  %i.1 = phi i64 [ %call, %if.then18 ], [ %., %if.then16 ], [ %., %land.lhs.true14 ], [ %., %if.then9 ]
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %i.1) #4
  br label %return

return:                                           ; preds = %if.end20, %entry, %land.lhs.true, %if.end, %land.lhs.true4, %land.lhs.true6, %if.then
  ret i32 0
}

declare void @Perl_sv_setiv(%struct.sv*, i64) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_regdatum_set(%struct.sv* nocapture readnone %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([0 x i8]* @PL_no_modify, i64 0, i64 0)) #4
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i64 @Perl_magic_len(%struct.sv* %sv, %struct.magic* %mg) #0 {
entry:
  %n_a = alloca i64, align 8
  %mg_ptr = getelementptr inbounds %struct.magic* %mg, i64 0, i32 6
  %0 = load i8** %mg_ptr, align 8, !tbaa !39
  %1 = load i8* %0, align 1, !tbaa !50
  %conv = sext i8 %1 to i32
  switch i32 %conv, label %sw.epilog [
    i32 49, label %sw.bb
    i32 50, label %sw.bb
    i32 51, label %sw.bb
    i32 52, label %sw.bb
    i32 53, label %sw.bb
    i32 54, label %sw.bb
    i32 55, label %sw.bb
    i32 56, label %sw.bb
    i32 57, label %sw.bb
    i32 38, label %sw.bb
    i32 43, label %sw.bb89
    i32 14, label %sw.bb99
    i32 96, label %sw.bb109
    i32 39, label %sw.bb128
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  %2 = load %struct.pmop** @PL_curpm, align 8, !tbaa !16
  %tobool = icmp eq %struct.pmop* %2, null
  br i1 %tobool, label %if.else57, label %land.lhs.true

land.lhs.true:                                    ; preds = %sw.bb
  %op_pmregexp = getelementptr inbounds %struct.pmop* %2, i64 0, i32 13
  %3 = load %struct.regexp** %op_pmregexp, align 8, !tbaa !41
  %tobool1 = icmp eq %struct.regexp* %3, null
  br i1 %tobool1, label %if.else57, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %call = call i32 @atoi(i8* %0) #4
  %conv3 = sext i32 %call to i64
  br label %getparen

getparen:                                         ; preds = %if.then94, %if.then104, %if.then
  %rx.0 = phi %struct.regexp* [ %43, %if.then104 ], [ %40, %if.then94 ], [ %3, %if.then ]
  %paren.0 = phi i64 [ %44, %if.then104 ], [ %41, %if.then94 ], [ %conv3, %if.then ]
  %nparens = getelementptr inbounds %struct.regexp* %rx.0, i64 0, i32 12
  %4 = load i64* %nparens, align 8, !tbaa !43
  %cmp = icmp sgt i64 %paren.0, %4
  br i1 %cmp, label %if.else, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %getparen
  %startp = getelementptr inbounds %struct.regexp* %rx.0, i64 0, i32 0
  %5 = load i64** %startp, align 8, !tbaa !46
  %arrayidx = getelementptr inbounds i64* %5, i64 %paren.0
  %6 = load i64* %arrayidx, align 8, !tbaa !25
  %cmp6 = icmp eq i64 %6, -1
  br i1 %cmp6, label %if.else, label %land.lhs.true8

land.lhs.true8:                                   ; preds = %land.lhs.true5
  %endp = getelementptr inbounds %struct.regexp* %rx.0, i64 0, i32 1
  %7 = load i64** %endp, align 8, !tbaa !47
  %arrayidx9 = getelementptr inbounds i64* %7, i64 %paren.0
  %8 = load i64* %arrayidx9, align 8, !tbaa !25
  %cmp10 = icmp eq i64 %8, -1
  br i1 %cmp10, label %if.else, label %getlen

getlen:                                           ; preds = %land.lhs.true8
  %sub = sub nsw i64 %8, %6
  %cmp13 = icmp sgt i64 %sub, 0
  br i1 %cmp13, label %land.lhs.true15, label %if.end25

land.lhs.true15:                                  ; preds = %if.then114, %if.then138, %getlen
  %t1.0211 = phi i64 [ %8, %getlen ], [ %53, %if.then138 ], [ %48, %if.then114 ]
  %s1.0210 = phi i64 [ %6, %getlen ], [ %52, %if.then138 ], [ 0, %if.then114 ]
  %rx.1209 = phi %struct.regexp* [ %rx.0, %getlen ], [ %50, %if.then138 ], [ %46, %if.then114 ]
  %i.0208 = phi i64 [ %sub, %getlen ], [ %sub141, %if.then138 ], [ %48, %if.then114 ]
  %reganch = getelementptr inbounds %struct.regexp* %rx.1209, i64 0, i32 15
  %9 = load i64* %reganch, align 8, !tbaa !48
  %and = and i64 %9, 268435456
  %tobool16 = icmp eq i64 %and, 0
  br i1 %tobool16, label %if.end25, label %if.then17

if.then17:                                        ; preds = %land.lhs.true15
  %subbeg = getelementptr inbounds %struct.regexp* %rx.1209, i64 0, i32 6
  %10 = load i8** %subbeg, align 8, !tbaa !49
  %add.ptr = getelementptr inbounds i8* %10, i64 %s1.0210
  %sub20 = sub nsw i64 %t1.0211, %s1.0210
  %call21 = call signext i8 @Perl_is_utf8_string(i8* %add.ptr, i64 %sub20) #4
  %tobool22 = icmp eq i8 %call21, 0
  br i1 %tobool22, label %if.end25, label %if.then23

if.then23:                                        ; preds = %if.then17
  %add.ptr19 = getelementptr inbounds i8* %10, i64 %t1.0211
  %call24 = call i64 @Perl_utf8_length(i8* %add.ptr, i8* %add.ptr19) #4
  br label %if.end25

if.end25:                                         ; preds = %if.then17, %land.lhs.true15, %if.then23, %getlen
  %i.1 = phi i64 [ %call24, %if.then23 ], [ %sub20, %if.then17 ], [ %i.0208, %land.lhs.true15 ], [ %sub, %getlen ]
  %cmp26 = icmp slt i64 %i.1, 0
  br i1 %cmp26, label %if.then28, label %return

if.then28:                                        ; preds = %if.end25
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([22 x i8]* @.str1, i64 0, i64 0), i64 %i.1) #4
  br label %return

if.else:                                          ; preds = %land.lhs.true8, %land.lhs.true5, %getparen
  %11 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings = getelementptr inbounds %struct.cop* %11, i64 0, i32 14
  %12 = load %struct.sv** %cop_warnings, align 8, !tbaa !51
  %cmp30 = icmp eq %struct.sv* %12, null
  br i1 %cmp30, label %lor.lhs.false45, label %land.lhs.true32

land.lhs.true32:                                  ; preds = %if.else
  %13 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings33 = getelementptr inbounds %struct.cop* %13, i64 0, i32 14
  %14 = load %struct.sv** %cop_warnings33, align 8, !tbaa !51
  %cmp34 = icmp eq %struct.sv* %14, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp34, label %lor.lhs.false45, label %land.lhs.true36

land.lhs.true36:                                  ; preds = %land.lhs.true32
  %15 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings37 = getelementptr inbounds %struct.cop* %15, i64 0, i32 14
  %16 = load %struct.sv** %cop_warnings37, align 8, !tbaa !51
  %cmp38 = icmp eq %struct.sv* %16, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp38, label %if.then53, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true36
  %17 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings40 = getelementptr inbounds %struct.cop* %17, i64 0, i32 14
  %18 = load %struct.sv** %cop_warnings40, align 8, !tbaa !51
  %sv_any = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %19 = load i8** %sv_any, align 8, !tbaa !1
  %xpv_pv = bitcast i8* %19 to i8**
  %20 = load i8** %xpv_pv, align 8, !tbaa !32
  %arrayidx41 = getelementptr inbounds i8* %20, i64 10
  %21 = load i8* %arrayidx41, align 1, !tbaa !50
  %and43 = and i8 %21, 4
  %tobool44 = icmp eq i8 %and43, 0
  br i1 %tobool44, label %lor.lhs.false45, label %if.then53

lor.lhs.false45:                                  ; preds = %lor.lhs.false, %land.lhs.true32, %if.else
  %22 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings46 = getelementptr inbounds %struct.cop* %22, i64 0, i32 14
  %23 = load %struct.sv** %cop_warnings46, align 8, !tbaa !51
  %cmp47 = icmp eq %struct.sv* %23, null
  br i1 %cmp47, label %land.lhs.true49, label %return

land.lhs.true49:                                  ; preds = %lor.lhs.false45
  %24 = load i8* @PL_dowarn, align 1, !tbaa !50
  %and51 = and i8 %24, 1
  %tobool52 = icmp eq i8 %and51, 0
  br i1 %tobool52, label %return, label %if.then53

if.then53:                                        ; preds = %lor.lhs.false, %land.lhs.true49, %land.lhs.true36
  %call54 = call i32 (...)* @report_uninit() #4
  br label %return

if.else57:                                        ; preds = %land.lhs.true, %sw.bb
  %25 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings58 = getelementptr inbounds %struct.cop* %25, i64 0, i32 14
  %26 = load %struct.sv** %cop_warnings58, align 8, !tbaa !51
  %cmp59 = icmp eq %struct.sv* %26, null
  br i1 %cmp59, label %lor.lhs.false77, label %land.lhs.true61

land.lhs.true61:                                  ; preds = %if.else57
  %27 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings62 = getelementptr inbounds %struct.cop* %27, i64 0, i32 14
  %28 = load %struct.sv** %cop_warnings62, align 8, !tbaa !51
  %cmp63 = icmp eq %struct.sv* %28, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp63, label %lor.lhs.false77, label %land.lhs.true65

land.lhs.true65:                                  ; preds = %land.lhs.true61
  %29 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings66 = getelementptr inbounds %struct.cop* %29, i64 0, i32 14
  %30 = load %struct.sv** %cop_warnings66, align 8, !tbaa !51
  %cmp67 = icmp eq %struct.sv* %30, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp67, label %if.then85, label %lor.lhs.false69

lor.lhs.false69:                                  ; preds = %land.lhs.true65
  %31 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings70 = getelementptr inbounds %struct.cop* %31, i64 0, i32 14
  %32 = load %struct.sv** %cop_warnings70, align 8, !tbaa !51
  %sv_any71 = getelementptr inbounds %struct.sv* %32, i64 0, i32 0
  %33 = load i8** %sv_any71, align 8, !tbaa !1
  %xpv_pv72 = bitcast i8* %33 to i8**
  %34 = load i8** %xpv_pv72, align 8, !tbaa !32
  %arrayidx73 = getelementptr inbounds i8* %34, i64 10
  %35 = load i8* %arrayidx73, align 1, !tbaa !50
  %and75 = and i8 %35, 4
  %tobool76 = icmp eq i8 %and75, 0
  br i1 %tobool76, label %lor.lhs.false77, label %if.then85

lor.lhs.false77:                                  ; preds = %lor.lhs.false69, %land.lhs.true61, %if.else57
  %36 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings78 = getelementptr inbounds %struct.cop* %36, i64 0, i32 14
  %37 = load %struct.sv** %cop_warnings78, align 8, !tbaa !51
  %cmp79 = icmp eq %struct.sv* %37, null
  br i1 %cmp79, label %land.lhs.true81, label %return

land.lhs.true81:                                  ; preds = %lor.lhs.false77
  %38 = load i8* @PL_dowarn, align 1, !tbaa !50
  %and83 = and i8 %38, 1
  %tobool84 = icmp eq i8 %and83, 0
  br i1 %tobool84, label %return, label %if.then85

if.then85:                                        ; preds = %lor.lhs.false69, %land.lhs.true81, %land.lhs.true65
  %call86 = call i32 (...)* @report_uninit() #4
  br label %return

sw.bb89:                                          ; preds = %entry
  %39 = load %struct.pmop** @PL_curpm, align 8, !tbaa !16
  %tobool90 = icmp eq %struct.pmop* %39, null
  br i1 %tobool90, label %return, label %land.lhs.true91

land.lhs.true91:                                  ; preds = %sw.bb89
  %op_pmregexp92 = getelementptr inbounds %struct.pmop* %39, i64 0, i32 13
  %40 = load %struct.regexp** %op_pmregexp92, align 8, !tbaa !41
  %tobool93 = icmp eq %struct.regexp* %40, null
  br i1 %tobool93, label %return, label %if.then94

if.then94:                                        ; preds = %land.lhs.true91
  %lastparen = getelementptr inbounds %struct.regexp* %40, i64 0, i32 13
  %41 = load i64* %lastparen, align 8, !tbaa !45
  %tobool95 = icmp eq i64 %41, 0
  br i1 %tobool95, label %return, label %getparen

sw.bb99:                                          ; preds = %entry
  %42 = load %struct.pmop** @PL_curpm, align 8, !tbaa !16
  %tobool100 = icmp eq %struct.pmop* %42, null
  br i1 %tobool100, label %return, label %land.lhs.true101

land.lhs.true101:                                 ; preds = %sw.bb99
  %op_pmregexp102 = getelementptr inbounds %struct.pmop* %42, i64 0, i32 13
  %43 = load %struct.regexp** %op_pmregexp102, align 8, !tbaa !41
  %tobool103 = icmp eq %struct.regexp* %43, null
  br i1 %tobool103, label %return, label %if.then104

if.then104:                                       ; preds = %land.lhs.true101
  %lastcloseparen = getelementptr inbounds %struct.regexp* %43, i64 0, i32 14
  %44 = load i64* %lastcloseparen, align 8, !tbaa !52
  %tobool105 = icmp eq i64 %44, 0
  br i1 %tobool105, label %return, label %getparen

sw.bb109:                                         ; preds = %entry
  %45 = load %struct.pmop** @PL_curpm, align 8, !tbaa !16
  %tobool110 = icmp eq %struct.pmop* %45, null
  br i1 %tobool110, label %return, label %land.lhs.true111

land.lhs.true111:                                 ; preds = %sw.bb109
  %op_pmregexp112 = getelementptr inbounds %struct.pmop* %45, i64 0, i32 13
  %46 = load %struct.regexp** %op_pmregexp112, align 8, !tbaa !41
  %tobool113 = icmp eq %struct.regexp* %46, null
  br i1 %tobool113, label %return, label %if.then114

if.then114:                                       ; preds = %land.lhs.true111
  %startp115 = getelementptr inbounds %struct.regexp* %46, i64 0, i32 0
  %47 = load i64** %startp115, align 8, !tbaa !46
  %48 = load i64* %47, align 8, !tbaa !25
  %cmp122 = icmp sgt i64 %48, 0
  br i1 %cmp122, label %land.lhs.true15, label %return

sw.bb128:                                         ; preds = %entry
  %49 = load %struct.pmop** @PL_curpm, align 8, !tbaa !16
  %tobool129 = icmp eq %struct.pmop* %49, null
  br i1 %tobool129, label %return, label %land.lhs.true130

land.lhs.true130:                                 ; preds = %sw.bb128
  %op_pmregexp131 = getelementptr inbounds %struct.pmop* %49, i64 0, i32 13
  %50 = load %struct.regexp** %op_pmregexp131, align 8, !tbaa !41
  %tobool132 = icmp eq %struct.regexp* %50, null
  br i1 %tobool132, label %return, label %if.then133

if.then133:                                       ; preds = %land.lhs.true130
  %endp134 = getelementptr inbounds %struct.regexp* %50, i64 0, i32 1
  %51 = load i64** %endp134, align 8, !tbaa !47
  %52 = load i64* %51, align 8, !tbaa !25
  %cmp136 = icmp eq i64 %52, -1
  br i1 %cmp136, label %return, label %if.then138

if.then138:                                       ; preds = %if.then133
  %sublen = getelementptr inbounds %struct.regexp* %50, i64 0, i32 8
  %53 = load i64* %sublen, align 8, !tbaa !53
  %sub141 = sub nsw i64 %53, %52
  %cmp142 = icmp sgt i64 %sub141, 0
  br i1 %cmp142, label %land.lhs.true15, label %return

sw.epilog:                                        ; preds = %entry
  %call151 = call i32 (%struct.sv*, %struct.magic*, ...)* bitcast (i32 (...)* @magic_get to i32 (%struct.sv*, %struct.magic*, ...)*)(%struct.sv* %sv, %struct.magic* %mg) #4
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %54 = load i64* %sv_flags, align 8, !tbaa !13
  %and152 = and i64 %54, 262144
  %tobool153 = icmp ne i64 %and152, 0
  %and156 = and i64 %54, 196608
  %tobool157 = icmp eq i64 %and156, 0
  %or.cond206 = or i1 %tobool153, %tobool157
  br i1 %or.cond206, label %if.end160, label %if.then158

if.then158:                                       ; preds = %sw.epilog
  %call159 = call i8* @Perl_sv_2pv_flags(%struct.sv* %sv, i64* %n_a, i64 2) #4
  %.pre = load i64* %sv_flags, align 8, !tbaa !13
  br label %if.end160

if.end160:                                        ; preds = %sw.epilog, %if.then158
  %55 = phi i64 [ %54, %sw.epilog ], [ %.pre, %if.then158 ]
  %and162 = and i64 %55, 262144
  %tobool163 = icmp eq i64 %and162, 0
  br i1 %tobool163, label %return, label %if.then164

if.then164:                                       ; preds = %if.end160
  %sv_any165 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %56 = load i8** %sv_any165, align 8, !tbaa !1
  %xpv_cur = getelementptr inbounds i8* %56, i64 8
  %57 = bitcast i8* %xpv_cur to i64*
  %58 = load i64* %57, align 8, !tbaa !30
  br label %return

return:                                           ; preds = %if.end160, %if.then138, %sw.bb128, %land.lhs.true130, %if.then133, %sw.bb109, %land.lhs.true111, %if.then114, %sw.bb99, %land.lhs.true101, %if.then104, %sw.bb89, %land.lhs.true91, %if.then94, %lor.lhs.false45, %if.then53, %if.then85, %lor.lhs.false77, %land.lhs.true49, %land.lhs.true81, %if.end25, %if.then28, %if.then164
  %retval.0 = phi i64 [ %58, %if.then164 ], [ %i.1, %if.then28 ], [ %i.1, %if.end25 ], [ 0, %land.lhs.true81 ], [ 0, %land.lhs.true49 ], [ 0, %lor.lhs.false77 ], [ 0, %if.then85 ], [ 0, %if.then53 ], [ 0, %lor.lhs.false45 ], [ 0, %if.then94 ], [ 0, %land.lhs.true91 ], [ 0, %sw.bb89 ], [ 0, %if.then104 ], [ 0, %land.lhs.true101 ], [ 0, %sw.bb99 ], [ 0, %if.then114 ], [ 0, %land.lhs.true111 ], [ 0, %sw.bb109 ], [ 0, %if.then133 ], [ 0, %land.lhs.true130 ], [ 0, %sw.bb128 ], [ 0, %if.then138 ], [ 0, %if.end160 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind readonly
declare i32 @atoi(i8* nocapture) #3

declare signext i8 @Perl_is_utf8_string(i8*, i64) #1

declare i32 @report_uninit(...) #1

declare i32 @magic_get(...) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_get(%struct.sv* %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %mg_ptr = getelementptr inbounds %struct.magic* %mg, i64 0, i32 6
  %0 = load i8** %mg_ptr, align 8, !tbaa !39
  %1 = load i8* %0, align 1, !tbaa !50
  %conv = sext i8 %1 to i32
  switch i32 %conv, label %sw.epilog [
    i32 1, label %sw.bb
    i32 3, label %sw.bb1
    i32 4, label %sw.bb3
    i32 5, label %sw.bb4
    i32 6, label %sw.bb20
    i32 8, label %sw.bb21
    i32 9, label %sw.bb22
    i32 15, label %sw.bb27
    i32 16, label %sw.bb48
    i32 19, label %sw.bb49
    i32 20, label %sw.bb75
    i32 21, label %sw.bb101
    i32 23, label %sw.bb114
    i32 49, label %sw.bb157
    i32 50, label %sw.bb157
    i32 51, label %sw.bb157
    i32 52, label %sw.bb157
    i32 53, label %sw.bb157
    i32 54, label %sw.bb157
    i32 55, label %sw.bb157
    i32 56, label %sw.bb157
    i32 57, label %sw.bb157
    i32 38, label %sw.bb157
    i32 43, label %sw.bb231
    i32 14, label %sw.bb241
    i32 96, label %sw.bb251
    i32 39, label %sw.bb269
    i32 46, label %sw.bb292
    i32 63, label %sw.bb313
    i32 94, label %sw.bb314
    i32 126, label %sw.bb340
    i32 61, label %sw.bb367
    i32 45, label %sw.bb378
    i32 37, label %sw.bb389
    i32 41, label %sw.bb445
    i32 40, label %sw.bb443
    i32 91, label %sw.bb400
    i32 124, label %sw.bb401
    i32 62, label %sw.bb441
    i32 92, label %sw.bb418
    i32 35, label %sw.bb422
    i32 33, label %sw.bb423
    i32 60, label %sw.bb439
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.sv** @PL_bodytarget, align 8, !tbaa !16
  tail call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* %2, i64 2) #4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %3 = load i8* @PL_minus_c, align 1, !tbaa !50
  %conv2 = sext i8 %3 to i64
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %conv2) #4
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %4 = load volatile i64* @PL_debug, align 8, !tbaa !25
  %and = and i64 %4, 2093055
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %and) #4
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %add.ptr = getelementptr inbounds i8* %0, i64 1
  %5 = load i8* %add.ptr, align 1, !tbaa !50
  %cmp = icmp eq i8 %5, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb4
  %call = tail call i32* @__errno_location() #4
  %6 = load i32* %call, align 4, !tbaa !54
  %call8 = tail call i32* @__errno_location() #4
  %7 = load i32* %call8, align 4, !tbaa !54
  %conv9 = sitofp i32 %7 to double
  tail call void @Perl_sv_setnv(%struct.sv* %sv, double %conv9) #4
  %call10 = tail call i32* @__errno_location() #4
  %8 = load i32* %call10, align 4, !tbaa !54
  %tobool = icmp eq i32 %8, 0
  br i1 %tobool, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.then
  %call11 = tail call i32* @__errno_location() #4
  %9 = load i32* %call11, align 4, !tbaa !54
  %call12 = tail call i8* @strerror(i32 %9) #4
  br label %cond.end

cond.end:                                         ; preds = %if.then, %cond.true
  %cond = phi i8* [ %call12, %cond.true ], [ getelementptr inbounds ([1 x i8]* @.str2, i64 0, i64 0), %if.then ]
  tail call void @Perl_sv_setpv(%struct.sv* %sv, i8* %cond) #4
  %call13 = tail call i32* @__errno_location() #4
  store i32 %6, i32* %call13, align 4, !tbaa !54
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %10 = load i64* %sv_flags, align 8, !tbaa !13
  %or = or i64 %10, 33685504
  store i64 %or, i64* %sv_flags, align 8, !tbaa !13
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb4
  %call16 = tail call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([8 x i8]* @.str3, i64 0, i64 0)) #4
  %tobool17 = icmp eq i32 %call16, 0
  br i1 %tobool17, label %if.then18, label %sw.epilog

if.then18:                                        ; preds = %if.else
  %11 = load %struct.sv** @PL_encoding, align 8, !tbaa !16
  tail call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* %11, i64 2) #4
  br label %sw.epilog

sw.bb20:                                          ; preds = %entry
  %12 = load i64* @PL_maxsysfd, align 8, !tbaa !25
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %12) #4
  br label %sw.epilog

sw.bb21:                                          ; preds = %entry
  %13 = load i64* @PL_hints, align 8, !tbaa !25
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %13) #4
  br label %sw.epilog

sw.bb22:                                          ; preds = %entry
  %14 = load i8** @PL_inplace, align 8, !tbaa !16
  %tobool23 = icmp eq i8* %14, null
  br i1 %tobool23, label %if.else25, label %if.then24

if.then24:                                        ; preds = %sw.bb22
  tail call void @Perl_sv_setpv(%struct.sv* %sv, i8* %14) #4
  br label %sw.epilog

if.else25:                                        ; preds = %sw.bb22
  tail call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* @PL_sv_undef, i64 2) #4
  br label %sw.epilog

sw.bb27:                                          ; preds = %entry
  %add.ptr29 = getelementptr inbounds i8* %0, i64 1
  %15 = load i8* %add.ptr29, align 1, !tbaa !50
  %cmp31 = icmp eq i8 %15, 0
  br i1 %cmp31, label %if.then33, label %if.else37

if.then33:                                        ; preds = %sw.bb27
  %16 = load i8** @PL_osname, align 8, !tbaa !16
  tail call void @Perl_sv_setpv(%struct.sv* %sv, i8* %16) #4
  %17 = load i8* @PL_tainting, align 1, !tbaa !50
  %tobool34 = icmp eq i8 %17, 0
  br i1 %tobool34, label %sw.epilog, label %if.then35

if.then35:                                        ; preds = %if.then33
  tail call void @Perl_sv_untaint(%struct.sv* %sv) #4
  br label %sw.epilog

if.else37:                                        ; preds = %sw.bb27
  %call39 = tail call i32 @strcmp(i8* %0, i8* getelementptr inbounds ([5 x i8]* @.str4, i64 0, i64 0)) #4
  %tobool40 = icmp eq i32 %call39, 0
  br i1 %tobool40, label %if.then41, label %sw.epilog

if.then41:                                        ; preds = %if.else37
  %18 = load %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 15), align 8, !tbaa !56
  %tobool42 = icmp eq %struct.sv* %18, null
  br i1 %tobool42, label %if.then43, label %if.else44

if.then43:                                        ; preds = %if.then41
  tail call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* @PL_sv_undef, i64 2) #4
  br label %sw.epilog

if.else44:                                        ; preds = %if.then41
  tail call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* %18, i64 2) #4
  br label %sw.epilog

sw.bb48:                                          ; preds = %entry
  %19 = load i64* @PL_perldb, align 8, !tbaa !25
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %19) #4
  br label %sw.epilog

sw.bb49:                                          ; preds = %entry
  %add.ptr51 = getelementptr inbounds i8* %0, i64 1
  %20 = load i8* %add.ptr51, align 1, !tbaa !50
  %cmp53 = icmp eq i8 %20, 0
  br i1 %cmp53, label %if.then55, label %sw.epilog

if.then55:                                        ; preds = %sw.bb49
  %21 = load i64* @PL_lex_state, align 8, !tbaa !25
  %cmp56 = icmp eq i64 %21, 11
  br i1 %cmp56, label %if.else66, label %if.then58

if.then58:                                        ; preds = %if.then55
  %sv_flags59 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %22 = load i64* %sv_flags59, align 8, !tbaa !13
  %and60 = and i64 %22, 1223753727
  store i64 %and60, i64* %sv_flags59, align 8, !tbaa !13
  %and62 = and i64 %22, 2097152
  %tobool63 = icmp eq i64 %and62, 0
  br i1 %tobool63, label %sw.epilog, label %land.rhs

land.rhs:                                         ; preds = %if.then58
  %call64 = tail call i32 @Perl_sv_backoff(%struct.sv* %sv) #4
  br label %sw.epilog

if.else66:                                        ; preds = %if.then55
  %23 = load volatile i32* @PL_in_eval, align 4, !tbaa !54
  %tobool67 = icmp eq i32 %23, 0
  br i1 %tobool67, label %if.else71, label %if.then68

if.then68:                                        ; preds = %if.else66
  %24 = load volatile i32* @PL_in_eval, align 4, !tbaa !54
  %and69 = and i32 %24, -9
  %conv70 = sext i32 %and69 to i64
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %conv70) #4
  br label %sw.epilog

if.else71:                                        ; preds = %if.else66
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 0) #4
  br label %sw.epilog

sw.bb75:                                          ; preds = %entry
  %add.ptr77 = getelementptr inbounds i8* %0, i64 1
  %25 = load i8* %add.ptr77, align 1, !tbaa !50
  %cmp79 = icmp eq i8 %25, 0
  br i1 %cmp79, label %if.then81, label %if.else82

if.then81:                                        ; preds = %sw.bb75
  %26 = load i64* @PL_basetime, align 8, !tbaa !25
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %26) #4
  br label %sw.epilog

if.else82:                                        ; preds = %sw.bb75
  %call84 = tail call i32 @strcmp(i8* %0, i8* getelementptr inbounds ([6 x i8]* @.str5, i64 0, i64 0)) #4
  %tobool85 = icmp eq i32 %call84, 0
  br i1 %tobool85, label %if.then86, label %sw.epilog

if.then86:                                        ; preds = %if.else82
  %27 = load i8* @PL_tainting, align 1, !tbaa !50
  %tobool88 = icmp eq i8 %27, 0
  br i1 %tobool88, label %cond.end96, label %cond.true89

cond.true89:                                      ; preds = %if.then86
  %28 = load i8* @PL_taint_warn, align 1, !tbaa !50
  %tobool91 = icmp eq i8 %28, 0
  br i1 %tobool91, label %lor.rhs, label %cond.end96

lor.rhs:                                          ; preds = %cond.true89
  %29 = load i8* @PL_unsafe, align 1, !tbaa !50
  %tobool93 = icmp ne i8 %29, 0
  %phitmp569 = select i1 %tobool93, i64 -1, i64 1
  br label %cond.end96

cond.end96:                                       ; preds = %lor.rhs, %cond.true89, %if.then86
  %cond97 = phi i64 [ 0, %if.then86 ], [ -1, %cond.true89 ], [ %phitmp569, %lor.rhs ]
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %cond97) #4
  br label %sw.epilog

sw.bb101:                                         ; preds = %entry
  %call103 = tail call i32 @strcmp(i8* %0, i8* getelementptr inbounds ([8 x i8]* @.str6, i64 0, i64 0)) #4
  %tobool104 = icmp eq i32 %call103, 0
  br i1 %tobool104, label %if.then105, label %if.else106

if.then105:                                       ; preds = %sw.bb101
  %30 = load i64* @PL_unicode, align 8, !tbaa !25
  tail call void @Perl_sv_setuv(%struct.sv* %sv, i64 %30) #4
  br label %sw.epilog

if.else106:                                       ; preds = %sw.bb101
  %call108 = tail call i32 @strcmp(i8* %0, i8* getelementptr inbounds ([11 x i8]* @.str7, i64 0, i64 0)) #4
  %tobool109 = icmp eq i32 %call108, 0
  br i1 %tobool109, label %if.then110, label %sw.epilog

if.then110:                                       ; preds = %if.else106
  %31 = load i8* @PL_utf8locale, align 1, !tbaa !50
  %conv111 = sext i8 %31 to i64
  tail call void @Perl_sv_setuv(%struct.sv* %sv, i64 %conv111) #4
  br label %sw.epilog

sw.bb114:                                         ; preds = %entry
  %add.ptr116 = getelementptr inbounds i8* %0, i64 1
  %32 = load i8* %add.ptr116, align 1, !tbaa !50
  %cmp118 = icmp eq i8 %32, 0
  br i1 %cmp118, label %if.then120, label %if.else126

if.then120:                                       ; preds = %sw.bb114
  %33 = load i8* @PL_dowarn, align 1, !tbaa !50
  %and122 = and i8 %33, 1
  %conv125 = zext i8 %and122 to i64
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %conv125) #4
  br label %sw.epilog

if.else126:                                       ; preds = %sw.bb114
  %call129 = tail call i32 @strcmp(i8* %add.ptr116, i8* getelementptr inbounds ([12 x i8]* @.str8, i64 0, i64 0)) #4
  %tobool130 = icmp eq i32 %call129, 0
  br i1 %tobool130, label %if.then131, label %sw.epilog

if.then131:                                       ; preds = %if.else126
  %34 = load %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !51
  %magicptr570 = ptrtoint %struct.sv* %34 to i64
  switch i64 %magicptr570, label %if.else148 [
    i64 48, label %if.then136
    i64 0, label %if.then136
    i64 24, label %if.then140
  ]

if.then136:                                       ; preds = %if.then131, %if.then131
  tail call void @Perl_sv_setpvn(%struct.sv* %sv, i8* getelementptr inbounds ([13 x i8]* @.str9, i64 0, i64 0), i64 12) #4
  br label %if.end150

if.then140:                                       ; preds = %if.then131
  %call141 = tail call %struct.hv* @Perl_get_hv(i8* getelementptr inbounds ([15 x i8]* @.str10, i64 0, i64 0), i64 0) #4
  %tobool142 = icmp eq %struct.hv* %call141, null
  br i1 %tobool142, label %if.else146, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then140
  %call143 = tail call %struct.sv** @Perl_hv_fetch(%struct.hv* %call141, i8* getelementptr inbounds ([4 x i8]* @.str11, i64 0, i64 0), i64 3, i64 0) #4
  %tobool144 = icmp eq %struct.sv** %call143, null
  br i1 %tobool144, label %if.else146, label %if.then145

if.then145:                                       ; preds = %land.lhs.true
  %35 = load %struct.sv** %call143, align 8, !tbaa !16
  tail call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* %35, i64 2) #4
  br label %if.end150

if.else146:                                       ; preds = %land.lhs.true, %if.then140
  tail call void @Perl_sv_setpvn(%struct.sv* %sv, i8* getelementptr inbounds ([13 x i8]* @.str12, i64 0, i64 0), i64 12) #4
  br label %if.end150

if.else148:                                       ; preds = %if.then131
  tail call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* %34, i64 2) #4
  br label %if.end150

if.end150:                                        ; preds = %if.else148, %if.else146, %if.then145, %if.then136
  %sv_flags151 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %36 = load i64* %sv_flags151, align 8, !tbaa !13
  %and152 = and i64 %36, 1223753727
  %or154 = or i64 %and152, 67371008
  store i64 %or154, i64* %sv_flags151, align 8, !tbaa !13
  br label %sw.epilog

sw.bb157:                                         ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  %37 = load %struct.pmop** @PL_curpm, align 8, !tbaa !16
  %tobool158 = icmp eq %struct.pmop* %37, null
  br i1 %tobool158, label %if.end230, label %land.lhs.true159

land.lhs.true159:                                 ; preds = %sw.bb157
  %op_pmregexp = getelementptr inbounds %struct.pmop* %37, i64 0, i32 13
  %38 = load %struct.regexp** %op_pmregexp, align 8, !tbaa !41
  %tobool160 = icmp eq %struct.regexp* %38, null
  br i1 %tobool160, label %if.end230, label %if.then161

if.then161:                                       ; preds = %land.lhs.true159
  %call163 = tail call i32 @atoi(i8* %0) #4
  %conv164 = sext i32 %call163 to i64
  br label %getparen

getparen:                                         ; preds = %if.then236, %if.then246, %if.then161
  %rx.0 = phi %struct.regexp* [ %65, %if.then246 ], [ %62, %if.then236 ], [ %38, %if.then161 ]
  %paren.0 = phi i64 [ %66, %if.then246 ], [ %63, %if.then236 ], [ %conv164, %if.then161 ]
  %nparens = getelementptr inbounds %struct.regexp* %rx.0, i64 0, i32 12
  %39 = load i64* %nparens, align 8, !tbaa !43
  %cmp165 = icmp sgt i64 %paren.0, %39
  br i1 %cmp165, label %if.end230, label %land.lhs.true167

land.lhs.true167:                                 ; preds = %getparen
  %startp = getelementptr inbounds %struct.regexp* %rx.0, i64 0, i32 0
  %40 = load i64** %startp, align 8, !tbaa !46
  %arrayidx = getelementptr inbounds i64* %40, i64 %paren.0
  %41 = load i64* %arrayidx, align 8, !tbaa !25
  %cmp168 = icmp eq i64 %41, -1
  br i1 %cmp168, label %if.end230, label %land.lhs.true170

land.lhs.true170:                                 ; preds = %land.lhs.true167
  %endp = getelementptr inbounds %struct.regexp* %rx.0, i64 0, i32 1
  %42 = load i64** %endp, align 8, !tbaa !47
  %arrayidx171 = getelementptr inbounds i64* %42, i64 %paren.0
  %43 = load i64* %arrayidx171, align 8, !tbaa !25
  %cmp172 = icmp eq i64 %43, -1
  br i1 %cmp172, label %if.end230, label %if.then174

if.then174:                                       ; preds = %land.lhs.true170
  %sub = sub nsw i64 %43, %41
  %subbeg = getelementptr inbounds %struct.regexp* %rx.0, i64 0, i32 6
  %44 = load i8** %subbeg, align 8, !tbaa !49
  %add.ptr175 = getelementptr inbounds i8* %44, i64 %41
  %tobool177 = icmp eq i8* %44, null
  br i1 %tobool177, label %sw.epilog, label %getrx

getrx:                                            ; preds = %land.lhs.true259, %if.then174, %if.then282
  %rx.1 = phi %struct.regexp* [ %73, %if.then282 ], [ %rx.0, %if.then174 ], [ %68, %land.lhs.true259 ]
  %i.0 = phi i64 [ %sub289, %if.then282 ], [ %sub, %if.then174 ], [ %71, %land.lhs.true259 ]
  %s.0 = phi i8* [ %add.ptr286, %if.then282 ], [ %add.ptr175, %if.then174 ], [ %69, %land.lhs.true259 ]
  %cmp180 = icmp sgt i64 %i.0, -1
  br i1 %cmp180, label %if.then182, label %if.end230

if.then182:                                       ; preds = %getrx
  tail call void @Perl_sv_setpvn(%struct.sv* %sv, i8* %s.0, i64 %i.0) #4
  %reganch = getelementptr inbounds %struct.regexp* %rx.1, i64 0, i32 15
  %45 = load i64* %reganch, align 8, !tbaa !48
  %and183 = and i64 %45, 268435456
  %tobool184 = icmp eq i64 %and183, 0
  br i1 %tobool184, label %if.else192, label %land.lhs.true185

land.lhs.true185:                                 ; preds = %if.then182
  %call186 = tail call signext i8 @Perl_is_utf8_string(i8* %s.0, i64 %i.0) #4
  %tobool188 = icmp eq i8 %call186, 0
  br i1 %tobool188, label %if.else192, label %if.then189

if.then189:                                       ; preds = %land.lhs.true185
  %sv_flags190 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %46 = load i64* %sv_flags190, align 8, !tbaa !13
  %or191 = or i64 %46, 536870912
  store i64 %or191, i64* %sv_flags190, align 8, !tbaa !13
  br label %if.end195

if.else192:                                       ; preds = %land.lhs.true185, %if.then182
  %sv_flags193 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %47 = load i64* %sv_flags193, align 8, !tbaa !13
  %and194 = and i64 %47, -536870913
  store i64 %and194, i64* %sv_flags193, align 8, !tbaa !13
  br label %if.end195

if.end195:                                        ; preds = %if.else192, %if.then189
  %48 = load i8* @PL_tainting, align 1, !tbaa !50
  %tobool196 = icmp eq i8 %48, 0
  br i1 %tobool196, label %sw.epilog, label %if.then197

if.then197:                                       ; preds = %if.end195
  %49 = load i64* %reganch, align 8, !tbaa !48
  %and199 = and i64 %49, 524288
  %tobool200 = icmp eq i64 %and199, 0
  br i1 %tobool200, label %if.then224, label %if.then201

if.then201:                                       ; preds = %if.then197
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %50 = load i8** %sv_any, align 8, !tbaa !1
  %xmg_magic = getelementptr inbounds i8* %50, i64 40
  %51 = bitcast i8* %xmg_magic to %struct.magic**
  %52 = load %struct.magic** %51, align 8, !tbaa !18
  store i8 1, i8* @PL_tainted, align 1, !tbaa !50
  %mg_moremagic = getelementptr inbounds %struct.magic* %52, i64 0, i32 0
  %53 = load %struct.magic** %mg_moremagic, align 8, !tbaa !23
  %54 = load i8** %sv_any, align 8, !tbaa !1
  %xmg_magic204 = getelementptr inbounds i8* %54, i64 40
  %55 = bitcast i8* %xmg_magic204 to %struct.magic**
  store %struct.magic* %53, %struct.magic** %55, align 8, !tbaa !18
  %56 = load i8* @PL_tainting, align 1, !tbaa !50
  %tobool205 = icmp ne i8 %56, 0
  %57 = load i8* @PL_tainted, align 1
  %tobool207 = icmp ne i8 %57, 0
  %or.cond457 = and i1 %tobool205, %tobool207
  br i1 %or.cond457, label %if.then210, label %if.end213

if.then210:                                       ; preds = %if.then201
  tail call void @Perl_sv_taint(%struct.sv* %sv) #4
  %.pre = load i8** %sv_any, align 8, !tbaa !1
  %xmg_magic215.phi.trans.insert = getelementptr inbounds i8* %.pre, i64 40
  %.phi.trans.insert = bitcast i8* %xmg_magic215.phi.trans.insert to %struct.magic**
  %.pre574 = load %struct.magic** %.phi.trans.insert, align 8, !tbaa !18
  br label %if.end213

if.end213:                                        ; preds = %if.then210, %if.then201
  %58 = phi %struct.magic* [ %.pre574, %if.then210 ], [ %53, %if.then201 ]
  %59 = phi i8* [ %.pre, %if.then210 ], [ %54, %if.then201 ]
  %tobool216 = icmp eq %struct.magic* %58, null
  br i1 %tobool216, label %sw.epilog, label %if.then217

if.then217:                                       ; preds = %if.end213
  %xmg_magic215 = getelementptr inbounds i8* %59, i64 40
  %60 = bitcast i8* %xmg_magic215 to %struct.magic**
  store %struct.magic* %58, %struct.magic** %mg_moremagic, align 8, !tbaa !23
  store %struct.magic* %52, %struct.magic** %60, align 8, !tbaa !18
  br label %sw.epilog

if.then224:                                       ; preds = %if.then197
  tail call void @Perl_sv_untaint(%struct.sv* %sv) #4
  br label %sw.epilog

if.end230:                                        ; preds = %land.lhs.true159, %sw.bb157, %land.lhs.true170, %land.lhs.true167, %getparen, %getrx
  tail call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* @PL_sv_undef, i64 2) #4
  br label %sw.epilog

sw.bb231:                                         ; preds = %entry
  %61 = load %struct.pmop** @PL_curpm, align 8, !tbaa !16
  %tobool232 = icmp eq %struct.pmop* %61, null
  br i1 %tobool232, label %if.end240, label %land.lhs.true233

land.lhs.true233:                                 ; preds = %sw.bb231
  %op_pmregexp234 = getelementptr inbounds %struct.pmop* %61, i64 0, i32 13
  %62 = load %struct.regexp** %op_pmregexp234, align 8, !tbaa !41
  %tobool235 = icmp eq %struct.regexp* %62, null
  br i1 %tobool235, label %if.end240, label %if.then236

if.then236:                                       ; preds = %land.lhs.true233
  %lastparen = getelementptr inbounds %struct.regexp* %62, i64 0, i32 13
  %63 = load i64* %lastparen, align 8, !tbaa !45
  %tobool237 = icmp eq i64 %63, 0
  br i1 %tobool237, label %if.end240, label %getparen

if.end240:                                        ; preds = %if.then236, %land.lhs.true233, %sw.bb231
  tail call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* @PL_sv_undef, i64 2) #4
  br label %sw.epilog

sw.bb241:                                         ; preds = %entry
  %64 = load %struct.pmop** @PL_curpm, align 8, !tbaa !16
  %tobool242 = icmp eq %struct.pmop* %64, null
  br i1 %tobool242, label %if.end250, label %land.lhs.true243

land.lhs.true243:                                 ; preds = %sw.bb241
  %op_pmregexp244 = getelementptr inbounds %struct.pmop* %64, i64 0, i32 13
  %65 = load %struct.regexp** %op_pmregexp244, align 8, !tbaa !41
  %tobool245 = icmp eq %struct.regexp* %65, null
  br i1 %tobool245, label %if.end250, label %if.then246

if.then246:                                       ; preds = %land.lhs.true243
  %lastcloseparen = getelementptr inbounds %struct.regexp* %65, i64 0, i32 14
  %66 = load i64* %lastcloseparen, align 8, !tbaa !52
  %tobool247 = icmp eq i64 %66, 0
  br i1 %tobool247, label %if.end250, label %getparen

if.end250:                                        ; preds = %if.then246, %land.lhs.true243, %sw.bb241
  tail call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* @PL_sv_undef, i64 2) #4
  br label %sw.epilog

sw.bb251:                                         ; preds = %entry
  %67 = load %struct.pmop** @PL_curpm, align 8, !tbaa !16
  %tobool252 = icmp eq %struct.pmop* %67, null
  br i1 %tobool252, label %if.end268, label %land.lhs.true253

land.lhs.true253:                                 ; preds = %sw.bb251
  %op_pmregexp254 = getelementptr inbounds %struct.pmop* %67, i64 0, i32 13
  %68 = load %struct.regexp** %op_pmregexp254, align 8, !tbaa !41
  %tobool255 = icmp eq %struct.regexp* %68, null
  br i1 %tobool255, label %if.end268, label %if.then256

if.then256:                                       ; preds = %land.lhs.true253
  %subbeg257 = getelementptr inbounds %struct.regexp* %68, i64 0, i32 6
  %69 = load i8** %subbeg257, align 8, !tbaa !49
  %tobool258 = icmp eq i8* %69, null
  br i1 %tobool258, label %if.end268, label %land.lhs.true259

land.lhs.true259:                                 ; preds = %if.then256
  %startp260 = getelementptr inbounds %struct.regexp* %68, i64 0, i32 0
  %70 = load i64** %startp260, align 8, !tbaa !46
  %71 = load i64* %70, align 8, !tbaa !25
  %cmp262 = icmp eq i64 %71, -1
  br i1 %cmp262, label %if.end268, label %getrx

if.end268:                                        ; preds = %land.lhs.true259, %if.then256, %land.lhs.true253, %sw.bb251
  tail call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* @PL_sv_undef, i64 2) #4
  br label %sw.epilog

sw.bb269:                                         ; preds = %entry
  %72 = load %struct.pmop** @PL_curpm, align 8, !tbaa !16
  %tobool270 = icmp eq %struct.pmop* %72, null
  br i1 %tobool270, label %if.end291, label %land.lhs.true271

land.lhs.true271:                                 ; preds = %sw.bb269
  %op_pmregexp272 = getelementptr inbounds %struct.pmop* %72, i64 0, i32 13
  %73 = load %struct.regexp** %op_pmregexp272, align 8, !tbaa !41
  %tobool273 = icmp eq %struct.regexp* %73, null
  br i1 %tobool273, label %if.end291, label %if.then274

if.then274:                                       ; preds = %land.lhs.true271
  %subbeg275 = getelementptr inbounds %struct.regexp* %73, i64 0, i32 6
  %74 = load i8** %subbeg275, align 8, !tbaa !49
  %tobool276 = icmp eq i8* %74, null
  br i1 %tobool276, label %if.end291, label %land.lhs.true277

land.lhs.true277:                                 ; preds = %if.then274
  %endp278 = getelementptr inbounds %struct.regexp* %73, i64 0, i32 1
  %75 = load i64** %endp278, align 8, !tbaa !47
  %76 = load i64* %75, align 8, !tbaa !25
  %cmp280 = icmp eq i64 %76, -1
  br i1 %cmp280, label %if.end291, label %if.then282

if.then282:                                       ; preds = %land.lhs.true277
  %add.ptr286 = getelementptr inbounds i8* %74, i64 %76
  %sublen = getelementptr inbounds %struct.regexp* %73, i64 0, i32 8
  %77 = load i64* %sublen, align 8, !tbaa !53
  %sub289 = sub nsw i64 %77, %76
  br label %getrx

if.end291:                                        ; preds = %land.lhs.true277, %if.then274, %land.lhs.true271, %sw.bb269
  tail call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* @PL_sv_undef, i64 2) #4
  br label %sw.epilog

sw.bb292:                                         ; preds = %entry
  %78 = load %struct.gv** @PL_last_in_gv, align 8, !tbaa !16
  %tobool293 = icmp eq %struct.gv* %78, null
  br i1 %tobool293, label %sw.epilog, label %land.lhs.true294

land.lhs.true294:                                 ; preds = %sw.bb292
  %79 = getelementptr inbounds %struct.gv* %78, i64 0, i32 2
  %80 = load i64* %79, align 8, !tbaa !13
  %and296 = and i64 %80, 255
  %cmp297 = icmp eq i64 %and296, 13
  br i1 %cmp297, label %land.lhs.true299, label %sw.epilog

land.lhs.true299:                                 ; preds = %land.lhs.true294
  %sv_any300 = getelementptr inbounds %struct.gv* %78, i64 0, i32 0
  %81 = load %struct.xpvgv** %sv_any300, align 8, !tbaa !57
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %81, i64 0, i32 7
  %82 = load %struct.gp** %xgv_gp, align 8, !tbaa !59
  %tobool301 = icmp eq %struct.gp* %82, null
  br i1 %tobool301, label %sw.epilog, label %cond.true302

cond.true302:                                     ; preds = %land.lhs.true299
  %gp_io = getelementptr inbounds %struct.gp* %82, i64 0, i32 2
  %83 = load %struct.io** %gp_io, align 8, !tbaa !61
  %tobool305 = icmp eq %struct.io* %83, null
  br i1 %tobool305, label %sw.epilog, label %if.then307

if.then307:                                       ; preds = %cond.true302
  %sv_any311 = getelementptr inbounds %struct.io* %83, i64 0, i32 0
  %84 = load %struct.xpvio** %sv_any311, align 8, !tbaa !63
  %xio_lines = getelementptr inbounds %struct.xpvio* %84, i64 0, i32 10
  %85 = load i64* %xio_lines, align 8, !tbaa !65
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %85) #4
  br label %sw.epilog

sw.bb313:                                         ; preds = %entry
  %86 = load i64* @PL_statusvalue, align 8, !tbaa !25
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %86) #4
  br label %sw.epilog

sw.bb314:                                         ; preds = %entry
  %87 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any315 = getelementptr inbounds %struct.gv* %87, i64 0, i32 0
  %88 = load %struct.xpvgv** %sv_any315, align 8, !tbaa !57
  %xgv_gp316 = getelementptr inbounds %struct.xpvgv* %88, i64 0, i32 7
  %89 = load %struct.gp** %xgv_gp316, align 8, !tbaa !59
  %gp_io317 = getelementptr inbounds %struct.gp* %89, i64 0, i32 2
  %90 = load %struct.io** %gp_io317, align 8, !tbaa !61
  %tobool318 = icmp eq %struct.io* %90, null
  br i1 %tobool318, label %if.else327, label %if.end324

if.end324:                                        ; preds = %sw.bb314
  %sv_any323 = getelementptr inbounds %struct.io* %90, i64 0, i32 0
  %91 = load %struct.xpvio** %sv_any323, align 8, !tbaa !63
  %xio_top_name = getelementptr inbounds %struct.xpvio* %91, i64 0, i32 14
  %92 = load i8** %xio_top_name, align 8, !tbaa !67
  %tobool325 = icmp eq i8* %92, null
  br i1 %tobool325, label %if.else327, label %if.then326

if.then326:                                       ; preds = %if.end324
  tail call void @Perl_sv_setpv(%struct.sv* %sv, i8* %92) #4
  br label %sw.epilog

if.else327:                                       ; preds = %sw.bb314, %if.end324
  %gp_egv = getelementptr inbounds %struct.gp* %89, i64 0, i32 6
  %93 = load %struct.gv** %gp_egv, align 8, !tbaa !68
  %tobool330 = icmp eq %struct.gv* %93, null
  %. = select i1 %tobool330, %struct.gv* %87, %struct.gv* %93
  %sv_any338 = getelementptr inbounds %struct.gv* %., i64 0, i32 0
  %94 = load %struct.xpvgv** %sv_any338, align 8, !tbaa !57
  %xgv_name = getelementptr inbounds %struct.xpvgv* %94, i64 0, i32 8
  %95 = load i8** %xgv_name, align 8, !tbaa !69
  tail call void @Perl_sv_setpv(%struct.sv* %sv, i8* %95) #4
  tail call void @Perl_sv_catpv(%struct.sv* %sv, i8* getelementptr inbounds ([5 x i8]* @.str13, i64 0, i64 0)) #4
  br label %sw.epilog

sw.bb340:                                         ; preds = %entry
  %96 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any341 = getelementptr inbounds %struct.gv* %96, i64 0, i32 0
  %97 = load %struct.xpvgv** %sv_any341, align 8, !tbaa !57
  %xgv_gp342 = getelementptr inbounds %struct.xpvgv* %97, i64 0, i32 7
  %98 = load %struct.gp** %xgv_gp342, align 8, !tbaa !59
  %gp_io343 = getelementptr inbounds %struct.gp* %98, i64 0, i32 2
  %99 = load %struct.io** %gp_io343, align 8, !tbaa !61
  %tobool344 = icmp eq %struct.io* %99, null
  br i1 %tobool344, label %if.then352, label %if.end350

if.end350:                                        ; preds = %sw.bb340
  %sv_any349 = getelementptr inbounds %struct.io* %99, i64 0, i32 0
  %100 = load %struct.xpvio** %sv_any349, align 8, !tbaa !63
  %xio_fmt_name = getelementptr inbounds %struct.xpvio* %100, i64 0, i32 16
  %101 = load i8** %xio_fmt_name, align 8, !tbaa !70
  %tobool351 = icmp eq i8* %101, null
  br i1 %tobool351, label %if.then352, label %if.end366

if.then352:                                       ; preds = %sw.bb340, %if.end350
  %gp_egv355 = getelementptr inbounds %struct.gp* %98, i64 0, i32 6
  %102 = load %struct.gv** %gp_egv355, align 8, !tbaa !68
  %tobool356 = icmp eq %struct.gv* %102, null
  %.571 = select i1 %tobool356, %struct.gv* %96, %struct.gv* %102
  %sv_any364 = getelementptr inbounds %struct.gv* %.571, i64 0, i32 0
  %103 = load %struct.xpvgv** %sv_any364, align 8, !tbaa !57
  %xgv_name365 = getelementptr inbounds %struct.xpvgv* %103, i64 0, i32 8
  %104 = load i8** %xgv_name365, align 8, !tbaa !69
  br label %if.end366

if.end366:                                        ; preds = %if.end350, %if.then352
  %s.3 = phi i8* [ %101, %if.end350 ], [ %104, %if.then352 ]
  tail call void @Perl_sv_setpv(%struct.sv* %sv, i8* %s.3) #4
  br label %sw.epilog

sw.bb367:                                         ; preds = %entry
  %105 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any368 = getelementptr inbounds %struct.gv* %105, i64 0, i32 0
  %106 = load %struct.xpvgv** %sv_any368, align 8, !tbaa !57
  %xgv_gp369 = getelementptr inbounds %struct.xpvgv* %106, i64 0, i32 7
  %107 = load %struct.gp** %xgv_gp369, align 8, !tbaa !59
  %gp_io370 = getelementptr inbounds %struct.gp* %107, i64 0, i32 2
  %108 = load %struct.io** %gp_io370, align 8, !tbaa !61
  %tobool371 = icmp eq %struct.io* %108, null
  br i1 %tobool371, label %sw.epilog, label %if.then372

if.then372:                                       ; preds = %sw.bb367
  %sv_any376 = getelementptr inbounds %struct.io* %108, i64 0, i32 0
  %109 = load %struct.xpvio** %sv_any376, align 8, !tbaa !63
  %xio_page_len = getelementptr inbounds %struct.xpvio* %109, i64 0, i32 12
  %110 = load i64* %xio_page_len, align 8, !tbaa !71
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %110) #4
  br label %sw.epilog

sw.bb378:                                         ; preds = %entry
  %111 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any379 = getelementptr inbounds %struct.gv* %111, i64 0, i32 0
  %112 = load %struct.xpvgv** %sv_any379, align 8, !tbaa !57
  %xgv_gp380 = getelementptr inbounds %struct.xpvgv* %112, i64 0, i32 7
  %113 = load %struct.gp** %xgv_gp380, align 8, !tbaa !59
  %gp_io381 = getelementptr inbounds %struct.gp* %113, i64 0, i32 2
  %114 = load %struct.io** %gp_io381, align 8, !tbaa !61
  %tobool382 = icmp eq %struct.io* %114, null
  br i1 %tobool382, label %sw.epilog, label %if.then383

if.then383:                                       ; preds = %sw.bb378
  %sv_any387 = getelementptr inbounds %struct.io* %114, i64 0, i32 0
  %115 = load %struct.xpvio** %sv_any387, align 8, !tbaa !63
  %xio_lines_left = getelementptr inbounds %struct.xpvio* %115, i64 0, i32 13
  %116 = load i64* %xio_lines_left, align 8, !tbaa !72
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %116) #4
  br label %sw.epilog

sw.bb389:                                         ; preds = %entry
  %117 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any390 = getelementptr inbounds %struct.gv* %117, i64 0, i32 0
  %118 = load %struct.xpvgv** %sv_any390, align 8, !tbaa !57
  %xgv_gp391 = getelementptr inbounds %struct.xpvgv* %118, i64 0, i32 7
  %119 = load %struct.gp** %xgv_gp391, align 8, !tbaa !59
  %gp_io392 = getelementptr inbounds %struct.gp* %119, i64 0, i32 2
  %120 = load %struct.io** %gp_io392, align 8, !tbaa !61
  %tobool393 = icmp eq %struct.io* %120, null
  br i1 %tobool393, label %sw.epilog, label %if.then394

if.then394:                                       ; preds = %sw.bb389
  %sv_any398 = getelementptr inbounds %struct.io* %120, i64 0, i32 0
  %121 = load %struct.xpvio** %sv_any398, align 8, !tbaa !63
  %xio_page = getelementptr inbounds %struct.xpvio* %121, i64 0, i32 11
  %122 = load i64* %xio_page, align 8, !tbaa !73
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %122) #4
  br label %sw.epilog

sw.bb400:                                         ; preds = %entry
  %123 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_arybase = getelementptr inbounds %struct.cop* %123, i64 0, i32 12
  %124 = load i64* %cop_arybase, align 8, !tbaa !74
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %124) #4
  br label %sw.epilog

sw.bb401:                                         ; preds = %entry
  %125 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any402 = getelementptr inbounds %struct.gv* %125, i64 0, i32 0
  %126 = load %struct.xpvgv** %sv_any402, align 8, !tbaa !57
  %xgv_gp403 = getelementptr inbounds %struct.xpvgv* %126, i64 0, i32 7
  %127 = load %struct.gp** %xgv_gp403, align 8, !tbaa !59
  %gp_io404 = getelementptr inbounds %struct.gp* %127, i64 0, i32 2
  %128 = load %struct.io** %gp_io404, align 8, !tbaa !61
  %tobool405 = icmp eq %struct.io* %128, null
  br i1 %tobool405, label %sw.epilog, label %if.then406

if.then406:                                       ; preds = %sw.bb401
  %sv_any410 = getelementptr inbounds %struct.io* %128, i64 0, i32 0
  %129 = load %struct.xpvio** %sv_any410, align 8, !tbaa !63
  %xio_flags = getelementptr inbounds %struct.xpvio* %129, i64 0, i32 22
  %130 = load i8* %xio_flags, align 1, !tbaa !75
  %and412 = lshr i8 %130, 2
  %and412.lobit = and i8 %and412, 1
  %conv416 = zext i8 %and412.lobit to i64
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %conv416) #4
  br label %sw.epilog

sw.bb418:                                         ; preds = %entry
  %131 = load %struct.sv** @PL_ors_sv, align 8, !tbaa !16
  %tobool419 = icmp eq %struct.sv* %131, null
  br i1 %tobool419, label %sw.epilog, label %if.then420

if.then420:                                       ; preds = %sw.bb418
  tail call void @Perl_sv_copypv(%struct.sv* %sv, %struct.sv* %131) #4
  br label %sw.epilog

sw.bb422:                                         ; preds = %entry
  %132 = load i8** @PL_ofmt, align 8, !tbaa !16
  tail call void @Perl_sv_setpv(%struct.sv* %sv, i8* %132) #4
  br label %sw.epilog

sw.bb423:                                         ; preds = %entry
  %call425 = tail call i32* @__errno_location() #4
  %133 = load i32* %call425, align 4, !tbaa !54
  %call426 = tail call i32* @__errno_location() #4
  %134 = load i32* %call426, align 4, !tbaa !54
  %conv427 = sitofp i32 %134 to double
  tail call void @Perl_sv_setnv(%struct.sv* %sv, double %conv427) #4
  %call428 = tail call i32* @__errno_location() #4
  %135 = load i32* %call428, align 4, !tbaa !54
  %tobool429 = icmp eq i32 %135, 0
  br i1 %tobool429, label %cond.end434, label %cond.true430

cond.true430:                                     ; preds = %sw.bb423
  %call431 = tail call i32* @__errno_location() #4
  %136 = load i32* %call431, align 4, !tbaa !54
  %call432 = tail call i8* @strerror(i32 %136) #4
  br label %cond.end434

cond.end434:                                      ; preds = %sw.bb423, %cond.true430
  %cond435 = phi i8* [ %call432, %cond.true430 ], [ getelementptr inbounds ([1 x i8]* @.str2, i64 0, i64 0), %sw.bb423 ]
  tail call void @Perl_sv_setpv(%struct.sv* %sv, i8* %cond435) #4
  %call436 = tail call i32* @__errno_location() #4
  store i32 %133, i32* %call436, align 4, !tbaa !54
  %sv_flags437 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %137 = load i64* %sv_flags437, align 8, !tbaa !13
  %or438 = or i64 %137, 33685504
  store i64 %or438, i64* %sv_flags437, align 8, !tbaa !13
  br label %sw.epilog

sw.bb439:                                         ; preds = %entry
  %138 = load i32* @PL_uid, align 4, !tbaa !54
  %conv440 = zext i32 %138 to i64
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %conv440) #4
  br label %sw.epilog

sw.bb441:                                         ; preds = %entry
  %139 = load i32* @PL_euid, align 4, !tbaa !54
  %conv442 = zext i32 %139 to i64
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %conv442) #4
  br label %sw.epilog

sw.bb443:                                         ; preds = %entry
  %140 = load i32* @PL_gid, align 4, !tbaa !54
  %conv444 = zext i32 %140 to i64
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %conv444) #4
  br label %add_groups

sw.bb445:                                         ; preds = %entry
  %141 = load i32* @PL_egid, align 4, !tbaa !54
  %conv446 = zext i32 %141 to i64
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %conv446) #4
  br label %add_groups

add_groups:                                       ; preds = %sw.bb445, %sw.bb443
  %sv_flags447 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %142 = load i64* %sv_flags447, align 8, !tbaa !13
  %and448 = and i64 %142, 2097152
  %tobool449 = icmp eq i64 %and448, 0
  br i1 %tobool449, label %land.end453, label %land.rhs450

land.rhs450:                                      ; preds = %add_groups
  %call451 = tail call i32 @Perl_sv_backoff(%struct.sv* %sv) #4
  %.pre575 = load i64* %sv_flags447, align 8, !tbaa !13
  br label %land.end453

land.end453:                                      ; preds = %add_groups, %land.rhs450
  %143 = phi i64 [ %142, %add_groups ], [ %.pre575, %land.rhs450 ]
  %or456 = or i64 %143, 16842752
  store i64 %or456, i64* %sv_flags447, align 8, !tbaa !13
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end195, %land.rhs, %if.then58, %if.else, %if.then33, %if.else37, %if.else82, %if.else106, %if.else126, %if.then174, %if.end213, %cond.true302, %land.lhs.true299, %sw.bb292, %sw.bb367, %sw.bb378, %sw.bb389, %sw.bb401, %sw.bb418, %if.then420, %if.then406, %if.then394, %if.then383, %if.then372, %if.then326, %if.else327, %if.then307, %land.lhs.true294, %if.then224, %if.then217, %if.then120, %if.end150, %if.then105, %if.then110, %if.then81, %cond.end96, %sw.bb49, %if.then68, %if.else71, %if.then35, %if.then43, %if.else44, %if.then24, %if.else25, %cond.end, %if.then18, %entry, %land.end453, %sw.bb441, %sw.bb439, %cond.end434, %sw.bb422, %sw.bb400, %if.end366, %sw.bb313, %if.end291, %if.end268, %if.end250, %if.end240, %if.end230, %sw.bb48, %sw.bb21, %sw.bb20, %sw.bb3, %sw.bb1, %sw.bb
  ret i32 0
}

declare void @Perl_sv_setsv_flags(%struct.sv*, %struct.sv*, i64) #1

declare i32* @__errno_location() #1

declare void @Perl_sv_setnv(%struct.sv*, double) #1

declare void @Perl_sv_setpv(%struct.sv*, i8*) #1

declare i8* @strerror(i32) #1

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8* nocapture, i8* nocapture) #3

declare void @Perl_sv_untaint(%struct.sv*) #1

declare void @Perl_sv_setuv(%struct.sv*, i64) #1

declare void @Perl_sv_setpvn(%struct.sv*, i8*, i64) #1

declare %struct.hv* @Perl_get_hv(i8*, i64) #1

declare %struct.sv** @Perl_hv_fetch(%struct.hv*, i8*, i64, i64) #1

declare void @Perl_sv_taint(%struct.sv*) #1

declare void @Perl_sv_catpv(%struct.sv*, i8*) #1

declare void @Perl_sv_copypv(%struct.sv*, %struct.sv*) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_getuvar(%struct.sv* %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %mg_ptr = getelementptr inbounds %struct.magic* %mg, i64 0, i32 6
  %0 = load i8** %mg_ptr, align 8, !tbaa !39
  %tobool = icmp eq i8* %0, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %uf_val = bitcast i8* %0 to i64 (i64, %struct.sv*)**
  %1 = load i64 (i64, %struct.sv*)** %uf_val, align 8, !tbaa !76
  %tobool1 = icmp eq i64 (i64, %struct.sv*)* %1, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %uf_index = getelementptr inbounds i8* %0, i64 16
  %2 = bitcast i8* %uf_index to i64*
  %3 = load i64* %2, align 8, !tbaa !78
  %call = tail call i64 %1(i64 %3, %struct.sv* %sv) #4
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry, %if.then
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setenv(%struct.sv* %sv, %struct.magic* nocapture %mg) #0 {
entry:
  %len = alloca i64, align 8
  %klen = alloca i64, align 8
  %tmpbuf = alloca [256 x i8], align 16
  %st = alloca %struct.stat, align 8
  %i = alloca i64, align 8
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %0, 262144
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %1 = load i8** %sv_any, align 8, !tbaa !1
  %xpv_cur = getelementptr inbounds i8* %1, i64 8
  %2 = bitcast i8* %xpv_cur to i64*
  %3 = load i64* %2, align 8, !tbaa !30
  store i64 %3, i64* %len, align 8, !tbaa !25
  %xpv_pv = bitcast i8* %1 to i8**
  %4 = load i8** %xpv_pv, align 8, !tbaa !32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %sv, i64* %len, i64 2) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %4, %cond.true ], [ %call, %cond.false ]
  %mg_len = getelementptr inbounds %struct.magic* %mg, i64 0, i32 7
  %5 = load i64* %mg_len, align 8, !tbaa !40
  store i64 %5, i64* %klen, align 8, !tbaa !25
  %conv = trunc i64 %5 to i32
  %cmp2 = icmp eq i32 %conv, -2
  %mg_ptr = getelementptr inbounds %struct.magic* %mg, i64 0, i32 6
  %6 = load i8** %mg_ptr, align 8, !tbaa !39
  br i1 %cmp2, label %cond.true4, label %cond.end23

cond.true4:                                       ; preds = %cond.end
  %sv_flags5 = getelementptr inbounds i8* %6, i64 16
  %7 = bitcast i8* %sv_flags5 to i64*
  %8 = load i64* %7, align 8, !tbaa !13
  %and6 = and i64 %8, 262144
  %cmp7 = icmp eq i64 %and6, 0
  br i1 %cmp7, label %cond.false16, label %cond.true9

cond.true9:                                       ; preds = %cond.true4
  %sv_any11 = bitcast i8* %6 to i8**
  %9 = load i8** %sv_any11, align 8, !tbaa !1
  %xpv_cur12 = getelementptr inbounds i8* %9, i64 8
  %10 = bitcast i8* %xpv_cur12 to i64*
  %11 = load i64* %10, align 8, !tbaa !30
  store i64 %11, i64* %klen, align 8, !tbaa !25
  %xpv_pv15 = bitcast i8* %9 to i8**
  %12 = load i8** %xpv_pv15, align 8, !tbaa !32
  br label %cond.end23

cond.false16:                                     ; preds = %cond.true4
  %13 = bitcast i8* %6 to %struct.sv*
  %call18 = call i8* @Perl_sv_2pv_flags(%struct.sv* %13, i64* %klen, i64 2) #4
  br label %cond.end23

cond.end23:                                       ; preds = %cond.end, %cond.true9, %cond.false16
  %cond24 = phi i8* [ %12, %cond.true9 ], [ %call18, %cond.false16 ], [ %6, %cond.end ]
  call void @Perl_my_setenv(i8* %cond24, i8* %cond) #4
  %14 = load i8* @PL_tainting, align 1, !tbaa !50
  %tobool = icmp eq i8 %14, 0
  br i1 %tobool, label %return, label %if.then

if.then:                                          ; preds = %cond.end23
  %mg_flags = getelementptr inbounds %struct.magic* %mg, i64 0, i32 4
  %15 = load i8* %mg_flags, align 1, !tbaa !12
  %and26 = and i8 %15, -2
  store i8 %and26, i8* %mg_flags, align 1, !tbaa !12
  %tobool28 = icmp ne i8* %cond, null
  %16 = load i64* %klen, align 8
  %cmp29 = icmp eq i64 %16, 4
  %or.cond = and i1 %tobool28, %cmp29
  br i1 %or.cond, label %land.lhs.true31, label %return

land.lhs.true31:                                  ; preds = %if.then
  %call32 = call i32 @strcmp(i8* %cond24, i8* getelementptr inbounds ([5 x i8]* @.str14, i64 0, i64 0)) #4
  %tobool33 = icmp eq i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %return

if.then34:                                        ; preds = %land.lhs.true31
  %17 = load i64* %len, align 8, !tbaa !25
  %add.ptr = getelementptr inbounds i8* %cond, i64 %17
  %cmp3578 = icmp sgt i64 %17, 0
  br i1 %cmp3578, label %while.body.lr.ph, label %return

while.body.lr.ph:                                 ; preds = %if.then34
  %18 = getelementptr inbounds [256 x i8]* %tmpbuf, i64 0, i64 0
  %19 = bitcast %struct.stat* %st to i8*
  %add.ptr38 = getelementptr inbounds [256 x i8]* %tmpbuf, i64 0, i64 256
  %st_mode = getelementptr inbounds %struct.stat* %st, i64 0, i32 3
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.cond.backedge
  %s.079 = phi i8* [ %cond, %while.body.lr.ph ], [ %incdec.ptr, %while.cond.backedge ]
  call void @llvm.lifetime.start(i64 256, i8* %18) #4
  call void @llvm.lifetime.start(i64 144, i8* %19) #4
  %call39 = call i8* @Perl_delimcpy(i8* %18, i8* %add.ptr38, i8* %s.079, i8* %add.ptr, i32 58, i64* %i) #4
  %incdec.ptr = getelementptr inbounds i8* %call39, i64 1
  %20 = load i64* %i, align 8, !tbaa !25
  %cmp40 = icmp ult i64 %20, 256
  %21 = load i8* %18, align 16
  %cmp44 = icmp eq i8 %21, 47
  %or.cond76 = and i1 %cmp40, %cmp44
  br i1 %or.cond76, label %lor.lhs.false46, label %if.then54

lor.lhs.false46:                                  ; preds = %while.body
  %call48 = call i32 @stat(i8* %18, %struct.stat* %st) #4
  %cmp49 = icmp eq i32 %call48, 0
  br i1 %cmp49, label %land.lhs.true51, label %while.cond.backedge

while.cond.backedge:                              ; preds = %lor.lhs.false46, %land.lhs.true51
  %cmp35 = icmp ult i8* %incdec.ptr, %add.ptr
  br i1 %cmp35, label %while.body, label %return

land.lhs.true51:                                  ; preds = %lor.lhs.false46
  %22 = load i32* %st_mode, align 8, !tbaa !79
  %and52 = and i32 %22, 2
  %tobool53 = icmp eq i32 %and52, 0
  br i1 %tobool53, label %while.cond.backedge, label %if.then54

if.then54:                                        ; preds = %while.body, %land.lhs.true51
  %23 = load i8* %mg_flags, align 1, !tbaa !12
  %or = or i8 %23, 1
  store i8 %or, i8* %mg_flags, align 1, !tbaa !12
  call void @llvm.lifetime.end(i64 144, i8* %19) #4
  call void @llvm.lifetime.end(i64 256, i8* %18) #4
  br label %return

return:                                           ; preds = %while.cond.backedge, %if.then34, %if.then, %cond.end23, %land.lhs.true31, %if.then54
  ret i32 0
}

declare void @Perl_my_setenv(i8*, i8*) #1

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #4

declare i8* @Perl_delimcpy(i8*, i8*, i8*, i8*, i32, i64*) #1

; Function Attrs: nounwind
declare i32 @stat(i8* nocapture readonly, %struct.stat* nocapture) #5

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #4

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_clearenv(%struct.sv* nocapture readnone %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %n_a = alloca i64, align 8
  %mg_len = getelementptr inbounds %struct.magic* %mg, i64 0, i32 7
  %0 = load i64* %mg_len, align 8, !tbaa !40
  store i64 %0, i64* %n_a, align 8, !tbaa !25
  %conv = trunc i64 %0 to i32
  %cmp = icmp eq i32 %conv, -2
  %mg_ptr = getelementptr inbounds %struct.magic* %mg, i64 0, i32 6
  %1 = load i8** %mg_ptr, align 8, !tbaa !39
  br i1 %cmp, label %cond.true, label %cond.end11

cond.true:                                        ; preds = %entry
  %sv_flags = getelementptr inbounds i8* %1, i64 16
  %2 = bitcast i8* %sv_flags to i64*
  %3 = load i64* %2, align 8, !tbaa !13
  %and = and i64 %3, 262144
  %cmp2 = icmp eq i64 %and, 0
  br i1 %cmp2, label %cond.false, label %cond.true4

cond.true4:                                       ; preds = %cond.true
  %sv_any = bitcast i8* %1 to i8**
  %4 = load i8** %sv_any, align 8, !tbaa !1
  %xpv_cur = getelementptr inbounds i8* %4, i64 8
  %5 = bitcast i8* %xpv_cur to i64*
  %6 = load i64* %5, align 8, !tbaa !30
  store i64 %6, i64* %n_a, align 8, !tbaa !25
  %xpv_pv = bitcast i8* %4 to i8**
  %7 = load i8** %xpv_pv, align 8, !tbaa !32
  br label %cond.end11

cond.false:                                       ; preds = %cond.true
  %8 = bitcast i8* %1 to %struct.sv*
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %8, i64* %n_a, i64 2) #4
  br label %cond.end11

cond.end11:                                       ; preds = %entry, %cond.true4, %cond.false
  %cond12 = phi i8* [ %7, %cond.true4 ], [ %call, %cond.false ], [ %1, %entry ]
  call void @Perl_my_setenv(i8* %cond12, i8* null) #4
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_set_all_env(%struct.sv* %sv, %struct.magic* %mg) #0 {
entry:
  %n_a = alloca i64, align 8
  %keylen = alloca i64, align 8
  %0 = load i32* @PL_localizing, align 4, !tbaa !54
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 (%struct.sv*, %struct.magic*, ...)* bitcast (i32 (...)* @magic_clear_all_env to i32 (%struct.sv*, %struct.magic*, ...)*)(%struct.sv* %sv, %struct.magic* %mg) #4
  %1 = bitcast %struct.sv* %sv to %struct.hv*
  %call2 = call i64 @Perl_hv_iterinit(%struct.hv* %1) #4
  %call320 = call %struct.he* @Perl_hv_iternext(%struct.hv* %1) #4
  %tobool421 = icmp eq %struct.he* %call320, null
  br i1 %tobool421, label %if.end, label %while.body

while.body:                                       ; preds = %if.then, %cond.end
  %call322 = phi %struct.he* [ %call3, %cond.end ], [ %call320, %if.then ]
  %call5 = call i8* @Perl_hv_iterkey(%struct.he* %call322, i64* %keylen) #4
  %call6 = call %struct.sv* @Perl_hv_iterval(%struct.hv* %1, %struct.he* %call322) #4
  %sv_flags = getelementptr inbounds %struct.sv* %call6, i64 0, i32 2
  %2 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %2, 262144
  %cmp = icmp eq i64 %and, 0
  %call7 = call %struct.sv* @Perl_hv_iterval(%struct.hv* %1, %struct.he* %call322) #4
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %while.body
  %sv_any = getelementptr inbounds %struct.sv* %call7, i64 0, i32 0
  %3 = load i8** %sv_any, align 8, !tbaa !1
  %xpv_cur = getelementptr inbounds i8* %3, i64 8
  %4 = bitcast i8* %xpv_cur to i64*
  %5 = load i64* %4, align 8, !tbaa !30
  store i64 %5, i64* %n_a, align 8, !tbaa !25
  %call8 = call %struct.sv* @Perl_hv_iterval(%struct.hv* %1, %struct.he* %call322) #4
  %sv_any9 = getelementptr inbounds %struct.sv* %call8, i64 0, i32 0
  %6 = load i8** %sv_any9, align 8, !tbaa !1
  %xpv_pv = bitcast i8* %6 to i8**
  %7 = load i8** %xpv_pv, align 8, !tbaa !32
  br label %cond.end

cond.false:                                       ; preds = %while.body
  %call11 = call i8* @Perl_sv_2pv_flags(%struct.sv* %call7, i64* %n_a, i64 2) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %7, %cond.true ], [ %call11, %cond.false ]
  call void @Perl_my_setenv(i8* %call5, i8* %cond) #4
  %call3 = call %struct.he* @Perl_hv_iternext(%struct.hv* %1) #4
  %tobool4 = icmp eq %struct.he* %call3, null
  br i1 %tobool4, label %if.end, label %while.body

if.end:                                           ; preds = %cond.end, %if.then, %entry
  ret i32 0
}

declare i32 @magic_clear_all_env(...) #1

declare i64 @Perl_hv_iterinit(%struct.hv*) #1

declare %struct.he* @Perl_hv_iternext(%struct.hv*) #1

declare i8* @Perl_hv_iterkey(%struct.he*, i64*) #1

declare %struct.sv* @Perl_hv_iterval(%struct.hv*, %struct.he*) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_clear_all_env(%struct.sv* nocapture readnone %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %0 = load i32* @PL_use_safe_putenv, align 4, !tbaa !54
  %tobool = icmp eq i32 %0, 0
  %1 = load i8*** @environ, align 8, !tbaa !16
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %2 = load i8*** @PL_origenviron, align 8, !tbaa !16
  %cmp = icmp eq i8** %1, %2
  br i1 %cmp, label %if.then1, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.then
  %3 = load i8** %1, align 8, !tbaa !16
  %tobool28 = icmp eq i8* %3, null
  br i1 %tobool28, label %if.end4, label %for.body

if.then1:                                         ; preds = %if.then
  %call = tail call i8* @Perl_safesysmalloc(i64 8) #4
  %4 = bitcast i8* %call to i8**
  store i8** %4, i8*** @environ, align 8, !tbaa !16
  br label %if.end4

for.body:                                         ; preds = %for.cond.preheader, %for.body
  %5 = phi i8* [ %7, %for.body ], [ %3, %for.cond.preheader ]
  %i.09 = phi i64 [ %inc, %for.body ], [ 0, %for.cond.preheader ]
  tail call void @Perl_safesysfree(i8* %5) #4
  %inc = add nsw i64 %i.09, 1
  %6 = load i8*** @environ, align 8, !tbaa !16
  %arrayidx = getelementptr inbounds i8** %6, i64 %inc
  %7 = load i8** %arrayidx, align 8, !tbaa !16
  %tobool2 = icmp eq i8* %7, null
  br i1 %tobool2, label %if.end4, label %for.body

if.end4:                                          ; preds = %for.body, %entry, %for.cond.preheader, %if.then1
  %8 = phi i8** [ %4, %if.then1 ], [ %1, %for.cond.preheader ], [ %1, %entry ], [ %6, %for.body ]
  store i8* null, i8** %8, align 8, !tbaa !16
  ret i32 0
}

declare i8* @Perl_safesysmalloc(i64) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_getsig(%struct.sv* %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %n_a = alloca i64, align 8
  %mg_len = getelementptr inbounds %struct.magic* %mg, i64 0, i32 7
  %0 = load i64* %mg_len, align 8, !tbaa !40
  store i64 %0, i64* %n_a, align 8, !tbaa !25
  %conv = trunc i64 %0 to i32
  %cmp = icmp eq i32 %conv, -2
  %mg_ptr = getelementptr inbounds %struct.magic* %mg, i64 0, i32 6
  %1 = load i8** %mg_ptr, align 8, !tbaa !39
  br i1 %cmp, label %cond.true, label %cond.end11

cond.true:                                        ; preds = %entry
  %sv_flags = getelementptr inbounds i8* %1, i64 16
  %2 = bitcast i8* %sv_flags to i64*
  %3 = load i64* %2, align 8, !tbaa !13
  %and = and i64 %3, 262144
  %cmp2 = icmp eq i64 %and, 0
  br i1 %cmp2, label %cond.false, label %cond.true4

cond.true4:                                       ; preds = %cond.true
  %sv_any = bitcast i8* %1 to i8**
  %4 = load i8** %sv_any, align 8, !tbaa !1
  %xpv_cur = getelementptr inbounds i8* %4, i64 8
  %5 = bitcast i8* %xpv_cur to i64*
  %6 = load i64* %5, align 8, !tbaa !30
  store i64 %6, i64* %n_a, align 8, !tbaa !25
  %xpv_pv = bitcast i8* %4 to i8**
  %7 = load i8** %xpv_pv, align 8, !tbaa !32
  br label %cond.end11

cond.false:                                       ; preds = %cond.true
  %8 = bitcast i8* %1 to %struct.sv*
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %8, i64* %n_a, i64 2) #4
  br label %cond.end11

cond.end11:                                       ; preds = %entry, %cond.true4, %cond.false
  %cond12 = phi i8* [ %7, %cond.true4 ], [ %call, %cond.false ], [ %1, %entry ]
  %9 = load i8** getelementptr inbounds ([0 x i8*]* @PL_sig_name, i64 0, i64 0), align 8, !tbaa !16
  %tobool9.i = icmp eq i8* %9, null
  br i1 %tobool9.i, label %for.end.i, label %for.body.i

for.cond.i:                                       ; preds = %for.body.i
  %10 = load i8** %incdec.ptr.i, align 8, !tbaa !16
  %tobool.i = icmp eq i8* %10, null
  br i1 %tobool.i, label %for.end.i, label %for.body.i

for.body.i:                                       ; preds = %cond.end11, %for.cond.i
  %11 = phi i8* [ %10, %for.cond.i ], [ %9, %cond.end11 ]
  %sigv.010.i = phi i8** [ %incdec.ptr.i, %for.cond.i ], [ getelementptr inbounds ([0 x i8*]* @PL_sig_name, i64 0, i64 0), %cond.end11 ]
  %call.i = call i32 @strcmp(i8* %cond12, i8* %11) #4
  %tobool1.i = icmp eq i32 %call.i, 0
  %incdec.ptr.i = getelementptr inbounds i8** %sigv.010.i, i64 1
  br i1 %tobool1.i, label %Perl_whichsig.exit, label %for.cond.i

for.end.i:                                        ; preds = %for.cond.i, %cond.end11
  %call2.i = call i32 @strcmp(i8* %cond12, i8* getelementptr inbounds ([4 x i8]* @.str39, i64 0, i64 0)) #4
  %tobool3.i = icmp eq i32 %call2.i, 0
  br i1 %tobool3.i, label %if.then, label %if.end30

Perl_whichsig.exit:                               ; preds = %for.body.i
  %sub.ptr.lhs.cast.i = ptrtoint i8** %sigv.010.i to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, ptrtoint ([0 x i8*]* @PL_sig_name to i64)
  %sub.ptr.div.i = ashr exact i64 %sub.ptr.sub.i, 3
  %arrayidx.i = getelementptr inbounds [0 x i32]* @PL_sig_num, i64 0, i64 %sub.ptr.div.i
  %12 = load i32* %arrayidx.i, align 4, !tbaa !54
  %conv.i = sext i32 %12 to i64
  %cmp14 = icmp sgt i32 %12, 0
  br i1 %cmp14, label %if.then, label %if.end30

if.then:                                          ; preds = %for.end.i, %Perl_whichsig.exit
  %retval.0.i42 = phi i64 [ %conv.i, %Perl_whichsig.exit ], [ 17, %for.end.i ]
  %13 = load %struct.sv*** @PL_psig_ptr, align 8, !tbaa !16
  %arrayidx = getelementptr inbounds %struct.sv** %13, i64 %retval.0.i42
  %14 = load %struct.sv** %arrayidx, align 8, !tbaa !16
  %tobool = icmp eq %struct.sv* %14, null
  br i1 %tobool, label %if.else, label %if.then16

if.then16:                                        ; preds = %if.then
  call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* %14, i64 2) #4
  br label %if.end30

if.else:                                          ; preds = %if.then
  %conv18 = trunc i64 %retval.0.i42 to i32
  %call19 = call void (i32)* (i32)* @Perl_rsignal_state(i32 %conv18) #4
  %cmp20 = icmp eq void (i32)* %call19, inttoptr (i64 1 to void (i32)*)
  br i1 %cmp20, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else
  call void @Perl_sv_setpv(%struct.sv* %sv, i8* getelementptr inbounds ([7 x i8]* @.str15, i64 0, i64 0)) #4
  br label %if.end

if.else23:                                        ; preds = %if.else
  call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* @PL_sv_undef, i64 2) #4
  br label %if.end

if.end:                                           ; preds = %if.else23, %if.then22
  store %struct.sv* %sv, %struct.sv** @PL_Sv, align 8, !tbaa !16
  %tobool24 = icmp eq %struct.sv* %sv, null
  br i1 %tobool24, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end
  %sv_refcnt = getelementptr inbounds %struct.sv* %sv, i64 0, i32 1
  %15 = load i64* %sv_refcnt, align 8, !tbaa !17
  %inc = add i64 %15, 1
  store i64 %inc, i64* %sv_refcnt, align 8, !tbaa !17
  br label %land.end

land.end:                                         ; preds = %if.end, %land.rhs
  %16 = load %struct.sv*** @PL_psig_ptr, align 8, !tbaa !16
  %arrayidx26 = getelementptr inbounds %struct.sv** %16, i64 %retval.0.i42
  store %struct.sv* %sv, %struct.sv** %arrayidx26, align 8, !tbaa !16
  %sv_flags27 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %17 = load i64* %sv_flags27, align 8, !tbaa !13
  %and28 = and i64 %17, -2049
  store i64 %and28, i64* %sv_flags27, align 8, !tbaa !13
  br label %if.end30

if.end30:                                         ; preds = %for.end.i, %if.then16, %land.end, %Perl_whichsig.exit
  ret i32 0
}

; Function Attrs: nounwind readonly uwtable
define i64 @Perl_whichsig(i8* nocapture readonly %sig) #2 {
entry:
  %0 = load i8** getelementptr inbounds ([0 x i8*]* @PL_sig_name, i64 0, i64 0), align 8, !tbaa !16
  %tobool9 = icmp eq i8* %0, null
  br i1 %tobool9, label %for.end, label %for.body

for.cond:                                         ; preds = %for.body
  %1 = load i8** %incdec.ptr, align 8, !tbaa !16
  %tobool = icmp eq i8* %1, null
  br i1 %tobool, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.cond
  %2 = phi i8* [ %1, %for.cond ], [ %0, %entry ]
  %sigv.010 = phi i8** [ %incdec.ptr, %for.cond ], [ getelementptr inbounds ([0 x i8*]* @PL_sig_name, i64 0, i64 0), %entry ]
  %call = tail call i32 @strcmp(i8* %sig, i8* %2) #4
  %tobool1 = icmp eq i32 %call, 0
  %incdec.ptr = getelementptr inbounds i8** %sigv.010, i64 1
  br i1 %tobool1, label %if.then, label %for.cond

if.then:                                          ; preds = %for.body
  %sub.ptr.lhs.cast = ptrtoint i8** %sigv.010 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, ptrtoint ([0 x i8*]* @PL_sig_name to i64)
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %arrayidx = getelementptr inbounds [0 x i32]* @PL_sig_num, i64 0, i64 %sub.ptr.div
  %3 = load i32* %arrayidx, align 4, !tbaa !54
  %conv = sext i32 %3 to i64
  br label %return

for.end:                                          ; preds = %for.cond, %entry
  %call2 = tail call i32 @strcmp(i8* %sig, i8* getelementptr inbounds ([4 x i8]* @.str39, i64 0, i64 0)) #4
  %tobool3 = icmp eq i32 %call2, 0
  %. = select i1 %tobool3, i64 17, i64 -1
  br label %return

return:                                           ; preds = %for.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %., %for.end ]
  ret i64 %retval.0
}

declare void (i32)* @Perl_rsignal_state(i32) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_clearsig(%struct.sv* nocapture readnone %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %n_a = alloca i64, align 8
  %mg_len = getelementptr inbounds %struct.magic* %mg, i64 0, i32 7
  %0 = load i64* %mg_len, align 8, !tbaa !40
  store i64 %0, i64* %n_a, align 8, !tbaa !25
  %conv = trunc i64 %0 to i32
  %cmp = icmp eq i32 %conv, -2
  %mg_ptr = getelementptr inbounds %struct.magic* %mg, i64 0, i32 6
  %1 = load i8** %mg_ptr, align 8, !tbaa !39
  br i1 %cmp, label %cond.true, label %cond.end11

cond.true:                                        ; preds = %entry
  %sv_flags = getelementptr inbounds i8* %1, i64 16
  %2 = bitcast i8* %sv_flags to i64*
  %3 = load i64* %2, align 8, !tbaa !13
  %and = and i64 %3, 262144
  %cmp2 = icmp eq i64 %and, 0
  br i1 %cmp2, label %cond.false, label %cond.true4

cond.true4:                                       ; preds = %cond.true
  %sv_any = bitcast i8* %1 to i8**
  %4 = load i8** %sv_any, align 8, !tbaa !1
  %xpv_cur = getelementptr inbounds i8* %4, i64 8
  %5 = bitcast i8* %xpv_cur to i64*
  %6 = load i64* %5, align 8, !tbaa !30
  store i64 %6, i64* %n_a, align 8, !tbaa !25
  %xpv_pv = bitcast i8* %4 to i8**
  %7 = load i8** %xpv_pv, align 8, !tbaa !32
  br label %cond.end11

cond.false:                                       ; preds = %cond.true
  %8 = bitcast i8* %1 to %struct.sv*
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %8, i64* %n_a, i64 2) #4
  br label %cond.end11

cond.end11:                                       ; preds = %entry, %cond.true4, %cond.false
  %cond12 = phi i8* [ %7, %cond.true4 ], [ %call, %cond.false ], [ %1, %entry ]
  %9 = load i8* %cond12, align 1, !tbaa !50
  %cmp14 = icmp eq i8 %9, 95
  br i1 %cmp14, label %if.then, label %if.else26

if.then:                                          ; preds = %cond.end11
  %call16 = call i32 @strcmp(i8* %cond12, i8* getelementptr inbounds ([8 x i8]* @.str16, i64 0, i64 0)) #4
  %tobool = icmp eq i32 %call16, 0
  br i1 %tobool, label %if.end22, label %if.else

if.else:                                          ; preds = %if.then
  %call18 = call i32 @strcmp(i8* %cond12, i8* getelementptr inbounds ([9 x i8]* @.str17, i64 0, i64 0)) #4
  %tobool19 = icmp eq i32 %call18, 0
  br i1 %tobool19, label %if.end22, label %if.else21

if.else21:                                        ; preds = %if.else
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([17 x i8]* @.str18, i64 0, i64 0), i8* %cond12) #4
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then, %if.else21
  %svp.0 = phi %struct.sv** [ undef, %if.else21 ], [ @PL_diehook, %if.then ], [ @PL_warnhook, %if.else ]
  %10 = load %struct.sv** %svp.0, align 8, !tbaa !16
  %tobool23 = icmp eq %struct.sv* %10, null
  br i1 %tobool23, label %if.end49, label %if.then24

if.then24:                                        ; preds = %if.end22
  store %struct.sv* null, %struct.sv** %svp.0, align 8, !tbaa !16
  call void @Perl_sv_free(%struct.sv* %10) #4
  br label %if.end49

if.else26:                                        ; preds = %cond.end11
  %11 = load i8** getelementptr inbounds ([0 x i8*]* @PL_sig_name, i64 0, i64 0), align 8, !tbaa !16
  %tobool9.i = icmp eq i8* %11, null
  br i1 %tobool9.i, label %for.end.i, label %for.body.i

for.cond.i:                                       ; preds = %for.body.i
  %12 = load i8** %incdec.ptr.i, align 8, !tbaa !16
  %tobool.i = icmp eq i8* %12, null
  br i1 %tobool.i, label %for.end.i, label %for.body.i

for.body.i:                                       ; preds = %if.else26, %for.cond.i
  %13 = phi i8* [ %12, %for.cond.i ], [ %11, %if.else26 ]
  %sigv.010.i = phi i8** [ %incdec.ptr.i, %for.cond.i ], [ getelementptr inbounds ([0 x i8*]* @PL_sig_name, i64 0, i64 0), %if.else26 ]
  %call.i = call i32 @strcmp(i8* %cond12, i8* %13) #4
  %tobool1.i = icmp eq i32 %call.i, 0
  %incdec.ptr.i = getelementptr inbounds i8** %sigv.010.i, i64 1
  br i1 %tobool1.i, label %Perl_whichsig.exit, label %for.cond.i

for.end.i:                                        ; preds = %for.cond.i, %if.else26
  %call2.i = call i32 @strcmp(i8* %cond12, i8* getelementptr inbounds ([4 x i8]* @.str39, i64 0, i64 0)) #4
  %tobool3.i = icmp eq i32 %call2.i, 0
  br i1 %tobool3.i, label %if.then30, label %if.end49

Perl_whichsig.exit:                               ; preds = %for.body.i
  %sub.ptr.lhs.cast.i = ptrtoint i8** %sigv.010.i to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, ptrtoint ([0 x i8*]* @PL_sig_name to i64)
  %sub.ptr.div.i = ashr exact i64 %sub.ptr.sub.i, 3
  %arrayidx.i = getelementptr inbounds [0 x i32]* @PL_sig_num, i64 0, i64 %sub.ptr.div.i
  %14 = load i32* %arrayidx.i, align 4, !tbaa !54
  %conv.i = sext i32 %14 to i64
  %cmp28 = icmp sgt i32 %14, 0
  br i1 %cmp28, label %if.then30, label %if.end49

if.then30:                                        ; preds = %for.end.i, %Perl_whichsig.exit
  %retval.0.i72 = phi i64 [ %conv.i, %Perl_whichsig.exit ], [ 17, %for.end.i ]
  %15 = load i32* @PL_sig_pending, align 4, !tbaa !54
  %tobool31 = icmp eq i32 %15, 0
  br i1 %tobool31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %if.then30
  store i32 0, i32* @PL_sig_pending, align 4, !tbaa !54
  br label %for.body.i68

for.body.i68:                                     ; preds = %for.inc.i, %if.then32
  %indvars.iv.i = phi i64 [ 1, %if.then32 ], [ %indvars.iv.next.i, %for.inc.i ]
  %16 = load i32** @PL_psig_pend, align 8, !tbaa !16
  %arrayidx.i66 = getelementptr inbounds i32* %16, i64 %indvars.iv.i
  %17 = load i32* %arrayidx.i66, align 4, !tbaa !54
  %tobool.i67 = icmp eq i32 %17, 0
  br i1 %tobool.i67, label %for.inc.i, label %if.then.i69

if.then.i69:                                      ; preds = %for.body.i68
  store i32 0, i32* %arrayidx.i66, align 4, !tbaa !54
  %18 = load void (i32)** @PL_sighandlerp, align 8, !tbaa !16
  %19 = trunc i64 %indvars.iv.i to i32
  call void %18(i32 %19) #4
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then.i69, %for.body.i68
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.i = icmp eq i64 %indvars.iv.next.i, 16
  br i1 %exitcond.i, label %if.end33, label %for.body.i68

if.end33:                                         ; preds = %for.inc.i, %if.then30
  %conv34 = trunc i64 %retval.0.i72 to i32
  %call35 = call void (i32)* (i32, void (i32)*)* @Perl_rsignal(i32 %conv34, void (i32)* null) #4
  %20 = load %struct.sv*** @PL_psig_name, align 8, !tbaa !16
  %arrayidx = getelementptr inbounds %struct.sv** %20, i64 %retval.0.i72
  %21 = load %struct.sv** %arrayidx, align 8, !tbaa !16
  %tobool36 = icmp eq %struct.sv* %21, null
  br i1 %tobool36, label %if.end40, label %if.then37

if.then37:                                        ; preds = %if.end33
  call void @Perl_sv_free(%struct.sv* %21) #4
  %22 = load %struct.sv*** @PL_psig_name, align 8, !tbaa !16
  %arrayidx39 = getelementptr inbounds %struct.sv** %22, i64 %retval.0.i72
  store %struct.sv* null, %struct.sv** %arrayidx39, align 8, !tbaa !16
  br label %if.end40

if.end40:                                         ; preds = %if.end33, %if.then37
  %23 = load %struct.sv*** @PL_psig_ptr, align 8, !tbaa !16
  %arrayidx41 = getelementptr inbounds %struct.sv** %23, i64 %retval.0.i72
  %24 = load %struct.sv** %arrayidx41, align 8, !tbaa !16
  %tobool42 = icmp eq %struct.sv* %24, null
  br i1 %tobool42, label %if.else46, label %if.then43

if.then43:                                        ; preds = %if.end40
  store %struct.sv* null, %struct.sv** %arrayidx41, align 8, !tbaa !16
  call void @Perl_pop_scope() #4
  call void @Perl_sv_free(%struct.sv* %24) #4
  br label %if.end49

if.else46:                                        ; preds = %if.end40
  call void @Perl_pop_scope() #4
  br label %if.end49

if.end49:                                         ; preds = %for.end.i, %if.end22, %Perl_whichsig.exit, %if.else46, %if.then43, %if.then24
  ret i32 0
}

; Function Attrs: nounwind uwtable
define void @Perl_despatch_signals() #0 {
entry:
  store i32 0, i32* @PL_sig_pending, align 4, !tbaa !54
  br label %for.body

for.body:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ 1, %entry ], [ %indvars.iv.next, %for.inc ]
  %0 = load i32** @PL_psig_pend, align 8, !tbaa !16
  %arrayidx = getelementptr inbounds i32* %0, i64 %indvars.iv
  %1 = load i32* %arrayidx, align 4, !tbaa !54
  %tobool = icmp eq i32 %1, 0
  br i1 %tobool, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  store i32 0, i32* %arrayidx, align 4, !tbaa !54
  %2 = load void (i32)** @PL_sighandlerp, align 8, !tbaa !16
  %3 = trunc i64 %indvars.iv to i32
  tail call void %2(i32 %3) #4
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 16
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc
  ret void
}

declare void (i32)* @Perl_rsignal(i32, void (i32)*) #1

declare void @Perl_pop_scope() #1

; Function Attrs: nounwind uwtable
define void @Perl_raise_signal(i32 %sig) #0 {
entry:
  %idxprom = sext i32 %sig to i64
  %0 = load i32** @PL_psig_pend, align 8, !tbaa !16
  %arrayidx = getelementptr inbounds i32* %0, i64 %idxprom
  %1 = load i32* %arrayidx, align 4, !tbaa !54
  %inc = add nsw i32 %1, 1
  store i32 %inc, i32* %arrayidx, align 4, !tbaa !54
  store i32 1, i32* @PL_sig_pending, align 4, !tbaa !54
  ret void
}

; Function Attrs: nounwind uwtable
define void @Perl_csighandler(i32 %sig) #0 {
entry:
  %0 = load i64* @PL_signals, align 8, !tbaa !25
  %and = and i64 %0, 1
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %1 = load void (i32)** @PL_sighandlerp, align 8, !tbaa !16
  tail call void %1(i32 %sig) #4
  br label %if.end

if.else:                                          ; preds = %entry
  %idxprom.i = sext i32 %sig to i64
  %2 = load i32** @PL_psig_pend, align 8, !tbaa !16
  %arrayidx.i = getelementptr inbounds i32* %2, i64 %idxprom.i
  %3 = load i32* %arrayidx.i, align 4, !tbaa !54
  %inc.i = add nsw i32 %3, 1
  store i32 %inc.i, i32* %arrayidx.i, align 4, !tbaa !54
  store i32 1, i32* @PL_sig_pending, align 4, !tbaa !54
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setsig(%struct.sv* %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %len = alloca i64, align 8
  %mg_len = getelementptr inbounds %struct.magic* %mg, i64 0, i32 7
  %0 = load i64* %mg_len, align 8, !tbaa !40
  store i64 %0, i64* %len, align 8, !tbaa !25
  %conv = trunc i64 %0 to i32
  %cmp = icmp eq i32 %conv, -2
  %mg_ptr = getelementptr inbounds %struct.magic* %mg, i64 0, i32 6
  %1 = load i8** %mg_ptr, align 8, !tbaa !39
  br i1 %cmp, label %cond.true, label %cond.end11

cond.true:                                        ; preds = %entry
  %sv_flags = getelementptr inbounds i8* %1, i64 16
  %2 = bitcast i8* %sv_flags to i64*
  %3 = load i64* %2, align 8, !tbaa !13
  %and = and i64 %3, 262144
  %cmp2 = icmp eq i64 %and, 0
  br i1 %cmp2, label %cond.false, label %cond.true4

cond.true4:                                       ; preds = %cond.true
  %sv_any = bitcast i8* %1 to i8**
  %4 = load i8** %sv_any, align 8, !tbaa !1
  %xpv_cur = getelementptr inbounds i8* %4, i64 8
  %5 = bitcast i8* %xpv_cur to i64*
  %6 = load i64* %5, align 8, !tbaa !30
  store i64 %6, i64* %len, align 8, !tbaa !25
  %xpv_pv = bitcast i8* %4 to i8**
  %7 = load i8** %xpv_pv, align 8, !tbaa !32
  br label %cond.end11

cond.false:                                       ; preds = %cond.true
  %8 = bitcast i8* %1 to %struct.sv*
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %8, i64* %len, i64 2) #4
  br label %cond.end11

cond.end11:                                       ; preds = %entry, %cond.true4, %cond.false
  %cond12 = phi i8* [ %7, %cond.true4 ], [ %call, %cond.false ], [ %1, %entry ]
  %9 = load i8* %cond12, align 1, !tbaa !50
  %cmp14 = icmp eq i8 %9, 95
  br i1 %cmp14, label %if.then, label %if.else26

if.then:                                          ; preds = %cond.end11
  %call16 = call i32 @strcmp(i8* %cond12, i8* getelementptr inbounds ([8 x i8]* @.str16, i64 0, i64 0)) #4
  %tobool = icmp eq i32 %call16, 0
  br i1 %tobool, label %if.end22, label %if.else

if.else:                                          ; preds = %if.then
  %call18 = call i32 @strcmp(i8* %cond12, i8* getelementptr inbounds ([9 x i8]* @.str17, i64 0, i64 0)) #4
  %tobool19 = icmp eq i32 %call18, 0
  br i1 %tobool19, label %if.end22, label %if.else21

if.else21:                                        ; preds = %if.else
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([17 x i8]* @.str18, i64 0, i64 0), i8* %cond12) #4
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then, %if.else21
  %svp.0 = phi %struct.sv** [ null, %if.else21 ], [ @PL_diehook, %if.then ], [ @PL_warnhook, %if.else ]
  %10 = load %struct.sv** %svp.0, align 8, !tbaa !16
  %tobool23 = icmp eq %struct.sv* %10, null
  br i1 %tobool23, label %if.end71, label %if.then24

if.then24:                                        ; preds = %if.end22
  store %struct.sv* null, %struct.sv** %svp.0, align 8, !tbaa !16
  br label %if.end71

if.else26:                                        ; preds = %cond.end11
  %11 = load i8** getelementptr inbounds ([0 x i8*]* @PL_sig_name, i64 0, i64 0), align 8, !tbaa !16
  %tobool9.i = icmp eq i8* %11, null
  br i1 %tobool9.i, label %for.end.i, label %for.body.i

for.cond.i:                                       ; preds = %for.body.i
  %12 = load i8** %incdec.ptr.i, align 8, !tbaa !16
  %tobool.i = icmp eq i8* %12, null
  br i1 %tobool.i, label %for.end.i, label %for.body.i

for.body.i:                                       ; preds = %if.else26, %for.cond.i
  %13 = phi i8* [ %12, %for.cond.i ], [ %11, %if.else26 ]
  %sigv.010.i = phi i8** [ %incdec.ptr.i, %for.cond.i ], [ getelementptr inbounds ([0 x i8*]* @PL_sig_name, i64 0, i64 0), %if.else26 ]
  %call.i = call i32 @strcmp(i8* %cond12, i8* %13) #4
  %tobool1.i = icmp eq i32 %call.i, 0
  %incdec.ptr.i = getelementptr inbounds i8** %sigv.010.i, i64 1
  br i1 %tobool1.i, label %Perl_whichsig.exit, label %for.cond.i

for.end.i:                                        ; preds = %for.cond.i, %if.else26
  %call2.i = call i32 @strcmp(i8* %cond12, i8* getelementptr inbounds ([4 x i8]* @.str39, i64 0, i64 0)) #4
  %tobool3.i = icmp eq i32 %call2.i, 0
  br i1 %tobool3.i, label %if.end56, label %if.then30

Perl_whichsig.exit:                               ; preds = %for.body.i
  %sub.ptr.lhs.cast.i = ptrtoint i8** %sigv.010.i to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, ptrtoint ([0 x i8*]* @PL_sig_name to i64)
  %sub.ptr.div.i = ashr exact i64 %sub.ptr.sub.i, 3
  %arrayidx.i = getelementptr inbounds [0 x i32]* @PL_sig_num, i64 0, i64 %sub.ptr.div.i
  %14 = load i32* %arrayidx.i, align 4, !tbaa !54
  %conv.i = sext i32 %14 to i64
  %cmp28 = icmp slt i32 %14, 0
  br i1 %cmp28, label %if.then30, label %if.end56

if.then30:                                        ; preds = %for.end.i, %Perl_whichsig.exit
  %15 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings = getelementptr inbounds %struct.cop* %15, i64 0, i32 14
  %16 = load %struct.sv** %cop_warnings, align 8, !tbaa !51
  %cmp31 = icmp eq %struct.sv* %16, null
  br i1 %cmp31, label %lor.lhs.false46, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then30
  %17 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings33 = getelementptr inbounds %struct.cop* %17, i64 0, i32 14
  %18 = load %struct.sv** %cop_warnings33, align 8, !tbaa !51
  %cmp34 = icmp eq %struct.sv* %18, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp34, label %lor.lhs.false46, label %land.lhs.true36

land.lhs.true36:                                  ; preds = %land.lhs.true
  %19 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings37 = getelementptr inbounds %struct.cop* %19, i64 0, i32 14
  %20 = load %struct.sv** %cop_warnings37, align 8, !tbaa !51
  %cmp38 = icmp eq %struct.sv* %20, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp38, label %if.then54, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true36
  %21 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings40 = getelementptr inbounds %struct.cop* %21, i64 0, i32 14
  %22 = load %struct.sv** %cop_warnings40, align 8, !tbaa !51
  %sv_any41 = getelementptr inbounds %struct.sv* %22, i64 0, i32 0
  %23 = load i8** %sv_any41, align 8, !tbaa !1
  %xpv_pv42 = bitcast i8* %23 to i8**
  %24 = load i8** %xpv_pv42, align 8, !tbaa !32
  %arrayidx = getelementptr inbounds i8* %24, i64 6
  %25 = load i8* %arrayidx, align 1, !tbaa !50
  %and44 = and i8 %25, 16
  %tobool45 = icmp eq i8 %and44, 0
  br i1 %tobool45, label %lor.lhs.false46, label %if.then54

lor.lhs.false46:                                  ; preds = %lor.lhs.false, %land.lhs.true, %if.then30
  %26 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings47 = getelementptr inbounds %struct.cop* %26, i64 0, i32 14
  %27 = load %struct.sv** %cop_warnings47, align 8, !tbaa !51
  %cmp48 = icmp eq %struct.sv* %27, null
  br i1 %cmp48, label %land.lhs.true50, label %return

land.lhs.true50:                                  ; preds = %lor.lhs.false46
  %28 = load i8* @PL_dowarn, align 1, !tbaa !50
  %and52 = and i8 %28, 1
  %tobool53 = icmp eq i8 %and52, 0
  br i1 %tobool53, label %return, label %if.then54

if.then54:                                        ; preds = %lor.lhs.false, %land.lhs.true50, %land.lhs.true36
  call void (i64, i8*, ...)* @Perl_warner(i64 26, i8* getelementptr inbounds ([22 x i8]* @.str19, i64 0, i64 0), i8* %cond12) #4
  br label %return

if.end56:                                         ; preds = %for.end.i, %Perl_whichsig.exit
  %retval.0.i207 = phi i64 [ %conv.i, %Perl_whichsig.exit ], [ 17, %for.end.i ]
  %29 = load i32* @PL_sig_pending, align 4, !tbaa !54
  %tobool57 = icmp eq i32 %29, 0
  br i1 %tobool57, label %if.end59, label %if.then58

if.then58:                                        ; preds = %if.end56
  store i32 0, i32* @PL_sig_pending, align 4, !tbaa !54
  br label %for.body.i201

for.body.i201:                                    ; preds = %for.inc.i, %if.then58
  %indvars.iv.i = phi i64 [ 1, %if.then58 ], [ %indvars.iv.next.i, %for.inc.i ]
  %30 = load i32** @PL_psig_pend, align 8, !tbaa !16
  %arrayidx.i199 = getelementptr inbounds i32* %30, i64 %indvars.iv.i
  %31 = load i32* %arrayidx.i199, align 4, !tbaa !54
  %tobool.i200 = icmp eq i32 %31, 0
  br i1 %tobool.i200, label %for.inc.i, label %if.then.i202

if.then.i202:                                     ; preds = %for.body.i201
  store i32 0, i32* %arrayidx.i199, align 4, !tbaa !54
  %32 = load void (i32)** @PL_sighandlerp, align 8, !tbaa !16
  %33 = trunc i64 %indvars.iv.i to i32
  call void %32(i32 %33) #4
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then.i202, %for.body.i201
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.i = icmp eq i64 %indvars.iv.next.i, 16
  br i1 %exitcond.i, label %if.end59, label %for.body.i201

if.end59:                                         ; preds = %for.inc.i, %if.end56
  %34 = load %struct.sv*** @PL_psig_name, align 8, !tbaa !16
  %arrayidx60 = getelementptr inbounds %struct.sv** %34, i64 %retval.0.i207
  %35 = load %struct.sv** %arrayidx60, align 8, !tbaa !16
  call void @Perl_sv_free(%struct.sv* %35) #4
  %36 = load %struct.sv*** @PL_psig_ptr, align 8, !tbaa !16
  %arrayidx61 = getelementptr inbounds %struct.sv** %36, i64 %retval.0.i207
  %37 = load %struct.sv** %arrayidx61, align 8, !tbaa !16
  store %struct.sv* %sv, %struct.sv** @PL_Sv, align 8, !tbaa !16
  %tobool62 = icmp eq %struct.sv* %sv, null
  br i1 %tobool62, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end59
  %sv_refcnt = getelementptr inbounds %struct.sv* %sv, i64 0, i32 1
  %38 = load i64* %sv_refcnt, align 8, !tbaa !17
  %inc = add i64 %38, 1
  store i64 %inc, i64* %sv_refcnt, align 8, !tbaa !17
  br label %land.end

land.end:                                         ; preds = %if.end59, %land.rhs
  store %struct.sv* %sv, %struct.sv** %arrayidx61, align 8, !tbaa !16
  %sv_flags65 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %39 = load i64* %sv_flags65, align 8, !tbaa !13
  %and66 = and i64 %39, -2049
  store i64 %and66, i64* %sv_flags65, align 8, !tbaa !13
  %40 = load i64* %len, align 8, !tbaa !25
  %call67 = call %struct.sv* @Perl_newSVpvn(i8* %cond12, i64 %40) #4
  %41 = load %struct.sv*** @PL_psig_name, align 8, !tbaa !16
  %arrayidx68 = getelementptr inbounds %struct.sv** %41, i64 %retval.0.i207
  store %struct.sv* %call67, %struct.sv** %arrayidx68, align 8, !tbaa !16
  %42 = load %struct.sv*** @PL_psig_name, align 8, !tbaa !16
  %arrayidx69 = getelementptr inbounds %struct.sv** %42, i64 %retval.0.i207
  %43 = load %struct.sv** %arrayidx69, align 8, !tbaa !16
  %sv_flags70 = getelementptr inbounds %struct.sv* %43, i64 0, i32 2
  %44 = load i64* %sv_flags70, align 8, !tbaa !13
  %or = or i64 %44, 8388608
  store i64 %or, i64* %sv_flags70, align 8, !tbaa !13
  br label %if.end71

if.end71:                                         ; preds = %if.end22, %if.then24, %land.end
  %i.0 = phi i64 [ 0, %if.then24 ], [ 0, %if.end22 ], [ %retval.0.i207, %land.end ]
  %svp.1 = phi %struct.sv** [ %svp.0, %if.then24 ], [ %svp.0, %if.end22 ], [ null, %land.end ]
  %to_dec.0 = phi %struct.sv* [ %10, %if.then24 ], [ null, %if.end22 ], [ %37, %land.end ]
  %sv_flags72 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %45 = load i64* %sv_flags72, align 8, !tbaa !13
  %and73 = and i64 %45, 255
  %cmp74 = icmp ne i64 %and73, 13
  %and78 = and i64 %45, 524288
  %tobool79 = icmp eq i64 %and78, 0
  %or.cond = and i1 %cmp74, %tobool79
  br i1 %or.cond, label %if.end97, label %if.then80

if.then80:                                        ; preds = %if.end71
  %tobool81 = icmp eq i64 %i.0, 0
  br i1 %tobool81, label %if.else85, label %if.then82

if.then82:                                        ; preds = %if.then80
  %conv83 = trunc i64 %i.0 to i32
  %46 = load void (i32)** @PL_csighandlerp, align 8, !tbaa !16
  %call84 = call void (i32)* (i32, void (i32)*)* @Perl_rsignal(i32 %conv83, void (i32)* %46) #4
  br label %if.end93

if.else85:                                        ; preds = %if.then80
  store %struct.sv* %sv, %struct.sv** @PL_Sv, align 8, !tbaa !16
  %tobool86 = icmp eq %struct.sv* %sv, null
  br i1 %tobool86, label %land.end91, label %land.rhs87

land.rhs87:                                       ; preds = %if.else85
  %sv_refcnt88 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 1
  %47 = load i64* %sv_refcnt88, align 8, !tbaa !17
  %inc89 = add i64 %47, 1
  store i64 %inc89, i64* %sv_refcnt88, align 8, !tbaa !17
  br label %land.end91

land.end91:                                       ; preds = %if.else85, %land.rhs87
  store %struct.sv* %sv, %struct.sv** %svp.1, align 8, !tbaa !16
  br label %if.end93

if.end93:                                         ; preds = %land.end91, %if.then82
  %tobool94 = icmp eq %struct.sv* %to_dec.0, null
  br i1 %tobool94, label %return, label %if.then95

if.then95:                                        ; preds = %if.end93
  call void @Perl_sv_free(%struct.sv* %to_dec.0) #4
  br label %return

if.end97:                                         ; preds = %if.end71
  %and99 = and i64 %45, 10223616
  %cmp100 = icmp eq i64 %and99, 262144
  br i1 %cmp100, label %cond.true102, label %cond.false107

cond.true102:                                     ; preds = %if.end97
  %sv_any103 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %48 = load i8** %sv_any103, align 8, !tbaa !1
  %xpv_cur104 = getelementptr inbounds i8* %48, i64 8
  %49 = bitcast i8* %xpv_cur104 to i64*
  %50 = load i64* %49, align 8, !tbaa !30
  store i64 %50, i64* %len, align 8, !tbaa !25
  %xpv_pv106 = bitcast i8* %48 to i8**
  %51 = load i8** %xpv_pv106, align 8, !tbaa !32
  br label %cond.end109

cond.false107:                                    ; preds = %if.end97
  %call108 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %sv, i64* %len, i64 2) #4
  br label %cond.end109

cond.end109:                                      ; preds = %cond.false107, %cond.true102
  %cond110 = phi i8* [ %51, %cond.true102 ], [ %call108, %cond.false107 ]
  %call111 = call i32 @strcmp(i8* %cond110, i8* getelementptr inbounds ([7 x i8]* @.str15, i64 0, i64 0)) #4
  %tobool112 = icmp eq i32 %call111, 0
  br i1 %tobool112, label %if.then113, label %if.else119

if.then113:                                       ; preds = %cond.end109
  %tobool114 = icmp eq i64 %i.0, 0
  br i1 %tobool114, label %if.end152, label %if.then115

if.then115:                                       ; preds = %if.then113
  %conv116 = trunc i64 %i.0 to i32
  %call117 = call void (i32)* (i32, void (i32)*)* @Perl_rsignal(i32 %conv116, void (i32)* inttoptr (i64 1 to void (i32)*)) #4
  br label %if.end152

if.else119:                                       ; preds = %cond.end109
  %call120 = call i32 @strcmp(i8* %cond110, i8* getelementptr inbounds ([8 x i8]* @.str20, i64 0, i64 0)) #4
  %tobool121 = icmp eq i32 %call120, 0
  br i1 %tobool121, label %if.then124, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %if.else119
  %52 = load i8* %cond110, align 1, !tbaa !50
  %tobool123 = icmp eq i8 %52, 0
  br i1 %tobool123, label %if.then124, label %if.else130

if.then124:                                       ; preds = %lor.lhs.false122, %if.else119
  %tobool125 = icmp eq i64 %i.0, 0
  br i1 %tobool125, label %if.end152, label %if.then126

if.then126:                                       ; preds = %if.then124
  %conv127 = trunc i64 %i.0 to i32
  %call128 = call void (i32)* (i32, void (i32)*)* @Perl_rsignal(i32 %conv127, void (i32)* null) #4
  br label %if.end152

if.else130:                                       ; preds = %lor.lhs.false122
  %call131 = call i8* @strchr(i8* %cond110, i32 58) #4
  %tobool132 = icmp eq i8* %call131, null
  br i1 %tobool132, label %land.lhs.true133, label %if.end137

land.lhs.true133:                                 ; preds = %if.else130
  %call134 = call i8* @strchr(i8* %cond110, i32 39) #4
  %tobool135 = icmp eq i8* %call134, null
  br i1 %tobool135, label %if.then136, label %if.end137

if.then136:                                       ; preds = %land.lhs.true133
  call void @Perl_sv_insert(%struct.sv* %sv, i64 0, i64 0, i8* getelementptr inbounds ([7 x i8]* @.str21, i64 0, i64 0), i64 6) #4
  br label %if.end137

if.end137:                                        ; preds = %land.lhs.true133, %if.else130, %if.then136
  %tobool138 = icmp eq i64 %i.0, 0
  br i1 %tobool138, label %if.else142, label %if.then139

if.then139:                                       ; preds = %if.end137
  %conv140 = trunc i64 %i.0 to i32
  %53 = load void (i32)** @PL_csighandlerp, align 8, !tbaa !16
  %call141 = call void (i32)* (i32, void (i32)*)* @Perl_rsignal(i32 %conv140, void (i32)* %53) #4
  br label %if.end152

if.else142:                                       ; preds = %if.end137
  store %struct.sv* %sv, %struct.sv** @PL_Sv, align 8, !tbaa !16
  %tobool143 = icmp eq %struct.sv* %sv, null
  br i1 %tobool143, label %land.end148, label %land.rhs144

land.rhs144:                                      ; preds = %if.else142
  %sv_refcnt145 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 1
  %54 = load i64* %sv_refcnt145, align 8, !tbaa !17
  %inc146 = add i64 %54, 1
  store i64 %inc146, i64* %sv_refcnt145, align 8, !tbaa !17
  br label %land.end148

land.end148:                                      ; preds = %if.else142, %land.rhs144
  store %struct.sv* %sv, %struct.sv** %svp.1, align 8, !tbaa !16
  br label %if.end152

if.end152:                                        ; preds = %if.then124, %if.then113, %if.then126, %land.end148, %if.then139, %if.then115
  %tobool153 = icmp eq %struct.sv* %to_dec.0, null
  br i1 %tobool153, label %return, label %if.then154

if.then154:                                       ; preds = %if.end152
  call void @Perl_sv_free(%struct.sv* %to_dec.0) #4
  br label %return

return:                                           ; preds = %if.then154, %if.end152, %if.then95, %if.end93, %lor.lhs.false46, %if.then54, %land.lhs.true50
  ret i32 0
}

declare void @Perl_warner(i64, i8*, ...) #1

declare %struct.sv* @Perl_newSVpvn(i8*, i64) #1

declare i8* @Perl_sv_pvn_force_flags(%struct.sv*, i64*, i64) #1

; Function Attrs: nounwind readonly
declare i8* @strchr(i8*, i32) #3

declare void @Perl_sv_insert(%struct.sv*, i64, i64, i8*, i64) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setisa(%struct.sv* nocapture readnone %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %0 = load i64* @PL_sub_generation, align 8, !tbaa !25
  %inc = add i64 %0, 1
  store i64 %inc, i64* @PL_sub_generation, align 8, !tbaa !25
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setamagic(%struct.sv* nocapture readnone %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %0 = load i64* @PL_amagic_generation, align 8, !tbaa !25
  %inc = add nsw i64 %0, 1
  store i64 %inc, i64* @PL_amagic_generation, align 8, !tbaa !25
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_getnkeys(%struct.sv* %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targ = getelementptr inbounds i8* %0, i64 72
  %1 = bitcast i8* %xlv_targ to %struct.sv**
  %2 = load %struct.sv** %1, align 8, !tbaa !82
  %3 = bitcast %struct.sv* %2 to %struct.hv*
  %tobool = icmp eq %struct.sv* %2, null
  br i1 %tobool, label %if.end9, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i64 @Perl_hv_iterinit(%struct.hv* %3) #4
  %sv_flags = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %4 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %4, 32768
  %tobool1 = icmp eq i64 %and, 0
  br i1 %tobool1, label %if.then.if.then4_crit_edge, label %if.end.i

if.then.if.then4_crit_edge:                       ; preds = %if.then
  %sv_any5.phi.trans.insert = bitcast %struct.sv* %2 to %struct.xpvhv**
  %.pre = load %struct.xpvhv** %sv_any5.phi.trans.insert, align 8, !tbaa !84
  br label %if.then4

if.end.i:                                         ; preds = %if.then
  %sv_any.i = getelementptr inbounds %struct.sv* %2, i64 0, i32 0
  %5 = load i8** %sv_any.i, align 8, !tbaa !1
  %xmg_magic.i = getelementptr inbounds i8* %5, i64 40
  %6 = bitcast i8* %xmg_magic.i to %struct.magic**
  %mg.08.i = load %struct.magic** %6, align 8
  %tobool19.i = icmp eq %struct.magic* %mg.08.i, null
  %7 = bitcast i8* %5 to %struct.xpvhv*
  br i1 %tobool19.i, label %if.then4, label %for.body.i

for.cond.i:                                       ; preds = %for.body.i
  %mg_moremagic.i = getelementptr inbounds %struct.magic* %mg.010.i, i64 0, i32 0
  %mg.0.i = load %struct.magic** %mg_moremagic.i, align 8
  %tobool1.i = icmp eq %struct.magic* %mg.0.i, null
  br i1 %tobool1.i, label %if.then4, label %for.body.i

for.body.i:                                       ; preds = %if.end.i, %for.cond.i
  %mg.010.i = phi %struct.magic* [ %mg.0.i, %for.cond.i ], [ %mg.08.i, %if.end.i ]
  %mg_type.i = getelementptr inbounds %struct.magic* %mg.010.i, i64 0, i32 3
  %8 = load i8* %mg_type.i, align 1, !tbaa !35
  %cmp.i = icmp eq i8 %8, 80
  br i1 %cmp.i, label %while.cond, label %for.cond.i

if.then4:                                         ; preds = %for.cond.i, %if.then.if.then4_crit_edge, %if.end.i
  %9 = phi %struct.xpvhv* [ %.pre, %if.then.if.then4_crit_edge ], [ %7, %if.end.i ], [ %7, %for.cond.i ]
  %xhv_keys = getelementptr inbounds %struct.xpvhv* %9, i64 0, i32 3
  %10 = load i64* %xhv_keys, align 8, !tbaa !86
  %xnv_nv = getelementptr inbounds %struct.xpvhv* %9, i64 0, i32 4
  %11 = load double* %xnv_nv, align 8, !tbaa !88
  %conv = fptosi double %11 to i64
  %sub = sub nsw i64 %10, %conv
  br label %if.end9

while.cond:                                       ; preds = %for.body.i, %while.cond
  %i.0 = phi i64 [ %inc, %while.cond ], [ 0, %for.body.i ]
  %call7 = tail call %struct.he* @Perl_hv_iternext(%struct.hv* %3) #4
  %tobool8 = icmp eq %struct.he* %call7, null
  %inc = add nsw i64 %i.0, 1
  br i1 %tobool8, label %if.end9, label %while.cond

if.end9:                                          ; preds = %while.cond, %entry, %if.then4
  %i.1 = phi i64 [ %sub, %if.then4 ], [ 0, %entry ], [ %i.0, %while.cond ]
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %i.1) #4
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setnkeys(%struct.sv* %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targ = getelementptr inbounds i8* %0, i64 72
  %1 = bitcast i8* %xlv_targ to %struct.sv**
  %2 = load %struct.sv** %1, align 8, !tbaa !82
  %tobool = icmp eq %struct.sv* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = bitcast %struct.sv* %2 to %struct.hv*
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %4 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %4, 65536
  %tobool3 = icmp eq i64 %and, 0
  br i1 %tobool3, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %xiv_iv = getelementptr inbounds i8* %0, i64 24
  %5 = bitcast i8* %xiv_iv to i64*
  %6 = load i64* %5, align 8, !tbaa !89
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %call = tail call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %6, %cond.true ], [ %call, %cond.false ]
  tail call void @Perl_hv_ksplit(%struct.hv* %3, i64 %cond) #4
  br label %if.end

if.end:                                           ; preds = %entry, %cond.end
  ret i32 0
}

declare void @Perl_hv_ksplit(%struct.hv*, i64) #1

declare i64 @Perl_sv_2iv(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_getpack(%struct.sv* %sv, %struct.magic* %mg) #0 {
entry:
  %mg_ptr = getelementptr inbounds %struct.magic* %mg, i64 0, i32 6
  %0 = load i8** %mg_ptr, align 8, !tbaa !39
  %tobool = icmp eq i8* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %mg_flags = getelementptr inbounds %struct.magic* %mg, i64 0, i32 4
  %1 = load i8* %mg_flags, align 1, !tbaa !12
  %or = or i8 %1, 4
  store i8 %or, i8* %mg_flags, align 1, !tbaa !12
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %call = tail call i32 (%struct.sv*, %struct.magic*, i8*, ...)* bitcast (i32 (...)* @magic_methpack to i32 (%struct.sv*, %struct.magic*, i8*, ...)*)(%struct.sv* %sv, %struct.magic* %mg, i8* getelementptr inbounds ([6 x i8]* @.str22, i64 0, i64 0)) #4
  ret i32 0
}

declare i32 @magic_methpack(...) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setpack(%struct.sv* %sv, %struct.magic* %mg) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  tail call void @Perl_push_scope() #4
  %1 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_next = getelementptr inbounds %struct.stackinfo* %1, i64 0, i32 6
  %2 = load %struct.stackinfo** %si_next, align 8, !tbaa !91
  %tobool = icmp eq %struct.stackinfo* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.stackinfo* @Perl_new_stackinfo(i64 32, i64 12) #4
  %3 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_prev = getelementptr inbounds %struct.stackinfo* %call, i64 0, i32 5
  store %struct.stackinfo* %3, %struct.stackinfo** %si_prev, align 8, !tbaa !93
  %4 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_next1 = getelementptr inbounds %struct.stackinfo* %4, i64 0, i32 6
  store %struct.stackinfo* %call, %struct.stackinfo** %si_next1, align 8, !tbaa !91
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %next.0 = phi %struct.stackinfo* [ %2, %entry ], [ %call, %if.then ]
  %si_type = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 4
  store i64 2, i64* %si_type, align 8, !tbaa !94
  %si_cxix = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !95
  %si_stack = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 0
  %5 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any = getelementptr inbounds %struct.av* %5, i64 0, i32 0
  %6 = load %struct.xpvav** %sv_any, align 8, !tbaa !97
  %xav_fill = getelementptr inbounds %struct.xpvav* %6, i64 0, i32 1
  store i64 0, i64* %xav_fill, align 8, !tbaa !33
  %7 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %7 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %8 = load %struct.av** @PL_curstack, align 8, !tbaa !16
  %sv_any2 = getelementptr inbounds %struct.av* %8, i64 0, i32 0
  %9 = load %struct.xpvav** %sv_any2, align 8, !tbaa !97
  %xav_fill3 = getelementptr inbounds %struct.xpvav* %9, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill3, align 8, !tbaa !33
  %xav_array = getelementptr inbounds %struct.xpvav* %6, i64 0, i32 0
  %10 = load i8** %xav_array, align 8, !tbaa !99
  %11 = bitcast i8* %10 to %struct.sv**
  store %struct.sv** %11, %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %12 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any7 = getelementptr inbounds %struct.av* %12, i64 0, i32 0
  %13 = load %struct.xpvav** %sv_any7, align 8, !tbaa !97
  %xav_max = getelementptr inbounds %struct.xpvav* %13, i64 0, i32 2
  %14 = load i64* %xav_max, align 8, !tbaa !100
  %add.ptr = getelementptr inbounds %struct.sv** %11, i64 %14
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  %15 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any9 = getelementptr inbounds %struct.av* %15, i64 0, i32 0
  %16 = load %struct.xpvav** %sv_any9, align 8, !tbaa !97
  %xav_fill10 = getelementptr inbounds %struct.xpvav* %16, i64 0, i32 1
  %17 = load i64* %xav_fill10, align 8, !tbaa !33
  %add.ptr11 = getelementptr inbounds %struct.sv** %11, i64 %17
  store %struct.sv** %add.ptr11, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %18 = load %struct.av** %si_stack, align 8, !tbaa !96
  store %struct.av* %18, %struct.av** @PL_curstack, align 8, !tbaa !16
  store %struct.stackinfo* %next.0, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %call13 = tail call i32 (%struct.sv*, %struct.magic*, i8*, i32, i32, %struct.sv*, ...)* bitcast (i32 (...)* @magic_methcall to i32 (%struct.sv*, %struct.magic*, i8*, i32, i32, %struct.sv*, ...)*)(%struct.sv* %sv, %struct.magic* %mg, i8* getelementptr inbounds ([6 x i8]* @.str23, i64 0, i64 0), i32 2, i32 3, %struct.sv* %sv) #4
  %19 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %20 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_prev17 = getelementptr inbounds %struct.stackinfo* %20, i64 0, i32 5
  %21 = load %struct.stackinfo** %si_prev17, align 8, !tbaa !93
  %tobool18 = icmp eq %struct.stackinfo* %21, null
  br i1 %tobool18, label %if.then19, label %if.end37

if.then19:                                        ; preds = %if.end
  %22 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !16
  %tobool20 = icmp eq %struct.gv* %22, null
  br i1 %tobool20, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then19
  %sv_flags = getelementptr inbounds %struct.gv* %22, i64 0, i32 2
  %23 = load i64* %sv_flags, align 8, !tbaa !101
  %and = and i64 %23, 255
  %cmp = icmp eq i64 %and, 13
  br i1 %cmp, label %land.lhs.true21, label %cond.false

land.lhs.true21:                                  ; preds = %land.lhs.true
  %sv_any22 = getelementptr inbounds %struct.gv* %22, i64 0, i32 0
  %24 = load %struct.xpvgv** %sv_any22, align 8, !tbaa !57
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %24, i64 0, i32 7
  %25 = load %struct.gp** %xgv_gp, align 8, !tbaa !59
  %gp_io = getelementptr inbounds %struct.gp* %25, i64 0, i32 2
  %26 = load %struct.io** %gp_io, align 8, !tbaa !61
  %tobool23 = icmp eq %struct.io* %26, null
  br i1 %tobool23, label %cond.false, label %land.lhs.true24

land.lhs.true24:                                  ; preds = %land.lhs.true21
  %sv_any28 = getelementptr inbounds %struct.io* %26, i64 0, i32 0
  %27 = load %struct.xpvio** %sv_any28, align 8, !tbaa !63
  %xio_ofp = getelementptr inbounds %struct.xpvio* %27, i64 0, i32 8
  %28 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !102
  %tobool29 = icmp eq %struct._PerlIO** %28, null
  br i1 %tobool29, label %cond.false, label %cond.end

cond.false:                                       ; preds = %land.lhs.true24, %land.lhs.true21, %if.then19, %land.lhs.true
  %call35 = tail call %struct._PerlIO** @Perl_PerlIO_stderr() #4
  br label %cond.end

cond.end:                                         ; preds = %land.lhs.true24, %cond.false
  %cond = phi %struct._PerlIO** [ %call35, %cond.false ], [ %28, %land.lhs.true24 ]
  %call36 = tail call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond, i8* getelementptr inbounds ([17 x i8]* @.str24, i64 0, i64 0)) #4
  tail call void @Perl_my_exit(i64 1) #4
  br label %if.end37

if.end37:                                         ; preds = %if.end, %cond.end
  %29 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %sub.ptr.lhs.cast38 = ptrtoint %struct.sv** %19 to i64
  %sub.ptr.rhs.cast39 = ptrtoint %struct.sv** %29 to i64
  %sub.ptr.sub40 = sub i64 %sub.ptr.lhs.cast38, %sub.ptr.rhs.cast39
  %sub.ptr.div41 = ashr exact i64 %sub.ptr.sub40, 3
  %30 = load %struct.av** @PL_curstack, align 8, !tbaa !16
  %sv_any42 = getelementptr inbounds %struct.av* %30, i64 0, i32 0
  %31 = load %struct.xpvav** %sv_any42, align 8, !tbaa !97
  %xav_fill43 = getelementptr inbounds %struct.xpvav* %31, i64 0, i32 1
  store i64 %sub.ptr.div41, i64* %xav_fill43, align 8, !tbaa !33
  %si_stack44 = getelementptr inbounds %struct.stackinfo* %21, i64 0, i32 0
  %32 = load %struct.av** %si_stack44, align 8, !tbaa !96
  %sv_any45 = getelementptr inbounds %struct.av* %32, i64 0, i32 0
  %33 = load %struct.xpvav** %sv_any45, align 8, !tbaa !97
  %xav_array46 = getelementptr inbounds %struct.xpvav* %33, i64 0, i32 0
  %34 = load i8** %xav_array46, align 8, !tbaa !99
  %35 = bitcast i8* %34 to %struct.sv**
  store %struct.sv** %35, %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %36 = load %struct.av** %si_stack44, align 8, !tbaa !96
  %sv_any48 = getelementptr inbounds %struct.av* %36, i64 0, i32 0
  %37 = load %struct.xpvav** %sv_any48, align 8, !tbaa !97
  %xav_max49 = getelementptr inbounds %struct.xpvav* %37, i64 0, i32 2
  %38 = load i64* %xav_max49, align 8, !tbaa !100
  %add.ptr50 = getelementptr inbounds %struct.sv** %35, i64 %38
  store %struct.sv** %add.ptr50, %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  %39 = load %struct.av** %si_stack44, align 8, !tbaa !96
  %sv_any52 = getelementptr inbounds %struct.av* %39, i64 0, i32 0
  %40 = load %struct.xpvav** %sv_any52, align 8, !tbaa !97
  %xav_fill53 = getelementptr inbounds %struct.xpvav* %40, i64 0, i32 1
  %41 = load i64* %xav_fill53, align 8, !tbaa !33
  %add.ptr54 = getelementptr inbounds %struct.sv** %35, i64 %41
  store %struct.sv** %add.ptr54, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %42 = load %struct.av** %si_stack44, align 8, !tbaa !96
  store %struct.av* %42, %struct.av** @PL_curstack, align 8, !tbaa !16
  store %struct.stackinfo* %21, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  tail call void @Perl_pop_scope() #4
  ret i32 0
}

declare void @Perl_push_scope() #1

declare %struct.stackinfo* @Perl_new_stackinfo(i64, i64) #1

declare i32 @magic_methcall(...) #1

declare i32 @PerlIO_printf(%struct._PerlIO**, i8*, ...) #1

declare %struct._PerlIO** @Perl_PerlIO_stderr() #1

declare void @Perl_my_exit(i64) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_clearpack(%struct.sv* %sv, %struct.magic* %mg) #0 {
entry:
  %call = tail call i32 (%struct.sv*, %struct.magic*, i8*, ...)* bitcast (i32 (...)* @magic_methpack to i32 (%struct.sv*, %struct.magic*, i8*, ...)*)(%struct.sv* %sv, %struct.magic* %mg, i8* getelementptr inbounds ([7 x i8]* @.str25, i64 0, i64 0)) #4
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i64 @Perl_magic_sizepack(%struct.sv* %sv, %struct.magic* %mg) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  tail call void @Perl_push_scope() #4
  tail call void @Perl_save_int(i32* bitcast (i64* @PL_tmps_floor to i32*)) #4
  %1 = load i64* @PL_tmps_ix, align 8, !tbaa !25
  store i64 %1, i64* @PL_tmps_floor, align 8, !tbaa !25
  %2 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_next = getelementptr inbounds %struct.stackinfo* %2, i64 0, i32 6
  %3 = load %struct.stackinfo** %si_next, align 8, !tbaa !91
  %tobool = icmp eq %struct.stackinfo* %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.stackinfo* @Perl_new_stackinfo(i64 32, i64 12) #4
  %4 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_prev = getelementptr inbounds %struct.stackinfo* %call, i64 0, i32 5
  store %struct.stackinfo* %4, %struct.stackinfo** %si_prev, align 8, !tbaa !93
  %5 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_next2 = getelementptr inbounds %struct.stackinfo* %5, i64 0, i32 6
  store %struct.stackinfo* %call, %struct.stackinfo** %si_next2, align 8, !tbaa !91
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %next.0 = phi %struct.stackinfo* [ %3, %entry ], [ %call, %if.then ]
  %si_type = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 4
  store i64 2, i64* %si_type, align 8, !tbaa !94
  %si_cxix = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !95
  %si_stack = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 0
  %6 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any = getelementptr inbounds %struct.av* %6, i64 0, i32 0
  %7 = load %struct.xpvav** %sv_any, align 8, !tbaa !97
  %xav_fill = getelementptr inbounds %struct.xpvav* %7, i64 0, i32 1
  store i64 0, i64* %xav_fill, align 8, !tbaa !33
  %8 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %9 = load %struct.av** @PL_curstack, align 8, !tbaa !16
  %sv_any3 = getelementptr inbounds %struct.av* %9, i64 0, i32 0
  %10 = load %struct.xpvav** %sv_any3, align 8, !tbaa !97
  %xav_fill4 = getelementptr inbounds %struct.xpvav* %10, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill4, align 8, !tbaa !33
  %xav_array = getelementptr inbounds %struct.xpvav* %7, i64 0, i32 0
  %11 = load i8** %xav_array, align 8, !tbaa !99
  %12 = bitcast i8* %11 to %struct.sv**
  store %struct.sv** %12, %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %13 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any8 = getelementptr inbounds %struct.av* %13, i64 0, i32 0
  %14 = load %struct.xpvav** %sv_any8, align 8, !tbaa !97
  %xav_max = getelementptr inbounds %struct.xpvav* %14, i64 0, i32 2
  %15 = load i64* %xav_max, align 8, !tbaa !100
  %add.ptr = getelementptr inbounds %struct.sv** %12, i64 %15
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  %16 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any10 = getelementptr inbounds %struct.av* %16, i64 0, i32 0
  %17 = load %struct.xpvav** %sv_any10, align 8, !tbaa !97
  %xav_fill11 = getelementptr inbounds %struct.xpvav* %17, i64 0, i32 1
  %18 = load i64* %xav_fill11, align 8, !tbaa !33
  %add.ptr12 = getelementptr inbounds %struct.sv** %12, i64 %18
  store %struct.sv** %add.ptr12, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %19 = load %struct.av** %si_stack, align 8, !tbaa !96
  store %struct.av* %19, %struct.av** @PL_curstack, align 8, !tbaa !16
  store %struct.stackinfo* %next.0, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %call14 = tail call i32 (%struct.sv*, %struct.magic*, i8*, i32, i32, i8*, ...)* bitcast (i32 (...)* @magic_methcall to i32 (%struct.sv*, %struct.magic*, i8*, i32, i32, i8*, ...)*)(%struct.sv* %sv, %struct.magic* %mg, i8* getelementptr inbounds ([10 x i8]* @.str26, i64 0, i64 0), i32 0, i32 2, i8* null) #4
  %tobool15 = icmp eq i32 %call14, 0
  br i1 %tobool15, label %if.end20, label %if.then16

if.then16:                                        ; preds = %if.end
  %20 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %incdec.ptr = getelementptr inbounds %struct.sv** %20, i64 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %21 = load %struct.sv** %20, align 8, !tbaa !16
  %sv_flags = getelementptr inbounds %struct.sv* %21, i64 0, i32 2
  %22 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %22, 65536
  %tobool17 = icmp eq i64 %and, 0
  br i1 %tobool17, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then16
  %sv_any18 = getelementptr inbounds %struct.sv* %21, i64 0, i32 0
  %23 = load i8** %sv_any18, align 8, !tbaa !1
  %xiv_iv = getelementptr inbounds i8* %23, i64 24
  %24 = bitcast i8* %xiv_iv to i64*
  %25 = load i64* %24, align 8, !tbaa !89
  br label %cond.end

cond.false:                                       ; preds = %if.then16
  %call19 = tail call i64 @Perl_sv_2iv(%struct.sv* %21) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %25, %cond.true ], [ %call19, %cond.false ]
  %sub = add i64 %cond, -1
  br label %if.end20

if.end20:                                         ; preds = %if.end, %cond.end
  %retval1.0 = phi i64 [ %sub, %cond.end ], [ 0, %if.end ]
  %26 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %27 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_prev24 = getelementptr inbounds %struct.stackinfo* %27, i64 0, i32 5
  %28 = load %struct.stackinfo** %si_prev24, align 8, !tbaa !93
  %tobool25 = icmp eq %struct.stackinfo* %28, null
  br i1 %tobool25, label %if.then26, label %if.end50

if.then26:                                        ; preds = %if.end20
  %29 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !16
  %tobool27 = icmp eq %struct.gv* %29, null
  br i1 %tobool27, label %cond.false45, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then26
  %sv_flags28 = getelementptr inbounds %struct.gv* %29, i64 0, i32 2
  %30 = load i64* %sv_flags28, align 8, !tbaa !101
  %and29 = and i64 %30, 255
  %cmp = icmp eq i64 %and29, 13
  br i1 %cmp, label %land.lhs.true30, label %cond.false45

land.lhs.true30:                                  ; preds = %land.lhs.true
  %sv_any31 = getelementptr inbounds %struct.gv* %29, i64 0, i32 0
  %31 = load %struct.xpvgv** %sv_any31, align 8, !tbaa !57
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %31, i64 0, i32 7
  %32 = load %struct.gp** %xgv_gp, align 8, !tbaa !59
  %gp_io = getelementptr inbounds %struct.gp* %32, i64 0, i32 2
  %33 = load %struct.io** %gp_io, align 8, !tbaa !61
  %tobool32 = icmp eq %struct.io* %33, null
  br i1 %tobool32, label %cond.false45, label %land.lhs.true33

land.lhs.true33:                                  ; preds = %land.lhs.true30
  %sv_any37 = getelementptr inbounds %struct.io* %33, i64 0, i32 0
  %34 = load %struct.xpvio** %sv_any37, align 8, !tbaa !63
  %xio_ofp = getelementptr inbounds %struct.xpvio* %34, i64 0, i32 8
  %35 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !102
  %tobool38 = icmp eq %struct._PerlIO** %35, null
  br i1 %tobool38, label %cond.false45, label %cond.end47

cond.false45:                                     ; preds = %land.lhs.true33, %land.lhs.true30, %if.then26, %land.lhs.true
  %call46 = tail call %struct._PerlIO** @Perl_PerlIO_stderr() #4
  br label %cond.end47

cond.end47:                                       ; preds = %land.lhs.true33, %cond.false45
  %cond48 = phi %struct._PerlIO** [ %call46, %cond.false45 ], [ %35, %land.lhs.true33 ]
  %call49 = tail call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond48, i8* getelementptr inbounds ([17 x i8]* @.str24, i64 0, i64 0)) #4
  tail call void @Perl_my_exit(i64 1) #4
  br label %if.end50

if.end50:                                         ; preds = %if.end20, %cond.end47
  %36 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %sub.ptr.lhs.cast51 = ptrtoint %struct.sv** %26 to i64
  %sub.ptr.rhs.cast52 = ptrtoint %struct.sv** %36 to i64
  %sub.ptr.sub53 = sub i64 %sub.ptr.lhs.cast51, %sub.ptr.rhs.cast52
  %sub.ptr.div54 = ashr exact i64 %sub.ptr.sub53, 3
  %37 = load %struct.av** @PL_curstack, align 8, !tbaa !16
  %sv_any55 = getelementptr inbounds %struct.av* %37, i64 0, i32 0
  %38 = load %struct.xpvav** %sv_any55, align 8, !tbaa !97
  %xav_fill56 = getelementptr inbounds %struct.xpvav* %38, i64 0, i32 1
  store i64 %sub.ptr.div54, i64* %xav_fill56, align 8, !tbaa !33
  %si_stack57 = getelementptr inbounds %struct.stackinfo* %28, i64 0, i32 0
  %39 = load %struct.av** %si_stack57, align 8, !tbaa !96
  %sv_any58 = getelementptr inbounds %struct.av* %39, i64 0, i32 0
  %40 = load %struct.xpvav** %sv_any58, align 8, !tbaa !97
  %xav_array59 = getelementptr inbounds %struct.xpvav* %40, i64 0, i32 0
  %41 = load i8** %xav_array59, align 8, !tbaa !99
  %42 = bitcast i8* %41 to %struct.sv**
  store %struct.sv** %42, %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %43 = load %struct.av** %si_stack57, align 8, !tbaa !96
  %sv_any61 = getelementptr inbounds %struct.av* %43, i64 0, i32 0
  %44 = load %struct.xpvav** %sv_any61, align 8, !tbaa !97
  %xav_max62 = getelementptr inbounds %struct.xpvav* %44, i64 0, i32 2
  %45 = load i64* %xav_max62, align 8, !tbaa !100
  %add.ptr63 = getelementptr inbounds %struct.sv** %42, i64 %45
  store %struct.sv** %add.ptr63, %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  %46 = load %struct.av** %si_stack57, align 8, !tbaa !96
  %sv_any65 = getelementptr inbounds %struct.av* %46, i64 0, i32 0
  %47 = load %struct.xpvav** %sv_any65, align 8, !tbaa !97
  %xav_fill66 = getelementptr inbounds %struct.xpvav* %47, i64 0, i32 1
  %48 = load i64* %xav_fill66, align 8, !tbaa !33
  %add.ptr67 = getelementptr inbounds %struct.sv** %42, i64 %48
  store %struct.sv** %add.ptr67, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %49 = load %struct.av** %si_stack57, align 8, !tbaa !96
  store %struct.av* %49, %struct.av** @PL_curstack, align 8, !tbaa !16
  store %struct.stackinfo* %28, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %50 = load i64* @PL_tmps_ix, align 8, !tbaa !25
  %51 = load i64* @PL_tmps_floor, align 8, !tbaa !25
  %cmp71 = icmp sgt i64 %50, %51
  br i1 %cmp71, label %if.then72, label %if.end73

if.then72:                                        ; preds = %if.end50
  tail call void @Perl_free_tmps() #4
  br label %if.end73

if.end73:                                         ; preds = %if.then72, %if.end50
  tail call void @Perl_pop_scope() #4
  ret i64 %retval1.0
}

declare void @Perl_save_int(i32*) #1

declare void @Perl_free_tmps() #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_wipepack(%struct.sv* %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  tail call void @Perl_push_scope() #4
  %1 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_next = getelementptr inbounds %struct.stackinfo* %1, i64 0, i32 6
  %2 = load %struct.stackinfo** %si_next, align 8, !tbaa !91
  %tobool = icmp eq %struct.stackinfo* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.stackinfo* @Perl_new_stackinfo(i64 32, i64 12) #4
  %3 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_prev = getelementptr inbounds %struct.stackinfo* %call, i64 0, i32 5
  store %struct.stackinfo* %3, %struct.stackinfo** %si_prev, align 8, !tbaa !93
  %4 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_next1 = getelementptr inbounds %struct.stackinfo* %4, i64 0, i32 6
  store %struct.stackinfo* %call, %struct.stackinfo** %si_next1, align 8, !tbaa !91
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %next.0 = phi %struct.stackinfo* [ %2, %entry ], [ %call, %if.then ]
  %si_type = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 4
  store i64 2, i64* %si_type, align 8, !tbaa !94
  %si_cxix = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !95
  %si_stack = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 0
  %5 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any = getelementptr inbounds %struct.av* %5, i64 0, i32 0
  %6 = load %struct.xpvav** %sv_any, align 8, !tbaa !97
  %xav_fill = getelementptr inbounds %struct.xpvav* %6, i64 0, i32 1
  store i64 0, i64* %xav_fill, align 8, !tbaa !33
  %7 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %7 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %8 = load %struct.av** @PL_curstack, align 8, !tbaa !16
  %sv_any2 = getelementptr inbounds %struct.av* %8, i64 0, i32 0
  %9 = load %struct.xpvav** %sv_any2, align 8, !tbaa !97
  %xav_fill3 = getelementptr inbounds %struct.xpvav* %9, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill3, align 8, !tbaa !33
  %xav_array = getelementptr inbounds %struct.xpvav* %6, i64 0, i32 0
  %10 = load i8** %xav_array, align 8, !tbaa !99
  %11 = bitcast i8* %10 to %struct.sv**
  store %struct.sv** %11, %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %12 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any7 = getelementptr inbounds %struct.av* %12, i64 0, i32 0
  %13 = load %struct.xpvav** %sv_any7, align 8, !tbaa !97
  %xav_max = getelementptr inbounds %struct.xpvav* %13, i64 0, i32 2
  %14 = load i64* %xav_max, align 8, !tbaa !100
  %add.ptr = getelementptr inbounds %struct.sv** %11, i64 %14
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  %15 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any9 = getelementptr inbounds %struct.av* %15, i64 0, i32 0
  %16 = load %struct.xpvav** %sv_any9, align 8, !tbaa !97
  %xav_fill10 = getelementptr inbounds %struct.xpvav* %16, i64 0, i32 1
  %17 = load i64* %xav_fill10, align 8, !tbaa !33
  %add.ptr11 = getelementptr inbounds %struct.sv** %11, i64 %17
  store %struct.sv** %add.ptr11, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %18 = load %struct.av** %si_stack, align 8, !tbaa !96
  store %struct.av* %18, %struct.av** @PL_curstack, align 8, !tbaa !16
  store %struct.stackinfo* %next.0, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %19 = load i64** @PL_markstack_ptr, align 8, !tbaa !16
  %incdec.ptr = getelementptr inbounds i64* %19, i64 1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !16
  %20 = load i64** @PL_markstack_max, align 8, !tbaa !16
  %cmp = icmp eq i64* %incdec.ptr, %20
  br i1 %cmp, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end
  tail call void @Perl_markstack_grow() #4
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %.pre106 = load i64** @PL_markstack_ptr, align 8, !tbaa !16
  %.pre107 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end
  %21 = phi %struct.sv** [ %.pre107, %if.then13 ], [ %add.ptr, %if.end ]
  %22 = phi i64* [ %.pre106, %if.then13 ], [ %incdec.ptr, %if.end ]
  %23 = phi %struct.sv** [ %.pre, %if.then13 ], [ %11, %if.end ]
  %sub.ptr.lhs.cast16 = ptrtoint %struct.sv** %add.ptr11 to i64
  %sub.ptr.rhs.cast17 = ptrtoint %struct.sv** %23 to i64
  %sub.ptr.sub18 = sub i64 %sub.ptr.lhs.cast16, %sub.ptr.rhs.cast17
  %sub.ptr.div19 = ashr exact i64 %sub.ptr.sub18, 3
  store i64 %sub.ptr.div19, i64* %22, align 8, !tbaa !25
  %sub.ptr.lhs.cast20 = ptrtoint %struct.sv** %21 to i64
  %sub.ptr.sub22 = sub i64 %sub.ptr.lhs.cast20, %sub.ptr.lhs.cast16
  %cmp24 = icmp slt i64 %sub.ptr.sub22, 8
  br i1 %cmp24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end14
  %call26 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr11, %struct.sv** %add.ptr11, i32 1) #4
  br label %if.end27

if.end27:                                         ; preds = %if.then25, %if.end14
  %sp.0 = phi %struct.sv** [ %call26, %if.then25 ], [ %add.ptr11, %if.end14 ]
  %mg_obj = getelementptr inbounds %struct.magic* %mg, i64 0, i32 5
  %24 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  %tobool29 = icmp eq %struct.sv* %24, null
  br i1 %tobool29, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.end27
  %call31 = tail call %struct.sv* @Perl_newRV(%struct.sv* %sv) #4
  %call32 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call31) #4
  br label %cond.end

cond.end:                                         ; preds = %if.end27, %cond.false
  %cond = phi %struct.sv* [ %call32, %cond.false ], [ %24, %if.end27 ]
  %incdec.ptr33 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33, align 8, !tbaa !16
  store %struct.sv** %incdec.ptr33, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %call34 = tail call i64 @Perl_call_method(i8* getelementptr inbounds ([6 x i8]* @.str27, i64 0, i64 0), i64 2) #4
  %25 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %26 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_prev38 = getelementptr inbounds %struct.stackinfo* %26, i64 0, i32 5
  %27 = load %struct.stackinfo** %si_prev38, align 8, !tbaa !93
  %tobool39 = icmp eq %struct.stackinfo* %27, null
  br i1 %tobool39, label %if.then40, label %if.end63

if.then40:                                        ; preds = %cond.end
  %28 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !16
  %tobool41 = icmp eq %struct.gv* %28, null
  br i1 %tobool41, label %cond.false58, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then40
  %sv_flags = getelementptr inbounds %struct.gv* %28, i64 0, i32 2
  %29 = load i64* %sv_flags, align 8, !tbaa !101
  %and = and i64 %29, 255
  %cmp42 = icmp eq i64 %and, 13
  br i1 %cmp42, label %land.lhs.true43, label %cond.false58

land.lhs.true43:                                  ; preds = %land.lhs.true
  %sv_any44 = getelementptr inbounds %struct.gv* %28, i64 0, i32 0
  %30 = load %struct.xpvgv** %sv_any44, align 8, !tbaa !57
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %30, i64 0, i32 7
  %31 = load %struct.gp** %xgv_gp, align 8, !tbaa !59
  %gp_io = getelementptr inbounds %struct.gp* %31, i64 0, i32 2
  %32 = load %struct.io** %gp_io, align 8, !tbaa !61
  %tobool45 = icmp eq %struct.io* %32, null
  br i1 %tobool45, label %cond.false58, label %land.lhs.true46

land.lhs.true46:                                  ; preds = %land.lhs.true43
  %sv_any50 = getelementptr inbounds %struct.io* %32, i64 0, i32 0
  %33 = load %struct.xpvio** %sv_any50, align 8, !tbaa !63
  %xio_ofp = getelementptr inbounds %struct.xpvio* %33, i64 0, i32 8
  %34 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !102
  %tobool51 = icmp eq %struct._PerlIO** %34, null
  br i1 %tobool51, label %cond.false58, label %cond.end60

cond.false58:                                     ; preds = %land.lhs.true46, %land.lhs.true43, %if.then40, %land.lhs.true
  %call59 = tail call %struct._PerlIO** @Perl_PerlIO_stderr() #4
  br label %cond.end60

cond.end60:                                       ; preds = %land.lhs.true46, %cond.false58
  %cond61 = phi %struct._PerlIO** [ %call59, %cond.false58 ], [ %34, %land.lhs.true46 ]
  %call62 = tail call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond61, i8* getelementptr inbounds ([17 x i8]* @.str24, i64 0, i64 0)) #4
  tail call void @Perl_my_exit(i64 1) #4
  br label %if.end63

if.end63:                                         ; preds = %cond.end, %cond.end60
  %35 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %sub.ptr.lhs.cast64 = ptrtoint %struct.sv** %25 to i64
  %sub.ptr.rhs.cast65 = ptrtoint %struct.sv** %35 to i64
  %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast65
  %sub.ptr.div67 = ashr exact i64 %sub.ptr.sub66, 3
  %36 = load %struct.av** @PL_curstack, align 8, !tbaa !16
  %sv_any68 = getelementptr inbounds %struct.av* %36, i64 0, i32 0
  %37 = load %struct.xpvav** %sv_any68, align 8, !tbaa !97
  %xav_fill69 = getelementptr inbounds %struct.xpvav* %37, i64 0, i32 1
  store i64 %sub.ptr.div67, i64* %xav_fill69, align 8, !tbaa !33
  %si_stack70 = getelementptr inbounds %struct.stackinfo* %27, i64 0, i32 0
  %38 = load %struct.av** %si_stack70, align 8, !tbaa !96
  %sv_any71 = getelementptr inbounds %struct.av* %38, i64 0, i32 0
  %39 = load %struct.xpvav** %sv_any71, align 8, !tbaa !97
  %xav_array72 = getelementptr inbounds %struct.xpvav* %39, i64 0, i32 0
  %40 = load i8** %xav_array72, align 8, !tbaa !99
  %41 = bitcast i8* %40 to %struct.sv**
  store %struct.sv** %41, %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %42 = load %struct.av** %si_stack70, align 8, !tbaa !96
  %sv_any74 = getelementptr inbounds %struct.av* %42, i64 0, i32 0
  %43 = load %struct.xpvav** %sv_any74, align 8, !tbaa !97
  %xav_max75 = getelementptr inbounds %struct.xpvav* %43, i64 0, i32 2
  %44 = load i64* %xav_max75, align 8, !tbaa !100
  %add.ptr76 = getelementptr inbounds %struct.sv** %41, i64 %44
  store %struct.sv** %add.ptr76, %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  %45 = load %struct.av** %si_stack70, align 8, !tbaa !96
  %sv_any78 = getelementptr inbounds %struct.av* %45, i64 0, i32 0
  %46 = load %struct.xpvav** %sv_any78, align 8, !tbaa !97
  %xav_fill79 = getelementptr inbounds %struct.xpvav* %46, i64 0, i32 1
  %47 = load i64* %xav_fill79, align 8, !tbaa !33
  %add.ptr80 = getelementptr inbounds %struct.sv** %41, i64 %47
  store %struct.sv** %add.ptr80, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %48 = load %struct.av** %si_stack70, align 8, !tbaa !96
  store %struct.av* %48, %struct.av** @PL_curstack, align 8, !tbaa !16
  store %struct.stackinfo* %27, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  tail call void @Perl_pop_scope() #4
  ret i32 0
}

declare void @Perl_markstack_grow() #1

declare %struct.sv** @Perl_stack_grow(%struct.sv**, %struct.sv**, i32) #1

declare i64 @Perl_call_method(i8*, i64) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_nextpack(%struct.sv* %sv, %struct.magic* nocapture readonly %mg, %struct.sv* %key) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %sv_flags = getelementptr inbounds %struct.sv* %key, i64 0, i32 2
  %1 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %1, 118423552
  %tobool = icmp ne i64 %and, 0
  %cond = select i1 %tobool, i8* getelementptr inbounds ([8 x i8]* @.str28, i64 0, i64 0), i8* getelementptr inbounds ([9 x i8]* @.str29, i64 0, i64 0)
  tail call void @Perl_push_scope() #4
  tail call void @Perl_save_int(i32* bitcast (i64* @PL_tmps_floor to i32*)) #4
  %2 = load i64* @PL_tmps_ix, align 8, !tbaa !25
  store i64 %2, i64* @PL_tmps_floor, align 8, !tbaa !25
  %3 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_next = getelementptr inbounds %struct.stackinfo* %3, i64 0, i32 6
  %4 = load %struct.stackinfo** %si_next, align 8, !tbaa !91
  %tobool1 = icmp eq %struct.stackinfo* %4, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.stackinfo* @Perl_new_stackinfo(i64 32, i64 12) #4
  %5 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_prev = getelementptr inbounds %struct.stackinfo* %call, i64 0, i32 5
  store %struct.stackinfo* %5, %struct.stackinfo** %si_prev, align 8, !tbaa !93
  %6 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_next2 = getelementptr inbounds %struct.stackinfo* %6, i64 0, i32 6
  store %struct.stackinfo* %call, %struct.stackinfo** %si_next2, align 8, !tbaa !91
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %next.0 = phi %struct.stackinfo* [ %4, %entry ], [ %call, %if.then ]
  %si_type = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 4
  store i64 2, i64* %si_type, align 8, !tbaa !94
  %si_cxix = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !95
  %si_stack = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 0
  %7 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any = getelementptr inbounds %struct.av* %7, i64 0, i32 0
  %8 = load %struct.xpvav** %sv_any, align 8, !tbaa !97
  %xav_fill = getelementptr inbounds %struct.xpvav* %8, i64 0, i32 1
  store i64 0, i64* %xav_fill, align 8, !tbaa !33
  %9 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %9 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %10 = load %struct.av** @PL_curstack, align 8, !tbaa !16
  %sv_any3 = getelementptr inbounds %struct.av* %10, i64 0, i32 0
  %11 = load %struct.xpvav** %sv_any3, align 8, !tbaa !97
  %xav_fill4 = getelementptr inbounds %struct.xpvav* %11, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill4, align 8, !tbaa !33
  %xav_array = getelementptr inbounds %struct.xpvav* %8, i64 0, i32 0
  %12 = load i8** %xav_array, align 8, !tbaa !99
  %13 = bitcast i8* %12 to %struct.sv**
  store %struct.sv** %13, %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %14 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any8 = getelementptr inbounds %struct.av* %14, i64 0, i32 0
  %15 = load %struct.xpvav** %sv_any8, align 8, !tbaa !97
  %xav_max = getelementptr inbounds %struct.xpvav* %15, i64 0, i32 2
  %16 = load i64* %xav_max, align 8, !tbaa !100
  %add.ptr = getelementptr inbounds %struct.sv** %13, i64 %16
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  %17 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any10 = getelementptr inbounds %struct.av* %17, i64 0, i32 0
  %18 = load %struct.xpvav** %sv_any10, align 8, !tbaa !97
  %xav_fill11 = getelementptr inbounds %struct.xpvav* %18, i64 0, i32 1
  %19 = load i64* %xav_fill11, align 8, !tbaa !33
  %add.ptr12 = getelementptr inbounds %struct.sv** %13, i64 %19
  store %struct.sv** %add.ptr12, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %20 = load %struct.av** %si_stack, align 8, !tbaa !96
  store %struct.av* %20, %struct.av** @PL_curstack, align 8, !tbaa !16
  store %struct.stackinfo* %next.0, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %21 = load i64** @PL_markstack_ptr, align 8, !tbaa !16
  %incdec.ptr = getelementptr inbounds i64* %21, i64 1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !16
  %22 = load i64** @PL_markstack_max, align 8, !tbaa !16
  %cmp = icmp eq i64* %incdec.ptr, %22
  br i1 %cmp, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  tail call void @Perl_markstack_grow() #4
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %.pre126 = load i64** @PL_markstack_ptr, align 8, !tbaa !16
  %.pre127 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end
  %23 = phi %struct.sv** [ %.pre127, %if.then14 ], [ %add.ptr, %if.end ]
  %24 = phi i64* [ %.pre126, %if.then14 ], [ %incdec.ptr, %if.end ]
  %25 = phi %struct.sv** [ %.pre, %if.then14 ], [ %13, %if.end ]
  %sub.ptr.lhs.cast17 = ptrtoint %struct.sv** %add.ptr12 to i64
  %sub.ptr.rhs.cast18 = ptrtoint %struct.sv** %25 to i64
  %sub.ptr.sub19 = sub i64 %sub.ptr.lhs.cast17, %sub.ptr.rhs.cast18
  %sub.ptr.div20 = ashr exact i64 %sub.ptr.sub19, 3
  store i64 %sub.ptr.div20, i64* %24, align 8, !tbaa !25
  %sub.ptr.lhs.cast21 = ptrtoint %struct.sv** %23 to i64
  %sub.ptr.sub23 = sub i64 %sub.ptr.lhs.cast21, %sub.ptr.lhs.cast17
  %cmp25 = icmp slt i64 %sub.ptr.sub23, 16
  br i1 %cmp25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %if.end15
  %call27 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr12, %struct.sv** %add.ptr12, i32 2) #4
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %if.end15
  %sp.0 = phi %struct.sv** [ %call27, %if.then26 ], [ %add.ptr12, %if.end15 ]
  %mg_obj = getelementptr inbounds %struct.magic* %mg, i64 0, i32 5
  %26 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  %tobool29 = icmp eq %struct.sv* %26, null
  br i1 %tobool29, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.end28
  %call31 = tail call %struct.sv* @Perl_newRV(%struct.sv* %sv) #4
  %call32 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call31) #4
  br label %cond.end

cond.end:                                         ; preds = %if.end28, %cond.false
  %cond33 = phi %struct.sv* [ %call32, %cond.false ], [ %26, %if.end28 ]
  %incdec.ptr34 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %cond33, %struct.sv** %incdec.ptr34, align 8, !tbaa !16
  %27 = load i64* %sv_flags, align 8, !tbaa !13
  %and36 = and i64 %27, 118423552
  %tobool37 = icmp eq i64 %and36, 0
  br i1 %tobool37, label %if.end40, label %if.then38

if.then38:                                        ; preds = %cond.end
  %incdec.ptr39 = getelementptr inbounds %struct.sv** %sp.0, i64 2
  store %struct.sv* %key, %struct.sv** %incdec.ptr39, align 8, !tbaa !16
  br label %if.end40

if.end40:                                         ; preds = %cond.end, %if.then38
  %sp.1 = phi %struct.sv** [ %incdec.ptr39, %if.then38 ], [ %incdec.ptr34, %cond.end ]
  store %struct.sv** %sp.1, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %call41 = tail call i64 @Perl_call_method(i8* %cond, i64 0) #4
  %tobool42 = icmp eq i64 %call41, 0
  br i1 %tobool42, label %if.end45, label %if.then43

if.then43:                                        ; preds = %if.end40
  %28 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %incdec.ptr44 = getelementptr inbounds %struct.sv** %28, i64 -1
  store %struct.sv** %incdec.ptr44, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %29 = load %struct.sv** %28, align 8, !tbaa !16
  tail call void @Perl_sv_setsv_flags(%struct.sv* %key, %struct.sv* %29, i64 2) #4
  br label %if.end45

if.end45:                                         ; preds = %if.end40, %if.then43
  %30 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %31 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_prev49 = getelementptr inbounds %struct.stackinfo* %31, i64 0, i32 5
  %32 = load %struct.stackinfo** %si_prev49, align 8, !tbaa !93
  %tobool50 = icmp eq %struct.stackinfo* %32, null
  br i1 %tobool50, label %if.then51, label %if.end76

if.then51:                                        ; preds = %if.end45
  %33 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !16
  %tobool52 = icmp eq %struct.gv* %33, null
  br i1 %tobool52, label %cond.false71, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then51
  %sv_flags53 = getelementptr inbounds %struct.gv* %33, i64 0, i32 2
  %34 = load i64* %sv_flags53, align 8, !tbaa !101
  %and54 = and i64 %34, 255
  %cmp55 = icmp eq i64 %and54, 13
  br i1 %cmp55, label %land.lhs.true56, label %cond.false71

land.lhs.true56:                                  ; preds = %land.lhs.true
  %sv_any57 = getelementptr inbounds %struct.gv* %33, i64 0, i32 0
  %35 = load %struct.xpvgv** %sv_any57, align 8, !tbaa !57
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %35, i64 0, i32 7
  %36 = load %struct.gp** %xgv_gp, align 8, !tbaa !59
  %gp_io = getelementptr inbounds %struct.gp* %36, i64 0, i32 2
  %37 = load %struct.io** %gp_io, align 8, !tbaa !61
  %tobool58 = icmp eq %struct.io* %37, null
  br i1 %tobool58, label %cond.false71, label %land.lhs.true59

land.lhs.true59:                                  ; preds = %land.lhs.true56
  %sv_any63 = getelementptr inbounds %struct.io* %37, i64 0, i32 0
  %38 = load %struct.xpvio** %sv_any63, align 8, !tbaa !63
  %xio_ofp = getelementptr inbounds %struct.xpvio* %38, i64 0, i32 8
  %39 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !102
  %tobool64 = icmp eq %struct._PerlIO** %39, null
  br i1 %tobool64, label %cond.false71, label %cond.end73

cond.false71:                                     ; preds = %land.lhs.true59, %land.lhs.true56, %if.then51, %land.lhs.true
  %call72 = tail call %struct._PerlIO** @Perl_PerlIO_stderr() #4
  br label %cond.end73

cond.end73:                                       ; preds = %land.lhs.true59, %cond.false71
  %cond74 = phi %struct._PerlIO** [ %call72, %cond.false71 ], [ %39, %land.lhs.true59 ]
  %call75 = tail call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond74, i8* getelementptr inbounds ([17 x i8]* @.str24, i64 0, i64 0)) #4
  tail call void @Perl_my_exit(i64 1) #4
  br label %if.end76

if.end76:                                         ; preds = %if.end45, %cond.end73
  %40 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %sub.ptr.lhs.cast77 = ptrtoint %struct.sv** %30 to i64
  %sub.ptr.rhs.cast78 = ptrtoint %struct.sv** %40 to i64
  %sub.ptr.sub79 = sub i64 %sub.ptr.lhs.cast77, %sub.ptr.rhs.cast78
  %sub.ptr.div80 = ashr exact i64 %sub.ptr.sub79, 3
  %41 = load %struct.av** @PL_curstack, align 8, !tbaa !16
  %sv_any81 = getelementptr inbounds %struct.av* %41, i64 0, i32 0
  %42 = load %struct.xpvav** %sv_any81, align 8, !tbaa !97
  %xav_fill82 = getelementptr inbounds %struct.xpvav* %42, i64 0, i32 1
  store i64 %sub.ptr.div80, i64* %xav_fill82, align 8, !tbaa !33
  %si_stack83 = getelementptr inbounds %struct.stackinfo* %32, i64 0, i32 0
  %43 = load %struct.av** %si_stack83, align 8, !tbaa !96
  %sv_any84 = getelementptr inbounds %struct.av* %43, i64 0, i32 0
  %44 = load %struct.xpvav** %sv_any84, align 8, !tbaa !97
  %xav_array85 = getelementptr inbounds %struct.xpvav* %44, i64 0, i32 0
  %45 = load i8** %xav_array85, align 8, !tbaa !99
  %46 = bitcast i8* %45 to %struct.sv**
  store %struct.sv** %46, %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %47 = load %struct.av** %si_stack83, align 8, !tbaa !96
  %sv_any87 = getelementptr inbounds %struct.av* %47, i64 0, i32 0
  %48 = load %struct.xpvav** %sv_any87, align 8, !tbaa !97
  %xav_max88 = getelementptr inbounds %struct.xpvav* %48, i64 0, i32 2
  %49 = load i64* %xav_max88, align 8, !tbaa !100
  %add.ptr89 = getelementptr inbounds %struct.sv** %46, i64 %49
  store %struct.sv** %add.ptr89, %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  %50 = load %struct.av** %si_stack83, align 8, !tbaa !96
  %sv_any91 = getelementptr inbounds %struct.av* %50, i64 0, i32 0
  %51 = load %struct.xpvav** %sv_any91, align 8, !tbaa !97
  %xav_fill92 = getelementptr inbounds %struct.xpvav* %51, i64 0, i32 1
  %52 = load i64* %xav_fill92, align 8, !tbaa !33
  %add.ptr93 = getelementptr inbounds %struct.sv** %46, i64 %52
  store %struct.sv** %add.ptr93, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %53 = load %struct.av** %si_stack83, align 8, !tbaa !96
  store %struct.av* %53, %struct.av** @PL_curstack, align 8, !tbaa !16
  store %struct.stackinfo* %32, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %54 = load i64* @PL_tmps_ix, align 8, !tbaa !25
  %55 = load i64* @PL_tmps_floor, align 8, !tbaa !25
  %cmp97 = icmp sgt i64 %54, %55
  br i1 %cmp97, label %if.then98, label %if.end99

if.then98:                                        ; preds = %if.end76
  tail call void @Perl_free_tmps() #4
  br label %if.end99

if.end99:                                         ; preds = %if.then98, %if.end76
  tail call void @Perl_pop_scope() #4
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_existspack(%struct.sv* %sv, %struct.magic* %mg) #0 {
entry:
  %call = tail call i32 (%struct.sv*, %struct.magic*, i8*, ...)* bitcast (i32 (...)* @magic_methpack to i32 (%struct.sv*, %struct.magic*, i8*, ...)*)(%struct.sv* %sv, %struct.magic* %mg, i8* getelementptr inbounds ([7 x i8]* @.str30, i64 0, i64 0)) #4
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define %struct.sv* @Perl_magic_scalarpack(%struct.hv* %hv, %struct.magic* %mg) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %mg_obj = getelementptr inbounds %struct.magic* %mg, i64 0, i32 5
  %1 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  %tobool = icmp eq %struct.sv* %1, null
  br i1 %tobool, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  %2 = bitcast %struct.hv* %hv to %struct.sv*
  %call = tail call %struct.sv* @Perl_newRV(%struct.sv* %2) #4
  %call3 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call) #4
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.false
  %cond = phi %struct.sv* [ %call3, %cond.false ], [ %1, %entry ]
  %sv_any = getelementptr inbounds %struct.sv* %cond, i64 0, i32 0
  %3 = load i8** %sv_any, align 8, !tbaa !1
  %xrv_rv = bitcast i8* %3 to %struct.sv**
  %4 = load %struct.sv** %xrv_rv, align 8, !tbaa !103
  %sv_any4 = getelementptr inbounds %struct.sv* %4, i64 0, i32 0
  %5 = load i8** %sv_any4, align 8, !tbaa !1
  %xmg_stash = getelementptr inbounds i8* %5, i64 48
  %6 = bitcast i8* %xmg_stash to %struct.hv**
  %7 = load %struct.hv** %6, align 8, !tbaa !105
  %call5 = tail call %struct.gv* @Perl_gv_fetchmethod_autoload(%struct.hv* %7, i8* getelementptr inbounds ([7 x i8]* @.str31, i64 0, i64 0), i64 0) #4
  %tobool6 = icmp eq %struct.gv* %call5, null
  br i1 %tobool6, label %if.then, label %if.end16

if.then:                                          ; preds = %cond.end
  %sv_any7 = getelementptr inbounds %struct.hv* %hv, i64 0, i32 0
  %8 = load %struct.xpvhv** %sv_any7, align 8, !tbaa !84
  %xhv_eiter = getelementptr inbounds %struct.xpvhv* %8, i64 0, i32 8
  %9 = load %struct.he** %xhv_eiter, align 8, !tbaa !106
  %tobool8 = icmp eq %struct.he* %9, null
  br i1 %tobool8, label %if.end, label %return

if.end:                                           ; preds = %if.then
  %call10 = tail call %struct.sv* @Perl_sv_newmortal() #4
  %10 = bitcast %struct.hv* %hv to %struct.sv*
  %call11 = tail call i32 (%struct.sv*, %struct.magic*, %struct.sv*, ...)* bitcast (i32 (...)* @magic_nextpack to i32 (%struct.sv*, %struct.magic*, %struct.sv*, ...)*)(%struct.sv* %10, %struct.magic* %mg, %struct.sv* %call10) #4
  %11 = load %struct.xpvhv** %sv_any7, align 8, !tbaa !84
  %xhv_eiter13 = getelementptr inbounds %struct.xpvhv* %11, i64 0, i32 8
  store %struct.he* null, %struct.he** %xhv_eiter13, align 8, !tbaa !106
  %sv_flags = getelementptr inbounds %struct.sv* %call10, i64 0, i32 2
  %12 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %12, 118423552
  %tobool14 = icmp ne i64 %and, 0
  %cond15 = select i1 %tobool14, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  br label %return

if.end16:                                         ; preds = %cond.end
  tail call void @Perl_push_scope() #4
  %13 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_next = getelementptr inbounds %struct.stackinfo* %13, i64 0, i32 6
  %14 = load %struct.stackinfo** %si_next, align 8, !tbaa !91
  %tobool17 = icmp eq %struct.stackinfo* %14, null
  br i1 %tobool17, label %if.then18, label %if.end21

if.then18:                                        ; preds = %if.end16
  %call19 = tail call %struct.stackinfo* @Perl_new_stackinfo(i64 32, i64 12) #4
  %15 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_prev = getelementptr inbounds %struct.stackinfo* %call19, i64 0, i32 5
  store %struct.stackinfo* %15, %struct.stackinfo** %si_prev, align 8, !tbaa !93
  %16 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_next20 = getelementptr inbounds %struct.stackinfo* %16, i64 0, i32 6
  store %struct.stackinfo* %call19, %struct.stackinfo** %si_next20, align 8, !tbaa !91
  br label %if.end21

if.end21:                                         ; preds = %if.end16, %if.then18
  %next.0 = phi %struct.stackinfo* [ %14, %if.end16 ], [ %call19, %if.then18 ]
  %si_type = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 4
  store i64 2, i64* %si_type, align 8, !tbaa !94
  %si_cxix = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !95
  %si_stack = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 0
  %17 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any22 = getelementptr inbounds %struct.av* %17, i64 0, i32 0
  %18 = load %struct.xpvav** %sv_any22, align 8, !tbaa !97
  %xav_fill = getelementptr inbounds %struct.xpvav* %18, i64 0, i32 1
  store i64 0, i64* %xav_fill, align 8, !tbaa !33
  %19 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %19 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %20 = load %struct.av** @PL_curstack, align 8, !tbaa !16
  %sv_any23 = getelementptr inbounds %struct.av* %20, i64 0, i32 0
  %21 = load %struct.xpvav** %sv_any23, align 8, !tbaa !97
  %xav_fill24 = getelementptr inbounds %struct.xpvav* %21, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill24, align 8, !tbaa !33
  %xav_array = getelementptr inbounds %struct.xpvav* %18, i64 0, i32 0
  %22 = load i8** %xav_array, align 8, !tbaa !99
  %23 = bitcast i8* %22 to %struct.sv**
  store %struct.sv** %23, %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %24 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any28 = getelementptr inbounds %struct.av* %24, i64 0, i32 0
  %25 = load %struct.xpvav** %sv_any28, align 8, !tbaa !97
  %xav_max = getelementptr inbounds %struct.xpvav* %25, i64 0, i32 2
  %26 = load i64* %xav_max, align 8, !tbaa !100
  %add.ptr = getelementptr inbounds %struct.sv** %23, i64 %26
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  %27 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any30 = getelementptr inbounds %struct.av* %27, i64 0, i32 0
  %28 = load %struct.xpvav** %sv_any30, align 8, !tbaa !97
  %xav_fill31 = getelementptr inbounds %struct.xpvav* %28, i64 0, i32 1
  %29 = load i64* %xav_fill31, align 8, !tbaa !33
  %add.ptr32 = getelementptr inbounds %struct.sv** %23, i64 %29
  store %struct.sv** %add.ptr32, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %30 = load %struct.av** %si_stack, align 8, !tbaa !96
  store %struct.av* %30, %struct.av** @PL_curstack, align 8, !tbaa !16
  store %struct.stackinfo* %next.0, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %31 = load i64** @PL_markstack_ptr, align 8, !tbaa !16
  %incdec.ptr = getelementptr inbounds i64* %31, i64 1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !16
  %32 = load i64** @PL_markstack_max, align 8, !tbaa !16
  %cmp = icmp eq i64* %incdec.ptr, %32
  br i1 %cmp, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end21
  tail call void @Perl_markstack_grow() #4
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %.pre134 = load i64** @PL_markstack_ptr, align 8, !tbaa !16
  %.pre135 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  br label %if.end35

if.end35:                                         ; preds = %if.then34, %if.end21
  %33 = phi %struct.sv** [ %.pre135, %if.then34 ], [ %add.ptr, %if.end21 ]
  %34 = phi i64* [ %.pre134, %if.then34 ], [ %incdec.ptr, %if.end21 ]
  %35 = phi %struct.sv** [ %.pre, %if.then34 ], [ %23, %if.end21 ]
  %sub.ptr.lhs.cast37 = ptrtoint %struct.sv** %add.ptr32 to i64
  %sub.ptr.rhs.cast38 = ptrtoint %struct.sv** %35 to i64
  %sub.ptr.sub39 = sub i64 %sub.ptr.lhs.cast37, %sub.ptr.rhs.cast38
  %sub.ptr.div40 = ashr exact i64 %sub.ptr.sub39, 3
  store i64 %sub.ptr.div40, i64* %34, align 8, !tbaa !25
  %sub.ptr.lhs.cast41 = ptrtoint %struct.sv** %33 to i64
  %sub.ptr.sub43 = sub i64 %sub.ptr.lhs.cast41, %sub.ptr.lhs.cast37
  %cmp45 = icmp slt i64 %sub.ptr.sub43, 8
  br i1 %cmp45, label %if.then46, label %if.end48

if.then46:                                        ; preds = %if.end35
  %call47 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr32, %struct.sv** %add.ptr32, i32 1) #4
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %if.end35
  %sp.0 = phi %struct.sv** [ %call47, %if.then46 ], [ %add.ptr32, %if.end35 ]
  %incdec.ptr49 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %cond, %struct.sv** %incdec.ptr49, align 8, !tbaa !16
  store %struct.sv** %incdec.ptr49, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %call50 = tail call i64 @Perl_call_method(i8* getelementptr inbounds ([7 x i8]* @.str31, i64 0, i64 0), i64 0) #4
  %tobool51 = icmp eq i64 %call50, 0
  %.pre136 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  br i1 %tobool51, label %if.end54, label %if.then52

if.then52:                                        ; preds = %if.end48
  %incdec.ptr53 = getelementptr inbounds %struct.sv** %.pre136, i64 -1
  store %struct.sv** %incdec.ptr53, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %36 = load %struct.sv** %.pre136, align 8, !tbaa !16
  br label %if.end54

if.end54:                                         ; preds = %if.end48, %if.then52
  %37 = phi %struct.sv** [ %incdec.ptr53, %if.then52 ], [ %.pre136, %if.end48 ]
  %retval1.0 = phi %struct.sv* [ %36, %if.then52 ], [ @PL_sv_undef, %if.end48 ]
  %38 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_prev58 = getelementptr inbounds %struct.stackinfo* %38, i64 0, i32 5
  %39 = load %struct.stackinfo** %si_prev58, align 8, !tbaa !93
  %tobool59 = icmp eq %struct.stackinfo* %39, null
  br i1 %tobool59, label %if.then60, label %if.end85

if.then60:                                        ; preds = %if.end54
  %40 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !16
  %tobool61 = icmp eq %struct.gv* %40, null
  br i1 %tobool61, label %cond.false80, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then60
  %sv_flags62 = getelementptr inbounds %struct.gv* %40, i64 0, i32 2
  %41 = load i64* %sv_flags62, align 8, !tbaa !101
  %and63 = and i64 %41, 255
  %cmp64 = icmp eq i64 %and63, 13
  br i1 %cmp64, label %land.lhs.true65, label %cond.false80

land.lhs.true65:                                  ; preds = %land.lhs.true
  %sv_any66 = getelementptr inbounds %struct.gv* %40, i64 0, i32 0
  %42 = load %struct.xpvgv** %sv_any66, align 8, !tbaa !57
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %42, i64 0, i32 7
  %43 = load %struct.gp** %xgv_gp, align 8, !tbaa !59
  %gp_io = getelementptr inbounds %struct.gp* %43, i64 0, i32 2
  %44 = load %struct.io** %gp_io, align 8, !tbaa !61
  %tobool67 = icmp eq %struct.io* %44, null
  br i1 %tobool67, label %cond.false80, label %land.lhs.true68

land.lhs.true68:                                  ; preds = %land.lhs.true65
  %sv_any72 = getelementptr inbounds %struct.io* %44, i64 0, i32 0
  %45 = load %struct.xpvio** %sv_any72, align 8, !tbaa !63
  %xio_ofp = getelementptr inbounds %struct.xpvio* %45, i64 0, i32 8
  %46 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !102
  %tobool73 = icmp eq %struct._PerlIO** %46, null
  br i1 %tobool73, label %cond.false80, label %cond.end82

cond.false80:                                     ; preds = %land.lhs.true68, %land.lhs.true65, %if.then60, %land.lhs.true
  %call81 = tail call %struct._PerlIO** @Perl_PerlIO_stderr() #4
  br label %cond.end82

cond.end82:                                       ; preds = %land.lhs.true68, %cond.false80
  %cond83 = phi %struct._PerlIO** [ %call81, %cond.false80 ], [ %46, %land.lhs.true68 ]
  %call84 = tail call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond83, i8* getelementptr inbounds ([17 x i8]* @.str24, i64 0, i64 0)) #4
  tail call void @Perl_my_exit(i64 1) #4
  br label %if.end85

if.end85:                                         ; preds = %if.end54, %cond.end82
  %47 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %sub.ptr.lhs.cast86 = ptrtoint %struct.sv** %37 to i64
  %sub.ptr.rhs.cast87 = ptrtoint %struct.sv** %47 to i64
  %sub.ptr.sub88 = sub i64 %sub.ptr.lhs.cast86, %sub.ptr.rhs.cast87
  %sub.ptr.div89 = ashr exact i64 %sub.ptr.sub88, 3
  %48 = load %struct.av** @PL_curstack, align 8, !tbaa !16
  %sv_any90 = getelementptr inbounds %struct.av* %48, i64 0, i32 0
  %49 = load %struct.xpvav** %sv_any90, align 8, !tbaa !97
  %xav_fill91 = getelementptr inbounds %struct.xpvav* %49, i64 0, i32 1
  store i64 %sub.ptr.div89, i64* %xav_fill91, align 8, !tbaa !33
  %si_stack92 = getelementptr inbounds %struct.stackinfo* %39, i64 0, i32 0
  %50 = load %struct.av** %si_stack92, align 8, !tbaa !96
  %sv_any93 = getelementptr inbounds %struct.av* %50, i64 0, i32 0
  %51 = load %struct.xpvav** %sv_any93, align 8, !tbaa !97
  %xav_array94 = getelementptr inbounds %struct.xpvav* %51, i64 0, i32 0
  %52 = load i8** %xav_array94, align 8, !tbaa !99
  %53 = bitcast i8* %52 to %struct.sv**
  store %struct.sv** %53, %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %54 = load %struct.av** %si_stack92, align 8, !tbaa !96
  %sv_any96 = getelementptr inbounds %struct.av* %54, i64 0, i32 0
  %55 = load %struct.xpvav** %sv_any96, align 8, !tbaa !97
  %xav_max97 = getelementptr inbounds %struct.xpvav* %55, i64 0, i32 2
  %56 = load i64* %xav_max97, align 8, !tbaa !100
  %add.ptr98 = getelementptr inbounds %struct.sv** %53, i64 %56
  store %struct.sv** %add.ptr98, %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  %57 = load %struct.av** %si_stack92, align 8, !tbaa !96
  %sv_any100 = getelementptr inbounds %struct.av* %57, i64 0, i32 0
  %58 = load %struct.xpvav** %sv_any100, align 8, !tbaa !97
  %xav_fill101 = getelementptr inbounds %struct.xpvav* %58, i64 0, i32 1
  %59 = load i64* %xav_fill101, align 8, !tbaa !33
  %add.ptr102 = getelementptr inbounds %struct.sv** %53, i64 %59
  store %struct.sv** %add.ptr102, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %60 = load %struct.av** %si_stack92, align 8, !tbaa !96
  store %struct.av* %60, %struct.av** @PL_curstack, align 8, !tbaa !16
  store %struct.stackinfo* %39, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  tail call void @Perl_pop_scope() #4
  br label %return

return:                                           ; preds = %if.then, %if.end85, %if.end
  %retval.0 = phi %struct.sv* [ %retval1.0, %if.end85 ], [ %cond15, %if.end ], [ @PL_sv_yes, %if.then ]
  ret %struct.sv* %retval.0
}

declare %struct.gv* @Perl_gv_fetchmethod_autoload(%struct.hv*, i8*, i64) #1

declare %struct.sv* @Perl_sv_newmortal() #1

declare i32 @magic_nextpack(...) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setdbline(%struct.sv* %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %n_a = alloca i64, align 8
  %0 = load %struct.gv** @PL_DBline, align 8, !tbaa !16
  %tobool = icmp eq %struct.sv* %sv, null
  br i1 %tobool, label %cond.end33, label %cond.false

cond.false:                                       ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %1 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %1, 262144
  %tobool1 = icmp eq i64 %and, 0
  br i1 %tobool1, label %cond.false10, label %cond.true2

cond.true2:                                       ; preds = %cond.false
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %2 = load i8** %sv_any, align 8, !tbaa !1
  %3 = bitcast i8* %2 to %struct.xpv*
  store %struct.xpv* %3, %struct.xpv** @PL_Xpv, align 8, !tbaa !16
  %tobool3 = icmp eq i8* %2, null
  br i1 %tobool3, label %land.end9, label %land.rhs

land.rhs:                                         ; preds = %cond.true2
  %xpv_cur = getelementptr inbounds i8* %2, i64 8
  %4 = bitcast i8* %xpv_cur to i64*
  %5 = load i64* %4, align 8, !tbaa !30
  %cmp = icmp ugt i64 %5, 1
  br i1 %cmp, label %land.end9, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %tobool5 = icmp eq i64 %5, 0
  br i1 %tobool5, label %land.end9, label %land.rhs6

land.rhs6:                                        ; preds = %lor.rhs
  %xpv_pv = bitcast i8* %2 to i8**
  %6 = load i8** %xpv_pv, align 8, !tbaa !32
  %7 = load i8* %6, align 1, !tbaa !50
  %cmp7 = icmp ne i8 %7, 48
  br label %land.end9

land.end9:                                        ; preds = %lor.rhs, %cond.true2, %land.rhs, %land.rhs6
  %8 = phi i1 [ false, %cond.true2 ], [ true, %land.rhs ], [ false, %lor.rhs ], [ %cmp7, %land.rhs6 ]
  %cond = zext i1 %8 to i64
  br label %cond.end33

cond.false10:                                     ; preds = %cond.false
  %and12 = and i64 %1, 65536
  %tobool13 = icmp eq i64 %and12, 0
  br i1 %tobool13, label %cond.false18, label %cond.true14

cond.true14:                                      ; preds = %cond.false10
  %sv_any15 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %9 = load i8** %sv_any15, align 8, !tbaa !1
  %xiv_iv = getelementptr inbounds i8* %9, i64 24
  %10 = bitcast i8* %xiv_iv to i64*
  %11 = load i64* %10, align 8, !tbaa !89
  %cmp16 = icmp ne i64 %11, 0
  %conv17 = zext i1 %cmp16 to i64
  br label %cond.end33

cond.false18:                                     ; preds = %cond.false10
  %and20 = and i64 %1, 131072
  %tobool21 = icmp eq i64 %and20, 0
  br i1 %tobool21, label %cond.false26, label %cond.true22

cond.true22:                                      ; preds = %cond.false18
  %sv_any23 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %12 = load i8** %sv_any23, align 8, !tbaa !1
  %xnv_nv = getelementptr inbounds i8* %12, i64 32
  %13 = bitcast i8* %xnv_nv to double*
  %14 = load double* %13, align 8, !tbaa !107
  %cmp24 = fcmp une double %14, 0.000000e+00
  %conv25 = zext i1 %cmp24 to i64
  br label %cond.end33

cond.false26:                                     ; preds = %cond.false18
  %call = call signext i8 @Perl_sv_2bool(%struct.sv* %sv) #4
  %conv27 = sext i8 %call to i64
  br label %cond.end33

cond.end33:                                       ; preds = %entry, %land.end9, %cond.true22, %cond.false26, %cond.true14
  %cond34 = phi i64 [ 0, %entry ], [ %cond, %land.end9 ], [ %conv17, %cond.true14 ], [ %conv25, %cond.true22 ], [ %conv27, %cond.false26 ]
  %sv_any36 = getelementptr inbounds %struct.gv* %0, i64 0, i32 0
  %15 = load %struct.xpvgv** %sv_any36, align 8, !tbaa !57
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %15, i64 0, i32 7
  %16 = load %struct.gp** %xgv_gp, align 8, !tbaa !59
  %gp_av = getelementptr inbounds %struct.gp* %16, i64 0, i32 4
  %17 = load %struct.av** %gp_av, align 8, !tbaa !109
  %mg_len = getelementptr inbounds %struct.magic* %mg, i64 0, i32 7
  %18 = load i64* %mg_len, align 8, !tbaa !40
  store i64 %18, i64* %n_a, align 8, !tbaa !25
  %conv37 = trunc i64 %18 to i32
  %cmp38 = icmp eq i32 %conv37, -2
  %mg_ptr = getelementptr inbounds %struct.magic* %mg, i64 0, i32 6
  %19 = load i8** %mg_ptr, align 8, !tbaa !39
  br i1 %cmp38, label %cond.true40, label %cond.end59

cond.true40:                                      ; preds = %cond.end33
  %sv_flags41 = getelementptr inbounds i8* %19, i64 16
  %20 = bitcast i8* %sv_flags41 to i64*
  %21 = load i64* %20, align 8, !tbaa !13
  %and42 = and i64 %21, 262144
  %cmp43 = icmp eq i64 %and42, 0
  br i1 %cmp43, label %cond.false52, label %cond.true45

cond.true45:                                      ; preds = %cond.true40
  %sv_any47 = bitcast i8* %19 to i8**
  %22 = load i8** %sv_any47, align 8, !tbaa !1
  %xpv_cur48 = getelementptr inbounds i8* %22, i64 8
  %23 = bitcast i8* %xpv_cur48 to i64*
  %24 = load i64* %23, align 8, !tbaa !30
  store i64 %24, i64* %n_a, align 8, !tbaa !25
  %xpv_pv51 = bitcast i8* %22 to i8**
  %25 = load i8** %xpv_pv51, align 8, !tbaa !32
  br label %cond.end59

cond.false52:                                     ; preds = %cond.true40
  %26 = bitcast i8* %19 to %struct.sv*
  %call54 = call i8* @Perl_sv_2pv_flags(%struct.sv* %26, i64* %n_a, i64 2) #4
  br label %cond.end59

cond.end59:                                       ; preds = %cond.end33, %cond.true45, %cond.false52
  %cond60 = phi i8* [ %25, %cond.true45 ], [ %call54, %cond.false52 ], [ %19, %cond.end33 ]
  %call61 = call i32 @atoi(i8* %cond60) #4
  %conv62 = sext i32 %call61 to i64
  %call63 = call %struct.sv** @Perl_av_fetch(%struct.av* %17, i64 %conv62, i64 0) #4
  %tobool64 = icmp eq %struct.sv** %call63, null
  br i1 %tobool64, label %if.end80, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.end59
  %27 = load %struct.sv** %call63, align 8, !tbaa !16
  %sv_flags65 = getelementptr inbounds %struct.sv* %27, i64 0, i32 2
  %28 = load i64* %sv_flags65, align 8, !tbaa !13
  %and66 = and i64 %28, 16777216
  %tobool67 = icmp eq i64 %and66, 0
  br i1 %tobool67, label %if.end80, label %land.lhs.true68

land.lhs.true68:                                  ; preds = %land.lhs.true
  %sv_any69 = getelementptr inbounds %struct.sv* %27, i64 0, i32 0
  %29 = load i8** %sv_any69, align 8, !tbaa !1
  %xiv_iv70 = getelementptr inbounds i8* %29, i64 24
  %30 = bitcast i8* %xiv_iv70 to i64*
  %31 = load i64* %30, align 8, !tbaa !89
  %tobool71 = icmp eq i64 %31, 0
  br i1 %tobool71, label %if.end80, label %if.then

if.then:                                          ; preds = %land.lhs.true68
  %32 = inttoptr i64 %31 to %struct.op*
  %sext.mask = and i64 %cond34, 4294967295
  %tobool72 = icmp eq i64 %sext.mask, 0
  %op_flags = getelementptr inbounds %struct.op* %32, i64 0, i32 6
  %33 = load i8* %op_flags, align 1, !tbaa !110
  br i1 %tobool72, label %if.else, label %if.then73

if.then73:                                        ; preds = %if.then
  %or = or i8 %33, -128
  store i8 %or, i8* %op_flags, align 1, !tbaa !110
  br label %if.end80

if.else:                                          ; preds = %if.then
  %and78 = and i8 %33, 127
  store i8 %and78, i8* %op_flags, align 1, !tbaa !110
  br label %if.end80

if.end80:                                         ; preds = %land.lhs.true68, %land.lhs.true, %cond.end59, %if.then73, %if.else
  ret i32 0
}

declare signext i8 @Perl_sv_2bool(%struct.sv*) #1

declare %struct.sv** @Perl_av_fetch(%struct.av*, i64, i64) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_getarylen(%struct.sv* %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %mg_obj = getelementptr inbounds %struct.magic* %mg, i64 0, i32 5
  %0 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  %sv_flags = getelementptr inbounds %struct.sv* %0, i64 0, i32 2
  %1 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %1, 32768
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %call = tail call i64 @Perl_mg_size(%struct.sv* %0)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %sv_any = bitcast %struct.sv* %0 to %struct.xpvav**
  %2 = load %struct.xpvav** %sv_any, align 8, !tbaa !97
  %xav_fill = getelementptr inbounds %struct.xpvav* %2, i64 0, i32 1
  %3 = load i64* %xav_fill, align 8, !tbaa !33
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ %3, %cond.false ]
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_arybase = getelementptr inbounds %struct.cop* %4, i64 0, i32 12
  %5 = load i64* %cop_arybase, align 8, !tbaa !74
  %add = add nsw i64 %5, %cond
  tail call void @Perl_sv_setiv(%struct.sv* %sv, i64 %add) #4
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setarylen(%struct.sv* %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %mg_obj = getelementptr inbounds %struct.magic* %mg, i64 0, i32 5
  %0 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  %1 = bitcast %struct.sv* %0 to %struct.av*
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %2 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %2, 65536
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %3 = load i8** %sv_any, align 8, !tbaa !1
  %xiv_iv = getelementptr inbounds i8* %3, i64 24
  %4 = bitcast i8* %xiv_iv to i64*
  %5 = load i64* %4, align 8, !tbaa !89
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = tail call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ %call, %cond.false ]
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_arybase = getelementptr inbounds %struct.cop* %6, i64 0, i32 12
  %7 = load i64* %cop_arybase, align 8, !tbaa !74
  %sub = sub nsw i64 %cond, %7
  tail call void @Perl_av_fill(%struct.av* %1, i64 %sub) #4
  ret i32 0
}

declare void @Perl_av_fill(%struct.av*, i64) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_getpos(%struct.sv* %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %i = alloca i64, align 8
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targ = getelementptr inbounds i8* %0, i64 72
  %1 = bitcast i8* %xlv_targ to %struct.sv**
  %2 = load %struct.sv** %1, align 8, !tbaa !82
  %sv_flags = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %3 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %3, 255
  %cmp = icmp ugt i64 %and, 6
  br i1 %cmp, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %sv_any1 = getelementptr inbounds %struct.sv* %2, i64 0, i32 0
  %4 = load i8** %sv_any1, align 8, !tbaa !1
  %xmg_magic = getelementptr inbounds i8* %4, i64 40
  %5 = bitcast i8* %xmg_magic to %struct.magic**
  %6 = load %struct.magic** %5, align 8, !tbaa !18
  %tobool = icmp eq %struct.magic* %6, null
  %tobool.i = icmp eq %struct.sv* %2, null
  %or.cond = or i1 %tobool, %tobool.i
  br i1 %or.cond, label %if.end15, label %for.body.i

for.cond.i:                                       ; preds = %for.body.i
  %mg_moremagic.i = getelementptr inbounds %struct.magic* %mg.010.i, i64 0, i32 0
  %mg.0.i = load %struct.magic** %mg_moremagic.i, align 8
  %tobool1.i = icmp eq %struct.magic* %mg.0.i, null
  br i1 %tobool1.i, label %if.end15, label %for.body.i

for.body.i:                                       ; preds = %land.lhs.true, %for.cond.i
  %mg.010.i = phi %struct.magic* [ %mg.0.i, %for.cond.i ], [ %6, %land.lhs.true ]
  %mg_type.i = getelementptr inbounds %struct.magic* %mg.010.i, i64 0, i32 3
  %7 = load i8* %mg_type.i, align 1, !tbaa !35
  %cmp.i = icmp eq i8 %7, 103
  br i1 %cmp.i, label %land.lhs.true3, label %for.cond.i

land.lhs.true3:                                   ; preds = %for.body.i
  %mg_len = getelementptr inbounds %struct.magic* %mg.010.i, i64 0, i32 7
  %8 = load i64* %mg_len, align 8, !tbaa !40
  %cmp4 = icmp sgt i64 %8, -1
  br i1 %cmp4, label %if.then5, label %if.end15

if.then5:                                         ; preds = %land.lhs.true3
  store i64 %8, i64* %i, align 8, !tbaa !25
  %9 = load i64* %sv_flags, align 8, !tbaa !13
  %and8 = and i64 %9, 536870912
  %tobool9 = icmp eq i64 %and8, 0
  br i1 %tobool9, label %if.end, label %land.lhs.true10

land.lhs.true10:                                  ; preds = %if.then5
  %10 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %op_private = getelementptr inbounds %struct.cop* %10, i64 0, i32 7
  %11 = load i8* %op_private, align 1, !tbaa !28
  %and11 = and i8 %11, 8
  %tobool12 = icmp eq i8 %and11, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %land.lhs.true10
  call void @Perl_sv_pos_b2u(%struct.sv* %2, i64* %i) #4
  br label %if.end

if.end:                                           ; preds = %land.lhs.true10, %if.then5, %if.then13
  %12 = load i64* %i, align 8, !tbaa !25
  %13 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_arybase = getelementptr inbounds %struct.cop* %13, i64 0, i32 12
  %14 = load i64* %cop_arybase, align 8, !tbaa !74
  %add = add nsw i64 %14, %12
  call void @Perl_sv_setiv(%struct.sv* %sv, i64 %add) #4
  br label %return

if.end15:                                         ; preds = %for.cond.i, %land.lhs.true, %land.lhs.true3, %entry
  %sv_flags16 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %15 = load i64* %sv_flags16, align 8, !tbaa !13
  %and17 = and i64 %15, 1223753727
  store i64 %and17, i64* %sv_flags16, align 8, !tbaa !13
  %and19 = and i64 %15, 2097152
  %tobool20 = icmp eq i64 %and19, 0
  br i1 %tobool20, label %return, label %land.rhs

land.rhs:                                         ; preds = %if.end15
  %call21 = call i32 @Perl_sv_backoff(%struct.sv* %sv) #4
  br label %return

return:                                           ; preds = %land.rhs, %if.end15, %if.end
  ret i32 0
}

declare void @Perl_sv_pos_b2u(%struct.sv*, i64*) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setpos(%struct.sv* %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %p = alloca i64, align 8
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targ = getelementptr inbounds i8* %0, i64 72
  %1 = bitcast i8* %xlv_targ to %struct.sv**
  %2 = load %struct.sv** %1, align 8, !tbaa !82
  %sv_flags = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %3 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %3, 255
  %cmp = icmp ugt i64 %and, 6
  br i1 %cmp, label %land.lhs.true, label %if.then3

land.lhs.true:                                    ; preds = %entry
  %sv_any1 = getelementptr inbounds %struct.sv* %2, i64 0, i32 0
  %4 = load i8** %sv_any1, align 8, !tbaa !1
  %xmg_magic = getelementptr inbounds i8* %4, i64 40
  %5 = bitcast i8* %xmg_magic to %struct.magic**
  %6 = load %struct.magic** %5, align 8, !tbaa !18
  %tobool = icmp eq %struct.magic* %6, null
  %tobool.i = icmp eq %struct.sv* %2, null
  %or.cond = or i1 %tobool, %tobool.i
  br i1 %or.cond, label %if.then3, label %for.body.i

for.cond.i:                                       ; preds = %for.body.i
  %mg_moremagic.i = getelementptr inbounds %struct.magic* %mg.010.i, i64 0, i32 0
  %mg.0.i = load %struct.magic** %mg_moremagic.i, align 8
  %tobool1.i = icmp eq %struct.magic* %mg.0.i, null
  br i1 %tobool1.i, label %if.then3, label %for.body.i

for.body.i:                                       ; preds = %land.lhs.true, %for.cond.i
  %mg.010.i = phi %struct.magic* [ %mg.0.i, %for.cond.i ], [ %6, %land.lhs.true ]
  %mg_type.i = getelementptr inbounds %struct.magic* %mg.010.i, i64 0, i32 3
  %7 = load i8* %mg_type.i, align 1, !tbaa !35
  %cmp.i = icmp eq i8 %7, 103
  br i1 %cmp.i, label %if.else, label %for.cond.i

if.then3:                                         ; preds = %for.cond.i, %land.lhs.true, %entry
  %sv_flags10104 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %8 = load i64* %sv_flags10104, align 8, !tbaa !13
  %and11105 = and i64 %8, 118423552
  %tobool12106 = icmp eq i64 %and11105, 0
  br i1 %tobool12106, label %return, label %if.end8

if.end8:                                          ; preds = %if.then3
  call void @Perl_sv_magic(%struct.sv* %2, %struct.sv* null, i32 103, i8* null, i64 0) #4
  %tobool.i86 = icmp eq %struct.sv* %2, null
  br i1 %tobool.i86, label %if.end15, label %if.end.i91

if.end.i91:                                       ; preds = %if.end8
  %sv_any.i87 = getelementptr inbounds %struct.sv* %2, i64 0, i32 0
  %9 = load i8** %sv_any.i87, align 8, !tbaa !1
  %xmg_magic.i88 = getelementptr inbounds i8* %9, i64 40
  %10 = bitcast i8* %xmg_magic.i88 to %struct.magic**
  %mg.08.i89 = load %struct.magic** %10, align 8
  %tobool19.i90 = icmp eq %struct.magic* %mg.08.i89, null
  br i1 %tobool19.i90, label %if.end15, label %for.body.i100

for.cond.i95:                                     ; preds = %for.body.i100
  %mg_moremagic.i92 = getelementptr inbounds %struct.magic* %mg.010.i96, i64 0, i32 0
  %mg.0.i93 = load %struct.magic** %mg_moremagic.i92, align 8
  %tobool1.i94 = icmp eq %struct.magic* %mg.0.i93, null
  br i1 %tobool1.i94, label %if.end15, label %for.body.i100

for.body.i100:                                    ; preds = %if.end.i91, %for.cond.i95
  %mg.010.i96 = phi %struct.magic* [ %mg.0.i93, %for.cond.i95 ], [ %mg.08.i89, %if.end.i91 ]
  %mg_type.i97 = getelementptr inbounds %struct.magic* %mg.010.i96, i64 0, i32 3
  %11 = load i8* %mg_type.i97, align 1, !tbaa !35
  %cmp.i99 = icmp eq i8 %11, 103
  br i1 %cmp.i99, label %if.end15, label %for.cond.i95

if.else:                                          ; preds = %for.body.i
  %sv_flags10112 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %12 = load i64* %sv_flags10112, align 8, !tbaa !13
  %and11113 = and i64 %12, 118423552
  %tobool12114 = icmp eq i64 %and11113, 0
  br i1 %tobool12114, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.else
  %mg_len = getelementptr inbounds %struct.magic* %mg.010.i, i64 0, i32 7
  store i64 -1, i64* %mg_len, align 8, !tbaa !40
  br label %return

if.end15:                                         ; preds = %for.body.i100, %for.cond.i95, %if.else, %if.end.i91, %if.end8
  %sv_flags10107 = phi i64* [ %sv_flags10112, %if.else ], [ %sv_flags10104, %if.end8 ], [ %sv_flags10104, %if.end.i91 ], [ %sv_flags10104, %for.cond.i95 ], [ %sv_flags10104, %for.body.i100 ]
  %mg.addr.1 = phi %struct.magic* [ %mg.010.i, %if.else ], [ null, %if.end8 ], [ null, %if.end.i91 ], [ %mg.010.i96, %for.body.i100 ], [ null, %for.cond.i95 ]
  %13 = load i64* %sv_flags, align 8, !tbaa !13
  %and17 = and i64 %13, 262144
  %tobool18 = icmp eq i64 %and17, 0
  br i1 %tobool18, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end15
  %sv_any19 = getelementptr inbounds %struct.sv* %2, i64 0, i32 0
  %14 = load i8** %sv_any19, align 8, !tbaa !1
  %xpv_cur = getelementptr inbounds i8* %14, i64 8
  %15 = bitcast i8* %xpv_cur to i64*
  %16 = load i64* %15, align 8, !tbaa !30
  br label %cond.end

cond.false:                                       ; preds = %if.end15
  %call20 = call i64 @Perl_sv_len(%struct.sv* %2) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %16, %cond.true ], [ %call20, %cond.false ]
  %17 = load i64* %sv_flags10107, align 8, !tbaa !13
  %and22 = and i64 %17, 65536
  %tobool23 = icmp eq i64 %and22, 0
  br i1 %tobool23, label %cond.false26, label %cond.true24

cond.true24:                                      ; preds = %cond.end
  %18 = load i8** %sv_any, align 8, !tbaa !1
  %xiv_iv = getelementptr inbounds i8* %18, i64 24
  %19 = bitcast i8* %xiv_iv to i64*
  %20 = load i64* %19, align 8, !tbaa !89
  br label %cond.end28

cond.false26:                                     ; preds = %cond.end
  %call27 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end28

cond.end28:                                       ; preds = %cond.false26, %cond.true24
  %cond29 = phi i64 [ %20, %cond.true24 ], [ %call27, %cond.false26 ]
  %21 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_arybase = getelementptr inbounds %struct.cop* %21, i64 0, i32 12
  %22 = load i64* %cop_arybase, align 8, !tbaa !74
  %sub = sub nsw i64 %cond29, %22
  %23 = load i64* %sv_flags, align 8, !tbaa !13
  %and31 = and i64 %23, 536870912
  %tobool32 = icmp eq i64 %and31, 0
  br i1 %tobool32, label %if.end41, label %land.lhs.true33

land.lhs.true33:                                  ; preds = %cond.end28
  %24 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %op_private = getelementptr inbounds %struct.cop* %24, i64 0, i32 7
  %25 = load i8* %op_private, align 1, !tbaa !28
  %and34 = and i8 %25, 8
  %tobool35 = icmp eq i8 %and34, 0
  br i1 %tobool35, label %if.then36, label %if.end41

if.then36:                                        ; preds = %land.lhs.true33
  %call37 = call i64 @Perl_sv_len_utf8(%struct.sv* %2) #4
  %tobool38 = icmp eq i64 %call37, 0
  %cond.call37 = select i1 %tobool38, i64 %cond, i64 %call37
  br label %if.end41

if.end41:                                         ; preds = %if.then36, %land.lhs.true33, %cond.end28
  %len.0 = phi i64 [ %cond, %land.lhs.true33 ], [ %cond, %cond.end28 ], [ %cond.call37, %if.then36 ]
  %ulen.0 = phi i64 [ 0, %land.lhs.true33 ], [ 0, %cond.end28 ], [ %call37, %if.then36 ]
  %cmp42 = icmp slt i64 %sub, 0
  br i1 %cmp42, label %if.then44, label %if.else49

if.then44:                                        ; preds = %if.end41
  %add = add i64 %len.0, %sub
  %cmp45 = icmp slt i64 %add, 0
  %.add = select i1 %cmp45, i64 0, i64 %add
  br label %if.end54

if.else49:                                        ; preds = %if.end41
  %cmp50 = icmp sgt i64 %sub, %len.0
  %len.0.sub = select i1 %cmp50, i64 %len.0, i64 %sub
  br label %if.end54

if.end54:                                         ; preds = %if.else49, %if.then44
  %pos.0 = phi i64 [ %.add, %if.then44 ], [ %len.0.sub, %if.else49 ]
  %tobool55 = icmp eq i64 %ulen.0, 0
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %if.end54
  store i64 %pos.0, i64* %p, align 8, !tbaa !25
  call void @Perl_sv_pos_u2b(%struct.sv* %2, i64* %p, i64* null) #4
  %26 = load i64* %p, align 8, !tbaa !25
  br label %if.end57

if.end57:                                         ; preds = %if.end54, %if.then56
  %pos.1 = phi i64 [ %26, %if.then56 ], [ %pos.0, %if.end54 ]
  %mg_len58 = getelementptr inbounds %struct.magic* %mg.addr.1, i64 0, i32 7
  store i64 %pos.1, i64* %mg_len58, align 8, !tbaa !40
  %mg_flags = getelementptr inbounds %struct.magic* %mg.addr.1, i64 0, i32 4
  %27 = load i8* %mg_flags, align 1, !tbaa !12
  %and60 = and i8 %27, -2
  store i8 %and60, i8* %mg_flags, align 1, !tbaa !12
  br label %return

return:                                           ; preds = %if.then3, %if.end57, %if.then13
  ret i32 0
}

declare i64 @Perl_sv_len(%struct.sv*) #1

declare i64 @Perl_sv_len_utf8(%struct.sv*) #1

declare void @Perl_sv_pos_u2b(%struct.sv*, i64*, i64*) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_getglob(%struct.sv* %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %0, 1048576
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %and2 = and i64 %0, -1048577
  store i64 %and2, i64* %sv_flags, align 8, !tbaa !13
  %1 = bitcast %struct.sv* %sv to %struct.gv*
  tail call void @Perl_gv_efullname4(%struct.sv* %sv, %struct.gv* %1, i8* getelementptr inbounds ([2 x i8]* @.str32, i64 0, i64 0), i8 signext 1) #4
  %2 = load i64* %sv_flags, align 8, !tbaa !13
  %or = or i64 %2, 1048576
  store i64 %or, i64* %sv_flags, align 8, !tbaa !13
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = bitcast %struct.sv* %sv to %struct.gv*
  tail call void @Perl_gv_efullname4(%struct.sv* %sv, %struct.gv* %3, i8* getelementptr inbounds ([2 x i8]* @.str32, i64 0, i64 0), i8 signext 1) #4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret i32 0
}

declare void @Perl_gv_efullname4(%struct.sv*, %struct.gv*, i8*, i8 signext) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setglob(%struct.sv* %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %n_a = alloca i64, align 8
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %0, 118423552
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %and2 = and i64 %0, 262144
  %cmp = icmp eq i64 %and2, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %1 = load i8** %sv_any, align 8, !tbaa !1
  %xpv_cur = getelementptr inbounds i8* %1, i64 8
  %2 = bitcast i8* %xpv_cur to i64*
  %3 = load i64* %2, align 8, !tbaa !30
  store i64 %3, i64* %n_a, align 8, !tbaa !25
  %xpv_pv = bitcast i8* %1 to i8**
  %4 = load i8** %xpv_pv, align 8, !tbaa !32
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %sv, i64* %n_a, i64 2) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %4, %cond.true ], [ %call, %cond.false ]
  %5 = load i8* %cond, align 1, !tbaa !50
  %cmp4 = icmp eq i8 %5, 42
  br i1 %cmp4, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %cond.end
  %arrayidx = getelementptr inbounds i8* %cond, i64 1
  %6 = load i8* %arrayidx, align 1, !tbaa !50
  %tobool7 = icmp eq i8 %6, 0
  %cond.incdec.ptr = select i1 %tobool7, i8* %cond, i8* %arrayidx
  br label %if.end9

if.end9:                                          ; preds = %land.lhs.true, %cond.end
  %s.0 = phi i8* [ %cond, %cond.end ], [ %cond.incdec.ptr, %land.lhs.true ]
  %call10 = call %struct.gv* @Perl_gv_fetchpv(i8* %s.0, i64 1, i64 13) #4
  %7 = bitcast %struct.gv* %call10 to %struct.sv*
  %cmp11 = icmp eq %struct.sv* %7, %sv
  br i1 %cmp11, label %return, label %if.end14

if.end14:                                         ; preds = %if.end9
  %sv_any15 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %8 = load i8** %sv_any15, align 8, !tbaa !1
  %xgv_gp = getelementptr inbounds i8* %8, i64 56
  %9 = bitcast i8* %xgv_gp to %struct.gp**
  %10 = load %struct.gp** %9, align 8, !tbaa !59
  %tobool16 = icmp eq %struct.gp* %10, null
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end14
  %11 = bitcast %struct.sv* %sv to %struct.gv*
  call void @Perl_gp_free(%struct.gv* %11) #4
  br label %if.end18

if.end18:                                         ; preds = %if.end14, %if.then17
  %sv_any19 = getelementptr inbounds %struct.gv* %call10, i64 0, i32 0
  %12 = load %struct.xpvgv** %sv_any19, align 8, !tbaa !57
  %xgv_gp20 = getelementptr inbounds %struct.xpvgv* %12, i64 0, i32 7
  %13 = load %struct.gp** %xgv_gp20, align 8, !tbaa !59
  %call21 = call %struct.gp* @Perl_gp_ref(%struct.gp* %13) #4
  %14 = load i8** %sv_any15, align 8, !tbaa !1
  %xgv_gp23 = getelementptr inbounds i8* %14, i64 56
  %15 = bitcast i8* %xgv_gp23 to %struct.gp**
  store %struct.gp* %call21, %struct.gp** %15, align 8, !tbaa !59
  br label %return

return:                                           ; preds = %if.end9, %entry, %if.end18
  ret i32 0
}

declare %struct.gv* @Perl_gv_fetchpv(i8*, i64, i64) #1

declare void @Perl_gp_free(%struct.gv*) #1

declare %struct.gp* @Perl_gp_ref(%struct.gp*) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_getsubstr(%struct.sv* %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %len = alloca i64, align 8
  %offs = alloca i64, align 8
  %rem = alloca i64, align 8
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targ = getelementptr inbounds i8* %0, i64 72
  %1 = bitcast i8* %xlv_targ to %struct.sv**
  %2 = load %struct.sv** %1, align 8, !tbaa !82
  %sv_flags = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %3 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %3, 262144
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any1 = getelementptr inbounds %struct.sv* %2, i64 0, i32 0
  %4 = load i8** %sv_any1, align 8, !tbaa !1
  %xpv_cur = getelementptr inbounds i8* %4, i64 8
  %5 = bitcast i8* %xpv_cur to i64*
  %6 = load i64* %5, align 8, !tbaa !30
  store i64 %6, i64* %len, align 8, !tbaa !25
  %xpv_pv = bitcast i8* %4 to i8**
  %7 = load i8** %xpv_pv, align 8, !tbaa !32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %2, i64* %len, i64 2) #4
  %.pre = load i8** %sv_any, align 8, !tbaa !1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %8 = phi i8* [ %0, %cond.true ], [ %.pre, %cond.false ]
  %cond = phi i8* [ %7, %cond.true ], [ %call, %cond.false ]
  %xlv_targoff = getelementptr inbounds i8* %8, i64 56
  %9 = bitcast i8* %xlv_targoff to i64*
  %10 = load i64* %9, align 8, !tbaa !112
  store i64 %10, i64* %offs, align 8, !tbaa !25
  %xlv_targlen = getelementptr inbounds i8* %8, i64 64
  %11 = bitcast i8* %xlv_targlen to i64*
  %12 = load i64* %11, align 8, !tbaa !113
  store i64 %12, i64* %rem, align 8, !tbaa !25
  %13 = load i64* %sv_flags, align 8, !tbaa !13
  %and6 = and i64 %13, 536870912
  %tobool = icmp eq i64 %and6, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  call void @Perl_sv_pos_u2b(%struct.sv* %2, i64* %offs, i64* %rem) #4
  %.pre28 = load i64* %offs, align 8, !tbaa !25
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  %14 = phi i64 [ %10, %cond.end ], [ %.pre28, %if.then ]
  %15 = load i64* %len, align 8, !tbaa !25
  %cmp7 = icmp sgt i64 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  store i64 %15, i64* %offs, align 8, !tbaa !25
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end
  %16 = phi i64 [ %15, %if.then8 ], [ %14, %if.end ]
  %17 = load i64* %rem, align 8, !tbaa !25
  %add = add nsw i64 %16, %17
  %cmp10 = icmp sgt i64 %add, %15
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end9
  %sub = sub i64 %15, %16
  store i64 %sub, i64* %rem, align 8, !tbaa !25
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end9
  %18 = phi i64 [ %sub, %if.then11 ], [ %17, %if.end9 ]
  %add.ptr = getelementptr inbounds i8* %cond, i64 %16
  call void @Perl_sv_setpvn(%struct.sv* %sv, i8* %add.ptr, i64 %18) #4
  %19 = load i64* %sv_flags, align 8, !tbaa !13
  %and14 = and i64 %19, 536870912
  %tobool15 = icmp eq i64 %and14, 0
  br i1 %tobool15, label %if.end18, label %if.then16

if.then16:                                        ; preds = %if.end12
  %sv_flags17 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %20 = load i64* %sv_flags17, align 8, !tbaa !13
  %or = or i64 %20, 536870912
  store i64 %or, i64* %sv_flags17, align 8, !tbaa !13
  br label %if.end18

if.end18:                                         ; preds = %if.end12, %if.then16
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setsubstr(%struct.sv* %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %len = alloca i64, align 8
  %lvoff = alloca i64, align 8
  %lvlen = alloca i64, align 8
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %0, 262144
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %1 = load i8** %sv_any, align 8, !tbaa !1
  %xpv_cur = getelementptr inbounds i8* %1, i64 8
  %2 = bitcast i8* %xpv_cur to i64*
  %3 = load i64* %2, align 8, !tbaa !30
  store i64 %3, i64* %len, align 8, !tbaa !25
  %xpv_pv = bitcast i8* %1 to i8**
  %4 = load i8** %xpv_pv, align 8, !tbaa !32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %sv, i64* %len, i64 2) #4
  %sv_any2.phi.trans.insert = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %.pre = load i8** %sv_any2.phi.trans.insert, align 8, !tbaa !1
  %.pre40 = load i64* %sv_flags, align 8, !tbaa !13
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %5 = phi i64 [ %0, %cond.true ], [ %.pre40, %cond.false ]
  %6 = phi i8* [ %1, %cond.true ], [ %.pre, %cond.false ]
  %cond = phi i8* [ %4, %cond.true ], [ %call, %cond.false ]
  %xlv_targ = getelementptr inbounds i8* %6, i64 72
  %7 = bitcast i8* %xlv_targ to %struct.sv**
  %8 = load %struct.sv** %7, align 8, !tbaa !82
  %xlv_targoff = getelementptr inbounds i8* %6, i64 56
  %9 = bitcast i8* %xlv_targoff to i64*
  %10 = load i64* %9, align 8, !tbaa !112
  store i64 %10, i64* %lvoff, align 8, !tbaa !25
  %xlv_targlen = getelementptr inbounds i8* %6, i64 64
  %11 = bitcast i8* %xlv_targlen to i64*
  %12 = load i64* %11, align 8, !tbaa !113
  store i64 %12, i64* %lvlen, align 8, !tbaa !25
  %and6 = and i64 %5, 536870912
  %tobool = icmp eq i64 %and6, 0
  br i1 %tobool, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.end
  %13 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %op_private = getelementptr inbounds %struct.cop* %13, i64 0, i32 7
  %14 = load i8* %op_private, align 1, !tbaa !28
  %and7 = and i8 %14, 8
  %tobool8 = icmp eq i8 %and7, 0
  br i1 %tobool8, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %call9 = call i64 @Perl_sv_utf8_upgrade_flags(%struct.sv* %8, i64 2) #4
  call void @Perl_sv_pos_u2b(%struct.sv* %8, i64* %lvoff, i64* %lvlen) #4
  %15 = load i64* %lvoff, align 8, !tbaa !25
  %16 = load i64* %lvlen, align 8, !tbaa !25
  %17 = load i64* %len, align 8, !tbaa !25
  call void @Perl_sv_insert(%struct.sv* %8, i64 %15, i64 %16, i8* %cond, i64 %17) #4
  %sv_flags10 = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %18 = load i64* %sv_flags10, align 8, !tbaa !13
  %or = or i64 %18, 536870912
  store i64 %or, i64* %sv_flags10, align 8, !tbaa !13
  br label %if.end19

if.else:                                          ; preds = %land.lhs.true, %cond.end
  %tobool11 = icmp eq %struct.sv* %8, null
  br i1 %tobool11, label %if.else18, label %land.lhs.true12

land.lhs.true12:                                  ; preds = %if.else
  %sv_flags13 = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %19 = load i64* %sv_flags13, align 8, !tbaa !13
  %and14 = and i64 %19, 536870912
  %tobool15 = icmp eq i64 %and14, 0
  br i1 %tobool15, label %if.else18, label %if.then16

if.then16:                                        ; preds = %land.lhs.true12
  call void @Perl_sv_pos_u2b(%struct.sv* %8, i64* %lvoff, i64* %lvlen) #4
  %call17 = call i8* @Perl_bytes_to_utf8(i8* %cond, i64* %len) #4
  %20 = load i64* %lvoff, align 8, !tbaa !25
  %21 = load i64* %lvlen, align 8, !tbaa !25
  %22 = load i64* %len, align 8, !tbaa !25
  call void @Perl_sv_insert(%struct.sv* %8, i64 %20, i64 %21, i8* %call17, i64 %22) #4
  call void @Perl_safesysfree(i8* %call17) #4
  br label %if.end19

if.else18:                                        ; preds = %land.lhs.true12, %if.else
  %23 = load i64* %lvoff, align 8, !tbaa !25
  %24 = load i64* %lvlen, align 8, !tbaa !25
  %25 = load i64* %len, align 8, !tbaa !25
  call void @Perl_sv_insert(%struct.sv* %8, i64 %23, i64 %24, i8* %cond, i64 %25) #4
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.else18, %if.then
  ret i32 0
}

declare i64 @Perl_sv_utf8_upgrade_flags(%struct.sv*, i64) #1

declare i8* @Perl_bytes_to_utf8(i8*, i64*) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_gettaint(%struct.sv* readnone %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %mg_len = getelementptr inbounds %struct.magic* %mg, i64 0, i32 7
  %0 = load i64* %mg_len, align 8, !tbaa !40
  %and = and i64 %0, 1
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %and2 = and i64 %0, 2
  %tobool3 = icmp eq i64 %and2, 0
  br i1 %tobool3, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false
  %mg_obj = getelementptr inbounds %struct.magic* %mg, i64 0, i32 5
  %1 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  %cmp = icmp eq %struct.sv* %1, %sv
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry, %land.lhs.true
  store i8 1, i8* @PL_tainted, align 1, !tbaa !50
  br label %if.end

if.end:                                           ; preds = %lor.lhs.false, %if.then, %land.lhs.true
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_settaint(%struct.sv* nocapture readnone %sv, %struct.magic* nocapture %mg) #0 {
entry:
  %0 = load i32* @PL_localizing, align 4, !tbaa !54
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %if.else3, label %if.then

if.then:                                          ; preds = %entry
  %cmp = icmp eq i32 %0, 1
  %mg_len = getelementptr inbounds %struct.magic* %mg, i64 0, i32 7
  %1 = load i64* %mg_len, align 8, !tbaa !40
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.then
  %shl = shl i64 %1, 1
  store i64 %shl, i64* %mg_len, align 8, !tbaa !40
  br label %if.end10

if.else:                                          ; preds = %if.then
  %shr = ashr i64 %1, 1
  store i64 %shr, i64* %mg_len, align 8, !tbaa !40
  br label %if.end10

if.else3:                                         ; preds = %entry
  %2 = load i8* @PL_tainted, align 1, !tbaa !50
  %tobool4 = icmp eq i8 %2, 0
  %mg_len6 = getelementptr inbounds %struct.magic* %mg, i64 0, i32 7
  %3 = load i64* %mg_len6, align 8, !tbaa !40
  br i1 %tobool4, label %if.else7, label %if.then5

if.then5:                                         ; preds = %if.else3
  %or = or i64 %3, 1
  store i64 %or, i64* %mg_len6, align 8, !tbaa !40
  br label %if.end10

if.else7:                                         ; preds = %if.else3
  %and = and i64 %3, -2
  store i64 %and, i64* %mg_len6, align 8, !tbaa !40
  br label %if.end10

if.end10:                                         ; preds = %if.then5, %if.else7, %if.then1, %if.else
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_getvec(%struct.sv* %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targ = getelementptr inbounds i8* %0, i64 72
  %1 = bitcast i8* %xlv_targ to %struct.sv**
  %2 = load %struct.sv** %1, align 8, !tbaa !82
  %tobool = icmp eq %struct.sv* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %3 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %3, 1223753727
  store i64 %and, i64* %sv_flags, align 8, !tbaa !13
  %and2 = and i64 %3, 2097152
  %tobool3 = icmp eq i64 %and2, 0
  br i1 %tobool3, label %return, label %land.rhs

land.rhs:                                         ; preds = %if.then
  %call = tail call i32 @Perl_sv_backoff(%struct.sv* %sv) #4
  br label %return

if.end:                                           ; preds = %entry
  %xlv_targoff = getelementptr inbounds i8* %0, i64 56
  %4 = bitcast i8* %xlv_targoff to i64*
  %5 = load i64* %4, align 8, !tbaa !112
  %xlv_targlen = getelementptr inbounds i8* %0, i64 64
  %6 = bitcast i8* %xlv_targlen to i64*
  %7 = load i64* %6, align 8, !tbaa !113
  %call7 = tail call i32 (%struct.sv*, i64, i64, ...)* bitcast (i32 (...)* @do_vecget to i32 (%struct.sv*, i64, i64, ...)*)(%struct.sv* %2, i64 %5, i64 %7) #4
  %conv = sext i32 %call7 to i64
  tail call void @Perl_sv_setuv(%struct.sv* %sv, i64 %conv) #4
  br label %return

return:                                           ; preds = %land.rhs, %if.then, %if.end
  ret i32 0
}

declare i32 @do_vecget(...) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setvec(%struct.sv* %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %call = tail call i32 (%struct.sv*, ...)* bitcast (i32 (...)* @do_vecset to i32 (%struct.sv*, ...)*)(%struct.sv* %sv) #4
  ret i32 0
}

declare i32 @do_vecset(...) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_getdefelem(%struct.sv* %sv, %struct.magic* nocapture %mg) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targlen = getelementptr inbounds i8* %0, i64 64
  %1 = bitcast i8* %xlv_targlen to i64*
  %2 = load i64* %1, align 8, !tbaa !113
  %tobool = icmp eq i64 %2, 0
  br i1 %tobool, label %if.else46, label %if.then

if.then:                                          ; preds = %entry
  %mg_obj = getelementptr inbounds %struct.magic* %mg, i64 0, i32 5
  %3 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  %tobool1 = icmp eq %struct.sv* %3, null
  %xlv_targ = getelementptr inbounds i8* %0, i64 72
  %4 = bitcast i8* %xlv_targ to %struct.sv**
  %5 = load %struct.sv** %4, align 8, !tbaa !82
  br i1 %tobool1, label %if.else14, label %if.then2

if.then2:                                         ; preds = %if.then
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %6, 255
  %cmp = icmp eq i64 %and, 11
  br i1 %cmp, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then2
  %7 = bitcast %struct.sv* %5 to %struct.hv*
  %call = tail call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %7, %struct.sv* %3, i64 0, i64 0) #4
  %tobool6 = icmp eq %struct.he* %call, null
  br i1 %tobool6, label %if.end49, label %if.then7

if.then7:                                         ; preds = %if.then4
  %hent_val = getelementptr inbounds %struct.he* %call, i64 0, i32 2
  br label %if.end29

if.else:                                          ; preds = %if.then2
  %8 = bitcast %struct.sv* %5 to %struct.av*
  %call9 = tail call %struct.sv** @Perl_avhv_fetch_ent(%struct.av* %8, %struct.sv* %3, i64 0, i64 0) #4
  %tobool10 = icmp eq %struct.sv** %call9, null
  br i1 %tobool10, label %if.end49, label %if.end29

if.else14:                                        ; preds = %if.then
  %xlv_targoff = getelementptr inbounds i8* %0, i64 56
  %9 = bitcast i8* %xlv_targoff to i64*
  %10 = load i64* %9, align 8, !tbaa !112
  %sv_flags18 = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %11 = load i64* %sv_flags18, align 8, !tbaa !13
  %and19 = and i64 %11, 32768
  %tobool20 = icmp eq i64 %and19, 0
  br i1 %tobool20, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else14
  %call21 = tail call i64 @Perl_mg_size(%struct.sv* %5)
  br label %cond.end

cond.false:                                       ; preds = %if.else14
  %sv_any22 = bitcast %struct.sv* %5 to %struct.xpvav**
  %12 = load %struct.xpvav** %sv_any22, align 8, !tbaa !97
  %xav_fill = getelementptr inbounds %struct.xpvav* %12, i64 0, i32 1
  %13 = load i64* %xav_fill, align 8, !tbaa !33
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call21, %cond.true ], [ %13, %cond.false ]
  %cmp23 = icmp sgt i64 %10, %cond
  br i1 %cmp23, label %if.end49, label %if.then24

if.then24:                                        ; preds = %cond.end
  %14 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targoff26 = getelementptr inbounds i8* %14, i64 56
  %15 = bitcast i8* %xlv_targoff26 to i64*
  %16 = load i64* %15, align 8, !tbaa !112
  %sv_any27 = bitcast %struct.sv* %5 to %struct.xpvav**
  %17 = load %struct.xpvav** %sv_any27, align 8, !tbaa !97
  %xav_array = getelementptr inbounds %struct.xpvav* %17, i64 0, i32 0
  %18 = load i8** %xav_array, align 8, !tbaa !99
  %19 = bitcast i8* %18 to %struct.sv**
  %arrayidx = getelementptr inbounds %struct.sv** %19, i64 %16
  br label %if.end29

if.end29:                                         ; preds = %if.else, %if.then24, %if.then7
  %targ.0.in = phi %struct.sv** [ %hent_val, %if.then7 ], [ %arrayidx, %if.then24 ], [ %call9, %if.else ]
  %targ.0 = load %struct.sv** %targ.0.in, align 8
  %tobool30 = icmp ne %struct.sv* %targ.0, null
  %cmp31 = icmp ne %struct.sv* %targ.0, @PL_sv_undef
  %or.cond = and i1 %tobool30, %cmp31
  br i1 %or.cond, label %land.end, label %if.end49

land.end:                                         ; preds = %if.end29
  %20 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targ34 = getelementptr inbounds i8* %20, i64 72
  %21 = bitcast i8* %xlv_targ34 to %struct.sv**
  %22 = load %struct.sv** %21, align 8, !tbaa !82
  tail call void @Perl_sv_free(%struct.sv* %22) #4
  store %struct.sv* %targ.0, %struct.sv** @PL_Sv, align 8, !tbaa !16
  %sv_refcnt = getelementptr inbounds %struct.sv* %targ.0, i64 0, i32 1
  %23 = load i64* %sv_refcnt, align 8, !tbaa !17
  %inc = add i64 %23, 1
  store i64 %inc, i64* %sv_refcnt, align 8, !tbaa !17
  %24 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targ38 = getelementptr inbounds i8* %24, i64 72
  %25 = bitcast i8* %xlv_targ38 to %struct.sv**
  store %struct.sv* %targ.0, %struct.sv** %25, align 8, !tbaa !82
  %xlv_targlen40 = getelementptr inbounds i8* %24, i64 64
  %26 = bitcast i8* %xlv_targlen40 to i64*
  store i64 0, i64* %26, align 8, !tbaa !113
  %27 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  tail call void @Perl_sv_free(%struct.sv* %27) #4
  store %struct.sv* null, %struct.sv** %mg_obj, align 8, !tbaa !37
  %mg_flags = getelementptr inbounds %struct.magic* %mg, i64 0, i32 4
  %28 = load i8* %mg_flags, align 1, !tbaa !12
  %and43 = and i8 %28, -3
  store i8 %and43, i8* %mg_flags, align 1, !tbaa !12
  br label %if.end49

if.else46:                                        ; preds = %entry
  %xlv_targ48 = getelementptr inbounds i8* %0, i64 72
  %29 = bitcast i8* %xlv_targ48 to %struct.sv**
  %30 = load %struct.sv** %29, align 8, !tbaa !82
  br label %if.end49

if.end49:                                         ; preds = %cond.end, %if.else, %if.then4, %if.end29, %land.end, %if.else46
  %targ.1 = phi %struct.sv* [ %targ.0, %land.end ], [ %targ.0, %if.end29 ], [ %30, %if.else46 ], [ null, %if.then4 ], [ null, %if.else ], [ null, %cond.end ]
  %tobool50 = icmp ne %struct.sv* %targ.1, null
  %cond54 = select i1 %tobool50, %struct.sv* %targ.1, %struct.sv* @PL_sv_undef
  tail call void @Perl_sv_setsv_flags(%struct.sv* %sv, %struct.sv* %cond54, i64 2) #4
  ret i32 0
}

declare %struct.he* @Perl_hv_fetch_ent(%struct.hv*, %struct.sv*, i64, i64) #1

declare %struct.sv** @Perl_avhv_fetch_ent(%struct.av*, %struct.sv*, i64, i64) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setdefelem(%struct.sv* %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targlen = getelementptr inbounds i8* %0, i64 64
  %1 = bitcast i8* %xlv_targlen to i64*
  %2 = load i64* %1, align 8, !tbaa !113
  %tobool = icmp eq i64 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 (%struct.sv*, ...)* bitcast (i32 (...)* @vivify_defelem to i32 (%struct.sv*, ...)*)(%struct.sv* %sv) #4
  %.pre = load i8** %sv_any, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %3 = phi i8* [ %0, %entry ], [ %.pre, %if.then ]
  %xlv_targ = getelementptr inbounds i8* %3, i64 72
  %4 = bitcast i8* %xlv_targ to %struct.sv**
  %5 = load %struct.sv** %4, align 8, !tbaa !82
  %tobool2 = icmp eq %struct.sv* %5, null
  br i1 %tobool2, label %if.end14, label %if.then3

if.then3:                                         ; preds = %if.end
  tail call void @Perl_sv_setsv_flags(%struct.sv* %5, %struct.sv* %sv, i64 2) #4
  %6 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targ7 = getelementptr inbounds i8* %6, i64 72
  %7 = bitcast i8* %xlv_targ7 to %struct.sv**
  %8 = load %struct.sv** %7, align 8, !tbaa !82
  %sv_flags = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %9 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %9, 16384
  %tobool8 = icmp eq i64 %and, 0
  br i1 %tobool8, label %if.end14, label %if.then9

if.then9:                                         ; preds = %if.then3
  %call12 = tail call i32 @Perl_mg_set(%struct.sv* %8)
  br label %if.end14

if.end14:                                         ; preds = %if.then3, %if.end, %if.then9
  ret i32 0
}

declare i32 @vivify_defelem(...) #1

; Function Attrs: nounwind uwtable
define void @Perl_vivify_defelem(%struct.sv* readonly %sv) #0 {
entry:
  %n_a = alloca i64, align 8
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %0 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targlen = getelementptr inbounds i8* %0, i64 64
  %1 = bitcast i8* %xlv_targlen to i64*
  %2 = load i64* %1, align 8, !tbaa !113
  %tobool = icmp eq i64 %2, 0
  br i1 %tobool, label %return, label %if.end.i

if.end.i:                                         ; preds = %entry
  %xmg_magic.i = getelementptr inbounds i8* %0, i64 40
  %3 = bitcast i8* %xmg_magic.i to %struct.magic**
  %mg.08.i = load %struct.magic** %3, align 8
  %tobool19.i = icmp eq %struct.magic* %mg.08.i, null
  br i1 %tobool19.i, label %return, label %for.body.i

for.cond.i:                                       ; preds = %for.body.i
  %mg_moremagic.i = getelementptr inbounds %struct.magic* %mg.010.i, i64 0, i32 0
  %mg.0.i = load %struct.magic** %mg_moremagic.i, align 8
  %tobool1.i = icmp eq %struct.magic* %mg.0.i, null
  br i1 %tobool1.i, label %return, label %for.body.i

for.body.i:                                       ; preds = %if.end.i, %for.cond.i
  %mg.010.i = phi %struct.magic* [ %mg.0.i, %for.cond.i ], [ %mg.08.i, %if.end.i ]
  %mg_type.i = getelementptr inbounds %struct.magic* %mg.010.i, i64 0, i32 3
  %4 = load i8* %mg_type.i, align 1, !tbaa !35
  %cmp.i = icmp eq i8 %4, 121
  br i1 %cmp.i, label %if.end, label %for.cond.i

if.end:                                           ; preds = %for.body.i
  %mg_obj = getelementptr inbounds %struct.magic* %mg.010.i, i64 0, i32 5
  %5 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  %tobool2 = icmp eq %struct.sv* %5, null
  %xlv_targ = getelementptr inbounds i8* %0, i64 72
  %6 = bitcast i8* %xlv_targ to %struct.sv**
  %7 = load %struct.sv** %6, align 8, !tbaa !82
  br i1 %tobool2, label %if.else32, label %if.then3

if.then3:                                         ; preds = %if.end
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %8, 255
  %cmp = icmp eq i64 %and, 11
  br i1 %cmp, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then3
  %9 = bitcast %struct.sv* %7 to %struct.hv*
  %call7 = call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %9, %struct.sv* %5, i64 1, i64 0) #4
  %tobool8 = icmp eq %struct.he* %call7, null
  br i1 %tobool8, label %if.then20, label %if.then9

if.then9:                                         ; preds = %if.then5
  %hent_val = getelementptr inbounds %struct.he* %call7, i64 0, i32 2
  br label %if.end16

if.else:                                          ; preds = %if.then3
  %10 = bitcast %struct.sv* %7 to %struct.av*
  %call12 = call %struct.sv** @Perl_avhv_fetch_ent(%struct.av* %10, %struct.sv* %5, i64 1, i64 0) #4
  %tobool13 = icmp eq %struct.sv** %call12, null
  br i1 %tobool13, label %if.then20, label %if.end16

if.end16:                                         ; preds = %if.else, %if.then9
  %value.0.in = phi %struct.sv** [ %hent_val, %if.then9 ], [ %call12, %if.else ]
  %value.0 = load %struct.sv** %value.0.in, align 8
  %tobool17 = icmp eq %struct.sv* %value.0, null
  %cmp19 = icmp eq %struct.sv* %value.0, @PL_sv_undef
  %or.cond = or i1 %tobool17, %cmp19
  br i1 %or.cond, label %if.then20, label %if.end65

if.then20:                                        ; preds = %if.else, %if.then5, %if.end16
  %value.0112 = phi %struct.sv* [ %value.0, %if.end16 ], [ null, %if.then5 ], [ null, %if.else ]
  %11 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  %sv_flags22 = getelementptr inbounds %struct.sv* %11, i64 0, i32 2
  %12 = load i64* %sv_flags22, align 8, !tbaa !13
  %and23 = and i64 %12, 262144
  %cmp24 = icmp eq i64 %and23, 0
  br i1 %cmp24, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then20
  %sv_any26 = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %13 = load i8** %sv_any26, align 8, !tbaa !1
  %xpv_cur = getelementptr inbounds i8* %13, i64 8
  %14 = bitcast i8* %xpv_cur to i64*
  %15 = load i64* %14, align 8, !tbaa !30
  store i64 %15, i64* %n_a, align 8, !tbaa !25
  %xpv_pv = bitcast i8* %13 to i8**
  %16 = load i8** %xpv_pv, align 8, !tbaa !32
  br label %cond.end

cond.false:                                       ; preds = %if.then20
  %call30 = call i8* @Perl_sv_2pv_flags(%struct.sv* %11, i64* %n_a, i64 2) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %16, %cond.true ], [ %call30, %cond.false ]
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([0 x i8]* @PL_no_helem, i64 0, i64 0), i8* %cond) #4
  br label %if.end65

if.else32:                                        ; preds = %if.end
  %17 = bitcast %struct.sv* %7 to %struct.av*
  %cmp37 = icmp slt i64 %2, 0
  br i1 %cmp37, label %land.lhs.true, label %if.else52

land.lhs.true:                                    ; preds = %if.else32
  %xlv_targoff = getelementptr inbounds i8* %0, i64 56
  %18 = bitcast i8* %xlv_targoff to i64*
  %19 = load i64* %18, align 8, !tbaa !112
  %sv_flags39 = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %20 = load i64* %sv_flags39, align 8, !tbaa !13
  %and40 = and i64 %20, 32768
  %tobool41 = icmp eq i64 %and40, 0
  br i1 %tobool41, label %cond.false44, label %cond.true42

cond.true42:                                      ; preds = %land.lhs.true
  %call43 = call i64 @Perl_mg_size(%struct.sv* %7)
  br label %cond.end46

cond.false44:                                     ; preds = %land.lhs.true
  %sv_any45 = bitcast %struct.sv* %7 to %struct.xpvav**
  %21 = load %struct.xpvav** %sv_any45, align 8, !tbaa !97
  %xav_fill = getelementptr inbounds %struct.xpvav* %21, i64 0, i32 1
  %22 = load i64* %xav_fill, align 8, !tbaa !33
  br label %cond.end46

cond.end46:                                       ; preds = %cond.false44, %cond.true42
  %cond47 = phi i64 [ %call43, %cond.true42 ], [ %22, %cond.false44 ]
  %cmp48 = icmp sgt i64 %19, %cond47
  %23 = load i8** %sv_any, align 8, !tbaa !1
  br i1 %cmp48, label %if.end65.thread, label %if.else52

if.end65.thread:                                  ; preds = %cond.end46
  %xlv_targ51 = getelementptr inbounds i8* %23, i64 72
  %24 = bitcast i8* %xlv_targ51 to %struct.sv**
  store %struct.sv* null, %struct.sv** %24, align 8, !tbaa !82
  store %struct.sv* null, %struct.sv** @PL_Sv, align 8, !tbaa !16
  br label %land.end

if.else52:                                        ; preds = %cond.end46, %if.else32
  %25 = phi i8* [ %0, %if.else32 ], [ %23, %cond.end46 ]
  %xlv_targoff55 = getelementptr inbounds i8* %25, i64 56
  %26 = bitcast i8* %xlv_targoff55 to i64*
  %27 = load i64* %26, align 8, !tbaa !112
  %call56 = call %struct.sv** @Perl_av_fetch(%struct.av* %17, i64 %27, i64 1) #4
  %tobool57 = icmp eq %struct.sv** %call56, null
  br i1 %tobool57, label %if.then60, label %lor.lhs.false58

lor.lhs.false58:                                  ; preds = %if.else52
  %28 = load %struct.sv** %call56, align 8, !tbaa !16
  %cmp59 = icmp eq %struct.sv* %28, @PL_sv_undef
  br i1 %cmp59, label %if.then60, label %if.end65

if.then60:                                        ; preds = %if.else52, %lor.lhs.false58
  %value.1 = phi %struct.sv* [ @PL_sv_undef, %lor.lhs.false58 ], [ null, %if.else52 ]
  %29 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targoff62 = getelementptr inbounds i8* %29, i64 56
  %30 = bitcast i8* %xlv_targoff62 to i64*
  %31 = load i64* %30, align 8, !tbaa !112
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([0 x i8]* @PL_no_aelem, i64 0, i64 0), i64 %31) #4
  br label %if.end65

if.end65:                                         ; preds = %if.then60, %lor.lhs.false58, %cond.end, %if.end16
  %value.2 = phi %struct.sv* [ %value.0112, %cond.end ], [ %value.0, %if.end16 ], [ %value.1, %if.then60 ], [ %28, %lor.lhs.false58 ]
  store %struct.sv* %value.2, %struct.sv** @PL_Sv, align 8, !tbaa !16
  %tobool66 = icmp eq %struct.sv* %value.2, null
  br i1 %tobool66, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end65
  %sv_refcnt = getelementptr inbounds %struct.sv* %value.2, i64 0, i32 1
  %32 = load i64* %sv_refcnt, align 8, !tbaa !17
  %inc = add i64 %32, 1
  store i64 %inc, i64* %sv_refcnt, align 8, !tbaa !17
  br label %land.end

land.end:                                         ; preds = %if.end65.thread, %if.end65, %land.rhs
  %value.2114 = phi %struct.sv* [ null, %if.end65.thread ], [ null, %if.end65 ], [ %value.2, %land.rhs ]
  %33 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targ69 = getelementptr inbounds i8* %33, i64 72
  %34 = bitcast i8* %xlv_targ69 to %struct.sv**
  %35 = load %struct.sv** %34, align 8, !tbaa !82
  call void @Perl_sv_free(%struct.sv* %35) #4
  %36 = load i8** %sv_any, align 8, !tbaa !1
  %xlv_targ71 = getelementptr inbounds i8* %36, i64 72
  %37 = bitcast i8* %xlv_targ71 to %struct.sv**
  store %struct.sv* %value.2114, %struct.sv** %37, align 8, !tbaa !82
  %xlv_targlen73 = getelementptr inbounds i8* %36, i64 64
  %38 = bitcast i8* %xlv_targlen73 to i64*
  store i64 0, i64* %38, align 8, !tbaa !113
  %39 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  call void @Perl_sv_free(%struct.sv* %39) #4
  store %struct.sv* null, %struct.sv** %mg_obj, align 8, !tbaa !37
  %mg_flags = getelementptr inbounds %struct.magic* %mg.010.i, i64 0, i32 4
  %40 = load i8* %mg_flags, align 1, !tbaa !12
  %and76 = and i8 %40, -3
  store i8 %and76, i8* %mg_flags, align 1, !tbaa !12
  br label %return

return:                                           ; preds = %for.cond.i, %if.end.i, %entry, %land.end
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_killbackrefs(%struct.sv* nocapture readnone %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %mg_obj = getelementptr inbounds %struct.magic* %mg, i64 0, i32 5
  %0 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  %sv_any = bitcast %struct.sv* %0 to %struct.xpvav**
  %1 = load %struct.xpvav** %sv_any, align 8, !tbaa !97
  %xav_array = getelementptr inbounds %struct.xpvav* %1, i64 0, i32 0
  %2 = load i8** %xav_array, align 8, !tbaa !99
  %3 = bitcast i8* %2 to %struct.sv**
  %xav_fill = getelementptr inbounds %struct.xpvav* %1, i64 0, i32 1
  %4 = load i64* %xav_fill, align 8, !tbaa !33
  %cmp39 = icmp sgt i64 %4, -1
  br i1 %cmp39, label %while.body, label %while.end

while.body:                                       ; preds = %entry, %if.end20
  %i.040 = phi i64 [ %dec, %if.end20 ], [ %4, %entry ]
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %i.040
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !16
  %tobool = icmp eq %struct.sv* %5, null
  br i1 %tobool, label %if.end20, label %if.then

if.then:                                          ; preds = %while.body
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %6, 2148007936
  %cmp3 = icmp eq i64 %and, 2148007936
  br i1 %cmp3, label %if.end, label %if.then4

if.then4:                                         ; preds = %if.then
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([26 x i8]* @.str33, i64 0, i64 0)) #4
  %.pre = load %struct.sv** %arrayidx, align 8, !tbaa !16
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %7 = phi %struct.sv* [ %.pre, %if.then4 ], [ %5, %if.then ]
  %sv_any6 = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %8 = load i8** %sv_any6, align 8, !tbaa !1
  %xrv_rv = bitcast i8* %8 to %struct.sv**
  store %struct.sv* null, %struct.sv** %xrv_rv, align 8, !tbaa !103
  %9 = load %struct.sv** %arrayidx, align 8, !tbaa !16
  %sv_flags8 = getelementptr inbounds %struct.sv* %9, i64 0, i32 2
  %10 = load i64* %sv_flags8, align 8, !tbaa !13
  %and9 = and i64 %10, 1223753727
  store i64 %and9, i64* %sv_flags8, align 8, !tbaa !13
  %and12 = and i64 %10, 2097152
  %tobool13 = icmp eq i64 %and12, 0
  br i1 %tobool13, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end
  %call = tail call i32 @Perl_sv_backoff(%struct.sv* %9) #4
  %.pre41 = load %struct.sv** %arrayidx, align 8, !tbaa !16
  %sv_flags17.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre41, i64 0, i32 2
  %.pre42 = load i64* %sv_flags17.phi.trans.insert, align 8, !tbaa !13
  br label %land.end

land.end:                                         ; preds = %if.end, %land.rhs
  %11 = phi i64 [ %and9, %if.end ], [ %.pre42, %land.rhs ]
  %12 = phi %struct.sv* [ %9, %if.end ], [ %.pre41, %land.rhs ]
  %sv_flags17 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %and18 = and i64 %11, 2146959359
  store i64 %and18, i64* %sv_flags17, align 8, !tbaa !13
  store %struct.sv* null, %struct.sv** %arrayidx, align 8, !tbaa !16
  br label %if.end20

if.end20:                                         ; preds = %while.body, %land.end
  %dec = add nsw i64 %i.040, -1
  %cmp = icmp sgt i64 %i.040, 0
  br i1 %cmp, label %while.body, label %while.end

while.end:                                        ; preds = %if.end20, %entry
  tail call void @Perl_sv_free(%struct.sv* %0) #4
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setmglob(%struct.sv* nocapture %sv, %struct.magic* nocapture %mg) #0 {
entry:
  %mg_len = getelementptr inbounds %struct.magic* %mg, i64 0, i32 7
  store i64 -1, i64* %mg_len, align 8, !tbaa !40
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %0, -134217729
  store i64 %and, i64* %sv_flags, align 8, !tbaa !13
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setbm(%struct.sv* %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %call = tail call i32 @Perl_sv_unmagic(%struct.sv* %sv, i32 66) #4
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %0, 2147483647
  store i64 %and, i64* %sv_flags, align 8, !tbaa !13
  ret i32 0
}

declare i32 @Perl_sv_unmagic(%struct.sv*, i32) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setfm(%struct.sv* %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %call = tail call i32 @Perl_sv_unmagic(%struct.sv* %sv, i32 102) #4
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %0, 2147483647
  store i64 %and, i64* %sv_flags, align 8, !tbaa !13
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setuvar(%struct.sv* %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %mg_ptr = getelementptr inbounds %struct.magic* %mg, i64 0, i32 6
  %0 = load i8** %mg_ptr, align 8, !tbaa !39
  %tobool = icmp eq i8* %0, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %uf_set = getelementptr inbounds i8* %0, i64 8
  %1 = bitcast i8* %uf_set to i64 (i64, %struct.sv*)**
  %2 = load i64 (i64, %struct.sv*)** %1, align 8, !tbaa !114
  %tobool1 = icmp eq i64 (i64, %struct.sv*)* %2, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %uf_index = getelementptr inbounds i8* %0, i64 16
  %3 = bitcast i8* %uf_index to i64*
  %4 = load i64* %3, align 8, !tbaa !78
  %call = tail call i64 %2(i64 %4, %struct.sv* %sv) #4
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry, %if.then
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setregexp(%struct.sv* %sv, %struct.magic* nocapture readnone %mg) #0 {
entry:
  %call = tail call i32 @Perl_sv_unmagic(%struct.sv* %sv, i32 114) #4
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_freeregexp(%struct.sv* nocapture readnone %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %mg_obj = getelementptr inbounds %struct.magic* %mg, i64 0, i32 5
  %0 = load %struct.sv** %mg_obj, align 8, !tbaa !37
  %1 = bitcast %struct.sv* %0 to %struct.regexp*
  %2 = load void (%struct.regexp*)** @PL_regfree, align 8, !tbaa !16
  tail call void %2(%struct.regexp* %1) #4
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_setutf8(%struct.sv* nocapture readnone %sv, %struct.magic* nocapture %mg) #0 {
entry:
  %mg_ptr = getelementptr inbounds %struct.magic* %mg, i64 0, i32 6
  %0 = load i8** %mg_ptr, align 8, !tbaa !39
  tail call void @Perl_safesysfree(i8* %0) #4
  store i8* null, i8** %mg_ptr, align 8, !tbaa !39
  %mg_len = getelementptr inbounds %struct.magic* %mg, i64 0, i32 7
  store i64 -1, i64* %mg_len, align 8, !tbaa !40
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_set(%struct.sv* %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %len = alloca i64, align 8
  %len185 = alloca i64, align 8
  %mg_ptr = getelementptr inbounds %struct.magic* %mg, i64 0, i32 6
  %0 = load i8** %mg_ptr, align 8, !tbaa !39
  %1 = load i8* %0, align 1, !tbaa !50
  %conv = sext i8 %1 to i32
  switch i32 %conv, label %sw.epilog [
    i32 1, label %sw.bb
    i32 3, label %sw.bb1
    i32 4, label %sw.bb3
    i32 5, label %sw.bb14
    i32 6, label %sw.bb49
    i32 8, label %sw.bb60
    i32 9, label %sw.bb71
    i32 15, label %sw.bb82
    i32 16, label %sw.bb113
    i32 20, label %sw.bb129
    i32 23, label %sw.bb140
    i32 46, label %sw.bb250
    i32 94, label %sw.bb293
    i32 126, label %sw.bb309
    i32 61, label %sw.bb325
    i32 45, label %sw.bb340
    i32 37, label %sw.bb369
    i32 124, label %sw.bb384
    i32 42, label %sw.bb427
    i32 47, label %sw.bb440
    i32 92, label %sw.bb442
    i32 44, label %sw.bb457
    i32 35, label %sw.bb472
    i32 91, label %sw.bb477
    i32 63, label %sw.bb488
    i32 33, label %sw.bb504
    i32 60, label %sw.bb524
    i32 62, label %sw.bb556
    i32 40, label %sw.bb593
    i32 41, label %sw.bb630
    i32 58, label %sw.bb667
    i32 48, label %sw.bb681
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.sv** @PL_bodytarget, align 8, !tbaa !16
  call void @Perl_sv_setsv_flags(%struct.sv* %2, %struct.sv* %sv, i64 2) #4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %3 = load i64* %sv_flags, align 8, !tbaa !13
  %and = and i64 %3, 65536
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %sw.bb1
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %4 = load i8** %sv_any, align 8, !tbaa !1
  %xiv_iv = getelementptr inbounds i8* %4, i64 24
  %5 = bitcast i8* %xiv_iv to i64*
  %6 = load i64* %5, align 8, !tbaa !89
  br label %cond.end

cond.false:                                       ; preds = %sw.bb1
  %call = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %6, %cond.true ], [ %call, %cond.false ]
  %conv2 = trunc i64 %cond to i8
  store i8 %conv2, i8* @PL_minus_c, align 1, !tbaa !50
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %sv_flags4 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %7 = load i64* %sv_flags4, align 8, !tbaa !13
  %and5 = and i64 %7, 65536
  %tobool6 = icmp eq i64 %and5, 0
  br i1 %tobool6, label %cond.false10, label %cond.true7

cond.true7:                                       ; preds = %sw.bb3
  %sv_any8 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %8 = load i8** %sv_any8, align 8, !tbaa !1
  %xiv_iv9 = getelementptr inbounds i8* %8, i64 24
  %9 = bitcast i8* %xiv_iv9 to i64*
  %10 = load i64* %9, align 8, !tbaa !89
  br label %cond.end12

cond.false10:                                     ; preds = %sw.bb3
  %call11 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end12

cond.end12:                                       ; preds = %cond.false10, %cond.true7
  %cond13 = phi i64 [ %10, %cond.true7 ], [ %call11, %cond.false10 ]
  %or = or i64 %cond13, 2147483648
  store volatile i64 %or, i64* @PL_debug, align 8, !tbaa !25
  br label %sw.epilog

sw.bb14:                                          ; preds = %entry
  %add.ptr = getelementptr inbounds i8* %0, i64 1
  %11 = load i8* %add.ptr, align 1, !tbaa !50
  %cmp = icmp eq i8 %11, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb14
  %sv_flags18 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %12 = load i64* %sv_flags18, align 8, !tbaa !13
  %and19 = and i64 %12, 65536
  %tobool20 = icmp eq i64 %and19, 0
  br i1 %tobool20, label %cond.false24, label %cond.true21

cond.true21:                                      ; preds = %if.then
  %sv_any22 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %13 = load i8** %sv_any22, align 8, !tbaa !1
  %xiv_iv23 = getelementptr inbounds i8* %13, i64 24
  %14 = bitcast i8* %xiv_iv23 to i64*
  %15 = load i64* %14, align 8, !tbaa !89
  br label %cond.end26

cond.false24:                                     ; preds = %if.then
  %call25 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false24, %cond.true21
  %cond27 = phi i64 [ %15, %cond.true21 ], [ %call25, %cond.false24 ]
  %conv28 = trunc i64 %cond27 to i32
  %call29 = call i32* @__errno_location() #4
  store i32 %conv28, i32* %call29, align 4, !tbaa !54
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb14
  %call32 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([8 x i8]* @.str3, i64 0, i64 0)) #4
  %tobool33 = icmp eq i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %sw.epilog

if.then34:                                        ; preds = %if.else
  %16 = load %struct.sv** @PL_encoding, align 8, !tbaa !16
  %tobool35 = icmp eq %struct.sv* %16, null
  br i1 %tobool35, label %if.end, label %if.then36

if.then36:                                        ; preds = %if.then34
  call void @Perl_sv_free(%struct.sv* %16) #4
  br label %if.end

if.end:                                           ; preds = %if.then34, %if.then36
  %sv_flags37 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %17 = load i64* %sv_flags37, align 8, !tbaa !13
  %18 = and i64 %17, 118431744
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %if.else45, label %if.then43

if.then43:                                        ; preds = %if.end
  %call44 = call %struct.sv* @Perl_newSVsv(%struct.sv* %sv) #4
  store %struct.sv* %call44, %struct.sv** @PL_encoding, align 8, !tbaa !16
  br label %sw.epilog

if.else45:                                        ; preds = %if.end
  store %struct.sv* null, %struct.sv** @PL_encoding, align 8, !tbaa !16
  br label %sw.epilog

sw.bb49:                                          ; preds = %entry
  %sv_flags50 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %20 = load i64* %sv_flags50, align 8, !tbaa !13
  %and51 = and i64 %20, 65536
  %tobool52 = icmp eq i64 %and51, 0
  br i1 %tobool52, label %cond.false56, label %cond.true53

cond.true53:                                      ; preds = %sw.bb49
  %sv_any54 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %21 = load i8** %sv_any54, align 8, !tbaa !1
  %xiv_iv55 = getelementptr inbounds i8* %21, i64 24
  %22 = bitcast i8* %xiv_iv55 to i64*
  %23 = load i64* %22, align 8, !tbaa !89
  br label %cond.end58

cond.false56:                                     ; preds = %sw.bb49
  %call57 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end58

cond.end58:                                       ; preds = %cond.false56, %cond.true53
  %cond59 = phi i64 [ %23, %cond.true53 ], [ %call57, %cond.false56 ]
  store i64 %cond59, i64* @PL_maxsysfd, align 8, !tbaa !25
  br label %sw.epilog

sw.bb60:                                          ; preds = %entry
  %sv_flags61 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %24 = load i64* %sv_flags61, align 8, !tbaa !13
  %and62 = and i64 %24, 65536
  %tobool63 = icmp eq i64 %and62, 0
  br i1 %tobool63, label %cond.false67, label %cond.true64

cond.true64:                                      ; preds = %sw.bb60
  %sv_any65 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %25 = load i8** %sv_any65, align 8, !tbaa !1
  %xiv_iv66 = getelementptr inbounds i8* %25, i64 24
  %26 = bitcast i8* %xiv_iv66 to i64*
  %27 = load i64* %26, align 8, !tbaa !89
  br label %cond.end69

cond.false67:                                     ; preds = %sw.bb60
  %call68 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end69

cond.end69:                                       ; preds = %cond.false67, %cond.true64
  %cond70 = phi i64 [ %27, %cond.true64 ], [ %call68, %cond.false67 ]
  store i64 %cond70, i64* @PL_hints, align 8, !tbaa !25
  br label %sw.epilog

sw.bb71:                                          ; preds = %entry
  %28 = load i8** @PL_inplace, align 8, !tbaa !16
  %tobool72 = icmp eq i8* %28, null
  br i1 %tobool72, label %if.end74, label %if.then73

if.then73:                                        ; preds = %sw.bb71
  call void @Perl_safesysfree(i8* %28) #4
  br label %if.end74

if.end74:                                         ; preds = %sw.bb71, %if.then73
  %sv_flags75 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %29 = load i64* %sv_flags75, align 8, !tbaa !13
  %and76 = and i64 %29, 118423552
  %tobool77 = icmp eq i64 %and76, 0
  br i1 %tobool77, label %if.else80, label %if.then78

if.then78:                                        ; preds = %if.end74
  %call79 = call i8* @Perl_savesvpv(%struct.sv* %sv) #4
  store i8* %call79, i8** @PL_inplace, align 8, !tbaa !16
  br label %sw.epilog

if.else80:                                        ; preds = %if.end74
  store i8* null, i8** @PL_inplace, align 8, !tbaa !16
  br label %sw.epilog

sw.bb82:                                          ; preds = %entry
  %add.ptr84 = getelementptr inbounds i8* %0, i64 1
  %30 = load i8* %add.ptr84, align 1, !tbaa !50
  %cmp86 = icmp eq i8 %30, 0
  br i1 %cmp86, label %if.then88, label %if.else101

if.then88:                                        ; preds = %sw.bb82
  %31 = load i8** @PL_osname, align 8, !tbaa !16
  %tobool89 = icmp eq i8* %31, null
  br i1 %tobool89, label %if.end91, label %if.then90

if.then90:                                        ; preds = %if.then88
  call void @Perl_safesysfree(i8* %31) #4
  store i8* null, i8** @PL_osname, align 8, !tbaa !16
  br label %if.end91

if.end91:                                         ; preds = %if.then88, %if.then90
  %sv_flags92 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %32 = load i64* %sv_flags92, align 8, !tbaa !13
  %and93 = and i64 %32, 118423552
  %tobool94 = icmp eq i64 %and93, 0
  br i1 %tobool94, label %sw.epilog, label %if.then95

if.then95:                                        ; preds = %if.end91
  %33 = load i8* @PL_tainting, align 1, !tbaa !50
  %tobool96 = icmp eq i8 %33, 0
  br i1 %tobool96, label %if.end98, label %if.then97

if.then97:                                        ; preds = %if.then95
  call void @Perl_taint_proper(i8* null, i8* getelementptr inbounds ([17 x i8]* @.str34, i64 0, i64 0)) #4
  br label %if.end98

if.end98:                                         ; preds = %if.then95, %if.then97
  %call99 = call i8* @Perl_savesvpv(%struct.sv* %sv) #4
  store i8* %call99, i8** @PL_osname, align 8, !tbaa !16
  br label %sw.epilog

if.else101:                                       ; preds = %sw.bb82
  %call103 = call i32 @strcmp(i8* %0, i8* getelementptr inbounds ([5 x i8]* @.str4, i64 0, i64 0)) #4
  %tobool104 = icmp eq i32 %call103, 0
  br i1 %tobool104, label %if.then105, label %sw.epilog

if.then105:                                       ; preds = %if.else101
  %34 = load %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 15), align 8, !tbaa !56
  %tobool106 = icmp eq %struct.sv* %34, null
  br i1 %tobool106, label %if.then107, label %if.else109

if.then107:                                       ; preds = %if.then105
  %call108 = call %struct.sv* @Perl_newSVsv(%struct.sv* %sv) #4
  store %struct.sv* %call108, %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 15), align 8, !tbaa !56
  br label %sw.epilog

if.else109:                                       ; preds = %if.then105
  call void @Perl_sv_setsv_flags(%struct.sv* %34, %struct.sv* %sv, i64 2) #4
  br label %sw.epilog

sw.bb113:                                         ; preds = %entry
  %sv_flags114 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %35 = load i64* %sv_flags114, align 8, !tbaa !13
  %and115 = and i64 %35, 65536
  %tobool116 = icmp eq i64 %and115, 0
  br i1 %tobool116, label %cond.false120, label %cond.true117

cond.true117:                                     ; preds = %sw.bb113
  %sv_any118 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %36 = load i8** %sv_any118, align 8, !tbaa !1
  %xiv_iv119 = getelementptr inbounds i8* %36, i64 24
  %37 = bitcast i8* %xiv_iv119 to i64*
  %38 = load i64* %37, align 8, !tbaa !89
  br label %cond.end122

cond.false120:                                    ; preds = %sw.bb113
  %call121 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end122

cond.end122:                                      ; preds = %cond.false120, %cond.true117
  %cond123 = phi i64 [ %38, %cond.true117 ], [ %call121, %cond.false120 ]
  store i64 %cond123, i64* @PL_perldb, align 8, !tbaa !25
  %tobool124 = icmp eq i64 %cond123, 0
  %39 = load %struct.sv** @PL_DBsingle, align 8
  %tobool125 = icmp ne %struct.sv* %39, null
  %or.cond = or i1 %tobool124, %tobool125
  br i1 %or.cond, label %sw.epilog, label %if.then126

if.then126:                                       ; preds = %cond.end122
  %call127 = call i32 (...)* @init_debugger() #4
  br label %sw.epilog

sw.bb129:                                         ; preds = %entry
  %sv_flags130 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %40 = load i64* %sv_flags130, align 8, !tbaa !13
  %and131 = and i64 %40, 65536
  %tobool132 = icmp eq i64 %and131, 0
  br i1 %tobool132, label %cond.false136, label %cond.true133

cond.true133:                                     ; preds = %sw.bb129
  %sv_any134 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %41 = load i8** %sv_any134, align 8, !tbaa !1
  %xiv_iv135 = getelementptr inbounds i8* %41, i64 24
  %42 = bitcast i8* %xiv_iv135 to i64*
  %43 = load i64* %42, align 8, !tbaa !89
  br label %cond.end138

cond.false136:                                    ; preds = %sw.bb129
  %call137 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end138

cond.end138:                                      ; preds = %cond.false136, %cond.true133
  %cond139 = phi i64 [ %43, %cond.true133 ], [ %call137, %cond.false136 ]
  store i64 %cond139, i64* @PL_basetime, align 8, !tbaa !25
  br label %sw.epilog

sw.bb140:                                         ; preds = %entry
  %add.ptr142 = getelementptr inbounds i8* %0, i64 1
  %44 = load i8* %add.ptr142, align 1, !tbaa !50
  %cmp144 = icmp eq i8 %44, 0
  br i1 %cmp144, label %if.then146, label %if.else168

if.then146:                                       ; preds = %sw.bb140
  %45 = load i8* @PL_dowarn, align 1, !tbaa !50
  %and148 = and i8 %45, 6
  %tobool149 = icmp eq i8 %and148, 0
  br i1 %tobool149, label %if.then150, label %sw.epilog

if.then150:                                       ; preds = %if.then146
  %sv_flags151 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %46 = load i64* %sv_flags151, align 8, !tbaa !13
  %and152 = and i64 %46, 65536
  %tobool153 = icmp eq i64 %and152, 0
  br i1 %tobool153, label %cond.false157, label %cond.true154

cond.true154:                                     ; preds = %if.then150
  %sv_any155 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %47 = load i8** %sv_any155, align 8, !tbaa !1
  %xiv_iv156 = getelementptr inbounds i8* %47, i64 24
  %48 = bitcast i8* %xiv_iv156 to i64*
  %49 = load i64* %48, align 8, !tbaa !89
  br label %cond.end159

cond.false157:                                    ; preds = %if.then150
  %call158 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  %.pre = load i8* @PL_dowarn, align 1, !tbaa !50
  br label %cond.end159

cond.end159:                                      ; preds = %cond.false157, %cond.true154
  %50 = phi i8 [ %45, %cond.true154 ], [ %.pre, %cond.false157 ]
  %cond160 = phi i64 [ %49, %cond.true154 ], [ %call158, %cond.false157 ]
  %and162 = and i8 %50, -2
  %tobool163 = icmp ne i64 %cond160, 0
  %cond164 = zext i1 %tobool163 to i8
  %or165 = or i8 %and162, %cond164
  store i8 %or165, i8* @PL_dowarn, align 1, !tbaa !50
  br label %sw.epilog

if.else168:                                       ; preds = %sw.bb140
  %call171 = call i32 @strcmp(i8* %add.ptr142, i8* getelementptr inbounds ([12 x i8]* @.str8, i64 0, i64 0)) #4
  %tobool172 = icmp eq i32 %call171, 0
  br i1 %tobool172, label %if.then173, label %sw.epilog

if.then173:                                       ; preds = %if.else168
  %51 = load i8* @PL_dowarn, align 1, !tbaa !50
  %and175 = and i8 %51, 6
  %tobool176 = icmp eq i8 %and175, 0
  br i1 %tobool176, label %if.then177, label %sw.epilog

if.then177:                                       ; preds = %if.then173
  %sv_flags178 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %52 = load i64* %sv_flags178, align 8, !tbaa !13
  %and179 = and i64 %52, 262144
  %tobool180 = icmp eq i64 %and179, 0
  %53 = load i32* @PL_localizing, align 4
  %tobool182 = icmp ne i32 %53, 0
  %or.cond721 = and i1 %tobool180, %tobool182
  br i1 %or.cond721, label %if.then183, label %if.end184

if.then183:                                       ; preds = %if.then177
  call void @Perl_sv_setpvn(%struct.sv* %sv, i8* getelementptr inbounds ([13 x i8]* @.str9, i64 0, i64 0), i64 12) #4
  store %struct.sv* inttoptr (i64 48 to %struct.sv*), %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !51
  br label %sw.epilog

if.end184:                                        ; preds = %if.then177
  br i1 %tobool180, label %cond.false194, label %cond.true191

cond.true191:                                     ; preds = %if.end184
  %sv_any192 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %54 = load i8** %sv_any192, align 8, !tbaa !1
  %xpv_cur = getelementptr inbounds i8* %54, i64 8
  %55 = bitcast i8* %xpv_cur to i64*
  %56 = load i64* %55, align 8, !tbaa !30
  store i64 %56, i64* %len185, align 8, !tbaa !25
  %xpv_pv = bitcast i8* %54 to i8**
  %57 = load i8** %xpv_pv, align 8, !tbaa !32
  br label %cond.end196

cond.false194:                                    ; preds = %if.end184
  %call195 = call i8* @Perl_sv_2pv_flags(%struct.sv* %sv, i64* %len185, i64 2) #4
  %.pre844 = load i64* %len185, align 8, !tbaa !25
  br label %cond.end196

cond.end196:                                      ; preds = %cond.false194, %cond.true191
  %58 = phi i64 [ %56, %cond.true191 ], [ %.pre844, %cond.false194 ]
  %cond197 = phi i8* [ %57, %cond.true191 ], [ %call195, %cond.false194 ]
  %cmp198836 = icmp eq i64 %58, 0
  br i1 %cmp198836, label %if.then207, label %for.body

for.body:                                         ; preds = %cond.end196, %for.body
  %i186.0839 = phi i64 [ %inc, %for.body ], [ 0, %cond.end196 ]
  %any_fatals.0838 = phi i32 [ %or205, %for.body ], [ 0, %cond.end196 ]
  %accumulate.0837 = phi i32 [ %or201, %for.body ], [ 0, %cond.end196 ]
  %arrayidx = getelementptr inbounds i8* %cond197, i64 %i186.0839
  %59 = load i8* %arrayidx, align 1, !tbaa !50
  %conv200 = sext i8 %59 to i32
  %or201 = or i32 %conv200, %accumulate.0837
  %and204 = and i32 %conv200, 170
  %or205 = or i32 %and204, %any_fatals.0838
  %inc = add i64 %i186.0839, 1
  %cmp198 = icmp ult i64 %inc, %58
  br i1 %cmp198, label %for.body, label %for.end

for.end:                                          ; preds = %for.body
  %phitmp = icmp eq i32 %or201, 0
  br i1 %phitmp, label %if.then207, label %if.else208

if.then207:                                       ; preds = %cond.end196, %for.end
  store %struct.sv* inttoptr (i64 48 to %struct.sv*), %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !51
  br label %sw.epilog

if.else208:                                       ; preds = %for.end
  %sv_any209 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %60 = load i8** %sv_any209, align 8, !tbaa !1
  %xpv_pv210 = bitcast i8* %60 to i8**
  %61 = load i8** %xpv_pv210, align 8, !tbaa !32
  %62 = load i8* %61, align 1, !tbaa !50
  %and213 = and i8 %62, 1
  %tobool214 = icmp eq i8 %and213, 0
  %tobool216 = icmp ne i32 %or205, 0
  %or.cond722 = or i1 %tobool214, %tobool216
  br i1 %or.cond722, label %if.else221, label %if.then217

if.then217:                                       ; preds = %if.else208
  store %struct.sv* inttoptr (i64 24 to %struct.sv*), %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !51
  %63 = load i8* @PL_dowarn, align 1, !tbaa !50
  %or219 = or i8 %63, 8
  store i8 %or219, i8* @PL_dowarn, align 1, !tbaa !50
  br label %sw.epilog

if.else221:                                       ; preds = %if.else208
  %64 = load %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !51
  %magicptr = ptrtoint %struct.sv* %64 to i64
  switch i64 %magicptr, label %if.else232 [
    i64 48, label %if.then230
    i64 24, label %if.then230
    i64 0, label %if.then230
  ]

if.then230:                                       ; preds = %if.else221, %if.else221, %if.else221
  %call231 = call %struct.sv* @Perl_newSVsv(%struct.sv* %sv) #4
  store %struct.sv* %call231, %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !51
  br label %if.end233

if.else232:                                       ; preds = %if.else221
  call void @Perl_sv_setsv_flags(%struct.sv* %64, %struct.sv* %sv, i64 2) #4
  %.pre845 = load %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !51
  br label %if.end233

if.end233:                                        ; preds = %if.else232, %if.then230
  %65 = phi %struct.sv* [ %.pre845, %if.else232 ], [ %call231, %if.then230 ]
  %sv_any234 = getelementptr inbounds %struct.sv* %65, i64 0, i32 0
  %66 = load i8** %sv_any234, align 8, !tbaa !1
  %xpv_pv235 = bitcast i8* %66 to i8**
  %67 = load i8** %xpv_pv235, align 8, !tbaa !32
  %arrayidx236 = getelementptr inbounds i8* %67, i64 3
  %68 = load i8* %arrayidx236, align 1, !tbaa !50
  %and238 = and i8 %68, 16
  %tobool239 = icmp eq i8 %and238, 0
  br i1 %tobool239, label %sw.epilog, label %if.then240

if.then240:                                       ; preds = %if.end233
  %69 = load i8* @PL_dowarn, align 1, !tbaa !50
  %or242 = or i8 %69, 8
  store i8 %or242, i8* @PL_dowarn, align 1, !tbaa !50
  br label %sw.epilog

sw.bb250:                                         ; preds = %entry
  %70 = load i32* @PL_localizing, align 4, !tbaa !54
  switch i32 %70, label %sw.epilog [
    i32 0, label %if.else257
    i32 1, label %if.then255
  ]

if.then255:                                       ; preds = %sw.bb250
  call void @Perl_save_sptr(%struct.sv** bitcast (%struct.gv** @PL_last_in_gv to %struct.sv**)) #4
  br label %sw.epilog

if.else257:                                       ; preds = %sw.bb250
  %sv_flags258 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %71 = load i64* %sv_flags258, align 8, !tbaa !13
  %and259 = and i64 %71, 118423552
  %tobool260 = icmp ne i64 %and259, 0
  %72 = load %struct.gv** @PL_last_in_gv, align 8
  %tobool262 = icmp ne %struct.gv* %72, null
  %or.cond725 = and i1 %tobool260, %tobool262
  br i1 %or.cond725, label %land.lhs.true263, label %sw.epilog

land.lhs.true263:                                 ; preds = %if.else257
  %73 = getelementptr inbounds %struct.gv* %72, i64 0, i32 2
  %74 = load i64* %73, align 8, !tbaa !13
  %and265 = and i64 %74, 255
  %cmp266 = icmp eq i64 %and265, 13
  br i1 %cmp266, label %land.lhs.true268, label %sw.epilog

land.lhs.true268:                                 ; preds = %land.lhs.true263
  %sv_any269 = getelementptr inbounds %struct.gv* %72, i64 0, i32 0
  %75 = load %struct.xpvgv** %sv_any269, align 8, !tbaa !57
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %75, i64 0, i32 7
  %76 = load %struct.gp** %xgv_gp, align 8, !tbaa !59
  %tobool270 = icmp eq %struct.gp* %76, null
  br i1 %tobool270, label %sw.epilog, label %cond.true271

cond.true271:                                     ; preds = %land.lhs.true268
  %gp_io = getelementptr inbounds %struct.gp* %76, i64 0, i32 2
  %77 = load %struct.io** %gp_io, align 8, !tbaa !61
  %tobool274 = icmp eq %struct.io* %77, null
  br i1 %tobool274, label %sw.epilog, label %if.then276

if.then276:                                       ; preds = %cond.true271
  %and278 = and i64 %71, 65536
  %tobool279 = icmp eq i64 %and278, 0
  br i1 %tobool279, label %cond.false283, label %cond.true280

cond.true280:                                     ; preds = %if.then276
  %sv_any281 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %78 = load i8** %sv_any281, align 8, !tbaa !1
  %xiv_iv282 = getelementptr inbounds i8* %78, i64 24
  %79 = bitcast i8* %xiv_iv282 to i64*
  %80 = load i64* %79, align 8, !tbaa !89
  br label %cond.end285

cond.false283:                                    ; preds = %if.then276
  %call284 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  %.pre846 = load %struct.gv** @PL_last_in_gv, align 8, !tbaa !16
  %sv_any287.phi.trans.insert = getelementptr inbounds %struct.gv* %.pre846, i64 0, i32 0
  %.pre847 = load %struct.xpvgv** %sv_any287.phi.trans.insert, align 8, !tbaa !57
  %xgv_gp288.phi.trans.insert = getelementptr inbounds %struct.xpvgv* %.pre847, i64 0, i32 7
  %.pre848 = load %struct.gp** %xgv_gp288.phi.trans.insert, align 8, !tbaa !59
  %gp_io289.phi.trans.insert = getelementptr inbounds %struct.gp* %.pre848, i64 0, i32 2
  %.pre849 = load %struct.io** %gp_io289.phi.trans.insert, align 8, !tbaa !61
  br label %cond.end285

cond.end285:                                      ; preds = %cond.false283, %cond.true280
  %81 = phi %struct.io* [ %77, %cond.true280 ], [ %.pre849, %cond.false283 ]
  %cond286 = phi i64 [ %80, %cond.true280 ], [ %call284, %cond.false283 ]
  %sv_any290 = getelementptr inbounds %struct.io* %81, i64 0, i32 0
  %82 = load %struct.xpvio** %sv_any290, align 8, !tbaa !63
  %xio_lines = getelementptr inbounds %struct.xpvio* %82, i64 0, i32 10
  store i64 %cond286, i64* %xio_lines, align 8, !tbaa !65
  br label %sw.epilog

sw.bb293:                                         ; preds = %entry
  %83 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any294 = getelementptr inbounds %struct.gv* %83, i64 0, i32 0
  %84 = load %struct.xpvgv** %sv_any294, align 8, !tbaa !57
  %xgv_gp295 = getelementptr inbounds %struct.xpvgv* %84, i64 0, i32 7
  %85 = load %struct.gp** %xgv_gp295, align 8, !tbaa !59
  %gp_io296 = getelementptr inbounds %struct.gp* %85, i64 0, i32 2
  %86 = load %struct.io** %gp_io296, align 8, !tbaa !61
  %sv_any297 = getelementptr inbounds %struct.io* %86, i64 0, i32 0
  %87 = load %struct.xpvio** %sv_any297, align 8, !tbaa !63
  %xio_top_name = getelementptr inbounds %struct.xpvio* %87, i64 0, i32 14
  %88 = load i8** %xio_top_name, align 8, !tbaa !67
  call void @Perl_safesysfree(i8* %88) #4
  %call298 = call i8* @Perl_savesvpv(%struct.sv* %sv) #4
  %89 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any299 = getelementptr inbounds %struct.gv* %89, i64 0, i32 0
  %90 = load %struct.xpvgv** %sv_any299, align 8, !tbaa !57
  %xgv_gp300 = getelementptr inbounds %struct.xpvgv* %90, i64 0, i32 7
  %91 = load %struct.gp** %xgv_gp300, align 8, !tbaa !59
  %gp_io301 = getelementptr inbounds %struct.gp* %91, i64 0, i32 2
  %92 = load %struct.io** %gp_io301, align 8, !tbaa !61
  %sv_any302 = getelementptr inbounds %struct.io* %92, i64 0, i32 0
  %93 = load %struct.xpvio** %sv_any302, align 8, !tbaa !63
  %xio_top_name303 = getelementptr inbounds %struct.xpvio* %93, i64 0, i32 14
  store i8* %call298, i8** %xio_top_name303, align 8, !tbaa !67
  %call304 = call %struct.gv* @Perl_gv_fetchpv(i8* %call298, i64 1, i64 15) #4
  %94 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any305 = getelementptr inbounds %struct.gv* %94, i64 0, i32 0
  %95 = load %struct.xpvgv** %sv_any305, align 8, !tbaa !57
  %xgv_gp306 = getelementptr inbounds %struct.xpvgv* %95, i64 0, i32 7
  %96 = load %struct.gp** %xgv_gp306, align 8, !tbaa !59
  %gp_io307 = getelementptr inbounds %struct.gp* %96, i64 0, i32 2
  %97 = load %struct.io** %gp_io307, align 8, !tbaa !61
  %sv_any308 = getelementptr inbounds %struct.io* %97, i64 0, i32 0
  %98 = load %struct.xpvio** %sv_any308, align 8, !tbaa !63
  %xio_top_gv = getelementptr inbounds %struct.xpvio* %98, i64 0, i32 15
  store %struct.gv* %call304, %struct.gv** %xio_top_gv, align 8, !tbaa !115
  br label %sw.epilog

sw.bb309:                                         ; preds = %entry
  %99 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any310 = getelementptr inbounds %struct.gv* %99, i64 0, i32 0
  %100 = load %struct.xpvgv** %sv_any310, align 8, !tbaa !57
  %xgv_gp311 = getelementptr inbounds %struct.xpvgv* %100, i64 0, i32 7
  %101 = load %struct.gp** %xgv_gp311, align 8, !tbaa !59
  %gp_io312 = getelementptr inbounds %struct.gp* %101, i64 0, i32 2
  %102 = load %struct.io** %gp_io312, align 8, !tbaa !61
  %sv_any313 = getelementptr inbounds %struct.io* %102, i64 0, i32 0
  %103 = load %struct.xpvio** %sv_any313, align 8, !tbaa !63
  %xio_fmt_name = getelementptr inbounds %struct.xpvio* %103, i64 0, i32 16
  %104 = load i8** %xio_fmt_name, align 8, !tbaa !70
  call void @Perl_safesysfree(i8* %104) #4
  %call314 = call i8* @Perl_savesvpv(%struct.sv* %sv) #4
  %105 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any315 = getelementptr inbounds %struct.gv* %105, i64 0, i32 0
  %106 = load %struct.xpvgv** %sv_any315, align 8, !tbaa !57
  %xgv_gp316 = getelementptr inbounds %struct.xpvgv* %106, i64 0, i32 7
  %107 = load %struct.gp** %xgv_gp316, align 8, !tbaa !59
  %gp_io317 = getelementptr inbounds %struct.gp* %107, i64 0, i32 2
  %108 = load %struct.io** %gp_io317, align 8, !tbaa !61
  %sv_any318 = getelementptr inbounds %struct.io* %108, i64 0, i32 0
  %109 = load %struct.xpvio** %sv_any318, align 8, !tbaa !63
  %xio_fmt_name319 = getelementptr inbounds %struct.xpvio* %109, i64 0, i32 16
  store i8* %call314, i8** %xio_fmt_name319, align 8, !tbaa !70
  %call320 = call %struct.gv* @Perl_gv_fetchpv(i8* %call314, i64 1, i64 15) #4
  %110 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any321 = getelementptr inbounds %struct.gv* %110, i64 0, i32 0
  %111 = load %struct.xpvgv** %sv_any321, align 8, !tbaa !57
  %xgv_gp322 = getelementptr inbounds %struct.xpvgv* %111, i64 0, i32 7
  %112 = load %struct.gp** %xgv_gp322, align 8, !tbaa !59
  %gp_io323 = getelementptr inbounds %struct.gp* %112, i64 0, i32 2
  %113 = load %struct.io** %gp_io323, align 8, !tbaa !61
  %sv_any324 = getelementptr inbounds %struct.io* %113, i64 0, i32 0
  %114 = load %struct.xpvio** %sv_any324, align 8, !tbaa !63
  %xio_fmt_gv = getelementptr inbounds %struct.xpvio* %114, i64 0, i32 17
  store %struct.gv* %call320, %struct.gv** %xio_fmt_gv, align 8, !tbaa !116
  br label %sw.epilog

sw.bb325:                                         ; preds = %entry
  %sv_flags326 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %115 = load i64* %sv_flags326, align 8, !tbaa !13
  %and327 = and i64 %115, 65536
  %tobool328 = icmp eq i64 %and327, 0
  br i1 %tobool328, label %cond.false332, label %cond.true329

cond.true329:                                     ; preds = %sw.bb325
  %sv_any330 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %116 = load i8** %sv_any330, align 8, !tbaa !1
  %xiv_iv331 = getelementptr inbounds i8* %116, i64 24
  %117 = bitcast i8* %xiv_iv331 to i64*
  %118 = load i64* %117, align 8, !tbaa !89
  br label %cond.end334

cond.false332:                                    ; preds = %sw.bb325
  %call333 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end334

cond.end334:                                      ; preds = %cond.false332, %cond.true329
  %cond335 = phi i64 [ %118, %cond.true329 ], [ %call333, %cond.false332 ]
  %119 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any336 = getelementptr inbounds %struct.gv* %119, i64 0, i32 0
  %120 = load %struct.xpvgv** %sv_any336, align 8, !tbaa !57
  %xgv_gp337 = getelementptr inbounds %struct.xpvgv* %120, i64 0, i32 7
  %121 = load %struct.gp** %xgv_gp337, align 8, !tbaa !59
  %gp_io338 = getelementptr inbounds %struct.gp* %121, i64 0, i32 2
  %122 = load %struct.io** %gp_io338, align 8, !tbaa !61
  %sv_any339 = getelementptr inbounds %struct.io* %122, i64 0, i32 0
  %123 = load %struct.xpvio** %sv_any339, align 8, !tbaa !63
  %xio_page_len = getelementptr inbounds %struct.xpvio* %123, i64 0, i32 12
  store i64 %cond335, i64* %xio_page_len, align 8, !tbaa !71
  br label %sw.epilog

sw.bb340:                                         ; preds = %entry
  %sv_flags341 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %124 = load i64* %sv_flags341, align 8, !tbaa !13
  %and342 = and i64 %124, 65536
  %tobool343 = icmp eq i64 %and342, 0
  br i1 %tobool343, label %cond.false347, label %cond.true344

cond.true344:                                     ; preds = %sw.bb340
  %sv_any345 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %125 = load i8** %sv_any345, align 8, !tbaa !1
  %xiv_iv346 = getelementptr inbounds i8* %125, i64 24
  %126 = bitcast i8* %xiv_iv346 to i64*
  %127 = load i64* %126, align 8, !tbaa !89
  br label %cond.end349

cond.false347:                                    ; preds = %sw.bb340
  %call348 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end349

cond.end349:                                      ; preds = %cond.false347, %cond.true344
  %cond350 = phi i64 [ %127, %cond.true344 ], [ %call348, %cond.false347 ]
  %128 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any351 = getelementptr inbounds %struct.gv* %128, i64 0, i32 0
  %129 = load %struct.xpvgv** %sv_any351, align 8, !tbaa !57
  %xgv_gp352 = getelementptr inbounds %struct.xpvgv* %129, i64 0, i32 7
  %130 = load %struct.gp** %xgv_gp352, align 8, !tbaa !59
  %gp_io353 = getelementptr inbounds %struct.gp* %130, i64 0, i32 2
  %131 = load %struct.io** %gp_io353, align 8, !tbaa !61
  %sv_any354 = getelementptr inbounds %struct.io* %131, i64 0, i32 0
  %132 = load %struct.xpvio** %sv_any354, align 8, !tbaa !63
  %xio_lines_left = getelementptr inbounds %struct.xpvio* %132, i64 0, i32 13
  %cmp360 = icmp slt i64 %cond350, 0
  %.cond350 = select i1 %cmp360, i64 0, i64 %cond350
  store i64 %.cond350, i64* %xio_lines_left, align 8, !tbaa !72
  ret i32 0

sw.bb369:                                         ; preds = %entry
  %sv_flags370 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %133 = load i64* %sv_flags370, align 8, !tbaa !13
  %and371 = and i64 %133, 65536
  %tobool372 = icmp eq i64 %and371, 0
  br i1 %tobool372, label %cond.false376, label %cond.true373

cond.true373:                                     ; preds = %sw.bb369
  %sv_any374 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %134 = load i8** %sv_any374, align 8, !tbaa !1
  %xiv_iv375 = getelementptr inbounds i8* %134, i64 24
  %135 = bitcast i8* %xiv_iv375 to i64*
  %136 = load i64* %135, align 8, !tbaa !89
  br label %cond.end378

cond.false376:                                    ; preds = %sw.bb369
  %call377 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end378

cond.end378:                                      ; preds = %cond.false376, %cond.true373
  %cond379 = phi i64 [ %136, %cond.true373 ], [ %call377, %cond.false376 ]
  %137 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any380 = getelementptr inbounds %struct.gv* %137, i64 0, i32 0
  %138 = load %struct.xpvgv** %sv_any380, align 8, !tbaa !57
  %xgv_gp381 = getelementptr inbounds %struct.xpvgv* %138, i64 0, i32 7
  %139 = load %struct.gp** %xgv_gp381, align 8, !tbaa !59
  %gp_io382 = getelementptr inbounds %struct.gp* %139, i64 0, i32 2
  %140 = load %struct.io** %gp_io382, align 8, !tbaa !61
  %sv_any383 = getelementptr inbounds %struct.io* %140, i64 0, i32 0
  %141 = load %struct.xpvio** %sv_any383, align 8, !tbaa !63
  %xio_page = getelementptr inbounds %struct.xpvio* %141, i64 0, i32 11
  store i64 %cond379, i64* %xio_page, align 8, !tbaa !73
  br label %sw.epilog

sw.bb384:                                         ; preds = %entry
  %142 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !16
  %sv_any385 = getelementptr inbounds %struct.gv* %142, i64 0, i32 0
  %143 = load %struct.xpvgv** %sv_any385, align 8, !tbaa !57
  %xgv_gp386 = getelementptr inbounds %struct.xpvgv* %143, i64 0, i32 7
  %144 = load %struct.gp** %xgv_gp386, align 8, !tbaa !59
  %gp_io387 = getelementptr inbounds %struct.gp* %144, i64 0, i32 2
  %145 = load %struct.io** %gp_io387, align 8, !tbaa !61
  %tobool388 = icmp eq %struct.io* %145, null
  br i1 %tobool388, label %sw.epilog, label %if.end390

if.end390:                                        ; preds = %sw.bb384
  %sv_flags391 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %146 = load i64* %sv_flags391, align 8, !tbaa !13
  %and392 = and i64 %146, 65536
  %tobool393 = icmp eq i64 %and392, 0
  br i1 %tobool393, label %cond.false397, label %cond.true394

cond.true394:                                     ; preds = %if.end390
  %sv_any395 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %147 = load i8** %sv_any395, align 8, !tbaa !1
  %xiv_iv396 = getelementptr inbounds i8* %147, i64 24
  %148 = bitcast i8* %xiv_iv396 to i64*
  %149 = load i64* %148, align 8, !tbaa !89
  br label %cond.end399

cond.false397:                                    ; preds = %if.end390
  %call398 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end399

cond.end399:                                      ; preds = %cond.false397, %cond.true394
  %cond400 = phi i64 [ %149, %cond.true394 ], [ %call398, %cond.false397 ]
  %cmp401 = icmp eq i64 %cond400, 0
  %sv_any404 = getelementptr inbounds %struct.io* %145, i64 0, i32 0
  %150 = load %struct.xpvio** %sv_any404, align 8, !tbaa !63
  %xio_flags = getelementptr inbounds %struct.xpvio* %150, i64 0, i32 22
  %151 = load i8* %xio_flags, align 1, !tbaa !75
  br i1 %cmp401, label %if.then403, label %if.else408

if.then403:                                       ; preds = %cond.end399
  %and406 = and i8 %151, -5
  store i8 %and406, i8* %xio_flags, align 1, !tbaa !75
  br label %sw.epilog

if.else408:                                       ; preds = %cond.end399
  %and412 = and i8 %151, 4
  %tobool413 = icmp eq i8 %and412, 0
  br i1 %tobool413, label %if.then414, label %sw.epilog

if.then414:                                       ; preds = %if.else408
  %xio_ofp = getelementptr inbounds %struct.xpvio* %150, i64 0, i32 8
  %152 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !102
  %tobool416 = icmp eq %struct._PerlIO** %152, null
  br i1 %tobool416, label %if.end419, label %if.then417

if.then417:                                       ; preds = %if.then414
  %call418 = call i32 @Perl_PerlIO_flush(%struct._PerlIO** %152) #4
  %.pre850 = load %struct.xpvio** %sv_any404, align 8, !tbaa !63
  %xio_flags421.phi.trans.insert = getelementptr inbounds %struct.xpvio* %.pre850, i64 0, i32 22
  %.pre851 = load i8* %xio_flags421.phi.trans.insert, align 1, !tbaa !75
  br label %if.end419

if.end419:                                        ; preds = %if.then414, %if.then417
  %153 = phi i8 [ %151, %if.then414 ], [ %.pre851, %if.then417 ]
  %154 = phi %struct.xpvio* [ %150, %if.then414 ], [ %.pre850, %if.then417 ]
  %xio_flags421 = getelementptr inbounds %struct.xpvio* %154, i64 0, i32 22
  %or423 = or i8 %153, 4
  store i8 %or423, i8* %xio_flags421, align 1, !tbaa !75
  br label %sw.epilog

sw.bb427:                                         ; preds = %entry
  %sv_flags428 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %155 = load i64* %sv_flags428, align 8, !tbaa !13
  %and429 = and i64 %155, 65536
  %tobool430 = icmp eq i64 %and429, 0
  br i1 %tobool430, label %cond.false434, label %cond.true431

cond.true431:                                     ; preds = %sw.bb427
  %sv_any432 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %156 = load i8** %sv_any432, align 8, !tbaa !1
  %xiv_iv433 = getelementptr inbounds i8* %156, i64 24
  %157 = bitcast i8* %xiv_iv433 to i64*
  %158 = load i64* %157, align 8, !tbaa !89
  br label %cond.end436

cond.false434:                                    ; preds = %sw.bb427
  %call435 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end436

cond.end436:                                      ; preds = %cond.false434, %cond.true431
  %cond437 = phi i64 [ %158, %cond.true431 ], [ %call435, %cond.false434 ]
  %cmp438 = icmp ne i64 %cond437, 0
  %conv439 = zext i1 %cmp438 to i32
  store i32 %conv439, i32* @PL_multiline, align 4, !tbaa !54
  br label %sw.epilog

sw.bb440:                                         ; preds = %entry
  %159 = load %struct.sv** @PL_rs, align 8, !tbaa !16
  call void @Perl_sv_free(%struct.sv* %159) #4
  %call441 = call %struct.sv* @Perl_newSVsv(%struct.sv* %sv) #4
  store %struct.sv* %call441, %struct.sv** @PL_rs, align 8, !tbaa !16
  br label %sw.epilog

sw.bb442:                                         ; preds = %entry
  %160 = load %struct.sv** @PL_ors_sv, align 8, !tbaa !16
  %tobool443 = icmp eq %struct.sv* %160, null
  br i1 %tobool443, label %if.end445, label %if.then444

if.then444:                                       ; preds = %sw.bb442
  call void @Perl_sv_free(%struct.sv* %160) #4
  br label %if.end445

if.end445:                                        ; preds = %sw.bb442, %if.then444
  %sv_flags446 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %161 = load i64* %sv_flags446, align 8, !tbaa !13
  %162 = and i64 %161, 118431744
  %163 = icmp eq i64 %162, 0
  br i1 %163, label %if.else455, label %if.then453

if.then453:                                       ; preds = %if.end445
  %call454 = call %struct.sv* @Perl_newSVsv(%struct.sv* %sv) #4
  store %struct.sv* %call454, %struct.sv** @PL_ors_sv, align 8, !tbaa !16
  br label %sw.epilog

if.else455:                                       ; preds = %if.end445
  store %struct.sv* null, %struct.sv** @PL_ors_sv, align 8, !tbaa !16
  br label %sw.epilog

sw.bb457:                                         ; preds = %entry
  %164 = load %struct.sv** @PL_ofs_sv, align 8, !tbaa !16
  %tobool458 = icmp eq %struct.sv* %164, null
  br i1 %tobool458, label %if.end460, label %if.then459

if.then459:                                       ; preds = %sw.bb457
  call void @Perl_sv_free(%struct.sv* %164) #4
  br label %if.end460

if.end460:                                        ; preds = %sw.bb457, %if.then459
  %sv_flags461 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %165 = load i64* %sv_flags461, align 8, !tbaa !13
  %166 = and i64 %165, 118431744
  %167 = icmp eq i64 %166, 0
  br i1 %167, label %if.else470, label %if.then468

if.then468:                                       ; preds = %if.end460
  %call469 = call %struct.sv* @Perl_newSVsv(%struct.sv* %sv) #4
  store %struct.sv* %call469, %struct.sv** @PL_ofs_sv, align 8, !tbaa !16
  br label %sw.epilog

if.else470:                                       ; preds = %if.end460
  store %struct.sv* null, %struct.sv** @PL_ofs_sv, align 8, !tbaa !16
  br label %sw.epilog

sw.bb472:                                         ; preds = %entry
  %168 = load i8** @PL_ofmt, align 8, !tbaa !16
  %tobool473 = icmp eq i8* %168, null
  br i1 %tobool473, label %if.end475, label %if.then474

if.then474:                                       ; preds = %sw.bb472
  call void @Perl_safesysfree(i8* %168) #4
  br label %if.end475

if.end475:                                        ; preds = %sw.bb472, %if.then474
  %call476 = call i8* @Perl_savesvpv(%struct.sv* %sv) #4
  store i8* %call476, i8** @PL_ofmt, align 8, !tbaa !16
  br label %sw.epilog

sw.bb477:                                         ; preds = %entry
  %sv_flags478 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %169 = load i64* %sv_flags478, align 8, !tbaa !13
  %and479 = and i64 %169, 65536
  %tobool480 = icmp eq i64 %and479, 0
  br i1 %tobool480, label %cond.false484, label %cond.true481

cond.true481:                                     ; preds = %sw.bb477
  %sv_any482 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %170 = load i8** %sv_any482, align 8, !tbaa !1
  %xiv_iv483 = getelementptr inbounds i8* %170, i64 24
  %171 = bitcast i8* %xiv_iv483 to i64*
  %172 = load i64* %171, align 8, !tbaa !89
  br label %cond.end486

cond.false484:                                    ; preds = %sw.bb477
  %call485 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end486

cond.end486:                                      ; preds = %cond.false484, %cond.true481
  %cond487 = phi i64 [ %172, %cond.true481 ], [ %call485, %cond.false484 ]
  store i64 %cond487, i64* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 12), align 8, !tbaa !74
  br label %sw.epilog

sw.bb488:                                         ; preds = %entry
  %sv_flags489 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %173 = load i64* %sv_flags489, align 8, !tbaa !13
  %and490 = and i64 %173, 65536
  %tobool491 = icmp eq i64 %and490, 0
  br i1 %tobool491, label %cond.false495, label %cond.true492

cond.true492:                                     ; preds = %sw.bb488
  %sv_any493 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %174 = load i8** %sv_any493, align 8, !tbaa !1
  %xiv_iv494 = getelementptr inbounds i8* %174, i64 24
  %175 = bitcast i8* %xiv_iv494 to i64*
  %176 = load i64* %175, align 8, !tbaa !89
  br label %cond.end497

cond.false495:                                    ; preds = %sw.bb488
  %call496 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end497

cond.end497:                                      ; preds = %cond.false495, %cond.true492
  %cond498 = phi i64 [ %176, %cond.true492 ], [ %call496, %cond.false495 ]
  store i64 %cond498, i64* @PL_statusvalue, align 8, !tbaa !25
  %cmp499 = icmp eq i64 %cond498, -1
  br i1 %cmp499, label %sw.epilog, label %if.then501

if.then501:                                       ; preds = %cond.end497
  %and502 = and i64 %cond498, 65535
  store i64 %and502, i64* @PL_statusvalue, align 8, !tbaa !25
  br label %sw.epilog

sw.bb504:                                         ; preds = %entry
  %sv_flags505 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %177 = load i64* %sv_flags505, align 8, !tbaa !13
  %and506 = and i64 %177, 65536
  %tobool507 = icmp eq i64 %and506, 0
  br i1 %tobool507, label %cond.false511, label %cond.true508

cond.true508:                                     ; preds = %sw.bb504
  %sv_any509 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %178 = load i8** %sv_any509, align 8, !tbaa !1
  %xiv_iv510 = getelementptr inbounds i8* %178, i64 24
  %179 = bitcast i8* %xiv_iv510 to i64*
  %180 = load i64* %179, align 8, !tbaa !89
  br label %cond.end520

cond.false511:                                    ; preds = %sw.bb504
  %and513 = and i64 %177, 118423552
  %tobool514 = icmp eq i64 %and513, 0
  br i1 %tobool514, label %cond.end520, label %cond.true515

cond.true515:                                     ; preds = %cond.false511
  %call516 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end520

cond.end520:                                      ; preds = %cond.false511, %cond.true515, %cond.true508
  %cond521 = phi i64 [ %180, %cond.true508 ], [ %call516, %cond.true515 ], [ 0, %cond.false511 ]
  %conv522 = trunc i64 %cond521 to i32
  %call523 = call i32* @__errno_location() #4
  store i32 %conv522, i32* %call523, align 4, !tbaa !54
  br label %sw.epilog

sw.bb524:                                         ; preds = %entry
  %sv_flags525 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %181 = load i64* %sv_flags525, align 8, !tbaa !13
  %and526 = and i64 %181, 65536
  %tobool527 = icmp eq i64 %and526, 0
  br i1 %tobool527, label %cond.false531, label %cond.true528

cond.true528:                                     ; preds = %sw.bb524
  %sv_any529 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %182 = load i8** %sv_any529, align 8, !tbaa !1
  %xiv_iv530 = getelementptr inbounds i8* %182, i64 24
  %183 = bitcast i8* %xiv_iv530 to i64*
  %184 = load i64* %183, align 8, !tbaa !89
  br label %cond.end533

cond.false531:                                    ; preds = %sw.bb524
  %call532 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end533

cond.end533:                                      ; preds = %cond.false531, %cond.true528
  %cond534 = phi i64 [ %184, %cond.true528 ], [ %call532, %cond.false531 ]
  %conv535 = trunc i64 %cond534 to i32
  store i32 %conv535, i32* @PL_uid, align 4, !tbaa !54
  %185 = load i32* @PL_delaymagic, align 4, !tbaa !54
  %tobool536 = icmp eq i32 %185, 0
  br i1 %tobool536, label %if.end539, label %if.then537

if.then537:                                       ; preds = %cond.end533
  %or538 = or i32 %185, 1
  store i32 %or538, i32* @PL_delaymagic, align 4, !tbaa !54
  br label %sw.epilog

if.end539:                                        ; preds = %cond.end533
  %186 = load i32* @PL_euid, align 4, !tbaa !54
  %cmp540 = icmp eq i32 %conv535, %186
  br i1 %cmp540, label %if.then542, label %if.else544

if.then542:                                       ; preds = %if.end539
  %call543 = call i32 @setuid(i32 %conv535) #4
  br label %if.end546

if.else544:                                       ; preds = %if.end539
  %call545 = call i32 @getuid() #4
  store i32 %call545, i32* @PL_uid, align 4, !tbaa !54
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([26 x i8]* @.str35, i64 0, i64 0)) #4
  br label %if.end546

if.end546:                                        ; preds = %if.else544, %if.then542
  %call547 = call i32 @getuid() #4
  store i32 %call547, i32* @PL_uid, align 4, !tbaa !54
  %tobool548 = icmp eq i32 %call547, 0
  br i1 %tobool548, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end546
  %187 = load i32* @PL_euid, align 4, !tbaa !54
  %cmp549 = icmp eq i32 %187, %call547
  br i1 %cmp549, label %lor.rhs, label %land.end

lor.rhs:                                          ; preds = %land.rhs
  %188 = load i32* @PL_egid, align 4, !tbaa !54
  %189 = load i32* @PL_gid, align 4, !tbaa !54
  %cmp551 = icmp ne i32 %188, %189
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end546, %lor.rhs
  %190 = phi i1 [ false, %if.end546 ], [ true, %land.rhs ], [ %cmp551, %lor.rhs ]
  %land.ext = zext i1 %190 to i8
  %191 = load i8* @PL_tainting, align 1, !tbaa !50
  %or554 = or i8 %191, %land.ext
  store i8 %or554, i8* @PL_tainting, align 1, !tbaa !50
  br label %sw.epilog

sw.bb556:                                         ; preds = %entry
  %sv_flags557 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %192 = load i64* %sv_flags557, align 8, !tbaa !13
  %and558 = and i64 %192, 65536
  %tobool559 = icmp eq i64 %and558, 0
  br i1 %tobool559, label %cond.false563, label %cond.true560

cond.true560:                                     ; preds = %sw.bb556
  %sv_any561 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %193 = load i8** %sv_any561, align 8, !tbaa !1
  %xiv_iv562 = getelementptr inbounds i8* %193, i64 24
  %194 = bitcast i8* %xiv_iv562 to i64*
  %195 = load i64* %194, align 8, !tbaa !89
  br label %cond.end565

cond.false563:                                    ; preds = %sw.bb556
  %call564 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end565

cond.end565:                                      ; preds = %cond.false563, %cond.true560
  %cond566 = phi i64 [ %195, %cond.true560 ], [ %call564, %cond.false563 ]
  %conv567 = trunc i64 %cond566 to i32
  store i32 %conv567, i32* @PL_euid, align 4, !tbaa !54
  %196 = load i32* @PL_delaymagic, align 4, !tbaa !54
  %tobool568 = icmp eq i32 %196, 0
  br i1 %tobool568, label %if.end571, label %if.then569

if.then569:                                       ; preds = %cond.end565
  %or570 = or i32 %196, 2
  store i32 %or570, i32* @PL_delaymagic, align 4, !tbaa !54
  br label %sw.epilog

if.end571:                                        ; preds = %cond.end565
  %197 = load i32* @PL_uid, align 4, !tbaa !54
  %cmp572 = icmp eq i32 %conv567, %197
  br i1 %cmp572, label %if.then574, label %if.else576

if.then574:                                       ; preds = %if.end571
  %call575 = call i32 @setuid(i32 %conv567) #4
  br label %if.end578

if.else576:                                       ; preds = %if.end571
  %call577 = call i32 @geteuid() #4
  store i32 %call577, i32* @PL_euid, align 4, !tbaa !54
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([26 x i8]* @.str36, i64 0, i64 0)) #4
  br label %if.end578

if.end578:                                        ; preds = %if.else576, %if.then574
  %call579 = call i32 @geteuid() #4
  store i32 %call579, i32* @PL_euid, align 4, !tbaa !54
  %198 = load i32* @PL_uid, align 4, !tbaa !54
  %tobool580 = icmp eq i32 %198, 0
  br i1 %tobool580, label %land.end588, label %land.rhs581

land.rhs581:                                      ; preds = %if.end578
  %cmp582 = icmp eq i32 %call579, %198
  br i1 %cmp582, label %lor.rhs584, label %land.end588

lor.rhs584:                                       ; preds = %land.rhs581
  %199 = load i32* @PL_egid, align 4, !tbaa !54
  %200 = load i32* @PL_gid, align 4, !tbaa !54
  %cmp585 = icmp ne i32 %199, %200
  br label %land.end588

land.end588:                                      ; preds = %land.rhs581, %if.end578, %lor.rhs584
  %201 = phi i1 [ false, %if.end578 ], [ true, %land.rhs581 ], [ %cmp585, %lor.rhs584 ]
  %land.ext589 = zext i1 %201 to i8
  %202 = load i8* @PL_tainting, align 1, !tbaa !50
  %or591 = or i8 %202, %land.ext589
  store i8 %or591, i8* @PL_tainting, align 1, !tbaa !50
  br label %sw.epilog

sw.bb593:                                         ; preds = %entry
  %sv_flags594 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %203 = load i64* %sv_flags594, align 8, !tbaa !13
  %and595 = and i64 %203, 65536
  %tobool596 = icmp eq i64 %and595, 0
  br i1 %tobool596, label %cond.false600, label %cond.true597

cond.true597:                                     ; preds = %sw.bb593
  %sv_any598 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %204 = load i8** %sv_any598, align 8, !tbaa !1
  %xiv_iv599 = getelementptr inbounds i8* %204, i64 24
  %205 = bitcast i8* %xiv_iv599 to i64*
  %206 = load i64* %205, align 8, !tbaa !89
  br label %cond.end602

cond.false600:                                    ; preds = %sw.bb593
  %call601 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end602

cond.end602:                                      ; preds = %cond.false600, %cond.true597
  %cond603 = phi i64 [ %206, %cond.true597 ], [ %call601, %cond.false600 ]
  %conv604 = trunc i64 %cond603 to i32
  store i32 %conv604, i32* @PL_gid, align 4, !tbaa !54
  %207 = load i32* @PL_delaymagic, align 4, !tbaa !54
  %tobool605 = icmp eq i32 %207, 0
  br i1 %tobool605, label %if.end608, label %if.then606

if.then606:                                       ; preds = %cond.end602
  %or607 = or i32 %207, 16
  store i32 %or607, i32* @PL_delaymagic, align 4, !tbaa !54
  br label %sw.epilog

if.end608:                                        ; preds = %cond.end602
  %208 = load i32* @PL_egid, align 4, !tbaa !54
  %cmp609 = icmp eq i32 %conv604, %208
  br i1 %cmp609, label %if.then611, label %if.else613

if.then611:                                       ; preds = %if.end608
  %call612 = call i32 @setgid(i32 %conv604) #4
  br label %if.end615

if.else613:                                       ; preds = %if.end608
  %call614 = call i32 @getgid() #4
  store i32 %call614, i32* @PL_gid, align 4, !tbaa !54
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([26 x i8]* @.str37, i64 0, i64 0)) #4
  br label %if.end615

if.end615:                                        ; preds = %if.else613, %if.then611
  %call616 = call i32 @getgid() #4
  store i32 %call616, i32* @PL_gid, align 4, !tbaa !54
  %209 = load i32* @PL_uid, align 4, !tbaa !54
  %tobool617 = icmp eq i32 %209, 0
  br i1 %tobool617, label %land.end625, label %land.rhs618

land.rhs618:                                      ; preds = %if.end615
  %210 = load i32* @PL_euid, align 4, !tbaa !54
  %cmp619 = icmp eq i32 %210, %209
  br i1 %cmp619, label %lor.rhs621, label %land.end625

lor.rhs621:                                       ; preds = %land.rhs618
  %211 = load i32* @PL_egid, align 4, !tbaa !54
  %cmp622 = icmp ne i32 %211, %call616
  br label %land.end625

land.end625:                                      ; preds = %land.rhs618, %if.end615, %lor.rhs621
  %212 = phi i1 [ false, %if.end615 ], [ true, %land.rhs618 ], [ %cmp622, %lor.rhs621 ]
  %land.ext626 = zext i1 %212 to i8
  %213 = load i8* @PL_tainting, align 1, !tbaa !50
  %or628 = or i8 %213, %land.ext626
  store i8 %or628, i8* @PL_tainting, align 1, !tbaa !50
  br label %sw.epilog

sw.bb630:                                         ; preds = %entry
  %sv_flags631 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %214 = load i64* %sv_flags631, align 8, !tbaa !13
  %and632 = and i64 %214, 65536
  %tobool633 = icmp eq i64 %and632, 0
  br i1 %tobool633, label %cond.false637, label %cond.true634

cond.true634:                                     ; preds = %sw.bb630
  %sv_any635 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %215 = load i8** %sv_any635, align 8, !tbaa !1
  %xiv_iv636 = getelementptr inbounds i8* %215, i64 24
  %216 = bitcast i8* %xiv_iv636 to i64*
  %217 = load i64* %216, align 8, !tbaa !89
  br label %cond.end639

cond.false637:                                    ; preds = %sw.bb630
  %call638 = call i64 @Perl_sv_2iv(%struct.sv* %sv) #4
  br label %cond.end639

cond.end639:                                      ; preds = %cond.false637, %cond.true634
  %cond640 = phi i64 [ %217, %cond.true634 ], [ %call638, %cond.false637 ]
  %conv641 = trunc i64 %cond640 to i32
  store i32 %conv641, i32* @PL_egid, align 4, !tbaa !54
  %218 = load i32* @PL_delaymagic, align 4, !tbaa !54
  %tobool642 = icmp eq i32 %218, 0
  br i1 %tobool642, label %if.end645, label %if.then643

if.then643:                                       ; preds = %cond.end639
  %or644 = or i32 %218, 32
  store i32 %or644, i32* @PL_delaymagic, align 4, !tbaa !54
  br label %sw.epilog

if.end645:                                        ; preds = %cond.end639
  %219 = load i32* @PL_gid, align 4, !tbaa !54
  %cmp646 = icmp eq i32 %conv641, %219
  br i1 %cmp646, label %if.then648, label %if.else650

if.then648:                                       ; preds = %if.end645
  %call649 = call i32 @setgid(i32 %conv641) #4
  br label %if.end652

if.else650:                                       ; preds = %if.end645
  %call651 = call i32 @getegid() #4
  store i32 %call651, i32* @PL_egid, align 4, !tbaa !54
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([26 x i8]* @.str38, i64 0, i64 0)) #4
  br label %if.end652

if.end652:                                        ; preds = %if.else650, %if.then648
  %call653 = call i32 @getegid() #4
  store i32 %call653, i32* @PL_egid, align 4, !tbaa !54
  %220 = load i32* @PL_uid, align 4, !tbaa !54
  %tobool654 = icmp eq i32 %220, 0
  br i1 %tobool654, label %land.end662, label %land.rhs655

land.rhs655:                                      ; preds = %if.end652
  %221 = load i32* @PL_euid, align 4, !tbaa !54
  %cmp656 = icmp eq i32 %221, %220
  br i1 %cmp656, label %lor.rhs658, label %land.end662

lor.rhs658:                                       ; preds = %land.rhs655
  %222 = load i32* @PL_gid, align 4, !tbaa !54
  %cmp659 = icmp ne i32 %call653, %222
  br label %land.end662

land.end662:                                      ; preds = %land.rhs655, %if.end652, %lor.rhs658
  %223 = phi i1 [ false, %if.end652 ], [ true, %land.rhs655 ], [ %cmp659, %lor.rhs658 ]
  %land.ext663 = zext i1 %223 to i8
  %224 = load i8* @PL_tainting, align 1, !tbaa !50
  %or665 = or i8 %224, %land.ext663
  store i8 %or665, i8* @PL_tainting, align 1, !tbaa !50
  br label %sw.epilog

sw.bb667:                                         ; preds = %entry
  %sv_flags668 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %225 = load i64* %sv_flags668, align 8, !tbaa !13
  %and669 = and i64 %225, 10223616
  %cmp670 = icmp eq i64 %and669, 262144
  br i1 %cmp670, label %cond.true672, label %cond.false677

cond.true672:                                     ; preds = %sw.bb667
  %sv_any673 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %226 = load i8** %sv_any673, align 8, !tbaa !1
  %xpv_cur674 = getelementptr inbounds i8* %226, i64 8
  %227 = bitcast i8* %xpv_cur674 to i64*
  %228 = load i64* %227, align 8, !tbaa !30
  store i64 %228, i64* %len, align 8, !tbaa !25
  %xpv_pv676 = bitcast i8* %226 to i8**
  %229 = load i8** %xpv_pv676, align 8, !tbaa !32
  br label %cond.end679

cond.false677:                                    ; preds = %sw.bb667
  %call678 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %sv, i64* %len, i64 2) #4
  br label %cond.end679

cond.end679:                                      ; preds = %cond.false677, %cond.true672
  %cond680 = phi i8* [ %229, %cond.true672 ], [ %call678, %cond.false677 ]
  store i8* %cond680, i8** @PL_chopset, align 8, !tbaa !16
  br label %sw.epilog

sw.bb681:                                         ; preds = %entry
  %sv_flags682 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %230 = load i64* %sv_flags682, align 8, !tbaa !13
  %and683 = and i64 %230, 10223616
  %cmp684 = icmp eq i64 %and683, 262144
  br i1 %cmp684, label %cond.true686, label %cond.false691

cond.true686:                                     ; preds = %sw.bb681
  %sv_any687 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %231 = load i8** %sv_any687, align 8, !tbaa !1
  %xpv_cur688 = getelementptr inbounds i8* %231, i64 8
  %232 = bitcast i8* %xpv_cur688 to i64*
  %233 = load i64* %232, align 8, !tbaa !30
  store i64 %233, i64* %len, align 8, !tbaa !25
  %xpv_pv690 = bitcast i8* %231 to i8**
  %234 = load i8** %xpv_pv690, align 8, !tbaa !32
  br label %cond.end693

cond.false691:                                    ; preds = %sw.bb681
  %call692 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %sv, i64* %len, i64 2) #4
  %.pre852 = load i64* %len, align 8, !tbaa !25
  br label %cond.end693

cond.end693:                                      ; preds = %cond.false691, %cond.true686
  %235 = phi i64 [ %233, %cond.true686 ], [ %.pre852, %cond.false691 ]
  %cond694 = phi i8* [ %234, %cond.true686 ], [ %call692, %cond.false691 ]
  %236 = load i64* @PL_origalen, align 8, !tbaa !25
  %cmp695 = icmp ult i64 %235, %236
  %237 = load i8*** @PL_origargv, align 8, !tbaa !16
  %238 = load i8** %237, align 8, !tbaa !16
  br i1 %cmp695, label %if.else701, label %if.then697

if.then697:                                       ; preds = %cond.end693
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %238, i8* %cond694, i64 %236, i32 1, i1 false)
  %239 = load i64* @PL_origalen, align 8, !tbaa !25
  %sub = add i64 %239, -1
  %240 = load i8*** @PL_origargv, align 8, !tbaa !16
  %241 = load i8** %240, align 8, !tbaa !16
  %arrayidx700 = getelementptr inbounds i8* %241, i64 %sub
  store i8 0, i8* %arrayidx700, align 1, !tbaa !50
  br label %sw.epilog

if.else701:                                       ; preds = %cond.end693
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %238, i8* %cond694, i64 %235, i32 1, i1 false)
  %242 = load i64* %len, align 8, !tbaa !25
  %243 = load i8*** @PL_origargv, align 8, !tbaa !16
  %244 = load i8** %243, align 8, !tbaa !16
  %arrayidx705 = getelementptr inbounds i8* %244, i64 %242
  store i8 0, i8* %arrayidx705, align 1, !tbaa !50
  %245 = load i8*** @PL_origargv, align 8, !tbaa !16
  %246 = load i8** %245, align 8, !tbaa !16
  %247 = load i64* %len, align 8, !tbaa !25
  %add.ptr707.sum = add i64 %247, 1
  %add.ptr708 = getelementptr inbounds i8* %246, i64 %add.ptr707.sum
  %248 = load i64* @PL_origalen, align 8, !tbaa !25
  %sub709 = xor i64 %247, -1
  %sub710 = add i64 %248, %sub709
  call void @llvm.memset.p0i8.i64(i8* %add.ptr708, i8 32, i64 %sub710, i32 1, i1 false)
  %249 = load i32* @PL_origargc, align 4, !tbaa !54
  %cmp713842 = icmp sgt i32 %249, 1
  br i1 %cmp713842, label %for.body715.lr.ph, label %sw.epilog

for.body715.lr.ph:                                ; preds = %if.else701
  %conv712 = sext i32 %249 to i64
  br label %for.body715

for.body715:                                      ; preds = %for.body715.lr.ph, %for.body715
  %i.0843 = phi i64 [ 1, %for.body715.lr.ph ], [ %inc718, %for.body715 ]
  %250 = load i8*** @PL_origargv, align 8, !tbaa !16
  %arrayidx716 = getelementptr inbounds i8** %250, i64 %i.0843
  store i8* null, i8** %arrayidx716, align 8, !tbaa !16
  %inc718 = add nsw i64 %i.0843, 1
  %cmp713 = icmp slt i64 %inc718, %conv712
  br i1 %cmp713, label %for.body715, label %sw.epilog

sw.epilog:                                        ; preds = %for.body715, %if.else701, %sw.bb250, %if.else, %if.end91, %if.else101, %if.then146, %if.end233, %if.then173, %if.else168, %cond.true271, %land.lhs.true268, %if.else408, %sw.bb384, %cond.end497, %if.then697, %if.then501, %if.then468, %if.else470, %if.then453, %if.else455, %if.then403, %if.end419, %if.then255, %land.lhs.true263, %cond.end285, %if.else257, %cond.end159, %if.then217, %if.then240, %if.then207, %if.then126, %cond.end122, %if.end98, %if.then107, %if.else109, %if.then78, %if.else80, %cond.end26, %if.then43, %if.else45, %entry, %cond.end679, %land.end662, %if.then643, %land.end625, %if.then606, %land.end588, %if.then569, %land.end, %if.then537, %cond.end520, %cond.end486, %if.end475, %sw.bb440, %cond.end436, %cond.end378, %cond.end334, %sw.bb309, %sw.bb293, %if.then183, %cond.end138, %cond.end69, %cond.end58, %cond.end12, %cond.end, %sw.bb
  ret i32 0
}

declare %struct.sv* @Perl_newSVsv(%struct.sv*) #1

declare i8* @Perl_savesvpv(%struct.sv*) #1

declare void @Perl_taint_proper(i8*, i8*) #1

declare i32 @init_debugger(...) #1

declare void @Perl_save_sptr(%struct.sv**) #1

declare i32 @Perl_PerlIO_flush(%struct._PerlIO**) #1

declare i32 @setuid(i32) #1

declare i32 @getuid() #1

declare i32 @geteuid() #1

declare i32 @setgid(i32) #1

declare i32 @getgid() #1

declare i32 @getegid() #1

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #4

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #4

; Function Attrs: nounwind uwtable
define void @Perl_sighandler(i32 %sig) #0 {
entry:
  %gv = alloca %struct.gv*, align 8
  %st = alloca %struct.hv*, align 8
  %flags = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  store %struct.gv* null, %struct.gv** %gv, align 8, !tbaa !16
  %1 = load %struct.sv** @PL_Sv, align 8, !tbaa !16
  %2 = load %struct.op** @PL_op, align 8, !tbaa !16
  %3 = load %struct.xpv** @PL_Xpv, align 8, !tbaa !16
  %4 = load i64* @PL_savestack_ix, align 8, !tbaa !25
  %add = add nsw i64 %4, 15
  %5 = load i64* @PL_savestack_max, align 8, !tbaa !25
  %not.cmp = icmp sle i64 %add, %5
  %. = zext i1 %not.cmp to i64
  store i64 %., i64* %flags, align 8, !tbaa !25
  %6 = load i64** @PL_markstack_ptr, align 8, !tbaa !16
  %7 = load i64** @PL_markstack_max, align 8, !tbaa !16
  %add.ptr = getelementptr inbounds i64* %7, i64 -2
  %cmp1 = icmp ult i64* %6, %add.ptr
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %entry
  %or3 = or i64 %., 4
  store i64 %or3, i64* %flags, align 8, !tbaa !25
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %entry
  %8 = phi i64 [ %or3, %if.then2 ], [ %., %entry ]
  %9 = load i64* @PL_retstack_ix, align 8, !tbaa !25
  %10 = load i64* @PL_retstack_max, align 8, !tbaa !25
  %sub = add nsw i64 %10, -2
  %cmp5 = icmp slt i64 %9, %sub
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %or7 = or i64 %8, 8
  store i64 %or7, i64* %flags, align 8, !tbaa !25
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %11 = phi i64 [ %or7, %if.then6 ], [ %8, %if.end4 ]
  %12 = load i64* @PL_scopestack_ix, align 8, !tbaa !25
  %13 = load i64* @PL_scopestack_max, align 8, !tbaa !25
  %sub9 = add nsw i64 %13, -3
  %cmp10 = icmp slt i64 %12, %sub9
  br i1 %cmp10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end8
  %or12 = or i64 %11, 16
  store i64 %or12, i64* %flags, align 8, !tbaa !25
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end8
  %14 = phi i64 [ %or12, %if.then11 ], [ %11, %if.end8 ]
  %idxprom = sext i32 %sig to i64
  %15 = load %struct.sv*** @PL_psig_ptr, align 8, !tbaa !16
  %arrayidx = getelementptr inbounds %struct.sv** %15, i64 %idxprom
  %16 = load %struct.sv** %arrayidx, align 8, !tbaa !16
  %tobool = icmp eq %struct.sv* %16, null
  br i1 %tobool, label %if.then14, label %if.end33

if.then14:                                        ; preds = %if.end13
  %17 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !16
  %tobool15 = icmp eq %struct.gv* %17, null
  br i1 %tobool15, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then14
  %sv_flags = getelementptr inbounds %struct.gv* %17, i64 0, i32 2
  %18 = load i64* %sv_flags, align 8, !tbaa !101
  %and = and i64 %18, 255
  %cmp16 = icmp eq i64 %and, 13
  br i1 %cmp16, label %land.lhs.true17, label %cond.false

land.lhs.true17:                                  ; preds = %land.lhs.true
  %sv_any = getelementptr inbounds %struct.gv* %17, i64 0, i32 0
  %19 = load %struct.xpvgv** %sv_any, align 8, !tbaa !57
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %19, i64 0, i32 7
  %20 = load %struct.gp** %xgv_gp, align 8, !tbaa !59
  %gp_io = getelementptr inbounds %struct.gp* %20, i64 0, i32 2
  %21 = load %struct.io** %gp_io, align 8, !tbaa !61
  %tobool18 = icmp eq %struct.io* %21, null
  br i1 %tobool18, label %cond.false, label %land.lhs.true19

land.lhs.true19:                                  ; preds = %land.lhs.true17
  %sv_any23 = getelementptr inbounds %struct.io* %21, i64 0, i32 0
  %22 = load %struct.xpvio** %sv_any23, align 8, !tbaa !63
  %xio_ofp = getelementptr inbounds %struct.xpvio* %22, i64 0, i32 8
  %23 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !102
  %tobool24 = icmp eq %struct._PerlIO** %23, null
  br i1 %tobool24, label %cond.false, label %cond.end

cond.false:                                       ; preds = %land.lhs.true19, %land.lhs.true17, %if.then14, %land.lhs.true
  %call = call %struct._PerlIO** @Perl_PerlIO_stderr() #4
  br label %cond.end

cond.end:                                         ; preds = %land.lhs.true19, %cond.false
  %cond = phi %struct._PerlIO** [ %call, %cond.false ], [ %23, %land.lhs.true19 ]
  %arrayidx31 = getelementptr inbounds [0 x i8*]* @PL_sig_name, i64 0, i64 %idxprom
  %24 = load i8** %arrayidx31, align 8, !tbaa !16
  %call32 = call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond, i8* getelementptr inbounds ([51 x i8]* @.str40, i64 0, i64 0), i8* %24) #4
  call void @exit(i32 %sig) #7
  unreachable

if.end33:                                         ; preds = %if.end13
  %and34 = and i64 %14, 1
  %tobool35 = icmp eq i64 %and34, 0
  br i1 %tobool35, label %if.end38, label %if.then36

if.then36:                                        ; preds = %if.end33
  %add37 = add nsw i64 %4, 5
  store i64 %add37, i64* @PL_savestack_ix, align 8, !tbaa !25
  %25 = bitcast i64* %flags to i8*
  call void @Perl_save_destructor_x(void (i8*)* @unwind_handler_stack, i8* %25) #4
  %.pre = load i64* %flags, align 8, !tbaa !25
  br label %if.end38

if.end38:                                         ; preds = %if.end33, %if.then36
  %26 = phi i64 [ %14, %if.end33 ], [ %.pre, %if.then36 ]
  %and39 = and i64 %26, 4
  %tobool40 = icmp eq i64 %and39, 0
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %if.end38
  %27 = load i64** @PL_markstack_ptr, align 8, !tbaa !16
  %incdec.ptr = getelementptr inbounds i64* %27, i64 1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !16
  br label %if.end42

if.end42:                                         ; preds = %if.end38, %if.then41
  %and43 = and i64 %26, 8
  %tobool44 = icmp eq i64 %and43, 0
  br i1 %tobool44, label %if.end47, label %if.then45

if.then45:                                        ; preds = %if.end42
  %28 = load i64* @PL_retstack_ix, align 8, !tbaa !25
  %inc = add nsw i64 %28, 1
  store i64 %inc, i64* @PL_retstack_ix, align 8, !tbaa !25
  %29 = load %struct.op*** @PL_retstack, align 8, !tbaa !16
  %arrayidx46 = getelementptr inbounds %struct.op** %29, i64 %inc
  store %struct.op* null, %struct.op** %arrayidx46, align 8, !tbaa !16
  br label %if.end47

if.end47:                                         ; preds = %if.end42, %if.then45
  %and48 = and i64 %26, 16
  %tobool49 = icmp eq i64 %and48, 0
  br i1 %tobool49, label %if.end52, label %if.then50

if.then50:                                        ; preds = %if.end47
  %30 = load i64* @PL_scopestack_ix, align 8, !tbaa !25
  %add51 = add nsw i64 %30, 1
  store i64 %add51, i64* @PL_scopestack_ix, align 8, !tbaa !25
  br label %if.end52

if.end52:                                         ; preds = %if.end47, %if.then50
  %31 = load %struct.sv*** @PL_psig_ptr, align 8, !tbaa !16
  %arrayidx54 = getelementptr inbounds %struct.sv** %31, i64 %idxprom
  %32 = load %struct.sv** %arrayidx54, align 8, !tbaa !16
  %sv_flags55 = getelementptr inbounds %struct.sv* %32, i64 0, i32 2
  %33 = load i64* %sv_flags55, align 8, !tbaa !13
  %and56 = and i64 %33, 524288
  %tobool57 = icmp eq i64 %and56, 0
  br i1 %tobool57, label %if.then66, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end52
  %sv_any60 = getelementptr inbounds %struct.sv* %32, i64 0, i32 0
  %34 = load i8** %sv_any60, align 8, !tbaa !1
  %xrv_rv = bitcast i8* %34 to %struct.sv**
  %35 = load %struct.sv** %xrv_rv, align 8, !tbaa !103
  %tobool61 = icmp eq %struct.sv* %35, null
  br i1 %tobool61, label %if.then66, label %lor.lhs.false62

lor.lhs.false62:                                  ; preds = %lor.lhs.false
  %36 = bitcast %struct.sv* %35 to %struct.cv*
  %37 = getelementptr inbounds %struct.sv* %35, i64 0, i32 2
  %38 = load i64* %37, align 8, !tbaa !117
  %and64 = and i64 %38, 255
  %cmp65 = icmp eq i64 %and64, 12
  br i1 %cmp65, label %if.end70, label %if.then66

if.then66:                                        ; preds = %lor.lhs.false62, %lor.lhs.false, %if.end52
  %call69 = call %struct.cv* @Perl_sv_2cv(%struct.sv* %32, %struct.hv** %st, %struct.gv** %gv, i64 1) #4
  br label %if.end70

if.end70:                                         ; preds = %lor.lhs.false62, %if.then66
  %cv.0 = phi %struct.cv* [ %call69, %if.then66 ], [ %36, %lor.lhs.false62 ]
  %tobool71 = icmp ne %struct.cv* %cv.0, null
  br i1 %tobool71, label %lor.lhs.false72, label %if.then75

lor.lhs.false72:                                  ; preds = %if.end70
  %sv_any73 = getelementptr inbounds %struct.cv* %cv.0, i64 0, i32 0
  %39 = load %struct.xpvcv** %sv_any73, align 8, !tbaa !119
  %xcv_root = getelementptr inbounds %struct.xpvcv* %39, i64 0, i32 9
  %40 = load %struct.op** %xcv_root, align 8, !tbaa !120
  %tobool74 = icmp eq %struct.op* %40, null
  br i1 %tobool74, label %if.then75, label %if.end144

if.then75:                                        ; preds = %lor.lhs.false72, %if.end70
  %41 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings = getelementptr inbounds %struct.cop* %41, i64 0, i32 14
  %42 = load %struct.sv** %cop_warnings, align 8, !tbaa !51
  %cmp76 = icmp eq %struct.sv* %42, null
  br i1 %cmp76, label %lor.lhs.false89, label %land.lhs.true77

land.lhs.true77:                                  ; preds = %if.then75
  %43 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings78 = getelementptr inbounds %struct.cop* %43, i64 0, i32 14
  %44 = load %struct.sv** %cop_warnings78, align 8, !tbaa !51
  %cmp79 = icmp eq %struct.sv* %44, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp79, label %lor.lhs.false89, label %land.lhs.true80

land.lhs.true80:                                  ; preds = %land.lhs.true77
  %45 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings81 = getelementptr inbounds %struct.cop* %45, i64 0, i32 14
  %46 = load %struct.sv** %cop_warnings81, align 8, !tbaa !51
  %cmp82 = icmp eq %struct.sv* %46, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp82, label %if.then97, label %lor.lhs.false83

lor.lhs.false83:                                  ; preds = %land.lhs.true80
  %47 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings84 = getelementptr inbounds %struct.cop* %47, i64 0, i32 14
  %48 = load %struct.sv** %cop_warnings84, align 8, !tbaa !51
  %sv_any85 = getelementptr inbounds %struct.sv* %48, i64 0, i32 0
  %49 = load i8** %sv_any85, align 8, !tbaa !1
  %xpv_pv = bitcast i8* %49 to i8**
  %50 = load i8** %xpv_pv, align 8, !tbaa !32
  %arrayidx86 = getelementptr inbounds i8* %50, i64 6
  %51 = load i8* %arrayidx86, align 1, !tbaa !50
  %and87 = and i8 %51, 16
  %tobool88 = icmp eq i8 %and87, 0
  br i1 %tobool88, label %lor.lhs.false89, label %if.then97

lor.lhs.false89:                                  ; preds = %lor.lhs.false83, %land.lhs.true77, %if.then75
  %52 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !16
  %cop_warnings90 = getelementptr inbounds %struct.cop* %52, i64 0, i32 14
  %53 = load %struct.sv** %cop_warnings90, align 8, !tbaa !51
  %cmp91 = icmp eq %struct.sv* %53, null
  br i1 %cmp91, label %land.lhs.true93, label %cleanup

land.lhs.true93:                                  ; preds = %lor.lhs.false89
  %54 = load i8* @PL_dowarn, align 1, !tbaa !50
  %and95 = and i8 %54, 1
  %tobool96 = icmp eq i8 %and95, 0
  br i1 %tobool96, label %cleanup, label %if.then97

if.then97:                                        ; preds = %lor.lhs.false83, %land.lhs.true93, %land.lhs.true80
  %arrayidx99 = getelementptr inbounds [0 x i8*]* @PL_sig_name, i64 0, i64 %idxprom
  %55 = load i8** %arrayidx99, align 8, !tbaa !16
  %56 = load %struct.gv** %gv, align 8, !tbaa !16
  %tobool100 = icmp eq %struct.gv* %56, null
  br i1 %tobool100, label %cond.false113, label %cond.true101

cond.true101:                                     ; preds = %if.then97
  %sv_any102 = getelementptr inbounds %struct.gv* %56, i64 0, i32 0
  %57 = load %struct.xpvgv** %sv_any102, align 8, !tbaa !57
  %xgv_gp103 = getelementptr inbounds %struct.xpvgv* %57, i64 0, i32 7
  %58 = load %struct.gp** %xgv_gp103, align 8, !tbaa !59
  %gp_egv = getelementptr inbounds %struct.gp* %58, i64 0, i32 6
  %59 = load %struct.gv** %gp_egv, align 8, !tbaa !68
  %tobool104 = icmp eq %struct.gv* %59, null
  %.378 = select i1 %tobool104, %struct.gv* %56, %struct.gv* %59
  %sv_any112 = getelementptr inbounds %struct.gv* %.378, i64 0, i32 0
  %60 = load %struct.xpvgv** %sv_any112, align 8, !tbaa !57
  %xgv_name = getelementptr inbounds %struct.xpvgv* %60, i64 0, i32 8
  %61 = load i8** %xgv_name, align 8, !tbaa !69
  br label %cond.end141

cond.false113:                                    ; preds = %if.then97
  br i1 %tobool71, label %land.lhs.true115, label %cond.end141

land.lhs.true115:                                 ; preds = %cond.false113
  %sv_any116 = getelementptr inbounds %struct.cv* %cv.0, i64 0, i32 0
  %62 = load %struct.xpvcv** %sv_any116, align 8, !tbaa !119
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %62, i64 0, i32 12
  %63 = load %struct.gv** %xcv_gv, align 8, !tbaa !122
  %tobool117 = icmp eq %struct.gv* %63, null
  br i1 %tobool117, label %cond.end141, label %cond.true118

cond.true118:                                     ; preds = %land.lhs.true115
  %sv_any121 = getelementptr inbounds %struct.gv* %63, i64 0, i32 0
  %64 = load %struct.xpvgv** %sv_any121, align 8, !tbaa !57
  %xgv_gp122 = getelementptr inbounds %struct.xpvgv* %64, i64 0, i32 7
  %65 = load %struct.gp** %xgv_gp122, align 8, !tbaa !59
  %gp_egv123 = getelementptr inbounds %struct.gp* %65, i64 0, i32 6
  %66 = load %struct.gv** %gp_egv123, align 8, !tbaa !68
  %tobool124 = icmp eq %struct.gv* %66, null
  %.379 = select i1 %tobool124, %struct.gv* %63, %struct.gv* %66
  %sv_any136 = getelementptr inbounds %struct.gv* %.379, i64 0, i32 0
  %67 = load %struct.xpvgv** %sv_any136, align 8, !tbaa !57
  %xgv_name137 = getelementptr inbounds %struct.xpvgv* %67, i64 0, i32 8
  %68 = load i8** %xgv_name137, align 8, !tbaa !69
  br label %cond.end141

cond.end141:                                      ; preds = %land.lhs.true115, %cond.true118, %cond.false113, %cond.true101
  %cond142 = phi i8* [ %61, %cond.true101 ], [ %68, %cond.true118 ], [ getelementptr inbounds ([9 x i8]* @.str42, i64 0, i64 0), %land.lhs.true115 ], [ getelementptr inbounds ([9 x i8]* @.str42, i64 0, i64 0), %cond.false113 ]
  call void (i64, i8*, ...)* @Perl_warner(i64 26, i8* getelementptr inbounds ([33 x i8]* @.str41, i64 0, i64 0), i8* %55, i8* %cond142) #4
  br label %cleanup

if.end144:                                        ; preds = %lor.lhs.false72
  %69 = load %struct.sv*** @PL_psig_name, align 8, !tbaa !16
  %arrayidx146 = getelementptr inbounds %struct.sv** %69, i64 %idxprom
  %70 = load %struct.sv** %arrayidx146, align 8, !tbaa !16
  %tobool147 = icmp eq %struct.sv* %70, null
  br i1 %tobool147, label %if.else, label %if.then148

if.then148:                                       ; preds = %if.end144
  store %struct.sv* %70, %struct.sv** @PL_Sv, align 8, !tbaa !16
  %sv_refcnt = getelementptr inbounds %struct.sv* %70, i64 0, i32 1
  %71 = load i64* %sv_refcnt, align 8, !tbaa !17
  %inc152 = add i64 %71, 1
  store i64 %inc152, i64* %sv_refcnt, align 8, !tbaa !17
  %72 = load i64* %flags, align 8, !tbaa !25
  %or154 = or i64 %72, 64
  store i64 %or154, i64* %flags, align 8, !tbaa !25
  store %struct.sv* %70, %struct.sv** @sig_sv, align 8, !tbaa !16
  br label %if.end158

if.else:                                          ; preds = %if.end144
  %call155 = call %struct.sv* @Perl_sv_newmortal() #4
  %arrayidx157 = getelementptr inbounds [0 x i8*]* @PL_sig_name, i64 0, i64 %idxprom
  %73 = load i8** %arrayidx157, align 8, !tbaa !16
  call void @Perl_sv_setpv(%struct.sv* %call155, i8* %73) #4
  br label %if.end158

if.end158:                                        ; preds = %if.else, %if.then148
  %sv.0 = phi %struct.sv* [ %70, %if.then148 ], [ %call155, %if.else ]
  %74 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_next = getelementptr inbounds %struct.stackinfo* %74, i64 0, i32 6
  %75 = load %struct.stackinfo** %si_next, align 8, !tbaa !91
  %tobool159 = icmp eq %struct.stackinfo* %75, null
  br i1 %tobool159, label %if.then160, label %if.end163

if.then160:                                       ; preds = %if.end158
  %call161 = call %struct.stackinfo* @Perl_new_stackinfo(i64 32, i64 12) #4
  %76 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_prev = getelementptr inbounds %struct.stackinfo* %call161, i64 0, i32 5
  store %struct.stackinfo* %76, %struct.stackinfo** %si_prev, align 8, !tbaa !93
  %77 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_next162 = getelementptr inbounds %struct.stackinfo* %77, i64 0, i32 6
  store %struct.stackinfo* %call161, %struct.stackinfo** %si_next162, align 8, !tbaa !91
  br label %if.end163

if.end163:                                        ; preds = %if.end158, %if.then160
  %next.0 = phi %struct.stackinfo* [ %75, %if.end158 ], [ %call161, %if.then160 ]
  %si_type = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 4
  store i64 4, i64* %si_type, align 8, !tbaa !94
  %si_cxix = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !95
  %si_stack = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 0
  %78 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any164 = getelementptr inbounds %struct.av* %78, i64 0, i32 0
  %79 = load %struct.xpvav** %sv_any164, align 8, !tbaa !97
  %xav_fill = getelementptr inbounds %struct.xpvav* %79, i64 0, i32 1
  store i64 0, i64* %xav_fill, align 8, !tbaa !33
  %80 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %80 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %81 = load %struct.av** @PL_curstack, align 8, !tbaa !16
  %sv_any165 = getelementptr inbounds %struct.av* %81, i64 0, i32 0
  %82 = load %struct.xpvav** %sv_any165, align 8, !tbaa !97
  %xav_fill166 = getelementptr inbounds %struct.xpvav* %82, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill166, align 8, !tbaa !33
  %xav_array = getelementptr inbounds %struct.xpvav* %79, i64 0, i32 0
  %83 = load i8** %xav_array, align 8, !tbaa !99
  %84 = bitcast i8* %83 to %struct.sv**
  store %struct.sv** %84, %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %85 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any170 = getelementptr inbounds %struct.av* %85, i64 0, i32 0
  %86 = load %struct.xpvav** %sv_any170, align 8, !tbaa !97
  %xav_max = getelementptr inbounds %struct.xpvav* %86, i64 0, i32 2
  %87 = load i64* %xav_max, align 8, !tbaa !100
  %add.ptr171 = getelementptr inbounds %struct.sv** %84, i64 %87
  store %struct.sv** %add.ptr171, %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  %88 = load %struct.av** %si_stack, align 8, !tbaa !96
  %sv_any173 = getelementptr inbounds %struct.av* %88, i64 0, i32 0
  %89 = load %struct.xpvav** %sv_any173, align 8, !tbaa !97
  %xav_fill174 = getelementptr inbounds %struct.xpvav* %89, i64 0, i32 1
  %90 = load i64* %xav_fill174, align 8, !tbaa !33
  %add.ptr175 = getelementptr inbounds %struct.sv** %84, i64 %90
  store %struct.sv** %add.ptr175, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %91 = load %struct.av** %si_stack, align 8, !tbaa !96
  store %struct.av* %91, %struct.av** @PL_curstack, align 8, !tbaa !16
  store %struct.stackinfo* %next.0, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %92 = load i64** @PL_markstack_ptr, align 8, !tbaa !16
  %incdec.ptr177 = getelementptr inbounds i64* %92, i64 1
  store i64* %incdec.ptr177, i64** @PL_markstack_ptr, align 8, !tbaa !16
  %93 = load i64** @PL_markstack_max, align 8, !tbaa !16
  %cmp178 = icmp eq i64* %incdec.ptr177, %93
  br i1 %cmp178, label %if.then180, label %if.end181

if.then180:                                       ; preds = %if.end163
  call void @Perl_markstack_grow() #4
  %.pre380 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %.pre381 = load i64** @PL_markstack_ptr, align 8, !tbaa !16
  br label %if.end181

if.end181:                                        ; preds = %if.then180, %if.end163
  %94 = phi i64* [ %.pre381, %if.then180 ], [ %incdec.ptr177, %if.end163 ]
  %95 = phi %struct.sv** [ %.pre380, %if.then180 ], [ %84, %if.end163 ]
  %sub.ptr.lhs.cast183 = ptrtoint %struct.sv** %add.ptr175 to i64
  %sub.ptr.rhs.cast184 = ptrtoint %struct.sv** %95 to i64
  %sub.ptr.sub185 = sub i64 %sub.ptr.lhs.cast183, %sub.ptr.rhs.cast184
  %sub.ptr.div186 = ashr exact i64 %sub.ptr.sub185, 3
  store i64 %sub.ptr.div186, i64* %94, align 8, !tbaa !25
  %add.ptr175.sum = add i64 %90, 1
  %incdec.ptr187 = getelementptr inbounds %struct.sv** %84, i64 %add.ptr175.sum
  store %struct.sv* %sv.0, %struct.sv** %incdec.ptr187, align 8, !tbaa !16
  store %struct.sv** %incdec.ptr187, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %96 = bitcast %struct.cv* %cv.0 to %struct.sv*
  %call188 = call i64 @Perl_call_sv(%struct.sv* %96, i64 6) #4
  %97 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %98 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %si_prev192 = getelementptr inbounds %struct.stackinfo* %98, i64 0, i32 5
  %99 = load %struct.stackinfo** %si_prev192, align 8, !tbaa !93
  %tobool193 = icmp eq %struct.stackinfo* %99, null
  br i1 %tobool193, label %if.then194, label %if.end224

if.then194:                                       ; preds = %if.end181
  %100 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !16
  %tobool195 = icmp eq %struct.gv* %100, null
  br i1 %tobool195, label %cond.false219, label %land.lhs.true196

land.lhs.true196:                                 ; preds = %if.then194
  %sv_flags197 = getelementptr inbounds %struct.gv* %100, i64 0, i32 2
  %101 = load i64* %sv_flags197, align 8, !tbaa !101
  %and198 = and i64 %101, 255
  %cmp199 = icmp eq i64 %and198, 13
  br i1 %cmp199, label %land.lhs.true201, label %cond.false219

land.lhs.true201:                                 ; preds = %land.lhs.true196
  %sv_any202 = getelementptr inbounds %struct.gv* %100, i64 0, i32 0
  %102 = load %struct.xpvgv** %sv_any202, align 8, !tbaa !57
  %xgv_gp203 = getelementptr inbounds %struct.xpvgv* %102, i64 0, i32 7
  %103 = load %struct.gp** %xgv_gp203, align 8, !tbaa !59
  %gp_io204 = getelementptr inbounds %struct.gp* %103, i64 0, i32 2
  %104 = load %struct.io** %gp_io204, align 8, !tbaa !61
  %tobool205 = icmp eq %struct.io* %104, null
  br i1 %tobool205, label %cond.false219, label %land.lhs.true206

land.lhs.true206:                                 ; preds = %land.lhs.true201
  %sv_any210 = getelementptr inbounds %struct.io* %104, i64 0, i32 0
  %105 = load %struct.xpvio** %sv_any210, align 8, !tbaa !63
  %xio_ofp211 = getelementptr inbounds %struct.xpvio* %105, i64 0, i32 8
  %106 = load %struct._PerlIO*** %xio_ofp211, align 8, !tbaa !102
  %tobool212 = icmp eq %struct._PerlIO** %106, null
  br i1 %tobool212, label %cond.false219, label %cond.end221

cond.false219:                                    ; preds = %land.lhs.true206, %land.lhs.true201, %if.then194, %land.lhs.true196
  %call220 = call %struct._PerlIO** @Perl_PerlIO_stderr() #4
  br label %cond.end221

cond.end221:                                      ; preds = %land.lhs.true206, %cond.false219
  %cond222 = phi %struct._PerlIO** [ %call220, %cond.false219 ], [ %106, %land.lhs.true206 ]
  %call223 = call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond222, i8* getelementptr inbounds ([17 x i8]* @.str24, i64 0, i64 0)) #4
  call void @Perl_my_exit(i64 1) #4
  br label %if.end224

if.end224:                                        ; preds = %if.end181, %cond.end221
  %107 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %sub.ptr.lhs.cast225 = ptrtoint %struct.sv** %97 to i64
  %sub.ptr.rhs.cast226 = ptrtoint %struct.sv** %107 to i64
  %sub.ptr.sub227 = sub i64 %sub.ptr.lhs.cast225, %sub.ptr.rhs.cast226
  %sub.ptr.div228 = ashr exact i64 %sub.ptr.sub227, 3
  %108 = load %struct.av** @PL_curstack, align 8, !tbaa !16
  %sv_any229 = getelementptr inbounds %struct.av* %108, i64 0, i32 0
  %109 = load %struct.xpvav** %sv_any229, align 8, !tbaa !97
  %xav_fill230 = getelementptr inbounds %struct.xpvav* %109, i64 0, i32 1
  store i64 %sub.ptr.div228, i64* %xav_fill230, align 8, !tbaa !33
  %si_stack231 = getelementptr inbounds %struct.stackinfo* %99, i64 0, i32 0
  %110 = load %struct.av** %si_stack231, align 8, !tbaa !96
  %sv_any232 = getelementptr inbounds %struct.av* %110, i64 0, i32 0
  %111 = load %struct.xpvav** %sv_any232, align 8, !tbaa !97
  %xav_array233 = getelementptr inbounds %struct.xpvav* %111, i64 0, i32 0
  %112 = load i8** %xav_array233, align 8, !tbaa !99
  %113 = bitcast i8* %112 to %struct.sv**
  store %struct.sv** %113, %struct.sv*** @PL_stack_base, align 8, !tbaa !16
  %114 = load %struct.av** %si_stack231, align 8, !tbaa !96
  %sv_any235 = getelementptr inbounds %struct.av* %114, i64 0, i32 0
  %115 = load %struct.xpvav** %sv_any235, align 8, !tbaa !97
  %xav_max236 = getelementptr inbounds %struct.xpvav* %115, i64 0, i32 2
  %116 = load i64* %xav_max236, align 8, !tbaa !100
  %add.ptr237 = getelementptr inbounds %struct.sv** %113, i64 %116
  store %struct.sv** %add.ptr237, %struct.sv*** @PL_stack_max, align 8, !tbaa !16
  %117 = load %struct.av** %si_stack231, align 8, !tbaa !96
  %sv_any239 = getelementptr inbounds %struct.av* %117, i64 0, i32 0
  %118 = load %struct.xpvav** %sv_any239, align 8, !tbaa !97
  %xav_fill240 = getelementptr inbounds %struct.xpvav* %118, i64 0, i32 1
  %119 = load i64* %xav_fill240, align 8, !tbaa !33
  %add.ptr241 = getelementptr inbounds %struct.sv** %113, i64 %119
  store %struct.sv** %add.ptr241, %struct.sv*** @PL_stack_sp, align 8, !tbaa !16
  %120 = load %struct.av** %si_stack231, align 8, !tbaa !96
  store %struct.av* %120, %struct.av** @PL_curstack, align 8, !tbaa !16
  store %struct.stackinfo* %99, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !16
  %121 = load %struct.gv** @PL_errgv, align 8, !tbaa !16
  %sv_any245 = getelementptr inbounds %struct.gv* %121, i64 0, i32 0
  %122 = load %struct.xpvgv** %sv_any245, align 8, !tbaa !57
  %xgv_gp246 = getelementptr inbounds %struct.xpvgv* %122, i64 0, i32 7
  %123 = load %struct.gp** %xgv_gp246, align 8, !tbaa !59
  %gp_sv = getelementptr inbounds %struct.gp* %123, i64 0, i32 0
  %124 = load %struct.sv** %gp_sv, align 8, !tbaa !123
  %tobool247 = icmp eq %struct.sv* %124, null
  br i1 %tobool247, label %cleanup, label %cond.false249

cond.false249:                                    ; preds = %if.end224
  %sv_flags253 = getelementptr inbounds %struct.sv* %124, i64 0, i32 2
  %125 = load i64* %sv_flags253, align 8, !tbaa !13
  %and254 = and i64 %125, 262144
  %tobool255 = icmp eq i64 %and254, 0
  br i1 %tobool255, label %cond.false275, label %cond.true256

cond.true256:                                     ; preds = %cond.false249
  %sv_any260 = getelementptr inbounds %struct.sv* %124, i64 0, i32 0
  %126 = load i8** %sv_any260, align 8, !tbaa !1
  %127 = bitcast i8* %126 to %struct.xpv*
  store %struct.xpv* %127, %struct.xpv** @PL_Xpv, align 8, !tbaa !16
  %tobool261 = icmp eq i8* %126, null
  br i1 %tobool261, label %cleanup, label %land.lhs.true262

land.lhs.true262:                                 ; preds = %cond.true256
  %xpv_cur = getelementptr inbounds i8* %126, i64 8
  %128 = bitcast i8* %xpv_cur to i64*
  %129 = load i64* %128, align 8, !tbaa !30
  %cmp263 = icmp ugt i64 %129, 1
  br i1 %cmp263, label %if.then310, label %lor.lhs.false265

lor.lhs.false265:                                 ; preds = %land.lhs.true262
  %tobool267 = icmp eq i64 %129, 0
  br i1 %tobool267, label %cleanup, label %land.lhs.true268

land.lhs.true268:                                 ; preds = %lor.lhs.false265
  %xpv_pv269 = bitcast i8* %126 to i8**
  %130 = load i8** %xpv_pv269, align 8, !tbaa !32
  %131 = load i8* %130, align 1, !tbaa !50
  %cmp271 = icmp eq i8 %131, 48
  br i1 %cmp271, label %cleanup, label %if.then310

cond.false275:                                    ; preds = %cond.false249
  %and280 = and i64 %125, 65536
  %tobool281 = icmp eq i64 %and280, 0
  br i1 %tobool281, label %cond.false289, label %cond.true282

cond.true282:                                     ; preds = %cond.false275
  %sv_any286 = getelementptr inbounds %struct.sv* %124, i64 0, i32 0
  %132 = load i8** %sv_any286, align 8, !tbaa !1
  %xiv_iv = getelementptr inbounds i8* %132, i64 24
  %133 = bitcast i8* %xiv_iv to i64*
  %134 = load i64* %133, align 8, !tbaa !89
  %cmp287 = icmp eq i64 %134, 0
  br i1 %cmp287, label %cleanup, label %if.then310

cond.false289:                                    ; preds = %cond.false275
  %and294 = and i64 %125, 131072
  %tobool295 = icmp eq i64 %and294, 0
  br i1 %tobool295, label %cond.false303, label %cond.true296

cond.true296:                                     ; preds = %cond.false289
  %sv_any300 = getelementptr inbounds %struct.sv* %124, i64 0, i32 0
  %135 = load i8** %sv_any300, align 8, !tbaa !1
  %xnv_nv = getelementptr inbounds i8* %135, i64 32
  %136 = bitcast i8* %xnv_nv to double*
  %137 = load double* %136, align 8, !tbaa !107
  %cmp301 = fcmp une double %137, 0.000000e+00
  br i1 %cmp301, label %if.then310, label %cleanup

cond.false303:                                    ; preds = %cond.false289
  %call307 = call signext i8 @Perl_sv_2bool(%struct.sv* %124) #4
  %tobool309 = icmp eq i8 %call307, 0
  br i1 %tobool309, label %cleanup, label %if.then310

if.then310:                                       ; preds = %land.lhs.true268, %cond.true282, %cond.false303, %land.lhs.true262, %cond.true296
  %call311 = call void (i32)* (i32, void (i32)*)* @Perl_rsignal(i32 %sig, void (i32)* inttoptr (i64 1 to void (i32)*)) #4
  %138 = load void (i32)** @PL_csighandlerp, align 8, !tbaa !16
  %call312 = call void (i32)* (i32, void (i32)*)* @Perl_rsignal(i32 %sig, void (i32)* %138) #4
  %call313 = call %struct.op* (i8*, ...)* @Perl_die(i8* null) #4
  br label %cleanup

cleanup:                                          ; preds = %land.lhs.true268, %lor.lhs.false265, %cond.true256, %cond.true282, %cond.false303, %if.end224, %land.lhs.true93, %cond.true296, %if.then310, %lor.lhs.false89, %cond.end141
  %sv.1 = phi %struct.sv* [ %sv.0, %if.then310 ], [ %sv.0, %land.lhs.true268 ], [ %sv.0, %lor.lhs.false265 ], [ %sv.0, %cond.true256 ], [ %sv.0, %cond.true282 ], [ %sv.0, %cond.true296 ], [ %sv.0, %cond.false303 ], [ %sv.0, %if.end224 ], [ null, %cond.end141 ], [ null, %land.lhs.true93 ], [ null, %lor.lhs.false89 ]
  %139 = load i64* %flags, align 8, !tbaa !25
  %and315 = and i64 %139, 1
  %tobool316 = icmp eq i64 %and315, 0
  br i1 %tobool316, label %if.end319, label %if.then317

if.then317:                                       ; preds = %cleanup
  %140 = load i64* @PL_savestack_ix, align 8, !tbaa !25
  %sub318 = add nsw i64 %140, -8
  store i64 %sub318, i64* @PL_savestack_ix, align 8, !tbaa !25
  br label %if.end319

if.end319:                                        ; preds = %cleanup, %if.then317
  %and320 = and i64 %139, 4
  %tobool321 = icmp eq i64 %and320, 0
  br i1 %tobool321, label %if.end324, label %if.then322

if.then322:                                       ; preds = %if.end319
  %141 = load i64** @PL_markstack_ptr, align 8, !tbaa !16
  %incdec.ptr323 = getelementptr inbounds i64* %141, i64 -1
  store i64* %incdec.ptr323, i64** @PL_markstack_ptr, align 8, !tbaa !16
  br label %if.end324

if.end324:                                        ; preds = %if.end319, %if.then322
  %and325 = and i64 %139, 8
  %tobool326 = icmp eq i64 %and325, 0
  br i1 %tobool326, label %if.end328, label %if.then327

if.then327:                                       ; preds = %if.end324
  %142 = load i64* @PL_retstack_ix, align 8, !tbaa !25
  %dec = add nsw i64 %142, -1
  store i64 %dec, i64* @PL_retstack_ix, align 8, !tbaa !25
  br label %if.end328

if.end328:                                        ; preds = %if.end324, %if.then327
  %and329 = and i64 %139, 16
  %tobool330 = icmp eq i64 %and329, 0
  br i1 %tobool330, label %if.end333, label %if.then331

if.then331:                                       ; preds = %if.end328
  %143 = load i64* @PL_scopestack_ix, align 8, !tbaa !25
  %sub332 = add nsw i64 %143, -1
  store i64 %sub332, i64* @PL_scopestack_ix, align 8, !tbaa !25
  br label %if.end333

if.end333:                                        ; preds = %if.end328, %if.then331
  %and334 = and i64 %139, 64
  %tobool335 = icmp eq i64 %and334, 0
  br i1 %tobool335, label %if.end337, label %if.then336

if.then336:                                       ; preds = %if.end333
  call void @Perl_sv_free(%struct.sv* %sv.1) #4
  br label %if.end337

if.end337:                                        ; preds = %if.end333, %if.then336
  store %struct.op* %2, %struct.op** @PL_op, align 8, !tbaa !16
  store %struct.sv* %1, %struct.sv** @PL_Sv, align 8, !tbaa !16
  store %struct.xpv* %3, %struct.xpv** @PL_Xpv, align 8, !tbaa !16
  ret void
}

; Function Attrs: noreturn
declare void @exit(i32) #6

declare void @Perl_save_destructor_x(void (i8*)*, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @unwind_handler_stack(i8* nocapture readonly %p) #0 {
entry:
  %0 = bitcast i8* %p to i64*
  %1 = load i64* %0, align 8, !tbaa !25
  %and = and i64 %1, 1
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i64* @PL_savestack_ix, align 8, !tbaa !25
  %sub = add nsw i64 %2, -5
  store i64 %sub, i64* @PL_savestack_ix, align 8, !tbaa !25
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %and1 = and i64 %1, 64
  %tobool2 = icmp eq i64 %and1, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  %3 = load %struct.sv** @sig_sv, align 8, !tbaa !16
  tail call void @Perl_sv_free(%struct.sv* %3) #4
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.then3
  ret void
}

declare %struct.cv* @Perl_sv_2cv(%struct.sv*, %struct.hv**, %struct.gv**, i64) #1

declare i64 @Perl_call_sv(%struct.sv*, i64) #1

declare %struct.op* @Perl_die(i8*, ...) #1

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind }
attributes #5 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { noreturn "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { noreturn nounwind }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5 (trunk)"}
!1 = metadata !{metadata !2, metadata !3, i64 0}
!2 = metadata !{metadata !"sv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!3 = metadata !{metadata !"any pointer", metadata !4, i64 0}
!4 = metadata !{metadata !"omnipotent char", metadata !5, i64 0}
!5 = metadata !{metadata !"Simple C/C++ TBAA"}
!6 = metadata !{metadata !"long", metadata !4, i64 0}
!7 = metadata !{metadata !8, metadata !3, i64 8}
!8 = metadata !{metadata !"magic", metadata !3, i64 0, metadata !3, i64 8, metadata !9, i64 16, metadata !4, i64 18, metadata !4, i64 19, metadata !3, i64 24, metadata !3, i64 32, metadata !6, i64 40}
!9 = metadata !{metadata !"short", metadata !4, i64 0}
!10 = metadata !{metadata !11, metadata !3, i64 0}
!11 = metadata !{metadata !"mgvtbl", metadata !3, i64 0, metadata !3, i64 8, metadata !3, i64 16, metadata !3, i64 24, metadata !3, i64 32, metadata !3, i64 40, metadata !3, i64 48}
!12 = metadata !{metadata !8, metadata !4, i64 19}
!13 = metadata !{metadata !2, metadata !6, i64 16}
!14 = metadata !{metadata !11, metadata !3, i64 8}
!15 = metadata !{metadata !11, metadata !3, i64 24}
!16 = metadata !{metadata !3, metadata !3, i64 0}
!17 = metadata !{metadata !2, metadata !6, i64 8}
!18 = metadata !{metadata !19, metadata !3, i64 40}
!19 = metadata !{metadata !"xpvmg", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !20, i64 32, metadata !3, i64 40, metadata !3, i64 48}
!20 = metadata !{metadata !"double", metadata !4, i64 0}
!21 = metadata !{metadata !22, metadata !6, i64 8}
!22 = metadata !{metadata !"magic_state", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!23 = metadata !{metadata !8, metadata !3, i64 0}
!24 = metadata !{metadata !22, metadata !3, i64 0}
!25 = metadata !{metadata !6, metadata !6, i64 0}
!26 = metadata !{metadata !22, metadata !6, i64 16}
!27 = metadata !{metadata !11, metadata !3, i64 16}
!28 = metadata !{metadata !29, metadata !4, i64 37}
!29 = metadata !{metadata !"cop", metadata !3, i64 0, metadata !3, i64 8, metadata !3, i64 16, metadata !6, i64 24, metadata !9, i64 32, metadata !9, i64 34, metadata !4, i64 36, metadata !4, i64 37, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !6, i64 64, metadata !6, i64 72, metadata !6, i64 80, metadata !3, i64 88, metadata !3, i64 96}
!30 = metadata !{metadata !31, metadata !6, i64 8}
!31 = metadata !{metadata !"xpv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!32 = metadata !{metadata !31, metadata !3, i64 0}
!33 = metadata !{metadata !34, metadata !6, i64 8}
!34 = metadata !{metadata !"xpvav", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !20, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !3, i64 64, metadata !4, i64 72}
!35 = metadata !{metadata !8, metadata !4, i64 18}
!36 = metadata !{metadata !11, metadata !3, i64 40}
!37 = metadata !{metadata !8, metadata !3, i64 24}
!38 = metadata !{metadata !11, metadata !3, i64 32}
!39 = metadata !{metadata !8, metadata !3, i64 32}
!40 = metadata !{metadata !8, metadata !6, i64 40}
!41 = metadata !{metadata !42, metadata !3, i64 80}
!42 = metadata !{metadata !"pmop", metadata !3, i64 0, metadata !3, i64 8, metadata !3, i64 16, metadata !6, i64 24, metadata !9, i64 32, metadata !9, i64 34, metadata !4, i64 36, metadata !4, i64 37, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !3, i64 64, metadata !3, i64 72, metadata !3, i64 80, metadata !6, i64 88, metadata !6, i64 96, metadata !4, i64 104, metadata !3, i64 112}
!43 = metadata !{metadata !44, metadata !6, i64 96}
!44 = metadata !{metadata !"regexp", metadata !3, i64 0, metadata !3, i64 8, metadata !3, i64 16, metadata !3, i64 24, metadata !3, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !6, i64 64, metadata !6, i64 72, metadata !6, i64 80, metadata !6, i64 88, metadata !6, i64 96, metadata !6, i64 104, metadata !6, i64 112, metadata !6, i64 120, metadata !4, i64 128}
!45 = metadata !{metadata !44, metadata !6, i64 104}
!46 = metadata !{metadata !44, metadata !3, i64 0}
!47 = metadata !{metadata !44, metadata !3, i64 8}
!48 = metadata !{metadata !44, metadata !6, i64 120}
!49 = metadata !{metadata !44, metadata !3, i64 48}
!50 = metadata !{metadata !4, metadata !4, i64 0}
!51 = metadata !{metadata !29, metadata !3, i64 88}
!52 = metadata !{metadata !44, metadata !6, i64 112}
!53 = metadata !{metadata !44, metadata !6, i64 64}
!54 = metadata !{metadata !55, metadata !55, i64 0}
!55 = metadata !{metadata !"int", metadata !4, i64 0}
!56 = metadata !{metadata !29, metadata !3, i64 96}
!57 = metadata !{metadata !58, metadata !3, i64 0}
!58 = metadata !{metadata !"gv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!59 = metadata !{metadata !60, metadata !3, i64 56}
!60 = metadata !{metadata !"xpvgv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !20, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !3, i64 64, metadata !6, i64 72, metadata !3, i64 80, metadata !4, i64 88}
!61 = metadata !{metadata !62, metadata !3, i64 16}
!62 = metadata !{metadata !"gp", metadata !3, i64 0, metadata !6, i64 8, metadata !3, i64 16, metadata !3, i64 24, metadata !3, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !6, i64 64, metadata !6, i64 72, metadata !6, i64 80, metadata !3, i64 88}
!63 = metadata !{metadata !64, metadata !3, i64 0}
!64 = metadata !{metadata !"io", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!65 = metadata !{metadata !66, metadata !6, i64 80}
!66 = metadata !{metadata !"xpvio", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !20, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !3, i64 64, metadata !4, i64 72, metadata !6, i64 80, metadata !6, i64 88, metadata !6, i64 96, metadata !6, i64 104, metadata !3, i64 112, metadata !3, i64 120, metadata !3, i64 128, metadata !3, i64 136, metadata !3, i64 144, metadata !3, i64 152, metadata !9, i64 160, metadata !4, i64 162, metadata !4, i64 163}
!67 = metadata !{metadata !66, metadata !3, i64 112}
!68 = metadata !{metadata !62, metadata !3, i64 48}
!69 = metadata !{metadata !60, metadata !3, i64 64}
!70 = metadata !{metadata !66, metadata !3, i64 128}
!71 = metadata !{metadata !66, metadata !6, i64 96}
!72 = metadata !{metadata !66, metadata !6, i64 104}
!73 = metadata !{metadata !66, metadata !6, i64 88}
!74 = metadata !{metadata !29, metadata !6, i64 72}
!75 = metadata !{metadata !66, metadata !4, i64 163}
!76 = metadata !{metadata !77, metadata !3, i64 0}
!77 = metadata !{metadata !"ufuncs", metadata !3, i64 0, metadata !3, i64 8, metadata !6, i64 16}
!78 = metadata !{metadata !77, metadata !6, i64 16}
!79 = metadata !{metadata !80, metadata !55, i64 24}
!80 = metadata !{metadata !"stat", metadata !6, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !55, i64 24, metadata !55, i64 28, metadata !55, i64 32, metadata !55, i64 36, metadata !6, i64 40, metadata !6, i64 48, metadata !6, i64 56, metadata !6, i64 64, metadata !81, i64 72, metadata !81, i64 88, metadata !81, i64 104, metadata !4, i64 120}
!81 = metadata !{metadata !"timespec", metadata !6, i64 0, metadata !6, i64 8}
!82 = metadata !{metadata !83, metadata !3, i64 72}
!83 = metadata !{metadata !"xpvlv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !20, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !6, i64 56, metadata !6, i64 64, metadata !3, i64 72, metadata !4, i64 80}
!84 = metadata !{metadata !85, metadata !3, i64 0}
!85 = metadata !{metadata !"hv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!86 = metadata !{metadata !87, metadata !6, i64 24}
!87 = metadata !{metadata !"xpvhv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !20, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !6, i64 56, metadata !3, i64 64, metadata !3, i64 72, metadata !3, i64 80}
!88 = metadata !{metadata !87, metadata !20, i64 32}
!89 = metadata !{metadata !90, metadata !6, i64 24}
!90 = metadata !{metadata !"xpviv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24}
!91 = metadata !{metadata !92, metadata !3, i64 48}
!92 = metadata !{metadata !"stackinfo", metadata !3, i64 0, metadata !3, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !6, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !6, i64 56}
!93 = metadata !{metadata !92, metadata !3, i64 40}
!94 = metadata !{metadata !92, metadata !6, i64 32}
!95 = metadata !{metadata !92, metadata !6, i64 16}
!96 = metadata !{metadata !92, metadata !3, i64 0}
!97 = metadata !{metadata !98, metadata !3, i64 0}
!98 = metadata !{metadata !"av", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!99 = metadata !{metadata !34, metadata !3, i64 0}
!100 = metadata !{metadata !34, metadata !6, i64 16}
!101 = metadata !{metadata !58, metadata !6, i64 16}
!102 = metadata !{metadata !66, metadata !3, i64 64}
!103 = metadata !{metadata !104, metadata !3, i64 0}
!104 = metadata !{metadata !"xrv", metadata !3, i64 0}
!105 = metadata !{metadata !19, metadata !3, i64 48}
!106 = metadata !{metadata !87, metadata !3, i64 64}
!107 = metadata !{metadata !108, metadata !20, i64 32}
!108 = metadata !{metadata !"xpvnv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !20, i64 32}
!109 = metadata !{metadata !62, metadata !3, i64 32}
!110 = metadata !{metadata !111, metadata !4, i64 36}
!111 = metadata !{metadata !"op", metadata !3, i64 0, metadata !3, i64 8, metadata !3, i64 16, metadata !6, i64 24, metadata !9, i64 32, metadata !9, i64 34, metadata !4, i64 36, metadata !4, i64 37}
!112 = metadata !{metadata !83, metadata !6, i64 56}
!113 = metadata !{metadata !83, metadata !6, i64 64}
!114 = metadata !{metadata !77, metadata !3, i64 8}
!115 = metadata !{metadata !66, metadata !3, i64 120}
!116 = metadata !{metadata !66, metadata !3, i64 136}
!117 = metadata !{metadata !118, metadata !6, i64 16}
!118 = metadata !{metadata !"cv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!119 = metadata !{metadata !118, metadata !3, i64 0}
!120 = metadata !{metadata !121, metadata !3, i64 72}
!121 = metadata !{metadata !"xpvcv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !20, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !3, i64 64, metadata !3, i64 72, metadata !3, i64 80, metadata !4, i64 88, metadata !3, i64 96, metadata !3, i64 104, metadata !6, i64 112, metadata !3, i64 120, metadata !3, i64 128, metadata !9, i64 136, metadata !6, i64 144}
!122 = metadata !{metadata !121, metadata !3, i64 96}
!123 = metadata !{metadata !62, metadata !3, i64 0}
