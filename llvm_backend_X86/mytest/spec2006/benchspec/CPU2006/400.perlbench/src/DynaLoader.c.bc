; ModuleID = 'DynaLoader.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.sv = type { i8*, i64, i64 }
%struct.op = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8 }
%struct.cv = type { %struct.xpvcv*, i64, i64 }
%struct.xpvcv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.hv*, %struct.op*, %struct.op*, {}*, %union.any, %struct.gv*, i8*, i64, %struct.av*, %struct.cv*, i16, i64 }
%struct.magic = type { %struct.magic*, %struct.mgvtbl*, i16, i8, i8, %struct.sv*, i8*, i64 }
%struct.mgvtbl = type { i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i64 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)*, i32 (%struct.magic*, %struct.clone_params*)* }
%struct.clone_params = type { %struct.av*, i64, %struct.interpreter* }
%struct.interpreter = type { i8 }
%struct.hv = type { %struct.xpvhv*, i64, i64 }
%struct.xpvhv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, i64, %struct.he*, %struct.pmop*, i8* }
%struct.he = type { %struct.he*, %struct.hek*, %struct.sv* }
%struct.hek = type { i64, i64, [1 x i8] }
%struct.pmop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.pmop*, %struct.regexp*, i64, i64, i8, %struct.hv* }
%struct.regexp = type { i64*, i64*, %struct.regnode*, %struct.reg_substr_data*, i8*, %struct.reg_data*, i8*, i64*, i64, i64, i64, i64, i64, i64, i64, i64, [1 x %struct.regnode] }
%struct.regnode = type { i8, i8, i16 }
%struct.reg_substr_data = type opaque
%struct.reg_data = type opaque
%union.any = type { i8* }
%struct.gv = type { %struct.xpvgv*, i64, i64 }
%struct.xpvgv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.gp*, i8*, i64, %struct.hv*, i8 }
%struct.gp = type { %struct.sv*, i64, %struct.io*, %struct.cv*, %struct.av*, %struct.hv*, %struct.gv*, %struct.cv*, i64, i64, i64, i8* }
%struct.io = type { %struct.xpvio*, i64, i64 }
%struct.xpvio = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct._PerlIO**, %struct._PerlIO**, %union.anon, i64, i64, i64, i64, i8*, %struct.gv*, i8*, %struct.gv*, i8*, %struct.gv*, i16, i8, i8 }
%struct._PerlIO = type opaque
%union.anon = type { %struct.__dirstream* }
%struct.__dirstream = type opaque
%struct.av = type { %struct.xpvav*, i64, i64 }
%struct.xpvav = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.sv**, %struct.sv*, i8 }

@PL_stack_sp = external global %struct.sv**
@PL_stack_base = external global %struct.sv**
@PL_markstack_ptr = external global i64*
@.str = private unnamed_addr constant [30 x i8] c"Usage: DynaLoader::dl_error()\00", align 1
@PL_op = external global %struct.op*
@PL_curpad = external global %struct.sv**
@.str1 = private unnamed_addr constant [16 x i8] c"Not implemented\00", align 1
@.str2 = private unnamed_addr constant [13 x i8] c"DynaLoader.c\00", align 1
@.str3 = private unnamed_addr constant [21 x i8] c"DynaLoader::dl_error\00", align 1
@PL_sv_yes = external global %struct.sv

; Function Attrs: nounwind uwtable
define void @XS_DynaLoader_dl_error(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add i64 %sub.ptr.div, 1
  %cmp = icmp eq %struct.sv** %0, %add.ptr
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([30 x i8]* @.str, i64 0, i64 0)) #2
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = load %struct.op** @PL_op, align 8, !tbaa !1
  %op_private = getelementptr inbounds %struct.op* %4, i64 0, i32 7
  %5 = load i8* %op_private, align 1, !tbaa !7
  %and = and i8 %5, 32
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %op_targ = getelementptr inbounds %struct.op* %4, i64 0, i32 3
  %6 = load i64* %op_targ, align 8, !tbaa !10
  %7 = load %struct.sv*** @PL_curpad, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.sv** %7, i64 %6
  %8 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = tail call %struct.sv* @Perl_sv_newmortal() #2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %8, %cond.true ], [ %call, %cond.false ]
  tail call void @Perl_sv_setpv(%struct.sv* %cond, i8* getelementptr inbounds ([16 x i8]* @.str1, i64 0, i64 0)) #2
  %9 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %10 = load i64* %sv_flags, align 8, !tbaa !11
  %and7 = and i64 %10, 16384
  %tobool8 = icmp eq i64 %and7, 0
  br i1 %tobool8, label %if.end11, label %if.then9

if.then9:                                         ; preds = %cond.end
  %call10 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #2
  br label %if.end11

if.end11:                                         ; preds = %cond.end, %if.then9
  %incdec.ptr12 = getelementptr inbounds %struct.sv** %9, i64 %add
  store %struct.sv* %cond, %struct.sv** %incdec.ptr12, align 8, !tbaa !1
  %11 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr14 = getelementptr inbounds %struct.sv** %11, i64 %add
  store %struct.sv** %add.ptr14, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare void @Perl_croak(i8*, ...) #1

declare %struct.sv* @Perl_sv_newmortal() #1

declare void @Perl_sv_setpv(%struct.sv*, i8*) #1

declare i32 @Perl_mg_set(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define void @boot_DynaLoader(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %0, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %1 = load i64* %0, align 8, !tbaa !5
  %add.ptr.idx = shl nuw i64 %1, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %call = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([21 x i8]* @.str3, i64 0, i64 0), void (%struct.cv*)* @XS_DynaLoader_dl_error, i8* getelementptr inbounds ([13 x i8]* @.str2, i64 0, i64 0)) #2
  %2 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.sv** %2, i64 %add
  store %struct.sv* @PL_sv_yes, %struct.sv** %arrayidx, align 8, !tbaa !1
  %3 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr6 = getelementptr inbounds %struct.sv** %3, i64 %add
  store %struct.sv** %add.ptr6, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare %struct.cv* @Perl_newXS(i8*, void (%struct.cv*)*, i8*) #1

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5 (trunk)"}
!1 = metadata !{metadata !2, metadata !2, i64 0}
!2 = metadata !{metadata !"any pointer", metadata !3, i64 0}
!3 = metadata !{metadata !"omnipotent char", metadata !4, i64 0}
!4 = metadata !{metadata !"Simple C/C++ TBAA"}
!5 = metadata !{metadata !6, metadata !6, i64 0}
!6 = metadata !{metadata !"long", metadata !3, i64 0}
!7 = metadata !{metadata !8, metadata !3, i64 37}
!8 = metadata !{metadata !"op", metadata !2, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !6, i64 24, metadata !9, i64 32, metadata !9, i64 34, metadata !3, i64 36, metadata !3, i64 37}
!9 = metadata !{metadata !"short", metadata !3, i64 0}
!10 = metadata !{metadata !8, metadata !6, i64 24}
!11 = metadata !{metadata !12, metadata !6, i64 16}
!12 = metadata !{metadata !"sv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16}
