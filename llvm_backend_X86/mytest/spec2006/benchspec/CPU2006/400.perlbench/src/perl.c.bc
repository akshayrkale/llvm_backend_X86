; ModuleID = 'perl.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.interpreter = type { i8 }
%struct.sv = type { i8*, i64, i64 }
%struct.cop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, i8*, %struct.hv*, %struct.gv*, i64, i64, i64, %struct.sv*, %struct.sv* }
%struct.op = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8 }
%struct.hv = type { %struct.xpvhv*, i64, i64 }
%struct.xpvhv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, i64, %struct.he*, %struct.pmop*, i8* }
%struct.magic = type { %struct.magic*, %struct.mgvtbl*, i16, i8, i8, %struct.sv*, i8*, i64 }
%struct.mgvtbl = type { i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i64 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)*, i32 (%struct.magic*, %struct.clone_params*)* }
%struct.clone_params = type { %struct.av*, i64, %struct.interpreter* }
%struct.av = type { %struct.xpvav*, i64, i64 }
%struct.xpvav = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.sv**, %struct.sv*, i8 }
%struct.he = type { %struct.he*, %struct.hek*, %struct.sv* }
%struct.hek = type { i64, i64, [1 x i8] }
%struct.pmop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.pmop*, %struct.regexp*, i64, i64, i8, %struct.hv* }
%struct.regexp = type { i64*, i64*, %struct.regnode*, %struct.reg_substr_data*, i8*, %struct.reg_data*, i8*, i64*, i64, i64, i64, i64, i64, i64, i64, i64, [1 x %struct.regnode] }
%struct.regnode = type { i8, i8, i16 }
%struct.reg_substr_data = type opaque
%struct.reg_data = type opaque
%struct.gv = type { %struct.xpvgv*, i64, i64 }
%struct.xpvgv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.gp*, i8*, i64, %struct.hv*, i8 }
%struct.gp = type { %struct.sv*, i64, %struct.io*, %struct.cv*, %struct.av*, %struct.hv*, %struct.gv*, %struct.cv*, i64, i64, i64, i8* }
%struct.io = type { %struct.xpvio*, i64, i64 }
%struct.xpvio = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct._PerlIO**, %struct._PerlIO**, %union.anon, i64, i64, i64, i64, i8*, %struct.gv*, i8*, %struct.gv*, i8*, %struct.gv*, i16, i8, i8 }
%struct._PerlIO = type opaque
%union.anon = type { %struct.__dirstream* }
%struct.__dirstream = type opaque
%struct.cv = type { %struct.xpvcv*, i64, i64 }
%struct.xpvcv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.hv*, %struct.op*, %struct.op*, void (%struct.cv*)*, %union.any, %struct.gv*, i8*, i64, %struct.av*, %struct.cv*, i16, i64 }
%union.any = type { i8* }
%struct.jmpenv = type { [1 x %struct.__jmp_buf_tag], %struct.jmpenv*, i32, i8 }
%struct.__jmp_buf_tag = type { [8 x i64], i64, [16 x i64] }
%struct.perl_debug_pad = type { [3 x %struct.sv] }
%struct.exitlistentry = type { void (i8*)*, i8* }
%struct.stackinfo = type { %struct.av*, %struct.context*, i64, i64, i64, %struct.stackinfo*, %struct.stackinfo*, i64 }
%struct.context = type { i64, %union.anon.0 }
%union.anon.0 = type { %struct.block }
%struct.block = type { i64, %struct.cop*, i64, i64, i64, %struct.pmop*, i8, %union.anon.1 }
%union.anon.1 = type { %struct.block_loop }
%struct.block_loop = type { i8*, i64, %struct.op*, %struct.op*, %struct.op*, %struct.sv**, %struct.sv*, %struct.sv*, %struct.av*, i64, i64 }
%struct.xpv = type { i8*, i64, i64 }
%struct.logop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op* }
%struct.unop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op* }

@PL_curinterp = external global %struct.interpreter*
@PL_perl_destruct_level = external global i32
@PL_linestr = external global %struct.sv*
@PL_compiling = external global %struct.cop
@PL_curcop = external global %struct.cop*
@PL_sv_undef = external global %struct.sv
@PL_sv_no = external global %struct.sv
@PL_No = external global i8*
@PL_sv_yes = external global %struct.sv
@PL_Yes = external global i8*
@PL_sv_placeholder = external global %struct.sv
@PL_sighandlerp = external global void (i32)*
@PL_pidstatus = external global %struct.hv*
@.str = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@PL_rs = external global %struct.sv*
@PL_lex_state = external global i64
@PL_start_env = external global %struct.jmpenv
@PL_top_env = external global %struct.jmpenv*
@PL_statusvalue = external global i64
@PL_patchlevel = external global %struct.sv*
@local_patches = internal global [2 x i8*] zeroinitializer, align 16
@PL_localpatches = external global i8**
@PL_fdpid = external global %struct.av*
@PL_modglobal = external global %struct.hv*
@.str1 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@PL_errors = external global %struct.sv*
@PL_debug_pad = external global %struct.perl_debug_pad
@PL_strtab = external global %struct.hv*
@environ = external global i8**
@PL_origenviron = external global i8**
@PL_clocktick = external global i64
@PL_stashcache = external global %struct.hv*
@PL_exit_flags = external global i8
@PL_endav = external global %struct.av*
@PL_minus_c = external global i8
@PL_scopestack_ix = external global i64
@PL_tmps_ix = external global i64
@PL_tmps_floor = external global i64
@PL_threadhook = external global i32 ()*
@PL_main_root = external global %struct.op*
@PL_main_cv = external global %struct.cv*
@PL_comppad = external global %struct.av*
@PL_curpad = external global %struct.sv**
@PL_main_start = external global %struct.op*
@PL_dirty = external global i8
@PL_sv_objcount = external global i64
@PL_warnhook = external global %struct.sv*
@PL_diehook = external global %struct.sv*
@PL_exitlistlen = external global i64
@PL_exitlist = external global %struct.exitlistentry*
@PL_use_safe_putenv = external global i32
@PL_rsfp = external global %struct._PerlIO**
@PL_rsfp_filters = external global %struct.av*
@PL_preprocess = external global i8
@PL_minus_n = external global i8
@PL_minus_p = external global i8
@PL_minus_l = external global i8
@PL_minus_a = external global i8
@PL_minus_F = external global i8
@PL_doswitches = external global i8
@PL_dowarn = external global i8
@PL_doextract = external global i8
@PL_sawampersand = external global i8
@PL_unsafe = external global i8
@PL_inplace = external global i8*
@PL_e_script = external global %struct.sv*
@PL_perldb = external global i64
@PL_ofs_sv = external global %struct.sv*
@PL_ors_sv = external global %struct.sv*
@PL_multiline = external global i32
@PL_osname = external global i8*
@PL_statname = external global %struct.sv*
@PL_statgv = external global %struct.gv*
@PL_lastscream = external global %struct.sv*
@PL_screamfirst = external global i64*
@PL_screamnext = external global i64*
@PL_efloatbuf = external global i8*
@PL_efloatsize = external global i64
@PL_beginav = external global %struct.av*
@PL_beginav_save = external global %struct.av*
@PL_checkav = external global %struct.av*
@PL_checkav_save = external global %struct.av*
@PL_initav = external global %struct.av*
@PL_envgv = external global %struct.gv*
@PL_incgv = external global %struct.gv*
@PL_hintgv = external global %struct.gv*
@PL_errgv = external global %struct.gv*
@PL_argvgv = external global %struct.gv*
@PL_argvoutgv = external global %struct.gv*
@PL_stdingv = external global %struct.gv*
@PL_stderrgv = external global %struct.gv*
@PL_last_in_gv = external global %struct.gv*
@PL_replgv = external global %struct.gv*
@PL_DBgv = external global %struct.gv*
@PL_DBline = external global %struct.gv*
@PL_DBsub = external global %struct.gv*
@PL_DBsingle = external global %struct.sv*
@PL_DBtrace = external global %struct.sv*
@PL_DBsignal = external global %struct.sv*
@PL_DBcv = external global %struct.cv*
@PL_dbargs = external global %struct.av*
@PL_debstash = external global %struct.hv*
@PL_argvout_stack = external global %struct.av*
@PL_preambleav = external global %struct.av*
@PL_subname = external global %struct.sv*
@PL_toptarget = external global %struct.sv*
@PL_bodytarget = external global %struct.sv*
@PL_formtarget = external global %struct.sv*
@PL_utf8_alnum = external global %struct.sv*
@PL_utf8_alnumc = external global %struct.sv*
@PL_utf8_ascii = external global %struct.sv*
@PL_utf8_alpha = external global %struct.sv*
@PL_utf8_space = external global %struct.sv*
@PL_utf8_cntrl = external global %struct.sv*
@PL_utf8_graph = external global %struct.sv*
@PL_utf8_digit = external global %struct.sv*
@PL_utf8_upper = external global %struct.sv*
@PL_utf8_lower = external global %struct.sv*
@PL_utf8_print = external global %struct.sv*
@PL_utf8_punct = external global %struct.sv*
@PL_utf8_xdigit = external global %struct.sv*
@PL_utf8_mark = external global %struct.sv*
@PL_utf8_toupper = external global %struct.sv*
@PL_utf8_totitle = external global %struct.sv*
@PL_utf8_tolower = external global %struct.sv*
@PL_utf8_tofold = external global %struct.sv*
@PL_utf8_idstart = external global %struct.sv*
@PL_utf8_idcont = external global %struct.sv*
@PL_defstash = external global %struct.hv*
@PL_curstname = external global %struct.sv*
@.str2 = private unnamed_addr constant [48 x i8] c"Unbalanced scopes: %ld more ENTERs than LEAVEs\0A\00", align 1
@PL_savestack_ix = external global i64
@.str3 = private unnamed_addr constant [48 x i8] c"Unbalanced saves: %ld more saves than restores\0A\00", align 1
@.str4 = private unnamed_addr constant [45 x i8] c"Unbalanced tmps: %ld more allocs than frees\0A\00", align 1
@PL_curstackinfo = external global %struct.stackinfo*
@.str5 = private unnamed_addr constant [47 x i8] c"Unbalanced context: %ld more PUSHes than POPs\0A\00", align 1
@PL_sv_count = external global i64
@.str6 = private unnamed_addr constant [48 x i8] c"Unbalanced string table refcount: (%d) for \22%s\22\00", align 1
@.str7 = private unnamed_addr constant [21 x i8] c"Scalars leaked: %ld\0A\00", align 1
@PL_origfilename = external global i8*
@PL_reg_start_tmp = external global i8**
@PL_reg_start_tmpl = external global i64
@PL_reg_curpm = external global %struct.pmop*
@PL_reg_poscache = external global i8*
@PL_op_mask = external global i8*
@PL_psig_ptr = external global %struct.sv**
@PL_psig_name = external global %struct.sv**
@PL_bitcount = external global i8*
@PL_psig_pend = external global i32*
@PL_formfeed = external global %struct.sv*
@PL_ofmt = external global i8*
@PL_tainting = external global i8
@PL_taint_warn = external global i8
@PL_hints = external global i64
@PL_debug = external global i64
@PL_mess_sv = external global %struct.sv*
@PL_rehash_seed_set = external global i8
@PL_rehash_seed = external global i64
@PL_origargc = external global i32
@PL_origargv = external global i8**
@.str8 = private unnamed_addr constant [11 x i8] c"NoNe  SuCh\00", align 1
@PL_origalen = external global i64
@PL_do_undump = external global i8
@PL_basetime = external global i64
@PL_curstash = external global %struct.hv*
@.str9 = private unnamed_addr constant [16 x i8] c"panic: top_env\0A\00", align 1
@PL_restartop = external global %struct.op*
@PL_curstack = external global %struct.av*
@PL_mainstack = external global %struct.av*
@PL_stack_sp = external global %struct.sv**
@.str10 = private unnamed_addr constant [17 x i8] c"panic: POPSTACK\0A\00", align 1
@PL_stack_base = external global %struct.sv**
@PL_stack_max = external global %struct.sv**
@.str11 = private unnamed_addr constant [18 x i8] c"panic: restartop\0A\00", align 1
@PL_markstack_ptr = external global i64*
@PL_markstack_max = external global i64*
@PL_op = external global %struct.op*
@PL_ppaddr = external global [0 x %struct.op* ()*]
@PL_markstack = external global i64*
@PL_retstack_ix = external global i64
@PL_curpm = external global %struct.pmop*
@PL_in_eval = external global i32
@PL_eval_root = external global %struct.op*
@.str12 = private unnamed_addr constant [21 x i8] c"Callback called exit\00", align 1
@.str13 = private unnamed_addr constant [10 x i8] c"eval_sv()\00", align 1
@PL_Xpv = external global %struct.xpv*
@PL_Sv = external global %struct.sv*
@.str14 = private unnamed_addr constant [10 x i8] c"require '\00", align 1
@.str15 = private unnamed_addr constant [2 x i8] c"'\00", align 1
@.str16 = private unnamed_addr constant [2 x i8] c"/\00", align 1
@PL_unicode = external global i64
@PL_splitstr = external global i8*
@.str17 = private unnamed_addr constant [3 x i8] c"-d\00", align 1
@.str18 = private unnamed_addr constant [17 x i8] c"PERL5DB_THREADED\00", align 1
@.str19 = private unnamed_addr constant [2 x i8] c"1\00", align 1
@.str20 = private unnamed_addr constant [12 x i8] c"use Devel::\00", align 1
@.str21 = private unnamed_addr constant [14 x i8] c" split(/,/,q{\00", align 1
@.str22 = private unnamed_addr constant [3 x i8] c"})\00", align 1
@.str23 = private unnamed_addr constant [8 x i8] c"PERL5DB\00", align 1
@PL_na = external global i64
@.str24 = private unnamed_addr constant [70 x i8] c"Recompile perl with -DDEBUGGING to use -D switch (did you mean -d ?)\0A\00", align 1
@.str25 = private unnamed_addr constant [3 x i8] c"-I\00", align 1
@.str26 = private unnamed_addr constant [30 x i8] c"No directory specified for -I\00", align 1
@.str27 = private unnamed_addr constant [3 x i8] c"\0A\0A\00", align 1
@.str28 = private unnamed_addr constant [3 x i8] c"-M\00", align 1
@.str29 = private unnamed_addr constant [3 x i8] c"-m\00", align 1
@.str30 = private unnamed_addr constant [5 x i8] c"use \00", align 1
@.str31 = private unnamed_addr constant [4 x i8] c"no \00", align 1
@.str32 = private unnamed_addr constant [28 x i8] c"Can't use '%c' after -mname\00", align 1
@.str33 = private unnamed_addr constant [4 x i8] c" ()\00", align 1
@.str34 = private unnamed_addr constant [37 x i8] c"Module name required with -%c option\00", align 1
@.str35 = private unnamed_addr constant [13 x i8] c" split(/,/,q\00", align 1
@.str36 = private unnamed_addr constant [3 x i8] c"\00)\00", align 1
@.str37 = private unnamed_addr constant [24 x i8] c"Missing argument to -%c\00", align 1
@.str38 = private unnamed_addr constant [3 x i8] c"-s\00", align 1
@.str39 = private unnamed_addr constant [68 x i8] c"\22-%c\22 is on the #! line, it must also be used on the command line%s\00", align 1
@.str40 = private unnamed_addr constant [33 x i8] c"\0AThis is perl, v%vd built for %s\00", align 1
@.str41 = private unnamed_addr constant [9 x i8] c"spec-cpu\00", align 1
@.str42 = private unnamed_addr constant [35 x i8] c"\0A\0ACopyright 1987-2005, Larry Wall\0A\00", align 1
@.str43 = private unnamed_addr constant [377 x i8] c"\0APerl may be copied only under the terms of either the Artistic License or the\0AGNU General Public License, which may be found in the Perl 5 source kit.\0A\0AComplete documentation for Perl, including FAQ lists, should be found on\0Athis system using `man perl' or `perldoc perl'.  If you have access to the\0AInternet, point your browser at http://www.perl.org/, the Perl Home Page.\0A\0A\00", align 1
@.str44 = private unnamed_addr constant [31 x i8] c"Can't emulate -%.1s on #! line\00", align 1
@.str45 = private unnamed_addr constant [9 x i8] c"DB::args\00", align 1
@.str46 = private unnamed_addr constant [7 x i8] c"DB::DB\00", align 1
@.str47 = private unnamed_addr constant [11 x i8] c"DB::dbline\00", align 1
@.str48 = private unnamed_addr constant [8 x i8] c"DB::sub\00", align 1
@.str49 = private unnamed_addr constant [11 x i8] c"DB::single\00", align 1
@.str50 = private unnamed_addr constant [10 x i8] c"DB::trace\00", align 1
@.str51 = private unnamed_addr constant [11 x i8] c"DB::signal\00", align 1
@PL_tmps_stack = external global %struct.sv**
@PL_tmps_max = external global i64
@PL_scopestack = external global i64*
@PL_scopestack_max = external global i64
@PL_savestack = external global %union.any*
@PL_savestack_max = external global i64
@PL_retstack = external global %struct.op**
@PL_retstack_max = external global i64
@.str52 = private unnamed_addr constant [5 x i8] c"ARGV\00", align 1
@PL_utf8locale = external global i8
@PL_savebegin = external global i8
@.str53 = private unnamed_addr constant [34 x i8] c"BEGIN failed--compilation aborted\00", align 1
@.str54 = private unnamed_addr constant [30 x i8] c"%s failed--call queue aborted\00", align 1
@.str55 = private unnamed_addr constant [6 x i8] c"CHECK\00", align 1
@.str56 = private unnamed_addr constant [5 x i8] c"INIT\00", align 1
@.str57 = private unnamed_addr constant [4 x i8] c"END\00", align 1
@.str58 = private unnamed_addr constant [3 x i8] c"%_\00", align 1

; Function Attrs: nounwind uwtable
define %struct.interpreter* @perl_alloc() #0 {
entry:
  %call = tail call i8* @malloc(i64 1) #2
  %0 = load %struct.interpreter** @PL_curinterp, align 8, !tbaa !1
  %tobool = icmp eq %struct.interpreter* %0, null
  %1 = bitcast i8* %call to %struct.interpreter*
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %struct.interpreter* %1, %struct.interpreter** @PL_curinterp, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  store i8 0, i8* %call, align 1
  ret %struct.interpreter* %1
}

; Function Attrs: nounwind
declare noalias i8* @malloc(i64) #1

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #2

; Function Attrs: nounwind uwtable
define void @perl_construct(%struct.interpreter* nocapture readnone %my_perl) #0 {
entry:
  %0 = load i32* @PL_perl_destruct_level, align 4, !tbaa !5
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call i32 (...)* @init_interp() #2
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load %struct.sv** @PL_linestr, align 8, !tbaa !1
  %tobool = icmp eq %struct.sv* %1, null
  br i1 %tobool, label %if.then1, label %if.end37

if.then1:                                         ; preds = %if.end
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !1
  %call2 = tail call %struct.sv* @Perl_newSV(i64 79) #2
  store %struct.sv* %call2, %struct.sv** @PL_linestr, align 8, !tbaa !1
  %call3 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %call2, i64 5) #2
  %2 = load i64* getelementptr inbounds (%struct.sv* @PL_sv_undef, i64 0, i32 2), align 8, !tbaa !7
  %and = and i64 %2, 8388608
  %tobool4 = icmp eq i64 %and, 0
  br i1 %tobool4, label %if.then5, label %if.end35

if.then5:                                         ; preds = %if.then1
  %or = or i64 %2, 8388608
  store i64 %or, i64* getelementptr inbounds (%struct.sv* @PL_sv_undef, i64 0, i32 2), align 8, !tbaa !7
  store i64 9223372036854775807, i64* getelementptr inbounds (%struct.sv* @PL_sv_undef, i64 0, i32 1), align 8, !tbaa !10
  %3 = load i8** @PL_No, align 8, !tbaa !1
  tail call void @Perl_sv_setpv(%struct.sv* @PL_sv_no, i8* %3) #2
  %4 = load i64* getelementptr inbounds (%struct.sv* @PL_sv_no, i64 0, i32 2), align 8, !tbaa !7
  %and6 = and i64 %4, 65536
  %tobool7 = icmp eq i64 %and6, 0
  br i1 %tobool7, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.then5
  %call8 = tail call i64 @Perl_sv_2iv(%struct.sv* @PL_sv_no) #2
  %.pre = load i64* getelementptr inbounds (%struct.sv* @PL_sv_no, i64 0, i32 2), align 8, !tbaa !7
  br label %cond.end

cond.end:                                         ; preds = %if.then5, %cond.false
  %5 = phi i64 [ %4, %if.then5 ], [ %.pre, %cond.false ]
  %and9 = and i64 %5, 131072
  %tobool10 = icmp eq i64 %and9, 0
  br i1 %tobool10, label %cond.false12, label %cond.end14

cond.false12:                                     ; preds = %cond.end
  %call13 = tail call double @Perl_sv_2nv(%struct.sv* @PL_sv_no) #2
  %.pre75 = load i64* getelementptr inbounds (%struct.sv* @PL_sv_no, i64 0, i32 2), align 8, !tbaa !7
  br label %cond.end14

cond.end14:                                       ; preds = %cond.end, %cond.false12
  %6 = phi i64 [ %5, %cond.end ], [ %.pre75, %cond.false12 ]
  %or16 = or i64 %6, 8388608
  store i64 %or16, i64* getelementptr inbounds (%struct.sv* @PL_sv_no, i64 0, i32 2), align 8, !tbaa !7
  store i64 9223372036854775807, i64* getelementptr inbounds (%struct.sv* @PL_sv_no, i64 0, i32 1), align 8, !tbaa !10
  %7 = load i8** @PL_Yes, align 8, !tbaa !1
  tail call void @Perl_sv_setpv(%struct.sv* @PL_sv_yes, i8* %7) #2
  %8 = load i64* getelementptr inbounds (%struct.sv* @PL_sv_yes, i64 0, i32 2), align 8, !tbaa !7
  %and17 = and i64 %8, 65536
  %tobool18 = icmp eq i64 %and17, 0
  br i1 %tobool18, label %cond.false21, label %cond.end23

cond.false21:                                     ; preds = %cond.end14
  %call22 = tail call i64 @Perl_sv_2iv(%struct.sv* @PL_sv_yes) #2
  %.pre76 = load i64* getelementptr inbounds (%struct.sv* @PL_sv_yes, i64 0, i32 2), align 8, !tbaa !7
  br label %cond.end23

cond.end23:                                       ; preds = %cond.end14, %cond.false21
  %9 = phi i64 [ %8, %cond.end14 ], [ %.pre76, %cond.false21 ]
  %and25 = and i64 %9, 131072
  %tobool26 = icmp eq i64 %and25, 0
  br i1 %tobool26, label %cond.false29, label %cond.end31

cond.false29:                                     ; preds = %cond.end23
  %call30 = tail call double @Perl_sv_2nv(%struct.sv* @PL_sv_yes) #2
  %.pre77 = load i64* getelementptr inbounds (%struct.sv* @PL_sv_yes, i64 0, i32 2), align 8, !tbaa !7
  br label %cond.end31

cond.end31:                                       ; preds = %cond.end23, %cond.false29
  %10 = phi i64 [ %9, %cond.end23 ], [ %.pre77, %cond.false29 ]
  %or33 = or i64 %10, 8388608
  store i64 %or33, i64* getelementptr inbounds (%struct.sv* @PL_sv_yes, i64 0, i32 2), align 8, !tbaa !7
  store i64 9223372036854775807, i64* getelementptr inbounds (%struct.sv* @PL_sv_yes, i64 0, i32 1), align 8, !tbaa !10
  %11 = load i64* getelementptr inbounds (%struct.sv* @PL_sv_placeholder, i64 0, i32 2), align 8, !tbaa !7
  %or34 = or i64 %11, 8388608
  store i64 %or34, i64* getelementptr inbounds (%struct.sv* @PL_sv_placeholder, i64 0, i32 2), align 8, !tbaa !7
  store i64 9223372036854775807, i64* getelementptr inbounds (%struct.sv* @PL_sv_placeholder, i64 0, i32 1), align 8, !tbaa !10
  br label %if.end35

if.end35:                                         ; preds = %if.then1, %cond.end31
  store void (i32)* @Perl_sighandler, void (i32)** @PL_sighandlerp, align 8, !tbaa !1
  %call36 = tail call %struct.hv* @Perl_newHV() #2
  store %struct.hv* %call36, %struct.hv** @PL_pidstatus, align 8, !tbaa !1
  br label %if.end37

if.end37:                                         ; preds = %if.end, %if.end35
  %call38 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([2 x i8]* @.str, i64 0, i64 0), i64 1) #2
  store %struct.sv* %call38, %struct.sv** @PL_rs, align 8, !tbaa !1
  %call.i = tail call %struct.stackinfo* @Perl_new_stackinfo(i64 128, i64 52) #2
  store %struct.stackinfo* %call.i, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  %si_type.i = getelementptr inbounds %struct.stackinfo* %call.i, i64 0, i32 4
  store i64 1, i64* %si_type.i, align 8, !tbaa !11
  %si_stack.i = getelementptr inbounds %struct.stackinfo* %call.i, i64 0, i32 0
  %12 = load %struct.av** %si_stack.i, align 8, !tbaa !13
  store %struct.av* %12, %struct.av** @PL_curstack, align 8, !tbaa !1
  store %struct.av* %12, %struct.av** @PL_mainstack, align 8, !tbaa !1
  %sv_any.i = getelementptr inbounds %struct.av* %12, i64 0, i32 0
  %13 = load %struct.xpvav** %sv_any.i, align 8, !tbaa !14
  %xav_array.i = getelementptr inbounds %struct.xpvav* %13, i64 0, i32 0
  %14 = load i8** %xav_array.i, align 8, !tbaa !16
  %15 = bitcast i8* %14 to %struct.sv**
  store %struct.sv** %15, %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  store %struct.sv** %15, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %16 = load %struct.xpvav** %sv_any.i, align 8, !tbaa !14
  %xav_max.i = getelementptr inbounds %struct.xpvav* %16, i64 0, i32 2
  %17 = load i64* %xav_max.i, align 8, !tbaa !19
  %add.ptr.i = getelementptr inbounds %struct.sv** %15, i64 %17
  store %struct.sv** %add.ptr.i, %struct.sv*** @PL_stack_max, align 8, !tbaa !1
  %call2.i = tail call i8* @Perl_safesysmalloc(i64 1024) #2
  %18 = bitcast i8* %call2.i to %struct.sv**
  store %struct.sv** %18, %struct.sv*** @PL_tmps_stack, align 8, !tbaa !1
  store i64 -1, i64* @PL_tmps_floor, align 8, !tbaa !20
  store i64 -1, i64* @PL_tmps_ix, align 8, !tbaa !20
  store i64 128, i64* @PL_tmps_max, align 8, !tbaa !20
  %call3.i = tail call i8* @Perl_safesysmalloc(i64 256) #2
  %19 = bitcast i8* %call3.i to i64*
  store i64* %19, i64** @PL_markstack, align 8, !tbaa !1
  store i64* %19, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %add.ptr4.i = getelementptr inbounds i8* %call3.i, i64 256
  %20 = bitcast i8* %add.ptr4.i to i64*
  store i64* %20, i64** @PL_markstack_max, align 8, !tbaa !1
  %call5.i = tail call i8* @Perl_safesysmalloc(i64 256) #2
  %21 = bitcast i8* %call5.i to i64*
  store i64* %21, i64** @PL_scopestack, align 8, !tbaa !1
  store i64 0, i64* @PL_scopestack_ix, align 8, !tbaa !20
  store i64 32, i64* @PL_scopestack_max, align 8, !tbaa !20
  %call6.i = tail call i8* @Perl_safesysmalloc(i64 1024) #2
  %22 = bitcast i8* %call6.i to %union.any*
  store %union.any* %22, %union.any** @PL_savestack, align 8, !tbaa !1
  store i64 0, i64* @PL_savestack_ix, align 8, !tbaa !20
  store i64 128, i64* @PL_savestack_max, align 8, !tbaa !20
  %call7.i = tail call i8* @Perl_safesysmalloc(i64 128) #2
  %23 = bitcast i8* %call7.i to %struct.op**
  store %struct.op** %23, %struct.op*** @PL_retstack, align 8, !tbaa !1
  store i64 0, i64* @PL_retstack_ix, align 8, !tbaa !20
  store i64 16, i64* @PL_retstack_max, align 8, !tbaa !20
  %call39 = tail call i32 (...)* @init_ids() #2
  store i64 11, i64* @PL_lex_state, align 8, !tbaa !20
  tail call void @llvm.memset.p0i8.i64(i8* bitcast (%struct.jmpenv* @PL_start_env to i8*), i8 0, i64 216, i32 8, i1 false)
  store i32 -1, i32* getelementptr inbounds (%struct.jmpenv* @PL_start_env, i64 0, i32 2), align 8, !tbaa !21
  store i8 1, i8* getelementptr inbounds (%struct.jmpenv* @PL_start_env, i64 0, i32 3), align 4, !tbaa !23
  store %struct.jmpenv* @PL_start_env, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  store i64 0, i64* @PL_statusvalue, align 8, !tbaa !20
  %call40 = tail call i32 @Perl_init_i18nl10n(i32 1) #2
  %call42 = tail call %struct.sv* @Perl_newSV(i64 4) #2
  store %struct.sv* %call42, %struct.sv** @PL_patchlevel, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %call42, i64 0, i32 2
  %24 = load i64* %sv_flags, align 8, !tbaa !7
  %and43 = and i64 %24, 254
  %cmp44 = icmp ugt i64 %and43, 5
  br i1 %cmp44, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end37
  %call45 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %call42, i64 6) #2
  %.pre78 = load %struct.sv** @PL_patchlevel, align 8, !tbaa !1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end37
  %25 = phi %struct.sv* [ %.pre78, %lor.rhs ], [ %call42, %if.end37 ]
  %sv_any = getelementptr inbounds %struct.sv* %25, i64 0, i32 0
  %26 = load i8** %sv_any, align 8, !tbaa !24
  %xpv_pv = bitcast i8* %26 to i8**
  %27 = load i8** %xpv_pv, align 8, !tbaa !25
  %call47 = tail call i8* @Perl_uvuni_to_utf8(i8* %27, i64 5) #2
  %call48 = tail call i8* @Perl_uvuni_to_utf8(i8* %call47, i64 8) #2
  %call49 = tail call i8* @Perl_uvuni_to_utf8(i8* %call48, i64 7) #2
  store i8 0, i8* %call49, align 1, !tbaa !27
  %28 = load %struct.sv** @PL_patchlevel, align 8, !tbaa !1
  %sv_any51 = getelementptr inbounds %struct.sv* %28, i64 0, i32 0
  %29 = load i8** %sv_any51, align 8, !tbaa !24
  %xpv_pv52 = bitcast i8* %29 to i8**
  %30 = load i8** %xpv_pv52, align 8, !tbaa !25
  %sub.ptr.lhs.cast = ptrtoint i8* %call49 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %30 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %xpv_cur = getelementptr inbounds i8* %29, i64 8
  %31 = bitcast i8* %xpv_cur to i64*
  store i64 %sub.ptr.sub, i64* %31, align 8, !tbaa !28
  %sv_flags54 = getelementptr inbounds %struct.sv* %28, i64 0, i32 2
  %32 = load i64* %sv_flags54, align 8, !tbaa !7
  %xnv_nv57 = getelementptr inbounds i8* %29, i64 32
  %33 = bitcast i8* %xnv_nv57 to double*
  store double 5.008007e+00, double* %33, align 8, !tbaa !29
  %or63 = or i64 %32, 646316032
  store i64 %or63, i64* %sv_flags54, align 8, !tbaa !7
  store i8** getelementptr inbounds ([2 x i8*]* @local_patches, i64 0, i64 0), i8*** @PL_localpatches, align 8, !tbaa !1
  tail call void @PerlIO_init() #2
  %call64 = tail call %struct.av* @Perl_newAV() #2
  store %struct.av* %call64, %struct.av** @PL_fdpid, align 8, !tbaa !1
  %call65 = tail call %struct.hv* @Perl_newHV() #2
  store %struct.hv* %call65, %struct.hv** @PL_modglobal, align 8, !tbaa !1
  %call66 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([1 x i8]* @.str1, i64 0, i64 0), i64 0) #2
  store %struct.sv* %call66, %struct.sv** @PL_errors, align 8, !tbaa !1
  tail call void @Perl_sv_setpvn(%struct.sv* getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 0), i8* getelementptr inbounds ([1 x i8]* @.str1, i64 0, i64 0), i64 0) #2
  tail call void @Perl_sv_setpvn(%struct.sv* getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 1), i8* getelementptr inbounds ([1 x i8]* @.str1, i64 0, i64 0), i64 0) #2
  tail call void @Perl_sv_setpvn(%struct.sv* getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 2), i8* getelementptr inbounds ([1 x i8]* @.str1, i64 0, i64 0), i64 0) #2
  %call67 = tail call %struct.hv* @Perl_newHV() #2
  store %struct.hv* %call67, %struct.hv** @PL_strtab, align 8, !tbaa !1
  %sv_flags68 = getelementptr inbounds %struct.hv* %call67, i64 0, i32 2
  %34 = load i64* %sv_flags68, align 8, !tbaa !31
  %and69 = and i64 %34, -536870913
  store i64 %and69, i64* %sv_flags68, align 8, !tbaa !31
  tail call void @Perl_hv_ksplit(%struct.hv* %call67, i64 512) #2
  %35 = load i8*** @environ, align 8, !tbaa !1
  store i8** %35, i8*** @PL_origenviron, align 8, !tbaa !1
  store i64 60, i64* @PL_clocktick, align 8, !tbaa !20
  %call70 = tail call %struct.hv* @Perl_newHV() #2
  store %struct.hv* %call70, %struct.hv** @PL_stashcache, align 8, !tbaa !1
  tail call void @Perl_push_scope() #2
  ret void
}

declare i32 @init_interp(...) #3

declare %struct.sv* @Perl_newSV(i64) #3

declare signext i8 @Perl_sv_upgrade(%struct.sv*, i64) #3

declare void @Perl_sv_setpv(%struct.sv*, i8*) #3

declare i64 @Perl_sv_2iv(%struct.sv*) #3

declare double @Perl_sv_2nv(%struct.sv*) #3

declare void @Perl_sighandler(i32) #3

declare %struct.hv* @Perl_newHV() #3

declare %struct.sv* @Perl_newSVpvn(i8*, i64) #3

; Function Attrs: nounwind uwtable
define void @Perl_init_stacks() #0 {
entry:
  %call = tail call %struct.stackinfo* @Perl_new_stackinfo(i64 128, i64 52) #2
  store %struct.stackinfo* %call, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  %si_type = getelementptr inbounds %struct.stackinfo* %call, i64 0, i32 4
  store i64 1, i64* %si_type, align 8, !tbaa !11
  %si_stack = getelementptr inbounds %struct.stackinfo* %call, i64 0, i32 0
  %0 = load %struct.av** %si_stack, align 8, !tbaa !13
  store %struct.av* %0, %struct.av** @PL_curstack, align 8, !tbaa !1
  store %struct.av* %0, %struct.av** @PL_mainstack, align 8, !tbaa !1
  %sv_any = getelementptr inbounds %struct.av* %0, i64 0, i32 0
  %1 = load %struct.xpvav** %sv_any, align 8, !tbaa !14
  %xav_array = getelementptr inbounds %struct.xpvav* %1, i64 0, i32 0
  %2 = load i8** %xav_array, align 8, !tbaa !16
  %3 = bitcast i8* %2 to %struct.sv**
  store %struct.sv** %3, %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  store %struct.sv** %3, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %4 = load %struct.xpvav** %sv_any, align 8, !tbaa !14
  %xav_max = getelementptr inbounds %struct.xpvav* %4, i64 0, i32 2
  %5 = load i64* %xav_max, align 8, !tbaa !19
  %add.ptr = getelementptr inbounds %struct.sv** %3, i64 %5
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_max, align 8, !tbaa !1
  %call2 = tail call i8* @Perl_safesysmalloc(i64 1024) #2
  %6 = bitcast i8* %call2 to %struct.sv**
  store %struct.sv** %6, %struct.sv*** @PL_tmps_stack, align 8, !tbaa !1
  store i64 -1, i64* @PL_tmps_floor, align 8, !tbaa !20
  store i64 -1, i64* @PL_tmps_ix, align 8, !tbaa !20
  store i64 128, i64* @PL_tmps_max, align 8, !tbaa !20
  %call3 = tail call i8* @Perl_safesysmalloc(i64 256) #2
  %7 = bitcast i8* %call3 to i64*
  store i64* %7, i64** @PL_markstack, align 8, !tbaa !1
  store i64* %7, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %add.ptr4 = getelementptr inbounds i8* %call3, i64 256
  %8 = bitcast i8* %add.ptr4 to i64*
  store i64* %8, i64** @PL_markstack_max, align 8, !tbaa !1
  %call5 = tail call i8* @Perl_safesysmalloc(i64 256) #2
  %9 = bitcast i8* %call5 to i64*
  store i64* %9, i64** @PL_scopestack, align 8, !tbaa !1
  store i64 0, i64* @PL_scopestack_ix, align 8, !tbaa !20
  store i64 32, i64* @PL_scopestack_max, align 8, !tbaa !20
  %call6 = tail call i8* @Perl_safesysmalloc(i64 1024) #2
  %10 = bitcast i8* %call6 to %union.any*
  store %union.any* %10, %union.any** @PL_savestack, align 8, !tbaa !1
  store i64 0, i64* @PL_savestack_ix, align 8, !tbaa !20
  store i64 128, i64* @PL_savestack_max, align 8, !tbaa !20
  %call7 = tail call i8* @Perl_safesysmalloc(i64 128) #2
  %11 = bitcast i8* %call7 to %struct.op**
  store %struct.op** %11, %struct.op*** @PL_retstack, align 8, !tbaa !1
  store i64 0, i64* @PL_retstack_ix, align 8, !tbaa !20
  store i64 16, i64* @PL_retstack_max, align 8, !tbaa !20
  ret void
}

declare i32 @init_ids(...) #3

declare i32 @Perl_init_i18nl10n(i32) #3

declare i8* @Perl_uvuni_to_utf8(i8*, i64) #3

declare void @PerlIO_init() #3

declare %struct.av* @Perl_newAV() #3

declare void @Perl_sv_setpvn(%struct.sv*, i8*, i64) #3

declare void @Perl_hv_ksplit(%struct.hv*, i64) #3

declare void @Perl_push_scope() #3

; Function Attrs: nounwind readnone uwtable
define i32 @Perl_nothreadhook() #4 {
entry:
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @perl_destruct(%struct.interpreter* nocapture readnone %my_perl) #0 {
entry:
  %destruct_level = alloca i32, align 4
  %cur_env = alloca %struct.jmpenv, align 8
  %0 = load i32* @PL_perl_destruct_level, align 4, !tbaa !5
  store volatile i32 %0, i32* %destruct_level, align 4
  %1 = load i8* @PL_exit_flags, align 1, !tbaa !27
  %and = and i8 %1, 2
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end7, label %if.then

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.jmpenv* %cur_env to i8*
  call void @llvm.lifetime.start(i64 216, i8* %2) #2
  %3 = load %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %je_prev = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 1
  store %struct.jmpenv* %3, %struct.jmpenv** %je_prev, align 8, !tbaa !33
  %arraydecay = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 0, i64 0
  %call = call i32 @sigsetjmp(%struct.__jmp_buf_tag* %arraydecay, i32 0) #8
  %je_ret = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 2
  store i32 %call, i32* %je_ret, align 8, !tbaa !21
  store %struct.jmpenv* %cur_env, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %je_mustcatch = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 3
  store i8 0, i8* %je_mustcatch, align 4, !tbaa !23
  %4 = load %struct.av** @PL_endav, align 8, !tbaa !1
  %tobool2 = icmp eq %struct.av* %4, null
  %5 = load i8* @PL_minus_c, align 1
  %tobool3 = icmp ne i8 %5, 0
  %or.cond = or i1 %tobool2, %tobool3
  br i1 %or.cond, label %if.end, label %if.then4

if.then4:                                         ; preds = %if.then
  %6 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  call void @Perl_call_list(i64 %6, %struct.av* %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %if.then4
  %7 = load %struct.jmpenv** %je_prev, align 8, !tbaa !33
  store %struct.jmpenv* %7, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  call void @llvm.lifetime.end(i64 216, i8* %2) #2
  br label %if.end7

if.end7:                                          ; preds = %entry, %if.end
  call void @Perl_pop_scope() #2
  %8 = load i64* @PL_tmps_ix, align 8, !tbaa !20
  %9 = load i64* @PL_tmps_floor, align 8, !tbaa !20
  %cmp = icmp sgt i64 %8, %9
  br i1 %cmp, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  call void @Perl_free_tmps() #2
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end7
  %call11 = call i64 @Perl_my_fflush_all() #2
  %10 = load i32 ()** @PL_threadhook, align 8, !tbaa !1
  %call12 = call i32 %10() #2
  %tobool13 = icmp eq i32 %call12, 0
  br i1 %tobool13, label %if.end16, label %return

if.end16:                                         ; preds = %if.end10
  %11 = load %struct.op** @PL_main_root, align 8, !tbaa !1
  %tobool17 = icmp eq %struct.op* %11, null
  br i1 %tobool17, label %if.end27, label %if.then18

if.then18:                                        ; preds = %if.end16
  %12 = load %struct.cv** @PL_main_cv, align 8, !tbaa !1
  %sv_any = getelementptr inbounds %struct.cv* %12, i64 0, i32 0
  %13 = load %struct.xpvcv** %sv_any, align 8, !tbaa !34
  %xcv_padlist = getelementptr inbounds %struct.xpvcv* %13, i64 0, i32 15
  %14 = load %struct.av** %xcv_padlist, align 8, !tbaa !36
  %tobool19 = icmp eq %struct.av* %14, null
  br i1 %tobool19, label %if.end26, label %if.then20

if.then20:                                        ; preds = %if.then18
  %sv_any23 = getelementptr inbounds %struct.av* %14, i64 0, i32 0
  %15 = load %struct.xpvav** %sv_any23, align 8, !tbaa !14
  %xav_array = getelementptr inbounds %struct.xpvav* %15, i64 0, i32 0
  %16 = load i8** %xav_array, align 8, !tbaa !16
  %arrayidx = getelementptr inbounds i8* %16, i64 8
  %17 = bitcast i8* %arrayidx to %struct.sv**
  %18 = load %struct.sv** %17, align 8, !tbaa !1
  %19 = bitcast %struct.sv* %18 to %struct.av*
  store %struct.av* %19, %struct.av** @PL_comppad, align 8, !tbaa !1
  %sv_any24 = bitcast %struct.sv* %18 to %struct.xpvav**
  %20 = load %struct.xpvav** %sv_any24, align 8, !tbaa !14
  %xav_array25 = getelementptr inbounds %struct.xpvav* %20, i64 0, i32 0
  %21 = load i8** %xav_array25, align 8, !tbaa !16
  %22 = bitcast i8* %21 to %struct.sv**
  store %struct.sv** %22, %struct.sv*** @PL_curpad, align 8, !tbaa !1
  br label %if.end26

if.end26:                                         ; preds = %if.then18, %if.then20
  call void @Perl_op_free(%struct.op* %11) #2
  store %struct.op* null, %struct.op** @PL_main_root, align 8, !tbaa !1
  br label %if.end27

if.end27:                                         ; preds = %if.end16, %if.end26
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !1
  store %struct.op* null, %struct.op** @PL_main_start, align 8, !tbaa !1
  %23 = load %struct.cv** @PL_main_cv, align 8, !tbaa !1
  %24 = bitcast %struct.cv* %23 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %24) #2
  store %struct.cv* null, %struct.cv** @PL_main_cv, align 8, !tbaa !1
  store i8 1, i8* @PL_dirty, align 1, !tbaa !27
  call void @PerlIO_destruct() #2
  %25 = load i64* @PL_sv_objcount, align 8, !tbaa !20
  %tobool28 = icmp eq i64 %25, 0
  br i1 %tobool28, label %if.end31, label %if.then29

if.then29:                                        ; preds = %if.end27
  %call30 = call i32 (...)* @sv_clean_objs() #2
  store i64 0, i64* @PL_sv_objcount, align 8, !tbaa !20
  br label %if.end31

if.end31:                                         ; preds = %if.end27, %if.then29
  %26 = load %struct.sv** @PL_warnhook, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %26) #2
  store %struct.sv* null, %struct.sv** @PL_warnhook, align 8, !tbaa !1
  %27 = load %struct.sv** @PL_diehook, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %27) #2
  store %struct.sv* null, %struct.sv** @PL_diehook, align 8, !tbaa !1
  %28 = load i64* @PL_exitlistlen, align 8, !tbaa !20
  %dec303 = add nsw i64 %28, -1
  store i64 %dec303, i64* @PL_exitlistlen, align 8, !tbaa !20
  %cmp32304 = icmp sgt i64 %28, 0
  %29 = load %struct.exitlistentry** @PL_exitlist, align 8, !tbaa !1
  br i1 %cmp32304, label %while.body, label %while.end

while.body:                                       ; preds = %if.end31, %while.body
  %30 = phi %struct.exitlistentry* [ %34, %while.body ], [ %29, %if.end31 ]
  %dec305 = phi i64 [ %dec, %while.body ], [ %dec303, %if.end31 ]
  %fn = getelementptr inbounds %struct.exitlistentry* %30, i64 %dec305, i32 0
  %31 = load void (i8*)** %fn, align 8, !tbaa !39
  %ptr = getelementptr inbounds %struct.exitlistentry* %30, i64 %dec305, i32 1
  %32 = load i8** %ptr, align 8, !tbaa !41
  call void %31(i8* %32) #2
  %33 = load i64* @PL_exitlistlen, align 8, !tbaa !20
  %dec = add nsw i64 %33, -1
  store i64 %dec, i64* @PL_exitlistlen, align 8, !tbaa !20
  %cmp32 = icmp sgt i64 %33, 0
  %34 = load %struct.exitlistentry** @PL_exitlist, align 8, !tbaa !1
  br i1 %cmp32, label %while.body, label %while.end

while.end:                                        ; preds = %while.body, %if.end31
  %.lcssa297 = phi %struct.exitlistentry* [ %29, %if.end31 ], [ %34, %while.body ]
  %35 = bitcast %struct.exitlistentry* %.lcssa297 to i8*
  call void @Perl_safesysfree(i8* %35) #2
  store %struct.exitlistentry* null, %struct.exitlistentry** @PL_exitlist, align 8, !tbaa !1
  store i64 0, i64* @PL_exitlistlen, align 8, !tbaa !20
  %destruct_level.0.destruct_level.0. = load volatile i32* %destruct_level, align 4
  %cmp36 = icmp eq i32 %destruct_level.0.destruct_level.0., 0
  br i1 %cmp36, label %if.then38, label %if.end40

if.then38:                                        ; preds = %while.end
  call void @PerlIO_cleanup() #2
  br label %return

if.end40:                                         ; preds = %while.end
  %36 = load i8*** @environ, align 8, !tbaa !1
  %37 = load i8*** @PL_origenviron, align 8, !tbaa !1
  %cmp41 = icmp eq i8** %36, %37
  %38 = load i32* @PL_use_safe_putenv, align 4
  %tobool44 = icmp ne i32 %38, 0
  %or.cond268 = or i1 %cmp41, %tobool44
  br i1 %or.cond268, label %if.end50, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end40
  %39 = load i8** %36, align 8, !tbaa !1
  %tobool48301 = icmp eq i8* %39, null
  br i1 %tobool48301, label %for.end, label %for.body

for.body:                                         ; preds = %for.cond.preheader, %for.body
  %40 = phi i8* [ %42, %for.body ], [ %39, %for.cond.preheader ]
  %i.0302 = phi i64 [ %inc, %for.body ], [ 0, %for.cond.preheader ]
  call void @Perl_safesysfree(i8* %40) #2
  %inc = add nsw i64 %i.0302, 1
  %41 = load i8*** @environ, align 8, !tbaa !1
  %arrayidx47 = getelementptr inbounds i8** %41, i64 %inc
  %42 = load i8** %arrayidx47, align 8, !tbaa !1
  %tobool48 = icmp eq i8* %42, null
  br i1 %tobool48, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %for.cond.preheader
  %.lcssa = phi i8** [ %36, %for.cond.preheader ], [ %41, %for.body ]
  %43 = bitcast i8** %.lcssa to i8*
  call void @Perl_safesysfree(i8* %43) #2
  %44 = load i8*** @PL_origenviron, align 8, !tbaa !1
  store i8** %44, i8*** @environ, align 8, !tbaa !1
  br label %if.end50

if.end50:                                         ; preds = %if.end40, %for.end
  %call51 = call i32 (%struct.gv*, ...)* bitcast (i32 (...)* @setdefout to i32 (%struct.gv*, ...)*)(%struct.gv* null) #2
  %45 = load %struct.hv** @PL_stashcache, align 8, !tbaa !1
  %46 = bitcast %struct.hv* %45 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %46) #2
  store %struct.hv* null, %struct.hv** @PL_stashcache, align 8, !tbaa !1
  %47 = load volatile %struct._PerlIO*** @PL_rsfp, align 8, !tbaa !1
  %tobool52 = icmp eq %struct._PerlIO** %47, null
  br i1 %tobool52, label %if.end55, label %if.then53

if.then53:                                        ; preds = %if.end50
  %48 = load volatile %struct._PerlIO*** @PL_rsfp, align 8, !tbaa !1
  %call54 = call i32 @Perl_PerlIO_close(%struct._PerlIO** %48) #2
  store volatile %struct._PerlIO** null, %struct._PerlIO*** @PL_rsfp, align 8, !tbaa !1
  br label %if.end55

if.end55:                                         ; preds = %if.end50, %if.then53
  %49 = load %struct.av** @PL_rsfp_filters, align 8, !tbaa !1
  %50 = bitcast %struct.av* %49 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %50) #2
  store %struct.av* null, %struct.av** @PL_rsfp_filters, align 8, !tbaa !1
  store i8 0, i8* @PL_preprocess, align 1, !tbaa !27
  store i8 0, i8* @PL_minus_n, align 1, !tbaa !27
  store i8 0, i8* @PL_minus_p, align 1, !tbaa !27
  store i8 0, i8* @PL_minus_l, align 1, !tbaa !27
  store i8 0, i8* @PL_minus_a, align 1, !tbaa !27
  store i8 0, i8* @PL_minus_F, align 1, !tbaa !27
  store i8 0, i8* @PL_doswitches, align 1, !tbaa !27
  store i8 0, i8* @PL_dowarn, align 1, !tbaa !27
  store i8 0, i8* @PL_doextract, align 1, !tbaa !27
  store i8 0, i8* @PL_sawampersand, align 1, !tbaa !27
  store i8 0, i8* @PL_unsafe, align 1, !tbaa !27
  %51 = load i8** @PL_inplace, align 8, !tbaa !1
  call void @Perl_safesysfree(i8* %51) #2
  store i8* null, i8** @PL_inplace, align 8, !tbaa !1
  %52 = load %struct.sv** @PL_patchlevel, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %52) #2
  %53 = load %struct.sv** @PL_e_script, align 8, !tbaa !1
  %tobool56 = icmp eq %struct.sv* %53, null
  br i1 %tobool56, label %if.end58, label %if.then57

if.then57:                                        ; preds = %if.end55
  call void @Perl_sv_free(%struct.sv* %53) #2
  store %struct.sv* null, %struct.sv** @PL_e_script, align 8, !tbaa !1
  br label %if.end58

if.end58:                                         ; preds = %if.end55, %if.then57
  store i64 0, i64* @PL_perldb, align 8, !tbaa !20
  %54 = load %struct.sv** @PL_ofs_sv, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %54) #2
  store %struct.sv* null, %struct.sv** @PL_ofs_sv, align 8, !tbaa !1
  %55 = load %struct.sv** @PL_ors_sv, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %55) #2
  store %struct.sv* null, %struct.sv** @PL_ors_sv, align 8, !tbaa !1
  %56 = load %struct.sv** @PL_rs, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %56) #2
  store %struct.sv* null, %struct.sv** @PL_rs, align 8, !tbaa !1
  store i32 0, i32* @PL_multiline, align 4, !tbaa !5
  %57 = load i8** @PL_osname, align 8, !tbaa !1
  call void @Perl_safesysfree(i8* %57) #2
  store i8* null, i8** @PL_osname, align 8, !tbaa !1
  %58 = load %struct.sv** @PL_statname, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %58) #2
  store %struct.sv* null, %struct.sv** @PL_statname, align 8, !tbaa !1
  store %struct.gv* null, %struct.gv** @PL_statgv, align 8, !tbaa !1
  %59 = load %struct.sv** @PL_lastscream, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %59) #2
  store %struct.sv* null, %struct.sv** @PL_lastscream, align 8, !tbaa !1
  %60 = load i64** @PL_screamfirst, align 8, !tbaa !1
  %61 = bitcast i64* %60 to i8*
  call void @Perl_safesysfree(i8* %61) #2
  store i64* null, i64** @PL_screamfirst, align 8, !tbaa !1
  %62 = load i64** @PL_screamnext, align 8, !tbaa !1
  %63 = bitcast i64* %62 to i8*
  call void @Perl_safesysfree(i8* %63) #2
  store i64* null, i64** @PL_screamnext, align 8, !tbaa !1
  %64 = load i8** @PL_efloatbuf, align 8, !tbaa !1
  call void @Perl_safesysfree(i8* %64) #2
  store i8* null, i8** @PL_efloatbuf, align 8, !tbaa !1
  store i64 0, i64* @PL_efloatsize, align 8, !tbaa !20
  %65 = load %struct.av** @PL_beginav, align 8, !tbaa !1
  %66 = bitcast %struct.av* %65 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %66) #2
  %67 = load %struct.av** @PL_beginav_save, align 8, !tbaa !1
  %68 = bitcast %struct.av* %67 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %68) #2
  %69 = load %struct.av** @PL_endav, align 8, !tbaa !1
  %70 = bitcast %struct.av* %69 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %70) #2
  %71 = load %struct.av** @PL_checkav, align 8, !tbaa !1
  %72 = bitcast %struct.av* %71 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %72) #2
  %73 = load %struct.av** @PL_checkav_save, align 8, !tbaa !1
  %74 = bitcast %struct.av* %73 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %74) #2
  %75 = load %struct.av** @PL_initav, align 8, !tbaa !1
  %76 = bitcast %struct.av* %75 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %76) #2
  store %struct.av* null, %struct.av** @PL_beginav, align 8, !tbaa !1
  store %struct.av* null, %struct.av** @PL_beginav_save, align 8, !tbaa !1
  store %struct.av* null, %struct.av** @PL_endav, align 8, !tbaa !1
  store %struct.av* null, %struct.av** @PL_checkav, align 8, !tbaa !1
  store %struct.av* null, %struct.av** @PL_checkav_save, align 8, !tbaa !1
  store %struct.av* null, %struct.av** @PL_initav, align 8, !tbaa !1
  store %struct.gv* null, %struct.gv** @PL_envgv, align 8, !tbaa !1
  store %struct.gv* null, %struct.gv** @PL_incgv, align 8, !tbaa !1
  store %struct.gv* null, %struct.gv** @PL_hintgv, align 8, !tbaa !1
  store %struct.gv* null, %struct.gv** @PL_errgv, align 8, !tbaa !1
  store %struct.gv* null, %struct.gv** @PL_argvgv, align 8, !tbaa !1
  store %struct.gv* null, %struct.gv** @PL_argvoutgv, align 8, !tbaa !1
  store %struct.gv* null, %struct.gv** @PL_stdingv, align 8, !tbaa !1
  store %struct.gv* null, %struct.gv** @PL_stderrgv, align 8, !tbaa !1
  store %struct.gv* null, %struct.gv** @PL_last_in_gv, align 8, !tbaa !1
  store %struct.gv* null, %struct.gv** @PL_replgv, align 8, !tbaa !1
  store %struct.gv* null, %struct.gv** @PL_DBgv, align 8, !tbaa !1
  store %struct.gv* null, %struct.gv** @PL_DBline, align 8, !tbaa !1
  store %struct.gv* null, %struct.gv** @PL_DBsub, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_DBsingle, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_DBtrace, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_DBsignal, align 8, !tbaa !1
  store %struct.cv* null, %struct.cv** @PL_DBcv, align 8, !tbaa !1
  store %struct.av* null, %struct.av** @PL_dbargs, align 8, !tbaa !1
  store %struct.hv* null, %struct.hv** @PL_debstash, align 8, !tbaa !1
  %77 = load %struct.av** @PL_argvout_stack, align 8, !tbaa !1
  %78 = bitcast %struct.av* %77 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %78) #2
  store %struct.av* null, %struct.av** @PL_argvout_stack, align 8, !tbaa !1
  %79 = load %struct.hv** @PL_modglobal, align 8, !tbaa !1
  %80 = bitcast %struct.hv* %79 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %80) #2
  store %struct.hv* null, %struct.hv** @PL_modglobal, align 8, !tbaa !1
  %81 = load %struct.av** @PL_preambleav, align 8, !tbaa !1
  %82 = bitcast %struct.av* %81 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %82) #2
  store %struct.av* null, %struct.av** @PL_preambleav, align 8, !tbaa !1
  %83 = load %struct.sv** @PL_subname, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %83) #2
  store %struct.sv* null, %struct.sv** @PL_subname, align 8, !tbaa !1
  %84 = load %struct.sv** @PL_linestr, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %84) #2
  store %struct.sv* null, %struct.sv** @PL_linestr, align 8, !tbaa !1
  %85 = load %struct.hv** @PL_pidstatus, align 8, !tbaa !1
  %86 = bitcast %struct.hv* %85 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %86) #2
  store %struct.hv* null, %struct.hv** @PL_pidstatus, align 8, !tbaa !1
  %87 = load %struct.sv** @PL_toptarget, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %87) #2
  store %struct.sv* null, %struct.sv** @PL_toptarget, align 8, !tbaa !1
  %88 = load %struct.sv** @PL_bodytarget, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %88) #2
  store %struct.sv* null, %struct.sv** @PL_bodytarget, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_formtarget, align 8, !tbaa !1
  %89 = load %struct.sv** @PL_utf8_alnum, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %89) #2
  %90 = load %struct.sv** @PL_utf8_alnumc, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %90) #2
  %91 = load %struct.sv** @PL_utf8_ascii, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %91) #2
  %92 = load %struct.sv** @PL_utf8_alpha, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %92) #2
  %93 = load %struct.sv** @PL_utf8_space, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %93) #2
  %94 = load %struct.sv** @PL_utf8_cntrl, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %94) #2
  %95 = load %struct.sv** @PL_utf8_graph, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %95) #2
  %96 = load %struct.sv** @PL_utf8_digit, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %96) #2
  %97 = load %struct.sv** @PL_utf8_upper, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %97) #2
  %98 = load %struct.sv** @PL_utf8_lower, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %98) #2
  %99 = load %struct.sv** @PL_utf8_print, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %99) #2
  %100 = load %struct.sv** @PL_utf8_punct, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %100) #2
  %101 = load %struct.sv** @PL_utf8_xdigit, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %101) #2
  %102 = load %struct.sv** @PL_utf8_mark, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %102) #2
  %103 = load %struct.sv** @PL_utf8_toupper, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %103) #2
  %104 = load %struct.sv** @PL_utf8_totitle, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %104) #2
  %105 = load %struct.sv** @PL_utf8_tolower, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %105) #2
  %106 = load %struct.sv** @PL_utf8_tofold, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %106) #2
  %107 = load %struct.sv** @PL_utf8_idstart, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %107) #2
  %108 = load %struct.sv** @PL_utf8_idcont, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %108) #2
  store %struct.sv* null, %struct.sv** @PL_utf8_alnum, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_alnumc, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_ascii, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_alpha, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_space, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_cntrl, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_graph, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_digit, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_upper, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_lower, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_print, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_punct, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_xdigit, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_mark, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_toupper, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_totitle, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_tolower, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_tofold, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_idstart, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_utf8_idcont, align 8, !tbaa !1
  %109 = load %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !42
  %magicptr = ptrtoint %struct.sv* %109 to i64
  switch i64 %magicptr, label %if.then66 [
    i64 48, label %if.end67
    i64 24, label %if.end67
    i64 0, label %if.end67
  ]

if.then66:                                        ; preds = %if.end58
  call void @Perl_sv_free(%struct.sv* %109) #2
  br label %if.end67

if.end67:                                         ; preds = %if.end58, %if.end58, %if.end58, %if.then66
  store %struct.sv* null, %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !42
  %110 = load %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 15), align 8, !tbaa !44
  %cmp68 = icmp eq %struct.sv* %110, null
  br i1 %cmp68, label %if.end71, label %if.then70

if.then70:                                        ; preds = %if.end67
  call void @Perl_sv_free(%struct.sv* %110) #2
  br label %if.end71

if.end71:                                         ; preds = %if.then70, %if.end67
  store %struct.sv* null, %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 15), align 8, !tbaa !44
  %111 = load %struct.gv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 10), align 8, !tbaa !45
  %112 = bitcast %struct.gv* %111 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %112) #2
  store %struct.gv* null, %struct.gv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 10), align 8, !tbaa !45
  %113 = load %struct.hv** @PL_defstash, align 8, !tbaa !1
  store %struct.hv* null, %struct.hv** @PL_defstash, align 8, !tbaa !1
  %114 = bitcast %struct.hv* %113 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %114) #2
  %115 = load %struct.sv** @PL_curstname, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %115) #2
  store %struct.sv* null, %struct.sv** @PL_curstname, align 8, !tbaa !1
  %116 = load %struct.sv** @PL_errors, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %116) #2
  store %struct.sv* null, %struct.sv** @PL_errors, align 8, !tbaa !1
  %117 = load i64* @PL_tmps_ix, align 8, !tbaa !20
  %118 = load i64* @PL_tmps_floor, align 8, !tbaa !20
  %cmp72 = icmp sgt i64 %117, %118
  br i1 %cmp72, label %if.then74, label %if.end75

if.then74:                                        ; preds = %if.end71
  call void @Perl_free_tmps() #2
  br label %if.end75

if.end75:                                         ; preds = %if.then74, %if.end71
  %destruct_level.0.destruct_level.0.292 = load volatile i32* %destruct_level, align 4
  %cmp76 = icmp sgt i32 %destruct_level.0.destruct_level.0.292, 1
  br i1 %cmp76, label %land.lhs.true78, label %if.end115

land.lhs.true78:                                  ; preds = %if.end75
  %119 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings = getelementptr inbounds %struct.cop* %119, i64 0, i32 14
  %120 = load %struct.sv** %cop_warnings, align 8, !tbaa !42
  %cmp79 = icmp eq %struct.sv* %120, null
  br i1 %cmp79, label %if.then96, label %lor.lhs.false81

lor.lhs.false81:                                  ; preds = %land.lhs.true78
  %121 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings82 = getelementptr inbounds %struct.cop* %121, i64 0, i32 14
  %122 = load %struct.sv** %cop_warnings82, align 8, !tbaa !42
  %cmp83 = icmp eq %struct.sv* %122, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp83, label %if.then96, label %lor.lhs.false85

lor.lhs.false85:                                  ; preds = %lor.lhs.false81
  %123 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings86 = getelementptr inbounds %struct.cop* %123, i64 0, i32 14
  %124 = load %struct.sv** %cop_warnings86, align 8, !tbaa !42
  %cmp87 = icmp eq %struct.sv* %124, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp87, label %if.end115, label %land.lhs.true89

land.lhs.true89:                                  ; preds = %lor.lhs.false85
  %125 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings90 = getelementptr inbounds %struct.cop* %125, i64 0, i32 14
  %126 = load %struct.sv** %cop_warnings90, align 8, !tbaa !42
  %sv_any91 = getelementptr inbounds %struct.sv* %126, i64 0, i32 0
  %127 = load i8** %sv_any91, align 8, !tbaa !24
  %xpv_pv = bitcast i8* %127 to i8**
  %128 = load i8** %xpv_pv, align 8, !tbaa !25
  %arrayidx92 = getelementptr inbounds i8* %128, i64 6
  %129 = load i8* %arrayidx92, align 1, !tbaa !27
  %and94 = and i8 %129, 1
  %tobool95 = icmp eq i8 %and94, 0
  br i1 %tobool95, label %if.end115, label %if.then96

if.then96:                                        ; preds = %land.lhs.true89, %lor.lhs.false81, %land.lhs.true78
  %130 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  %cmp97 = icmp eq i64 %130, 0
  br i1 %cmp97, label %if.end100, label %if.then99

if.then99:                                        ; preds = %if.then96
  call void (i64, i8*, ...)* @Perl_warner(i64 24, i8* getelementptr inbounds ([48 x i8]* @.str2, i64 0, i64 0), i64 %130) #2
  br label %if.end100

if.end100:                                        ; preds = %if.then96, %if.then99
  %131 = load i64* @PL_savestack_ix, align 8, !tbaa !20
  %cmp101 = icmp eq i64 %131, 0
  br i1 %cmp101, label %if.end104, label %if.then103

if.then103:                                       ; preds = %if.end100
  call void (i64, i8*, ...)* @Perl_warner(i64 24, i8* getelementptr inbounds ([48 x i8]* @.str3, i64 0, i64 0), i64 %131) #2
  br label %if.end104

if.end104:                                        ; preds = %if.end100, %if.then103
  %132 = load i64* @PL_tmps_floor, align 8, !tbaa !20
  %cmp105 = icmp eq i64 %132, -1
  br i1 %cmp105, label %if.end108, label %if.then107

if.then107:                                       ; preds = %if.end104
  %add = add nsw i64 %132, 1
  call void (i64, i8*, ...)* @Perl_warner(i64 24, i8* getelementptr inbounds ([45 x i8]* @.str4, i64 0, i64 0), i64 %add) #2
  br label %if.end108

if.end108:                                        ; preds = %if.end104, %if.then107
  %133 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  %si_cxix = getelementptr inbounds %struct.stackinfo* %133, i64 0, i32 2
  %134 = load i64* %si_cxix, align 8, !tbaa !46
  %cmp109 = icmp eq i64 %134, -1
  br i1 %cmp109, label %if.end115, label %if.then111

if.then111:                                       ; preds = %if.end108
  %add113 = add nsw i64 %134, 1
  call void (i64, i8*, ...)* @Perl_warner(i64 24, i8* getelementptr inbounds ([47 x i8]* @.str5, i64 0, i64 0), i64 %add113) #2
  br label %if.end115

if.end115:                                        ; preds = %if.end108, %land.lhs.true89, %lor.lhs.false85, %if.then111, %if.end75
  %135 = load %struct.av** @PL_fdpid, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.av* %135, i64 0, i32 2
  %136 = load i64* %sv_flags, align 8, !tbaa !47
  %or = or i64 %136, 255
  store i64 %or, i64* %sv_flags, align 8, !tbaa !47
  %137 = load %struct.hv** @PL_strtab, align 8, !tbaa !1
  %sv_flags116 = getelementptr inbounds %struct.hv* %137, i64 0, i32 2
  %138 = load i64* %sv_flags116, align 8, !tbaa !31
  %or117 = or i64 %138, 255
  store i64 %or117, i64* %sv_flags116, align 8, !tbaa !31
  %.old = load i64* @PL_sv_count, align 8, !tbaa !20
  %cmp119.old = icmp sgt i64 %.old, 2
  br i1 %cmp119.old, label %land.rhs, label %while.end124

land.rhs:                                         ; preds = %if.end115, %land.rhs
  %call121 = call i32 (...)* @sv_clean_all() #2
  %tobool122 = icmp ne i32 %call121, 0
  %139 = load i64* @PL_sv_count, align 8
  %cmp119 = icmp sgt i64 %139, 2
  %or.cond271 = and i1 %tobool122, %cmp119
  br i1 %or.cond271, label %land.rhs, label %while.end124.loopexit

while.end124.loopexit:                            ; preds = %land.rhs
  %.pre = load %struct.av** @PL_fdpid, align 8, !tbaa !1
  %sv_flags125.phi.trans.insert = getelementptr inbounds %struct.av* %.pre, i64 0, i32 2
  %.pre309 = load i64* %sv_flags125.phi.trans.insert, align 8, !tbaa !47
  %.pre310 = load %struct.hv** @PL_strtab, align 8, !tbaa !1
  %sv_flags129.phi.trans.insert = getelementptr inbounds %struct.hv* %.pre310, i64 0, i32 2
  %.pre311 = load i64* %sv_flags129.phi.trans.insert, align 8, !tbaa !31
  br label %while.end124

while.end124:                                     ; preds = %while.end124.loopexit, %if.end115
  %140 = phi i64 [ %.pre311, %while.end124.loopexit ], [ %or117, %if.end115 ]
  %141 = phi %struct.hv* [ %.pre310, %while.end124.loopexit ], [ %137, %if.end115 ]
  %142 = phi i64 [ %.pre309, %while.end124.loopexit ], [ %or, %if.end115 ]
  %143 = phi %struct.av* [ %.pre, %while.end124.loopexit ], [ %135, %if.end115 ]
  %sv_flags125 = getelementptr inbounds %struct.av* %143, i64 0, i32 2
  %and126 = and i64 %142, -256
  %or128 = or i64 %and126, 10
  store i64 %or128, i64* %sv_flags125, align 8, !tbaa !47
  %sv_flags129 = getelementptr inbounds %struct.hv* %141, i64 0, i32 2
  %and130 = and i64 %140, -256
  %or132 = or i64 %and130, 11
  store i64 %or132, i64* %sv_flags129, align 8, !tbaa !31
  %sv_any133 = getelementptr inbounds %struct.av* %143, i64 0, i32 0
  %144 = load %struct.xpvav** %sv_any133, align 8, !tbaa !14
  %xav_flags = getelementptr inbounds %struct.xpvav* %144, i64 0, i32 9
  %145 = load i8* %xav_flags, align 1, !tbaa !48
  %and135 = and i8 %145, -2
  store i8 %and135, i8* %xav_flags, align 1, !tbaa !48
  %146 = bitcast %struct.av* %143 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %146) #2
  store %struct.av* null, %struct.av** @PL_fdpid, align 8, !tbaa !1
  %147 = load %struct.hv** @PL_strtab, align 8, !tbaa !1
  %sv_any141 = getelementptr inbounds %struct.hv* %147, i64 0, i32 0
  %148 = load %struct.xpvhv** %sv_any141, align 8, !tbaa !49
  %xhv_max = getelementptr inbounds %struct.xpvhv* %148, i64 0, i32 2
  %149 = load i64* %xhv_max, align 8, !tbaa !50
  %150 = bitcast %struct.xpvhv* %148 to %struct.he***
  %151 = load %struct.he*** %150, align 8, !tbaa !1
  br label %for.cond144.outer

for.cond144.outer:                                ; preds = %if.end176, %while.end124
  %riter.0.ph = phi i64 [ 0, %while.end124 ], [ %inc172, %if.end176 ]
  %hent.0.ph.in = phi %struct.he** [ %151, %while.end124 ], [ %arrayidx177, %if.end176 ]
  %hent.0.ph = load %struct.he** %hent.0.ph.in, align 8
  br label %for.cond144

for.cond144:                                      ; preds = %for.cond144.outer, %if.end169
  %hent.0 = phi %struct.he* [ %hent.1, %if.end169 ], [ %hent.0.ph, %for.cond144.outer ]
  %tobool145 = icmp eq %struct.he* %hent.0, null
  br i1 %tobool145, label %if.then171, label %land.lhs.true146

land.lhs.true146:                                 ; preds = %for.cond144
  %152 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings147 = getelementptr inbounds %struct.cop* %152, i64 0, i32 14
  %153 = load %struct.sv** %cop_warnings147, align 8, !tbaa !42
  %cmp148 = icmp eq %struct.sv* %153, null
  br i1 %cmp148, label %if.then166, label %lor.lhs.false150

lor.lhs.false150:                                 ; preds = %land.lhs.true146
  %154 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings151 = getelementptr inbounds %struct.cop* %154, i64 0, i32 14
  %155 = load %struct.sv** %cop_warnings151, align 8, !tbaa !42
  %cmp152 = icmp eq %struct.sv* %155, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp152, label %if.then166, label %lor.lhs.false154

lor.lhs.false154:                                 ; preds = %lor.lhs.false150
  %156 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings155 = getelementptr inbounds %struct.cop* %156, i64 0, i32 14
  %157 = load %struct.sv** %cop_warnings155, align 8, !tbaa !42
  %cmp156 = icmp eq %struct.sv* %157, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp156, label %if.end169, label %land.lhs.true158

land.lhs.true158:                                 ; preds = %lor.lhs.false154
  %158 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings159 = getelementptr inbounds %struct.cop* %158, i64 0, i32 14
  %159 = load %struct.sv** %cop_warnings159, align 8, !tbaa !42
  %sv_any160 = getelementptr inbounds %struct.sv* %159, i64 0, i32 0
  %160 = load i8** %sv_any160, align 8, !tbaa !24
  %xpv_pv161 = bitcast i8* %160 to i8**
  %161 = load i8** %xpv_pv161, align 8, !tbaa !25
  %arrayidx162 = getelementptr inbounds i8* %161, i64 6
  %162 = load i8* %arrayidx162, align 1, !tbaa !27
  %and164 = and i8 %162, 1
  %tobool165 = icmp eq i8 %and164, 0
  br i1 %tobool165, label %if.end169, label %if.then166

if.then166:                                       ; preds = %land.lhs.true158, %lor.lhs.false150, %land.lhs.true146
  %hent_val = getelementptr inbounds %struct.he* %hent.0, i64 0, i32 2
  %163 = load %struct.sv** %hent_val, align 8, !tbaa !52
  %sub.ptr.lhs.cast = ptrtoint %struct.sv* %163 to i64
  %sub.ptr.div = sdiv exact i64 %sub.ptr.lhs.cast, 24
  %hent_hek = getelementptr inbounds %struct.he* %hent.0, i64 0, i32 1
  %164 = load %struct.hek** %hent_hek, align 8, !tbaa !54
  %arraydecay167 = getelementptr inbounds %struct.hek* %164, i64 0, i32 2, i64 0
  call void (i64, i8*, ...)* @Perl_warner(i64 24, i8* getelementptr inbounds ([48 x i8]* @.str6, i64 0, i64 0), i64 %sub.ptr.div, i8* %arraydecay167) #2
  store %struct.sv* null, %struct.sv** %hent_val, align 8, !tbaa !52
  %hent_next = getelementptr inbounds %struct.he* %hent.0, i64 0, i32 0
  %165 = load %struct.he** %hent_next, align 8, !tbaa !55
  br label %if.end169

if.end169:                                        ; preds = %land.lhs.true158, %lor.lhs.false154, %if.then166
  %hent.1 = phi %struct.he* [ %165, %if.then166 ], [ %hent.0, %land.lhs.true158 ], [ %hent.0, %lor.lhs.false154 ]
  %tobool170 = icmp eq %struct.he* %hent.1, null
  br i1 %tobool170, label %if.then171, label %for.cond144

if.then171:                                       ; preds = %for.cond144, %if.end169
  %inc172 = add nsw i64 %riter.0.ph, 1
  %cmp173 = icmp slt i64 %riter.0.ph, %149
  br i1 %cmp173, label %if.end176, label %for.end179

if.end176:                                        ; preds = %if.then171
  %arrayidx177 = getelementptr inbounds %struct.he** %151, i64 %inc172
  br label %for.cond144.outer

for.end179:                                       ; preds = %if.then171
  %166 = load %struct.hv** @PL_strtab, align 8, !tbaa !1
  %167 = bitcast %struct.hv* %166 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %167) #2
  store i64 0, i64* getelementptr inbounds (%struct.sv* @PL_sv_yes, i64 0, i32 1), align 8, !tbaa !10
  call void @Perl_sv_clear(%struct.sv* @PL_sv_yes) #2
  store i8* null, i8** getelementptr inbounds (%struct.sv* @PL_sv_yes, i64 0, i32 0), align 8, !tbaa !24
  store i64 0, i64* getelementptr inbounds (%struct.sv* @PL_sv_yes, i64 0, i32 2), align 8, !tbaa !7
  store i64 0, i64* getelementptr inbounds (%struct.sv* @PL_sv_no, i64 0, i32 1), align 8, !tbaa !10
  call void @Perl_sv_clear(%struct.sv* @PL_sv_no) #2
  store i8* null, i8** getelementptr inbounds (%struct.sv* @PL_sv_no, i64 0, i32 0), align 8, !tbaa !24
  store i64 0, i64* getelementptr inbounds (%struct.sv* @PL_sv_no, i64 0, i32 2), align 8, !tbaa !7
  store i64 0, i64* getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 0, i32 1), align 8, !tbaa !10
  call void @Perl_sv_clear(%struct.sv* getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 0)) #2
  store i8* null, i8** getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 0, i32 0), align 8, !tbaa !24
  store i64 0, i64* getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 0, i32 2), align 8, !tbaa !7
  store i64 0, i64* getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 1, i32 1), align 8, !tbaa !10
  call void @Perl_sv_clear(%struct.sv* getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 1)) #2
  store i8* null, i8** getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 1, i32 0), align 8, !tbaa !24
  store i64 0, i64* getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 1, i32 2), align 8, !tbaa !7
  store i64 0, i64* getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 2, i32 1), align 8, !tbaa !10
  call void @Perl_sv_clear(%struct.sv* getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 2)) #2
  store i8* null, i8** getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 2, i32 0), align 8, !tbaa !24
  store i64 0, i64* getelementptr inbounds (%struct.perl_debug_pad* @PL_debug_pad, i64 0, i32 0, i64 2, i32 2), align 8, !tbaa !7
  %168 = load i64* @PL_sv_count, align 8, !tbaa !20
  %cmp198 = icmp eq i64 %168, 0
  br i1 %cmp198, label %if.end221, label %land.lhs.true200

land.lhs.true200:                                 ; preds = %for.end179
  %169 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings201 = getelementptr inbounds %struct.cop* %169, i64 0, i32 14
  %170 = load %struct.sv** %cop_warnings201, align 8, !tbaa !42
  %cmp202 = icmp eq %struct.sv* %170, null
  br i1 %cmp202, label %if.then220, label %lor.lhs.false204

lor.lhs.false204:                                 ; preds = %land.lhs.true200
  %171 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings205 = getelementptr inbounds %struct.cop* %171, i64 0, i32 14
  %172 = load %struct.sv** %cop_warnings205, align 8, !tbaa !42
  %cmp206 = icmp eq %struct.sv* %172, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp206, label %if.then220, label %lor.lhs.false208

lor.lhs.false208:                                 ; preds = %lor.lhs.false204
  %173 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings209 = getelementptr inbounds %struct.cop* %173, i64 0, i32 14
  %174 = load %struct.sv** %cop_warnings209, align 8, !tbaa !42
  %cmp210 = icmp eq %struct.sv* %174, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp210, label %if.end221, label %land.lhs.true212

land.lhs.true212:                                 ; preds = %lor.lhs.false208
  %175 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings213 = getelementptr inbounds %struct.cop* %175, i64 0, i32 14
  %176 = load %struct.sv** %cop_warnings213, align 8, !tbaa !42
  %sv_any214 = getelementptr inbounds %struct.sv* %176, i64 0, i32 0
  %177 = load i8** %sv_any214, align 8, !tbaa !24
  %xpv_pv215 = bitcast i8* %177 to i8**
  %178 = load i8** %xpv_pv215, align 8, !tbaa !25
  %arrayidx216 = getelementptr inbounds i8* %178, i64 6
  %179 = load i8* %arrayidx216, align 1, !tbaa !27
  %and218 = and i8 %179, 1
  %tobool219 = icmp eq i8 %and218, 0
  br i1 %tobool219, label %if.end221, label %if.then220

if.then220:                                       ; preds = %land.lhs.true212, %lor.lhs.false204, %land.lhs.true200
  %180 = load i64* @PL_sv_count, align 8, !tbaa !20
  call void (i64, i8*, ...)* @Perl_warner(i64 24, i8* getelementptr inbounds ([21 x i8]* @.str7, i64 0, i64 0), i64 %180) #2
  br label %if.end221

if.end221:                                        ; preds = %land.lhs.true212, %lor.lhs.false208, %for.end179, %if.then220
  store i64 0, i64* @PL_sv_count, align 8, !tbaa !20
  call void @PerlIO_cleanup() #2
  store i64 0, i64* getelementptr inbounds (%struct.sv* @PL_sv_undef, i64 0, i32 1), align 8, !tbaa !10
  %181 = load i64* getelementptr inbounds (%struct.sv* @PL_sv_undef, i64 0, i32 2), align 8, !tbaa !7
  %and222 = and i64 %181, -8388609
  store i64 %and222, i64* getelementptr inbounds (%struct.sv* @PL_sv_undef, i64 0, i32 2), align 8, !tbaa !7
  %182 = load i8** @PL_origfilename, align 8, !tbaa !1
  call void @Perl_safesysfree(i8* %182) #2
  store i8* null, i8** @PL_origfilename, align 8, !tbaa !1
  %183 = load i8*** @PL_reg_start_tmp, align 8, !tbaa !1
  %184 = bitcast i8** %183 to i8*
  call void @Perl_safesysfree(i8* %184) #2
  store i8** null, i8*** @PL_reg_start_tmp, align 8, !tbaa !1
  store i64 0, i64* @PL_reg_start_tmpl, align 8, !tbaa !20
  %185 = load %struct.pmop** @PL_reg_curpm, align 8, !tbaa !1
  %tobool223 = icmp eq %struct.pmop* %185, null
  br i1 %tobool223, label %if.end225, label %if.then224

if.then224:                                       ; preds = %if.end221
  %186 = bitcast %struct.pmop* %185 to i8*
  call void @Perl_safesysfree(i8* %186) #2
  br label %if.end225

if.end225:                                        ; preds = %if.end221, %if.then224
  %187 = load i8** @PL_reg_poscache, align 8, !tbaa !1
  call void @Perl_safesysfree(i8* %187) #2
  %call226 = call i32 (...)* @free_tied_hv_pool() #2
  %188 = load i8** @PL_op_mask, align 8, !tbaa !1
  call void @Perl_safesysfree(i8* %188) #2
  %189 = load %struct.sv*** @PL_psig_ptr, align 8, !tbaa !1
  %190 = bitcast %struct.sv** %189 to i8*
  call void @Perl_safesysfree(i8* %190) #2
  store %struct.sv** null, %struct.sv*** @PL_psig_ptr, align 8, !tbaa !1
  %191 = load %struct.sv*** @PL_psig_name, align 8, !tbaa !1
  %192 = bitcast %struct.sv** %191 to i8*
  call void @Perl_safesysfree(i8* %192) #2
  store %struct.sv** null, %struct.sv*** @PL_psig_name, align 8, !tbaa !1
  %193 = load i8** @PL_bitcount, align 8, !tbaa !1
  call void @Perl_safesysfree(i8* %193) #2
  store i8* null, i8** @PL_bitcount, align 8, !tbaa !1
  %194 = load i32** @PL_psig_pend, align 8, !tbaa !1
  %195 = bitcast i32* %194 to i8*
  call void @Perl_safesysfree(i8* %195) #2
  store i32* null, i32** @PL_psig_pend, align 8, !tbaa !1
  store %struct.sv* null, %struct.sv** @PL_formfeed, align 8, !tbaa !1
  %196 = load i8** @PL_ofmt, align 8, !tbaa !1
  call void @Perl_safesysfree(i8* %196) #2
  store i8* null, i8** @PL_ofmt, align 8, !tbaa !1
  %call227 = call i32 (...)* @nuke_stacks() #2
  store i8 0, i8* @PL_tainting, align 1, !tbaa !27
  store i8 0, i8* @PL_taint_warn, align 1, !tbaa !27
  store i64 0, i64* @PL_hints, align 8, !tbaa !20
  store volatile i64 0, i64* @PL_debug, align 8, !tbaa !20
  %call228 = call i32 (...)* @sv_free_arenas() #2
  %197 = load %struct.sv** @PL_mess_sv, align 8, !tbaa !1
  %tobool229 = icmp eq %struct.sv* %197, null
  br i1 %tobool229, label %return, label %if.then230

if.then230:                                       ; preds = %if.end225
  %sv_flags231 = getelementptr inbounds %struct.sv* %197, i64 0, i32 2
  %198 = load i64* %sv_flags231, align 8, !tbaa !7
  %and232 = and i64 %198, 255
  %cmp233 = icmp ugt i64 %and232, 6
  br i1 %cmp233, label %if.then235, label %if.end255

if.then235:                                       ; preds = %if.then230
  %sv_any238 = getelementptr inbounds %struct.sv* %197, i64 0, i32 0
  %199 = load i8** %sv_any238, align 8, !tbaa !24
  %xmg_magic = getelementptr inbounds i8* %199, i64 40
  %200 = bitcast i8* %xmg_magic to %struct.magic**
  %201 = load %struct.magic** %200, align 8, !tbaa !56
  %tobool240298 = icmp eq %struct.magic* %201, null
  br i1 %tobool240298, label %if.end255, label %for.body241

for.body241:                                      ; preds = %if.then235, %if.end252
  %mg.0299 = phi %struct.magic* [ %202, %if.end252 ], [ %201, %if.then235 ]
  %mg_moremagic = getelementptr inbounds %struct.magic* %mg.0299, i64 0, i32 0
  %202 = load %struct.magic** %mg_moremagic, align 8, !tbaa !58
  %mg_ptr = getelementptr inbounds %struct.magic* %mg.0299, i64 0, i32 6
  %203 = load i8** %mg_ptr, align 8, !tbaa !60
  %tobool242 = icmp eq i8* %203, null
  br i1 %tobool242, label %if.end252, label %land.lhs.true243

land.lhs.true243:                                 ; preds = %for.body241
  %mg_type = getelementptr inbounds %struct.magic* %mg.0299, i64 0, i32 3
  %204 = load i8* %mg_type, align 1, !tbaa !61
  %cmp245 = icmp eq i8 %204, 103
  br i1 %cmp245, label %if.end252, label %land.lhs.true247

land.lhs.true247:                                 ; preds = %land.lhs.true243
  %mg_len = getelementptr inbounds %struct.magic* %mg.0299, i64 0, i32 7
  %205 = load i64* %mg_len, align 8, !tbaa !62
  %cmp248 = icmp sgt i64 %205, -1
  br i1 %cmp248, label %if.then250, label %if.end252

if.then250:                                       ; preds = %land.lhs.true247
  call void @Perl_safesysfree(i8* %203) #2
  br label %if.end252

if.end252:                                        ; preds = %land.lhs.true243, %for.body241, %if.then250, %land.lhs.true247
  %206 = bitcast %struct.magic* %mg.0299 to i8*
  call void @Perl_safesysfree(i8* %206) #2
  %tobool240 = icmp eq %struct.magic* %202, null
  br i1 %tobool240, label %for.cond239.if.end255.loopexit_crit_edge, label %for.body241

for.cond239.if.end255.loopexit_crit_edge:         ; preds = %if.end252
  %.pre312.pre = load %struct.sv** @PL_mess_sv, align 8, !tbaa !1
  %sv_flags256.phi.trans.insert.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre312.pre, i64 0, i32 2
  %.pre313.pre = load i64* %sv_flags256.phi.trans.insert.phi.trans.insert, align 8, !tbaa !7
  br label %if.end255

if.end255:                                        ; preds = %if.then235, %for.cond239.if.end255.loopexit_crit_edge, %if.then230
  %207 = phi i64 [ %198, %if.then230 ], [ %.pre313.pre, %for.cond239.if.end255.loopexit_crit_edge ], [ %198, %if.then235 ]
  %208 = phi %struct.sv* [ %197, %if.then230 ], [ %.pre312.pre, %for.cond239.if.end255.loopexit_crit_edge ], [ %197, %if.then235 ]
  %and257 = and i64 %207, 2097152
  %tobool258 = icmp eq i64 %and257, 0
  br i1 %tobool258, label %land.end262, label %land.rhs259

land.rhs259:                                      ; preds = %if.end255
  %call260 = call i32 @Perl_sv_backoff(%struct.sv* %208) #2
  %.pre314 = load %struct.sv** @PL_mess_sv, align 8, !tbaa !1
  br label %land.end262

land.end262:                                      ; preds = %if.end255, %land.rhs259
  %209 = phi %struct.sv* [ %208, %if.end255 ], [ %.pre314, %land.rhs259 ]
  %sv_any263 = getelementptr inbounds %struct.sv* %209, i64 0, i32 0
  %210 = load i8** %sv_any263, align 8, !tbaa !24
  %xpv_pv264 = bitcast i8* %210 to i8**
  %211 = load i8** %xpv_pv264, align 8, !tbaa !25
  call void @Perl_safesysfree(i8* %211) #2
  %212 = load %struct.sv** @PL_mess_sv, align 8, !tbaa !1
  %sv_any265 = getelementptr inbounds %struct.sv* %212, i64 0, i32 0
  %213 = load i8** %sv_any265, align 8, !tbaa !24
  call void @Perl_safesysfree(i8* %213) #2
  %214 = load %struct.sv** @PL_mess_sv, align 8, !tbaa !1
  %215 = bitcast %struct.sv* %214 to i8*
  call void @Perl_safesysfree(i8* %215) #2
  store %struct.sv* null, %struct.sv** @PL_mess_sv, align 8, !tbaa !1
  br label %return

return:                                           ; preds = %land.end262, %if.end225, %if.end10, %if.then38
  %retval.0.in = load i64* @PL_statusvalue, align 8
  %retval.0 = trunc i64 %retval.0.in to i32
  ret i32 %retval.0
}

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #2

; Function Attrs: returns_twice
declare i32 @sigsetjmp(%struct.__jmp_buf_tag*, i32) #5

; Function Attrs: nounwind uwtable
define void @Perl_call_list(i64 %oldscope, %struct.av* %paramList) #0 {
entry:
  %len = alloca i64, align 8
  %cur_env = alloca %struct.jmpenv, align 8
  %0 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_line = getelementptr inbounds %struct.cop* %0, i64 0, i32 13
  %1 = load i64* %cop_line, align 8, !tbaa !63
  %2 = bitcast %struct.jmpenv* %cur_env to i8*
  call void @llvm.lifetime.start(i64 216, i8* %2) #2
  %3 = getelementptr inbounds %struct.av* %paramList, i64 0, i32 2
  %sv_any = getelementptr inbounds %struct.av* %paramList, i64 0, i32 0
  %je_prev = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 1
  %arraydecay = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 0, i64 0
  %je_ret = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 2
  %je_mustcatch = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 3
  %4 = bitcast %struct.av* %paramList to %struct.sv*
  br label %while.cond

while.cond:                                       ; preds = %sw.epilog, %entry
  %5 = load i64* %3, align 8, !tbaa !7
  %and = and i64 %5, 32768
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %while.cond
  %call = call i64 @Perl_mg_size(%struct.sv* %4) #2
  br label %cond.end

cond.false:                                       ; preds = %while.cond
  %6 = load %struct.xpvav** %sv_any, align 8, !tbaa !14
  %xav_fill = getelementptr inbounds %struct.xpvav* %6, i64 0, i32 1
  %7 = load i64* %xav_fill, align 8, !tbaa !64
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ %7, %cond.false ]
  %cmp = icmp sgt i64 %cond, -1
  br i1 %cmp, label %while.body, label %while.end130

while.body:                                       ; preds = %cond.end
  %call1 = call %struct.sv* @Perl_av_shift(%struct.av* %paramList) #2
  %8 = bitcast %struct.sv* %call1 to %struct.cv*
  %9 = load i8* @PL_savebegin, align 1, !tbaa !27
  %tobool2 = icmp eq i8 %9, 0
  br i1 %tobool2, label %if.else16, label %if.then

if.then:                                          ; preds = %while.body
  %10 = load %struct.av** @PL_beginav, align 8, !tbaa !1
  %cmp3 = icmp eq %struct.av* %10, %paramList
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  %11 = load %struct.av** @PL_beginav_save, align 8, !tbaa !1
  %tobool5 = icmp eq %struct.av* %11, null
  br i1 %tobool5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then4
  %call7 = call %struct.av* @Perl_newAV() #2
  store %struct.av* %call7, %struct.av** @PL_beginav_save, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then6
  %12 = phi %struct.av* [ %11, %if.then4 ], [ %call7, %if.then6 ]
  call void @Perl_av_push(%struct.av* %12, %struct.sv* %call1) #2
  br label %if.end17

if.else:                                          ; preds = %if.then
  %13 = load %struct.av** @PL_checkav, align 8, !tbaa !1
  %cmp8 = icmp eq %struct.av* %13, %paramList
  br i1 %cmp8, label %if.then9, label %if.end17

if.then9:                                         ; preds = %if.else
  %14 = load %struct.av** @PL_checkav_save, align 8, !tbaa !1
  %tobool10 = icmp eq %struct.av* %14, null
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.then9
  %call12 = call %struct.av* @Perl_newAV() #2
  store %struct.av* %call12, %struct.av** @PL_checkav_save, align 8, !tbaa !1
  br label %if.end13

if.end13:                                         ; preds = %if.then9, %if.then11
  %15 = phi %struct.av* [ %14, %if.then9 ], [ %call12, %if.then11 ]
  call void @Perl_av_push(%struct.av* %15, %struct.sv* %call1) #2
  br label %if.end17

if.else16:                                        ; preds = %while.body
  call void @Perl_save_freesv(%struct.sv* %call1) #2
  br label %if.end17

if.end17:                                         ; preds = %if.end, %if.end13, %if.else, %if.else16
  %16 = load %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  store %struct.jmpenv* %16, %struct.jmpenv** %je_prev, align 8, !tbaa !33
  %call18 = call i32 @sigsetjmp(%struct.__jmp_buf_tag* %arraydecay, i32 0) #8
  store i32 %call18, i32* %je_ret, align 8, !tbaa !21
  store %struct.jmpenv* %cur_env, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  store i8 0, i8* %je_mustcatch, align 4, !tbaa !23
  switch i32 %call18, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb52
    i32 2, label %while.cond54.preheader
    i32 3, label %sw.bb84
  ]

sw.bb:                                            ; preds = %if.end17
  %call20 = call i32 (%struct.cv*, ...)* bitcast (i32 (...)* @call_list_body to i32 (%struct.cv*, ...)*)(%struct.cv* %8) #2
  %17 = load %struct.gv** @PL_errgv, align 8, !tbaa !1
  %sv_any21 = getelementptr inbounds %struct.gv* %17, i64 0, i32 0
  %18 = load %struct.xpvgv** %sv_any21, align 8, !tbaa !65
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %18, i64 0, i32 7
  %19 = load %struct.gp** %xgv_gp, align 8, !tbaa !67
  %gp_sv = getelementptr inbounds %struct.gp* %19, i64 0, i32 0
  %20 = load %struct.sv** %gp_sv, align 8, !tbaa !69
  %sv_flags22 = getelementptr inbounds %struct.sv* %20, i64 0, i32 2
  %21 = load i64* %sv_flags22, align 8, !tbaa !7
  %and23 = and i64 %21, 262144
  %cmp24 = icmp eq i64 %and23, 0
  br i1 %cmp24, label %cond.false28, label %cond.true25

cond.true25:                                      ; preds = %sw.bb
  %sv_any26 = getelementptr inbounds %struct.sv* %20, i64 0, i32 0
  %22 = load i8** %sv_any26, align 8, !tbaa !24
  %xpv_cur = getelementptr inbounds i8* %22, i64 8
  %23 = bitcast i8* %xpv_cur to i64*
  %24 = load i64* %23, align 8, !tbaa !28
  store i64 %24, i64* %len, align 8, !tbaa !20
  br label %cond.end30

cond.false28:                                     ; preds = %sw.bb
  %call29 = call i8* @Perl_sv_2pv_flags(%struct.sv* %20, i64* %len, i64 2) #2
  %.pr = load i64* %len, align 8, !tbaa !20
  br label %cond.end30

cond.end30:                                       ; preds = %cond.false28, %cond.true25
  %25 = phi i64 [ %.pr, %cond.false28 ], [ %24, %cond.true25 ]
  %tobool32 = icmp eq i64 %25, 0
  br i1 %tobool32, label %sw.epilog, label %if.then33

if.then33:                                        ; preds = %cond.end30
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !1
  %26 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_line34 = getelementptr inbounds %struct.cop* %26, i64 0, i32 13
  store i64 %1, i64* %cop_line34, align 8, !tbaa !63
  %27 = load %struct.av** @PL_beginav, align 8, !tbaa !1
  %cmp35 = icmp eq %struct.av* %27, %paramList
  br i1 %cmp35, label %if.then36, label %if.else37

if.then36:                                        ; preds = %if.then33
  call void @Perl_sv_catpv(%struct.sv* %20, i8* getelementptr inbounds ([34 x i8]* @.str53, i64 0, i64 0)) #2
  br label %while.cond46.preheader

if.else37:                                        ; preds = %if.then33
  %28 = load %struct.av** @PL_checkav, align 8, !tbaa !1
  %cmp38 = icmp eq %struct.av* %28, %paramList
  br i1 %cmp38, label %cond.end43, label %cond.false40

cond.false40:                                     ; preds = %if.else37
  %29 = load %struct.av** @PL_initav, align 8, !tbaa !1
  %cmp41 = icmp eq %struct.av* %29, %paramList
  %cond42 = select i1 %cmp41, i8* getelementptr inbounds ([5 x i8]* @.str56, i64 0, i64 0), i8* getelementptr inbounds ([4 x i8]* @.str57, i64 0, i64 0)
  br label %cond.end43

cond.end43:                                       ; preds = %if.else37, %cond.false40
  %cond44 = phi i8* [ %cond42, %cond.false40 ], [ getelementptr inbounds ([6 x i8]* @.str55, i64 0, i64 0), %if.else37 ]
  call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %20, i8* getelementptr inbounds ([30 x i8]* @.str54, i64 0, i64 0), i8* %cond44) #2
  br label %while.cond46.preheader

while.cond46.preheader:                           ; preds = %cond.end43, %if.then36
  %30 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  %cmp47152 = icmp sgt i64 %30, %oldscope
  br i1 %cmp47152, label %while.body48, label %while.end

while.body48:                                     ; preds = %while.cond46.preheader, %while.body48
  call void @Perl_pop_scope() #2
  %31 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  %cmp47 = icmp sgt i64 %31, %oldscope
  br i1 %cmp47, label %while.body48, label %while.end

while.end:                                        ; preds = %while.body48, %while.cond46.preheader
  %32 = load %struct.jmpenv** %je_prev, align 8, !tbaa !33
  store %struct.jmpenv* %32, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([3 x i8]* @.str58, i64 0, i64 0), %struct.sv* %20) #2
  br label %sw.epilog

sw.bb52:                                          ; preds = %if.end17
  store i64 1, i64* @PL_statusvalue, align 8, !tbaa !20
  br label %while.cond54.preheader

while.cond54.preheader:                           ; preds = %if.end17, %sw.bb52
  %33 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  %cmp55151 = icmp sgt i64 %33, %oldscope
  br i1 %cmp55151, label %while.body56, label %while.end57

while.body56:                                     ; preds = %while.cond54.preheader, %while.body56
  call void @Perl_pop_scope() #2
  %34 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  %cmp55 = icmp sgt i64 %34, %oldscope
  br i1 %cmp55, label %while.body56, label %while.end57

while.end57:                                      ; preds = %while.body56, %while.cond54.preheader
  %35 = load i64* @PL_tmps_ix, align 8, !tbaa !20
  %36 = load i64* @PL_tmps_floor, align 8, !tbaa !20
  %cmp58 = icmp sgt i64 %35, %36
  br i1 %cmp58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %while.end57
  call void @Perl_free_tmps() #2
  br label %if.end60

if.end60:                                         ; preds = %if.then59, %while.end57
  %37 = load %struct.hv** @PL_defstash, align 8, !tbaa !1
  store %struct.hv* %37, %struct.hv** @PL_curstash, align 8, !tbaa !1
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !1
  %38 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_line61 = getelementptr inbounds %struct.cop* %38, i64 0, i32 13
  store i64 %1, i64* %cop_line61, align 8, !tbaa !63
  %39 = load %struct.jmpenv** %je_prev, align 8, !tbaa !33
  store %struct.jmpenv* %39, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %40 = load i64* @PL_statusvalue, align 8, !tbaa !20
  %tobool64 = icmp eq i64 %40, 0
  br i1 %tobool64, label %if.end82, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end60
  %41 = load i8* @PL_exit_flags, align 1, !tbaa !27
  %and65 = and i8 %41, 1
  %tobool66 = icmp eq i8 %and65, 0
  br i1 %tobool66, label %if.then67, label %if.end82

if.then67:                                        ; preds = %land.lhs.true
  %42 = load %struct.av** @PL_beginav, align 8, !tbaa !1
  %cmp68 = icmp eq %struct.av* %42, %paramList
  br i1 %cmp68, label %if.then70, label %if.else71

if.then70:                                        ; preds = %if.then67
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([34 x i8]* @.str53, i64 0, i64 0)) #2
  br label %if.end82

if.else71:                                        ; preds = %if.then67
  %43 = load %struct.av** @PL_checkav, align 8, !tbaa !1
  %cmp72 = icmp eq %struct.av* %43, %paramList
  br i1 %cmp72, label %cond.end79, label %cond.false75

cond.false75:                                     ; preds = %if.else71
  %44 = load %struct.av** @PL_initav, align 8, !tbaa !1
  %cmp76 = icmp eq %struct.av* %44, %paramList
  %cond78 = select i1 %cmp76, i8* getelementptr inbounds ([5 x i8]* @.str56, i64 0, i64 0), i8* getelementptr inbounds ([4 x i8]* @.str57, i64 0, i64 0)
  br label %cond.end79

cond.end79:                                       ; preds = %if.else71, %cond.false75
  %cond80 = phi i8* [ %cond78, %cond.false75 ], [ getelementptr inbounds ([6 x i8]* @.str55, i64 0, i64 0), %if.else71 ]
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([30 x i8]* @.str54, i64 0, i64 0), i8* %cond80) #2
  br label %if.end82

if.end82:                                         ; preds = %land.lhs.true, %if.end60, %if.then70, %cond.end79
  %call83 = call i32 (...)* @my_exit_jump() #2
  br label %sw.bb84

sw.bb84:                                          ; preds = %if.end17, %if.end82
  %45 = load %struct.op** @PL_restartop, align 8, !tbaa !1
  %tobool85 = icmp eq %struct.op* %45, null
  br i1 %tobool85, label %if.end96, label %if.then86

if.then86:                                        ; preds = %sw.bb84
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !1
  %46 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_line87 = getelementptr inbounds %struct.cop* %46, i64 0, i32 13
  store i64 %1, i64* %cop_line87, align 8, !tbaa !63
  %47 = load %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %je_prev88 = getelementptr inbounds %struct.jmpenv* %47, i64 0, i32 1
  %48 = load %struct.jmpenv** %je_prev88, align 8, !tbaa !33
  %tobool89 = icmp eq %struct.jmpenv* %48, null
  br i1 %tobool89, label %if.end93, label %if.then90

if.then90:                                        ; preds = %if.then86
  %arraydecay92 = getelementptr inbounds %struct.jmpenv* %47, i64 0, i32 0, i64 0
  call void @siglongjmp(%struct.__jmp_buf_tag* %arraydecay92, i32 3) #9
  unreachable

if.end93:                                         ; preds = %if.then86
  %call94 = call %struct._PerlIO** @Perl_PerlIO_stderr() #2
  %call95 = call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %call94, i8* getelementptr inbounds ([16 x i8]* @.str9, i64 0, i64 0)) #2
  call void @exit(i32 1) #9
  unreachable

if.end96:                                         ; preds = %sw.bb84
  %49 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !1
  %tobool97 = icmp eq %struct.gv* %49, null
  br i1 %tobool97, label %cond.false119, label %land.lhs.true98

land.lhs.true98:                                  ; preds = %if.end96
  %sv_flags99 = getelementptr inbounds %struct.gv* %49, i64 0, i32 2
  %50 = load i64* %sv_flags99, align 8, !tbaa !71
  %and100 = and i64 %50, 255
  %cmp101 = icmp eq i64 %and100, 13
  br i1 %cmp101, label %land.lhs.true103, label %cond.false119

land.lhs.true103:                                 ; preds = %land.lhs.true98
  %sv_any104 = getelementptr inbounds %struct.gv* %49, i64 0, i32 0
  %51 = load %struct.xpvgv** %sv_any104, align 8, !tbaa !65
  %xgv_gp105 = getelementptr inbounds %struct.xpvgv* %51, i64 0, i32 7
  %52 = load %struct.gp** %xgv_gp105, align 8, !tbaa !67
  %gp_io = getelementptr inbounds %struct.gp* %52, i64 0, i32 2
  %53 = load %struct.io** %gp_io, align 8, !tbaa !72
  %tobool106 = icmp eq %struct.io* %53, null
  br i1 %tobool106, label %cond.false119, label %land.lhs.true107

land.lhs.true107:                                 ; preds = %land.lhs.true103
  %sv_any111 = getelementptr inbounds %struct.io* %53, i64 0, i32 0
  %54 = load %struct.xpvio** %sv_any111, align 8, !tbaa !73
  %xio_ofp = getelementptr inbounds %struct.xpvio* %54, i64 0, i32 8
  %55 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !75
  %tobool112 = icmp eq %struct._PerlIO** %55, null
  br i1 %tobool112, label %cond.false119, label %cond.end121

cond.false119:                                    ; preds = %land.lhs.true107, %land.lhs.true103, %if.end96, %land.lhs.true98
  %call120 = call %struct._PerlIO** @Perl_PerlIO_stderr() #2
  br label %cond.end121

cond.end121:                                      ; preds = %land.lhs.true107, %cond.false119
  %cond122 = phi %struct._PerlIO** [ %call120, %cond.false119 ], [ %55, %land.lhs.true107 ]
  %call123 = call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond122, i8* getelementptr inbounds ([18 x i8]* @.str11, i64 0, i64 0)) #2
  %56 = load i64* @PL_tmps_ix, align 8, !tbaa !20
  %57 = load i64* @PL_tmps_floor, align 8, !tbaa !20
  %cmp124 = icmp sgt i64 %56, %57
  br i1 %cmp124, label %if.then126, label %sw.epilog

if.then126:                                       ; preds = %cond.end121
  call void @Perl_free_tmps() #2
  br label %sw.epilog

sw.epilog:                                        ; preds = %cond.end30, %cond.end121, %if.then126, %while.end, %if.end17
  %58 = load %struct.jmpenv** %je_prev, align 8, !tbaa !33
  store %struct.jmpenv* %58, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  br label %while.cond

while.end130:                                     ; preds = %cond.end
  call void @llvm.lifetime.end(i64 216, i8* %2) #2
  ret void
}

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #2

declare void @Perl_pop_scope() #3

declare void @Perl_free_tmps() #3

declare i64 @Perl_my_fflush_all() #3

declare void @Perl_op_free(%struct.op*) #3

declare void @Perl_sv_free(%struct.sv*) #3

declare void @PerlIO_destruct() #3

declare i32 @sv_clean_objs(...) #3

declare void @Perl_safesysfree(i8*) #3

declare void @PerlIO_cleanup() #3

declare i32 @setdefout(...) #3

declare i32 @Perl_PerlIO_close(%struct._PerlIO**) #3

declare void @Perl_warner(i64, i8*, ...) #3

declare i32 @sv_clean_all(...) #3

declare void @Perl_sv_clear(%struct.sv*) #3

declare i32 @free_tied_hv_pool(...) #3

declare i32 @nuke_stacks(...) #3

declare i32 @sv_free_arenas(...) #3

declare i32 @Perl_sv_backoff(%struct.sv*) #3

; Function Attrs: nounwind uwtable
define void @perl_free(%struct.interpreter* nocapture %my_perl) #0 {
entry:
  %0 = getelementptr inbounds %struct.interpreter* %my_perl, i64 0, i32 0
  tail call void @free(i8* %0)
  ret void
}

; Function Attrs: nounwind
declare void @free(i8* nocapture) #1

; Function Attrs: nounwind uwtable
define void @Perl_call_atexit(void (i8*)* %fn, i8* %ptr) #0 {
entry:
  %0 = load %struct.exitlistentry** @PL_exitlist, align 8, !tbaa !1
  %1 = bitcast %struct.exitlistentry* %0 to i8*
  %2 = load i64* @PL_exitlistlen, align 8, !tbaa !20
  %add = shl i64 %2, 4
  %mul = add i64 %add, 16
  %call = tail call i8* @Perl_safesysrealloc(i8* %1, i64 %mul) #2
  %3 = bitcast i8* %call to %struct.exitlistentry*
  store %struct.exitlistentry* %3, %struct.exitlistentry** @PL_exitlist, align 8, !tbaa !1
  %4 = load i64* @PL_exitlistlen, align 8, !tbaa !20
  %fn1 = getelementptr inbounds %struct.exitlistentry* %3, i64 %4, i32 0
  store void (i8*)* %fn, void (i8*)** %fn1, align 8, !tbaa !39
  %5 = load %struct.exitlistentry** @PL_exitlist, align 8, !tbaa !1
  %ptr3 = getelementptr inbounds %struct.exitlistentry* %5, i64 %4, i32 1
  store i8* %ptr, i8** %ptr3, align 8, !tbaa !41
  %inc = add nsw i64 %4, 1
  store i64 %inc, i64* @PL_exitlistlen, align 8, !tbaa !20
  ret void
}

declare i8* @Perl_safesysrealloc(i8*, i64) #3

; Function Attrs: nounwind uwtable
define i32 @perl_parse(%struct.interpreter* nocapture readnone %my_perl, void ()* %xsinit, i32 %argc, i8** %argv, i8** %env) #0 {
entry:
  %cur_env = alloca %struct.jmpenv, align 8
  %0 = bitcast %struct.jmpenv* %cur_env to i8*
  call void @llvm.lifetime.start(i64 216, i8* %0) #2
  %1 = load i8* @PL_rehash_seed_set, align 1, !tbaa !27
  %tobool = icmp eq i8 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (...)* @get_hash_seed() #2
  %conv = sext i32 %call to i64
  store i64 %conv, i64* @PL_rehash_seed, align 8, !tbaa !20
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  store i32 %argc, i32* @PL_origargc, align 4, !tbaa !5
  store i8** %argv, i8*** @PL_origargv, align 8, !tbaa !1
  %2 = load i8** %argv, align 8, !tbaa !1
  %3 = ptrtoint i8* %2 to i64
  %and = and i64 %3, -4
  %cmp3 = icmp eq i64 %and, %3
  %notlhs = icmp eq i8** %argv, null
  %notrhs = icmp slt i32 %argc, 1
  %or.cond.not = or i1 %notrhs, %notlhs
  %tobool11 = icmp eq i8* %2, null
  %or.cond208 = or i1 %or.cond.not, %tobool11
  br i1 %or.cond208, label %if.end41, label %while.cond

while.cond:                                       ; preds = %if.end, %while.cond
  %s.0 = phi i8* [ %incdec.ptr, %while.cond ], [ %2, %if.end ]
  %4 = load i8* %s.0, align 1, !tbaa !27
  %tobool13 = icmp eq i8 %4, 0
  %incdec.ptr = getelementptr inbounds i8* %s.0, i64 1
  br i1 %tobool13, label %for.cond.preheader, label %while.cond

for.cond.preheader:                               ; preds = %while.cond
  %cmp14217 = icmp sgt i32 %argc, 1
  br i1 %cmp14217, label %for.body.lr.ph, label %if.end41

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  br i1 %cmp3, label %for.body.us, label %for.body

for.body.us:                                      ; preds = %for.body.lr.ph, %for.inc.us
  %indvars.iv235 = phi i64 [ %indvars.iv.next236, %for.inc.us ], [ 1, %for.body.lr.ph ]
  %s.1219.us = phi i8* [ %s.2.us, %for.inc.us ], [ %s.0, %for.body.lr.ph ]
  %arrayidx16.us = getelementptr inbounds i8** %argv, i64 %indvars.iv235
  %5 = load i8** %arrayidx16.us, align 8, !tbaa !1
  %add.ptr.us = getelementptr inbounds i8* %s.1219.us, i64 1
  %cmp17.us = icmp eq i8* %5, %add.ptr.us
  br i1 %cmp17.us, label %while.cond35.us, label %lor.lhs.false.us

lor.lhs.false.us:                                 ; preds = %for.body.us
  %cmp23.us = icmp ugt i8* %5, %s.1219.us
  br i1 %cmp23.us, label %land.lhs.true25.us, label %if.end41

land.lhs.true25.us:                               ; preds = %lor.lhs.false.us
  %add.ptr28.us = getelementptr inbounds i8* %s.1219.us, i64 4
  %6 = ptrtoint i8* %add.ptr28.us to i64
  %and29.us = and i64 %6, -4
  %7 = inttoptr i64 %and29.us to i8*
  %cmp30.us = icmp ugt i8* %5, %7
  br i1 %cmp30.us, label %if.end41, label %while.cond35.us

while.cond35.us:                                  ; preds = %for.body.us, %land.lhs.true25.us, %while.cond35.us
  %s.2.us = phi i8* [ %incdec.ptr38.us, %while.cond35.us ], [ %5, %land.lhs.true25.us ], [ %5, %for.body.us ]
  %8 = load i8* %s.2.us, align 1, !tbaa !27
  %tobool36.us = icmp eq i8 %8, 0
  %incdec.ptr38.us = getelementptr inbounds i8* %s.2.us, i64 1
  br i1 %tobool36.us, label %for.inc.us, label %while.cond35.us

for.inc.us:                                       ; preds = %while.cond35.us
  %indvars.iv.next236 = add nuw nsw i64 %indvars.iv235, 1
  %9 = trunc i64 %indvars.iv.next236 to i32
  %cmp14.us = icmp slt i32 %9, %argc
  br i1 %cmp14.us, label %for.body.us, label %if.end41

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv231 = phi i64 [ %indvars.iv.next232, %for.inc ], [ 1, %for.body.lr.ph ]
  %s.1219 = phi i8* [ %s.2, %for.inc ], [ %s.0, %for.body.lr.ph ]
  %arrayidx16 = getelementptr inbounds i8** %argv, i64 %indvars.iv231
  %10 = load i8** %arrayidx16, align 8, !tbaa !1
  %add.ptr = getelementptr inbounds i8* %s.1219, i64 1
  %cmp17 = icmp eq i8* %10, %add.ptr
  br i1 %cmp17, label %while.cond35, label %if.end41

while.cond35:                                     ; preds = %for.body, %while.cond35
  %s.2 = phi i8* [ %incdec.ptr38, %while.cond35 ], [ %10, %for.body ]
  %11 = load i8* %s.2, align 1, !tbaa !27
  %tobool36 = icmp eq i8 %11, 0
  %incdec.ptr38 = getelementptr inbounds i8* %s.2, i64 1
  br i1 %tobool36, label %for.inc, label %while.cond35

for.inc:                                          ; preds = %while.cond35
  %indvars.iv.next232 = add nuw nsw i64 %indvars.iv231, 1
  %12 = trunc i64 %indvars.iv.next232 to i32
  %cmp14 = icmp slt i32 %12, %argc
  br i1 %cmp14, label %for.body, label %if.end41

if.end41:                                         ; preds = %for.body, %for.inc, %lor.lhs.false.us, %for.inc.us, %land.lhs.true25.us, %for.cond.preheader, %if.end
  %s.3 = phi i8* [ null, %if.end ], [ %s.0, %for.cond.preheader ], [ %s.1219.us, %lor.lhs.false.us ], [ %s.2.us, %for.inc.us ], [ %s.1219.us, %land.lhs.true25.us ], [ %s.1219, %for.body ], [ %s.2, %for.inc ]
  %13 = load i8*** @PL_origenviron, align 8, !tbaa !1
  %tobool42 = icmp eq i8** %13, null
  br i1 %tobool42, label %if.end105, label %if.then43

if.then43:                                        ; preds = %if.end41
  %14 = load i8** %13, align 8, !tbaa !1
  %add.ptr45 = getelementptr inbounds i8* %s.3, i64 1
  %cmp46 = icmp eq i8* %14, %add.ptr45
  br i1 %cmp46, label %while.cond62, label %lor.lhs.false48

lor.lhs.false48:                                  ; preds = %if.then43
  %cmp52 = icmp ugt i8* %14, %s.3
  %or.cond206 = and i1 %cmp3, %cmp52
  br i1 %or.cond206, label %land.lhs.true54, label %if.end105

land.lhs.true54:                                  ; preds = %lor.lhs.false48
  %add.ptr56 = getelementptr inbounds i8* %s.3, i64 4
  %15 = ptrtoint i8* %add.ptr56 to i64
  %and57 = and i64 %15, -4
  %16 = inttoptr i64 %and57 to i8*
  %cmp58 = icmp ugt i8* %14, %16
  br i1 %cmp58, label %if.end105, label %while.cond62

while.cond62:                                     ; preds = %if.then43, %land.lhs.true54, %while.cond62
  %s.4 = phi i8* [ %incdec.ptr65, %while.cond62 ], [ %14, %land.lhs.true54 ], [ %14, %if.then43 ]
  %17 = load i8* %s.4, align 1, !tbaa !27
  %tobool63 = icmp eq i8 %17, 0
  %incdec.ptr65 = getelementptr inbounds i8* %s.4, i64 1
  br i1 %tobool63, label %while.end66, label %while.cond62

while.end66:                                      ; preds = %while.cond62
  call void @Perl_my_setenv(i8* getelementptr inbounds ([11 x i8]* @.str8, i64 0, i64 0), i8* null) #2
  %18 = load i8*** @PL_origenviron, align 8, !tbaa !1
  %arrayidx69210 = getelementptr inbounds i8** %18, i64 1
  %19 = load i8** %arrayidx69210, align 8, !tbaa !1
  %tobool70211 = icmp eq i8* %19, null
  br i1 %tobool70211, label %if.end105.loopexit, label %for.body71.lr.ph

for.body71.lr.ph:                                 ; preds = %while.end66
  br i1 %cmp3, label %for.body71.us, label %for.body71

for.body71.us:                                    ; preds = %for.body71.lr.ph, %for.inc101.us
  %indvars.iv233 = phi i64 [ %indvars.iv.next234, %for.inc101.us ], [ 1, %for.body71.lr.ph ]
  %20 = phi i8* [ %24, %for.inc101.us ], [ %19, %for.body71.lr.ph ]
  %s.5213.us = phi i8* [ %s.6.us, %for.inc101.us ], [ %s.4, %for.body71.lr.ph ]
  %add.ptr74.us = getelementptr inbounds i8* %s.5213.us, i64 1
  %cmp75.us = icmp eq i8* %20, %add.ptr74.us
  br i1 %cmp75.us, label %while.cond94.us, label %lor.lhs.false77.us

lor.lhs.false77.us:                               ; preds = %for.body71.us
  %cmp82.us = icmp ugt i8* %20, %s.5213.us
  br i1 %cmp82.us, label %land.lhs.true84.us, label %if.end105.loopexit

land.lhs.true84.us:                               ; preds = %lor.lhs.false77.us
  %add.ptr87.us = getelementptr inbounds i8* %s.5213.us, i64 4
  %21 = ptrtoint i8* %add.ptr87.us to i64
  %and88.us = and i64 %21, -4
  %22 = inttoptr i64 %and88.us to i8*
  %cmp89.us = icmp ugt i8* %20, %22
  br i1 %cmp89.us, label %if.end105.loopexit, label %while.cond94.us

while.cond94.us:                                  ; preds = %for.body71.us, %land.lhs.true84.us, %while.cond94.us
  %s.6.us = phi i8* [ %incdec.ptr97.us, %while.cond94.us ], [ %20, %land.lhs.true84.us ], [ %20, %for.body71.us ]
  %23 = load i8* %s.6.us, align 1, !tbaa !27
  %tobool95.us = icmp eq i8 %23, 0
  %incdec.ptr97.us = getelementptr inbounds i8* %s.6.us, i64 1
  br i1 %tobool95.us, label %for.inc101.us, label %while.cond94.us

for.inc101.us:                                    ; preds = %while.cond94.us
  %indvars.iv.next234 = add nuw nsw i64 %indvars.iv233, 1
  %arrayidx69.us = getelementptr inbounds i8** %18, i64 %indvars.iv.next234
  %24 = load i8** %arrayidx69.us, align 8, !tbaa !1
  %tobool70.us = icmp eq i8* %24, null
  br i1 %tobool70.us, label %if.end105.loopexit, label %for.body71.us

for.body71:                                       ; preds = %for.body71.lr.ph, %for.inc101
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc101 ], [ 1, %for.body71.lr.ph ]
  %25 = phi i8* [ %27, %for.inc101 ], [ %19, %for.body71.lr.ph ]
  %s.5213 = phi i8* [ %s.6, %for.inc101 ], [ %s.4, %for.body71.lr.ph ]
  %add.ptr74 = getelementptr inbounds i8* %s.5213, i64 1
  %cmp75 = icmp eq i8* %25, %add.ptr74
  br i1 %cmp75, label %while.cond94, label %if.end105.loopexit

while.cond94:                                     ; preds = %for.body71, %while.cond94
  %s.6 = phi i8* [ %incdec.ptr97, %while.cond94 ], [ %25, %for.body71 ]
  %26 = load i8* %s.6, align 1, !tbaa !27
  %tobool95 = icmp eq i8 %26, 0
  %incdec.ptr97 = getelementptr inbounds i8* %s.6, i64 1
  br i1 %tobool95, label %for.inc101, label %while.cond94

for.inc101:                                       ; preds = %while.cond94
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %arrayidx69 = getelementptr inbounds i8** %18, i64 %indvars.iv.next
  %27 = load i8** %arrayidx69, align 8, !tbaa !1
  %tobool70 = icmp eq i8* %27, null
  br i1 %tobool70, label %if.end105.loopexit, label %for.body71

if.end105.loopexit:                               ; preds = %for.inc101, %for.body71, %land.lhs.true84.us, %for.inc101.us, %lor.lhs.false77.us, %while.end66
  %s.5.lcssa = phi i8* [ %s.4, %while.end66 ], [ %s.5213.us, %land.lhs.true84.us ], [ %s.6.us, %for.inc101.us ], [ %s.5213.us, %lor.lhs.false77.us ], [ %s.6, %for.inc101 ], [ %s.5213, %for.body71 ]
  %.pre = load i8*** @PL_origargv, align 8, !tbaa !1
  %.pre237 = load i8** %.pre, align 8, !tbaa !1
  br label %if.end105

if.end105:                                        ; preds = %if.end105.loopexit, %land.lhs.true54, %if.end41, %lor.lhs.false48
  %28 = phi i8* [ %2, %land.lhs.true54 ], [ %2, %lor.lhs.false48 ], [ %2, %if.end41 ], [ %.pre237, %if.end105.loopexit ]
  %s.7 = phi i8* [ %s.3, %land.lhs.true54 ], [ %s.3, %lor.lhs.false48 ], [ %s.3, %if.end41 ], [ %s.5.lcssa, %if.end105.loopexit ]
  %sub.ptr.lhs.cast = ptrtoint i8* %s.7 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %28 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* @PL_origalen, align 8, !tbaa !20
  %29 = load i8* @PL_do_undump, align 1, !tbaa !27
  %tobool107 = icmp eq i8 %29, 0
  br i1 %tobool107, label %if.end113, label %if.then108

if.then108:                                       ; preds = %if.end105
  %30 = load i8** %argv, align 8, !tbaa !1
  %call110 = call i8* @Perl_savepv(i8* %30) #2
  store i8* %call110, i8** @PL_origfilename, align 8, !tbaa !1
  store i8 0, i8* @PL_do_undump, align 1, !tbaa !27
  %31 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  %si_cxix = getelementptr inbounds %struct.stackinfo* %31, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !46
  %call111 = call i32 (...)* @init_ids() #2
  %call112 = call i32 (i32, i8**, i8**, ...)* bitcast (i32 (...)* @init_postdump_symbols to i32 (i32, i8**, i8**, ...)*)(i32 %argc, i8** %argv, i8** %env) #2
  br label %cleanup

if.end113:                                        ; preds = %if.end105
  %32 = load %struct.op** @PL_main_root, align 8, !tbaa !1
  %tobool114 = icmp eq %struct.op* %32, null
  br i1 %tobool114, label %if.end116, label %if.then115

if.then115:                                       ; preds = %if.end113
  call void @Perl_op_free(%struct.op* %32) #2
  store %struct.op* null, %struct.op** @PL_main_root, align 8, !tbaa !1
  br label %if.end116

if.end116:                                        ; preds = %if.end113, %if.then115
  store %struct.op* null, %struct.op** @PL_main_start, align 8, !tbaa !1
  %33 = load %struct.cv** @PL_main_cv, align 8, !tbaa !1
  %34 = bitcast %struct.cv* %33 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %34) #2
  store %struct.cv* null, %struct.cv** @PL_main_cv, align 8, !tbaa !1
  %call117 = call i32 (i64*, ...)* bitcast (i32 (...)* @time to i32 (i64*, ...)*)(i64* @PL_basetime) #2
  %35 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  store i8 0, i8* @PL_dowarn, align 1, !tbaa !27
  %36 = load %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %je_prev = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 1
  store %struct.jmpenv* %36, %struct.jmpenv** %je_prev, align 8, !tbaa !33
  %arraydecay = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 0, i64 0
  %call118 = call i32 @sigsetjmp(%struct.__jmp_buf_tag* %arraydecay, i32 0) #8
  %je_ret = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 2
  store i32 %call118, i32* %je_ret, align 8, !tbaa !21
  store %struct.jmpenv* %cur_env, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %je_mustcatch = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 3
  store i8 0, i8* %je_mustcatch, align 4, !tbaa !23
  switch i32 %call118, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb124
    i32 2, label %while.cond126.preheader
    i32 3, label %sw.bb139
  ]

sw.bb:                                            ; preds = %if.end116
  %call120 = call i32 (i8**, void ()*, ...)* bitcast (i32 (...)* @parse_body to i32 (i8**, void ()*, ...)*)(i8** %env, void ()* %xsinit) #2
  %37 = load %struct.av** @PL_checkav, align 8, !tbaa !1
  %tobool121 = icmp eq %struct.av* %37, null
  br i1 %tobool121, label %sw.epilog, label %if.then122

if.then122:                                       ; preds = %sw.bb
  call void @Perl_call_list(i64 %35, %struct.av* %37)
  br label %sw.epilog

sw.bb124:                                         ; preds = %if.end116
  store i64 1, i64* @PL_statusvalue, align 8, !tbaa !20
  br label %while.cond126.preheader

while.cond126.preheader:                          ; preds = %if.end116, %sw.bb124
  %38 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  %cmp127209 = icmp sgt i64 %38, %35
  br i1 %cmp127209, label %while.body129, label %while.end130

while.body129:                                    ; preds = %while.cond126.preheader, %while.body129
  call void @Perl_pop_scope() #2
  %39 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  %cmp127 = icmp sgt i64 %39, %35
  br i1 %cmp127, label %while.body129, label %while.end130

while.end130:                                     ; preds = %while.body129, %while.cond126.preheader
  %40 = load i64* @PL_tmps_ix, align 8, !tbaa !20
  %41 = load i64* @PL_tmps_floor, align 8, !tbaa !20
  %cmp131 = icmp sgt i64 %40, %41
  br i1 %cmp131, label %if.then133, label %if.end134

if.then133:                                       ; preds = %while.end130
  call void @Perl_free_tmps() #2
  br label %if.end134

if.end134:                                        ; preds = %if.then133, %while.end130
  %42 = load %struct.hv** @PL_defstash, align 8, !tbaa !1
  store %struct.hv* %42, %struct.hv** @PL_curstash, align 8, !tbaa !1
  %43 = load %struct.av** @PL_checkav, align 8, !tbaa !1
  %tobool135 = icmp eq %struct.av* %43, null
  br i1 %tobool135, label %if.end137, label %if.then136

if.then136:                                       ; preds = %if.end134
  call void @Perl_call_list(i64 %35, %struct.av* %43)
  br label %if.end137

if.end137:                                        ; preds = %if.end134, %if.then136
  %44 = load i64* @PL_statusvalue, align 8, !tbaa !20
  %conv138 = trunc i64 %44 to i32
  br label %sw.epilog

sw.bb139:                                         ; preds = %if.end116
  %45 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !1
  %tobool140 = icmp eq %struct.gv* %45, null
  br i1 %tobool140, label %cond.false, label %land.lhs.true141

land.lhs.true141:                                 ; preds = %sw.bb139
  %sv_flags = getelementptr inbounds %struct.gv* %45, i64 0, i32 2
  %46 = load i64* %sv_flags, align 8, !tbaa !71
  %and142 = and i64 %46, 255
  %cmp143 = icmp eq i64 %and142, 13
  br i1 %cmp143, label %land.lhs.true145, label %cond.false

land.lhs.true145:                                 ; preds = %land.lhs.true141
  %sv_any = getelementptr inbounds %struct.gv* %45, i64 0, i32 0
  %47 = load %struct.xpvgv** %sv_any, align 8, !tbaa !65
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %47, i64 0, i32 7
  %48 = load %struct.gp** %xgv_gp, align 8, !tbaa !67
  %gp_io = getelementptr inbounds %struct.gp* %48, i64 0, i32 2
  %49 = load %struct.io** %gp_io, align 8, !tbaa !72
  %tobool146 = icmp eq %struct.io* %49, null
  br i1 %tobool146, label %cond.false, label %land.lhs.true147

land.lhs.true147:                                 ; preds = %land.lhs.true145
  %sv_any151 = getelementptr inbounds %struct.io* %49, i64 0, i32 0
  %50 = load %struct.xpvio** %sv_any151, align 8, !tbaa !73
  %xio_ofp = getelementptr inbounds %struct.xpvio* %50, i64 0, i32 8
  %51 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !75
  %tobool152 = icmp eq %struct._PerlIO** %51, null
  br i1 %tobool152, label %cond.false, label %cond.end

cond.false:                                       ; preds = %land.lhs.true147, %land.lhs.true145, %sw.bb139, %land.lhs.true141
  %call158 = call %struct._PerlIO** @Perl_PerlIO_stderr() #2
  br label %cond.end

cond.end:                                         ; preds = %land.lhs.true147, %cond.false
  %cond = phi %struct._PerlIO** [ %call158, %cond.false ], [ %51, %land.lhs.true147 ]
  %call159 = call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond, i8* getelementptr inbounds ([16 x i8]* @.str9, i64 0, i64 0)) #2
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then122, %sw.bb, %if.end116, %cond.end, %if.end137
  %ret.0 = phi i32 [ %call118, %if.end116 ], [ 1, %cond.end ], [ %conv138, %if.end137 ], [ 0, %sw.bb ], [ 0, %if.then122 ]
  %52 = load %struct.jmpenv** %je_prev, align 8, !tbaa !33
  store %struct.jmpenv* %52, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %if.then108
  %retval.0 = phi i32 [ 0, %if.then108 ], [ %ret.0, %sw.epilog ]
  call void @llvm.lifetime.end(i64 216, i8* %0) #2
  ret i32 %retval.0
}

declare i32 @get_hash_seed(...) #3

declare void @Perl_my_setenv(i8*, i8*) #3

declare i8* @Perl_savepv(i8*) #3

declare i32 @init_postdump_symbols(...) #3

declare i32 @time(...) #3

declare i32 @parse_body(...) #3

declare i32 @PerlIO_printf(%struct._PerlIO**, i8*, ...) #3

declare %struct._PerlIO** @Perl_PerlIO_stderr() #3

; Function Attrs: nounwind uwtable
define i32 @perl_run(%struct.interpreter* nocapture readnone %my_perl) #0 {
entry:
  %cur_env = alloca %struct.jmpenv, align 8
  %0 = bitcast %struct.jmpenv* %cur_env to i8*
  call void @llvm.lifetime.start(i64 216, i8* %0) #2
  %1 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  %2 = load %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %je_prev = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 1
  store %struct.jmpenv* %2, %struct.jmpenv** %je_prev, align 8, !tbaa !33
  %arraydecay = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 0, i64 0
  %call = call i32 @sigsetjmp(%struct.__jmp_buf_tag* %arraydecay, i32 0) #8
  %je_ret = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 2
  store i32 %call, i32* %je_ret, align 8, !tbaa !21
  store %struct.jmpenv* %cur_env, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %je_mustcatch = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 3
  store i8 0, i8* %je_mustcatch, align 4, !tbaa !23
  switch i32 %call, label %sw.epilog [
    i32 1, label %sw.bb
    i32 0, label %redo_body
    i32 2, label %while.cond.preheader
    i32 3, label %sw.bb12
  ]

sw.bb:                                            ; preds = %entry
  %3 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  %si_cxix = getelementptr inbounds %struct.stackinfo* %3, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !46
  br label %redo_body

redo_body:                                        ; preds = %if.end43, %while.cond15.preheader, %entry, %sw.bb
  %call3 = call i32 (i64, ...)* bitcast (i32 (...)* @run_body to i32 (i64, ...)*)(i64 %1) #2
  br label %while.cond.preheader

while.cond.preheader:                             ; preds = %entry, %redo_body
  %4 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  %cmp101 = icmp sgt i64 %4, %1
  br i1 %cmp101, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond.preheader, %while.body
  call void @Perl_pop_scope() #2
  %5 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  %cmp = icmp sgt i64 %5, %1
  br i1 %cmp, label %while.body, label %while.end

while.end:                                        ; preds = %while.body, %while.cond.preheader
  %6 = load i64* @PL_tmps_ix, align 8, !tbaa !20
  %7 = load i64* @PL_tmps_floor, align 8, !tbaa !20
  %cmp5 = icmp sgt i64 %6, %7
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %while.end
  call void @Perl_free_tmps() #2
  br label %if.end

if.end:                                           ; preds = %if.then, %while.end
  %8 = load %struct.hv** @PL_defstash, align 8, !tbaa !1
  store %struct.hv* %8, %struct.hv** @PL_curstash, align 8, !tbaa !1
  %9 = load i8* @PL_exit_flags, align 1, !tbaa !27
  %and = and i8 %9, 2
  %10 = load %struct.av** @PL_endav, align 8
  %notlhs = icmp ne i8 %and, 0
  %notrhs = icmp eq %struct.av* %10, null
  %or.cond.not = or i1 %notrhs, %notlhs
  %11 = load i8* @PL_minus_c, align 1
  %tobool8 = icmp ne i8 %11, 0
  %or.cond92 = or i1 %or.cond.not, %tobool8
  br i1 %or.cond92, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end
  call void @Perl_call_list(i64 %1, %struct.av* %10)
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then9
  %12 = load i64* @PL_statusvalue, align 8, !tbaa !20
  %conv11 = trunc i64 %12 to i32
  br label %sw.epilog

sw.bb12:                                          ; preds = %entry
  %13 = load %struct.op** @PL_restartop, align 8, !tbaa !1
  %tobool13 = icmp eq %struct.op* %13, null
  br i1 %tobool13, label %if.end56, label %while.cond15.preheader

while.cond15.preheader:                           ; preds = %sw.bb12
  %14 = load %struct.av** @PL_curstack, align 8, !tbaa !1
  %15 = load %struct.av** @PL_mainstack, align 8, !tbaa !1
  %cmp16102 = icmp eq %struct.av* %14, %15
  br i1 %cmp16102, label %redo_body, label %while.body18

while.body18:                                     ; preds = %while.cond15.preheader, %if.end43
  call void @Perl_dounwind(i64 -1) #2
  %16 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %17 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  %si_prev = getelementptr inbounds %struct.stackinfo* %17, i64 0, i32 5
  %18 = load %struct.stackinfo** %si_prev, align 8, !tbaa !77
  %tobool21 = icmp eq %struct.stackinfo* %18, null
  br i1 %tobool21, label %if.then22, label %if.end43

if.then22:                                        ; preds = %while.body18
  %19 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !1
  %tobool23 = icmp eq %struct.gv* %19, null
  br i1 %tobool23, label %cond.false, label %land.lhs.true24

land.lhs.true24:                                  ; preds = %if.then22
  %sv_flags = getelementptr inbounds %struct.gv* %19, i64 0, i32 2
  %20 = load i64* %sv_flags, align 8, !tbaa !71
  %and25 = and i64 %20, 255
  %cmp26 = icmp eq i64 %and25, 13
  br i1 %cmp26, label %land.lhs.true28, label %cond.false

land.lhs.true28:                                  ; preds = %land.lhs.true24
  %sv_any = getelementptr inbounds %struct.gv* %19, i64 0, i32 0
  %21 = load %struct.xpvgv** %sv_any, align 8, !tbaa !65
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %21, i64 0, i32 7
  %22 = load %struct.gp** %xgv_gp, align 8, !tbaa !67
  %gp_io = getelementptr inbounds %struct.gp* %22, i64 0, i32 2
  %23 = load %struct.io** %gp_io, align 8, !tbaa !72
  %tobool29 = icmp eq %struct.io* %23, null
  br i1 %tobool29, label %cond.false, label %land.lhs.true30

land.lhs.true30:                                  ; preds = %land.lhs.true28
  %sv_any34 = getelementptr inbounds %struct.io* %23, i64 0, i32 0
  %24 = load %struct.xpvio** %sv_any34, align 8, !tbaa !73
  %xio_ofp = getelementptr inbounds %struct.xpvio* %24, i64 0, i32 8
  %25 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !75
  %tobool35 = icmp eq %struct._PerlIO** %25, null
  br i1 %tobool35, label %cond.false, label %cond.end

cond.false:                                       ; preds = %land.lhs.true30, %land.lhs.true28, %if.then22, %land.lhs.true24
  %call41 = call %struct._PerlIO** @Perl_PerlIO_stderr() #2
  br label %cond.end

cond.end:                                         ; preds = %land.lhs.true30, %cond.false
  %cond = phi %struct._PerlIO** [ %call41, %cond.false ], [ %25, %land.lhs.true30 ]
  %call42 = call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond, i8* getelementptr inbounds ([17 x i8]* @.str10, i64 0, i64 0)) #2
  store i64 1, i64* @PL_statusvalue, align 8, !tbaa !20
  %call.i = call i32 (...)* @my_exit_jump() #2
  br label %if.end43

if.end43:                                         ; preds = %while.body18, %cond.end
  %26 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %16 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %26 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %27 = load %struct.av** @PL_curstack, align 8, !tbaa !1
  %sv_any44 = getelementptr inbounds %struct.av* %27, i64 0, i32 0
  %28 = load %struct.xpvav** %sv_any44, align 8, !tbaa !14
  %xav_fill = getelementptr inbounds %struct.xpvav* %28, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill, align 8, !tbaa !64
  %si_stack = getelementptr inbounds %struct.stackinfo* %18, i64 0, i32 0
  %29 = load %struct.av** %si_stack, align 8, !tbaa !13
  %sv_any45 = getelementptr inbounds %struct.av* %29, i64 0, i32 0
  %30 = load %struct.xpvav** %sv_any45, align 8, !tbaa !14
  %xav_array = getelementptr inbounds %struct.xpvav* %30, i64 0, i32 0
  %31 = load i8** %xav_array, align 8, !tbaa !16
  %32 = bitcast i8* %31 to %struct.sv**
  store %struct.sv** %32, %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %33 = load %struct.av** %si_stack, align 8, !tbaa !13
  %sv_any47 = getelementptr inbounds %struct.av* %33, i64 0, i32 0
  %34 = load %struct.xpvav** %sv_any47, align 8, !tbaa !14
  %xav_max = getelementptr inbounds %struct.xpvav* %34, i64 0, i32 2
  %35 = load i64* %xav_max, align 8, !tbaa !19
  %add.ptr = getelementptr inbounds %struct.sv** %32, i64 %35
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_max, align 8, !tbaa !1
  %36 = load %struct.av** %si_stack, align 8, !tbaa !13
  %sv_any49 = getelementptr inbounds %struct.av* %36, i64 0, i32 0
  %37 = load %struct.xpvav** %sv_any49, align 8, !tbaa !14
  %xav_fill50 = getelementptr inbounds %struct.xpvav* %37, i64 0, i32 1
  %38 = load i64* %xav_fill50, align 8, !tbaa !64
  %add.ptr51 = getelementptr inbounds %struct.sv** %32, i64 %38
  store %struct.sv** %add.ptr51, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %39 = load %struct.av** %si_stack, align 8, !tbaa !13
  store %struct.av* %39, %struct.av** @PL_curstack, align 8, !tbaa !1
  store %struct.stackinfo* %18, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  %40 = load %struct.av** @PL_mainstack, align 8, !tbaa !1
  %cmp16 = icmp eq %struct.av* %39, %40
  br i1 %cmp16, label %redo_body, label %while.body18

if.end56:                                         ; preds = %sw.bb12
  %41 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !1
  %tobool57 = icmp eq %struct.gv* %41, null
  br i1 %tobool57, label %cond.false81, label %land.lhs.true58

land.lhs.true58:                                  ; preds = %if.end56
  %sv_flags59 = getelementptr inbounds %struct.gv* %41, i64 0, i32 2
  %42 = load i64* %sv_flags59, align 8, !tbaa !71
  %and60 = and i64 %42, 255
  %cmp61 = icmp eq i64 %and60, 13
  br i1 %cmp61, label %land.lhs.true63, label %cond.false81

land.lhs.true63:                                  ; preds = %land.lhs.true58
  %sv_any64 = getelementptr inbounds %struct.gv* %41, i64 0, i32 0
  %43 = load %struct.xpvgv** %sv_any64, align 8, !tbaa !65
  %xgv_gp65 = getelementptr inbounds %struct.xpvgv* %43, i64 0, i32 7
  %44 = load %struct.gp** %xgv_gp65, align 8, !tbaa !67
  %gp_io66 = getelementptr inbounds %struct.gp* %44, i64 0, i32 2
  %45 = load %struct.io** %gp_io66, align 8, !tbaa !72
  %tobool67 = icmp eq %struct.io* %45, null
  br i1 %tobool67, label %cond.false81, label %land.lhs.true68

land.lhs.true68:                                  ; preds = %land.lhs.true63
  %sv_any72 = getelementptr inbounds %struct.io* %45, i64 0, i32 0
  %46 = load %struct.xpvio** %sv_any72, align 8, !tbaa !73
  %xio_ofp73 = getelementptr inbounds %struct.xpvio* %46, i64 0, i32 8
  %47 = load %struct._PerlIO*** %xio_ofp73, align 8, !tbaa !75
  %tobool74 = icmp eq %struct._PerlIO** %47, null
  br i1 %tobool74, label %cond.false81, label %cond.end83

cond.false81:                                     ; preds = %land.lhs.true68, %land.lhs.true63, %if.end56, %land.lhs.true58
  %call82 = call %struct._PerlIO** @Perl_PerlIO_stderr() #2
  br label %cond.end83

cond.end83:                                       ; preds = %land.lhs.true68, %cond.false81
  %cond84 = phi %struct._PerlIO** [ %call82, %cond.false81 ], [ %47, %land.lhs.true68 ]
  %call85 = call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond84, i8* getelementptr inbounds ([18 x i8]* @.str11, i64 0, i64 0)) #2
  %48 = load i64* @PL_tmps_ix, align 8, !tbaa !20
  %49 = load i64* @PL_tmps_floor, align 8, !tbaa !20
  %cmp86 = icmp sgt i64 %48, %49
  br i1 %cmp86, label %if.then88, label %sw.epilog

if.then88:                                        ; preds = %cond.end83
  call void @Perl_free_tmps() #2
  br label %sw.epilog

sw.epilog:                                        ; preds = %cond.end83, %if.then88, %entry, %if.end10
  %ret.0 = phi i32 [ %call, %entry ], [ %conv11, %if.end10 ], [ 1, %if.then88 ], [ 1, %cond.end83 ]
  %50 = load %struct.jmpenv** %je_prev, align 8, !tbaa !33
  store %struct.jmpenv* %50, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  call void @llvm.lifetime.end(i64 216, i8* %0) #2
  ret i32 %ret.0
}

declare i32 @run_body(...) #3

declare void @Perl_dounwind(i64) #3

; Function Attrs: nounwind uwtable
define void @Perl_my_exit(i64 %status) #0 {
entry:
  switch i64 %status, label %sw.default [
    i64 0, label %sw.bb
    i64 1, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  store i64 0, i64* @PL_statusvalue, align 8, !tbaa !20
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  store i64 1, i64* @PL_statusvalue, align 8, !tbaa !20
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store i64 %status, i64* @PL_statusvalue, align 8, !tbaa !20
  %cmp = icmp eq i64 %status, -1
  br i1 %cmp, label %sw.epilog, label %if.then

if.then:                                          ; preds = %sw.default
  %and = and i64 %status, 65535
  store i64 %and, i64* @PL_statusvalue, align 8, !tbaa !20
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.then, %sw.bb1, %sw.bb
  %call = tail call i32 (...)* @my_exit_jump() #2
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.sv* @Perl_get_sv(i8* %name, i64 %create) #0 {
entry:
  %call = tail call %struct.gv* @Perl_gv_fetchpv(i8* %name, i64 %create, i64 4) #2
  %tobool = icmp eq %struct.gv* %call, null
  br i1 %tobool, label %return, label %if.then

if.then:                                          ; preds = %entry
  %sv_any = getelementptr inbounds %struct.gv* %call, i64 0, i32 0
  %0 = load %struct.xpvgv** %sv_any, align 8, !tbaa !65
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %0, i64 0, i32 7
  %1 = load %struct.gp** %xgv_gp, align 8, !tbaa !67
  %gp_sv = getelementptr inbounds %struct.gp* %1, i64 0, i32 0
  %2 = load %struct.sv** %gp_sv, align 8, !tbaa !69
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi %struct.sv* [ %2, %if.then ], [ null, %entry ]
  ret %struct.sv* %retval.0
}

declare %struct.gv* @Perl_gv_fetchpv(i8*, i64, i64) #3

; Function Attrs: nounwind uwtable
define %struct.av* @Perl_get_av(i8* %name, i64 %create) #0 {
entry:
  %call = tail call %struct.gv* @Perl_gv_fetchpv(i8* %name, i64 %create, i64 10) #2
  %tobool = icmp eq i64 %create, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sv_any = getelementptr inbounds %struct.gv* %call, i64 0, i32 0
  %0 = load %struct.xpvgv** %sv_any, align 8, !tbaa !65
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %0, i64 0, i32 7
  %1 = load %struct.gp** %xgv_gp, align 8, !tbaa !67
  %gp_av = getelementptr inbounds %struct.gp* %1, i64 0, i32 4
  %2 = load %struct.av** %gp_av, align 8, !tbaa !78
  %tobool1 = icmp eq %struct.av* %2, null
  br i1 %tobool1, label %cond.false, label %return

cond.false:                                       ; preds = %if.then
  %call5 = tail call %struct.gv* @Perl_gv_AVadd(%struct.gv* %call) #2
  %sv_any6 = getelementptr inbounds %struct.gv* %call5, i64 0, i32 0
  %3 = load %struct.xpvgv** %sv_any6, align 8, !tbaa !65
  %xgv_gp7 = getelementptr inbounds %struct.xpvgv* %3, i64 0, i32 7
  %4 = load %struct.gp** %xgv_gp7, align 8, !tbaa !67
  %gp_av8 = getelementptr inbounds %struct.gp* %4, i64 0, i32 4
  %5 = load %struct.av** %gp_av8, align 8, !tbaa !78
  br label %return

if.end:                                           ; preds = %entry
  %tobool9 = icmp eq %struct.gv* %call, null
  br i1 %tobool9, label %return, label %if.then10

if.then10:                                        ; preds = %if.end
  %sv_any11 = getelementptr inbounds %struct.gv* %call, i64 0, i32 0
  %6 = load %struct.xpvgv** %sv_any11, align 8, !tbaa !65
  %xgv_gp12 = getelementptr inbounds %struct.xpvgv* %6, i64 0, i32 7
  %7 = load %struct.gp** %xgv_gp12, align 8, !tbaa !67
  %gp_av13 = getelementptr inbounds %struct.gp* %7, i64 0, i32 4
  %8 = load %struct.av** %gp_av13, align 8, !tbaa !78
  br label %return

return:                                           ; preds = %if.end, %cond.false, %if.then, %if.then10
  %retval.0 = phi %struct.av* [ %8, %if.then10 ], [ %5, %cond.false ], [ %2, %if.then ], [ null, %if.end ]
  ret %struct.av* %retval.0
}

declare %struct.gv* @Perl_gv_AVadd(%struct.gv*) #3

; Function Attrs: nounwind uwtable
define %struct.hv* @Perl_get_hv(i8* %name, i64 %create) #0 {
entry:
  %call = tail call %struct.gv* @Perl_gv_fetchpv(i8* %name, i64 %create, i64 11) #2
  %tobool = icmp eq i64 %create, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sv_any = getelementptr inbounds %struct.gv* %call, i64 0, i32 0
  %0 = load %struct.xpvgv** %sv_any, align 8, !tbaa !65
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %0, i64 0, i32 7
  %1 = load %struct.gp** %xgv_gp, align 8, !tbaa !67
  %gp_hv = getelementptr inbounds %struct.gp* %1, i64 0, i32 5
  %2 = load %struct.hv** %gp_hv, align 8, !tbaa !79
  %tobool1 = icmp eq %struct.hv* %2, null
  br i1 %tobool1, label %cond.false, label %return

cond.false:                                       ; preds = %if.then
  %call5 = tail call %struct.gv* @Perl_gv_HVadd(%struct.gv* %call) #2
  %sv_any6 = getelementptr inbounds %struct.gv* %call5, i64 0, i32 0
  %3 = load %struct.xpvgv** %sv_any6, align 8, !tbaa !65
  %xgv_gp7 = getelementptr inbounds %struct.xpvgv* %3, i64 0, i32 7
  %4 = load %struct.gp** %xgv_gp7, align 8, !tbaa !67
  %gp_hv8 = getelementptr inbounds %struct.gp* %4, i64 0, i32 5
  %5 = load %struct.hv** %gp_hv8, align 8, !tbaa !79
  br label %return

if.end:                                           ; preds = %entry
  %tobool9 = icmp eq %struct.gv* %call, null
  br i1 %tobool9, label %return, label %if.then10

if.then10:                                        ; preds = %if.end
  %sv_any11 = getelementptr inbounds %struct.gv* %call, i64 0, i32 0
  %6 = load %struct.xpvgv** %sv_any11, align 8, !tbaa !65
  %xgv_gp12 = getelementptr inbounds %struct.xpvgv* %6, i64 0, i32 7
  %7 = load %struct.gp** %xgv_gp12, align 8, !tbaa !67
  %gp_hv13 = getelementptr inbounds %struct.gp* %7, i64 0, i32 5
  %8 = load %struct.hv** %gp_hv13, align 8, !tbaa !79
  br label %return

return:                                           ; preds = %if.end, %cond.false, %if.then, %if.then10
  %retval.0 = phi %struct.hv* [ %8, %if.then10 ], [ %5, %cond.false ], [ %2, %if.then ], [ null, %if.end ]
  ret %struct.hv* %retval.0
}

declare %struct.gv* @Perl_gv_HVadd(%struct.gv*) #3

; Function Attrs: nounwind uwtable
define %struct.cv* @Perl_get_cv(i8* %name, i64 %create) #0 {
entry:
  %call = tail call %struct.gv* @Perl_gv_fetchpv(i8* %name, i64 %create, i64 12) #2
  %tobool = icmp eq i64 %create, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %sv_any = getelementptr inbounds %struct.gv* %call, i64 0, i32 0
  %0 = load %struct.xpvgv** %sv_any, align 8, !tbaa !65
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %0, i64 0, i32 7
  %1 = load %struct.gp** %xgv_gp, align 8, !tbaa !67
  %gp_cvgen = getelementptr inbounds %struct.gp* %1, i64 0, i32 8
  %2 = load i64* %gp_cvgen, align 8, !tbaa !80
  %tobool1 = icmp eq i64 %2, 0
  br i1 %tobool1, label %cond.false, label %if.then

cond.false:                                       ; preds = %land.lhs.true
  %gp_cv = getelementptr inbounds %struct.gp* %1, i64 0, i32 7
  %3 = load %struct.cv** %gp_cv, align 8, !tbaa !81
  %tobool4 = icmp eq %struct.cv* %3, null
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %cond.false, %land.lhs.true
  %call5 = tail call i64 @Perl_start_subparse(i64 0, i64 0) #2
  %call6 = tail call %struct.sv* @Perl_newSVpv(i8* %name, i64 0) #2
  %call7 = tail call %struct.op* @Perl_newSVOP(i64 5, i64 0, %struct.sv* %call6) #2
  %call8 = tail call %struct.cv* @Perl_newSUB(i64 %call5, %struct.op* %call7, %struct.op* null, %struct.op* null) #2
  br label %return

if.end:                                           ; preds = %cond.false, %entry
  %tobool9 = icmp eq %struct.gv* %call, null
  br i1 %tobool9, label %return, label %if.then10

if.then10:                                        ; preds = %if.end
  %sv_any11 = getelementptr inbounds %struct.gv* %call, i64 0, i32 0
  %4 = load %struct.xpvgv** %sv_any11, align 8, !tbaa !65
  %xgv_gp12 = getelementptr inbounds %struct.xpvgv* %4, i64 0, i32 7
  %5 = load %struct.gp** %xgv_gp12, align 8, !tbaa !67
  %gp_cvgen13 = getelementptr inbounds %struct.gp* %5, i64 0, i32 8
  %6 = load i64* %gp_cvgen13, align 8, !tbaa !80
  %tobool14 = icmp eq i64 %6, 0
  br i1 %tobool14, label %cond.false16, label %return

cond.false16:                                     ; preds = %if.then10
  %gp_cv19 = getelementptr inbounds %struct.gp* %5, i64 0, i32 7
  %7 = load %struct.cv** %gp_cv19, align 8, !tbaa !81
  br label %return

return:                                           ; preds = %if.end, %cond.false16, %if.then10, %if.then
  %retval.0 = phi %struct.cv* [ %call8, %if.then ], [ %7, %cond.false16 ], [ null, %if.then10 ], [ null, %if.end ]
  ret %struct.cv* %retval.0
}

declare %struct.cv* @Perl_newSUB(i64, %struct.op*, %struct.op*, %struct.op*) #3

declare i64 @Perl_start_subparse(i64, i64) #3

declare %struct.op* @Perl_newSVOP(i64, i64, %struct.sv*) #3

declare %struct.sv* @Perl_newSVpv(i8*, i64) #3

; Function Attrs: nounwind uwtable
define i64 @Perl_call_argv(i8* %sub_name, i64 %flags, i8** readonly %argv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %1, i64 1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_max, align 8, !tbaa !1
  %cmp = icmp eq i64* %incdec.ptr, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @Perl_markstack_grow() #2
  %.pre = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = phi i64* [ %.pre, %if.then ], [ %incdec.ptr, %entry ]
  %4 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %4 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  store i64 %sub.ptr.div, i64* %3, align 8, !tbaa !20
  %tobool = icmp eq i8** %argv, null
  br i1 %tobool, label %if.end15, label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.end
  %5 = load i8** %argv, align 8, !tbaa !1
  %tobool225 = icmp eq i8* %5, null
  br i1 %tobool225, label %while.end, label %while.body

while.body:                                       ; preds = %while.cond.preheader, %if.end9
  %6 = phi i8* [ %9, %if.end9 ], [ %5, %while.cond.preheader ]
  %argv.addr.027 = phi i8** [ %incdec.ptr14, %if.end9 ], [ %argv, %while.cond.preheader ]
  %sp.026 = phi %struct.sv** [ %incdec.ptr13, %if.end9 ], [ %0, %while.cond.preheader ]
  %7 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !1
  %sub.ptr.lhs.cast3 = ptrtoint %struct.sv** %7 to i64
  %sub.ptr.rhs.cast4 = ptrtoint %struct.sv** %sp.026 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  %cmp7 = icmp slt i64 %sub.ptr.sub5, 8
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %while.body
  %call = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %sp.026, %struct.sv** %sp.026, i32 1) #2
  %.pre28 = load i8** %argv.addr.027, align 8, !tbaa !1
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %while.body
  %8 = phi i8* [ %.pre28, %if.then8 ], [ %6, %while.body ]
  %sp.1 = phi %struct.sv** [ %call, %if.then8 ], [ %sp.026, %while.body ]
  %call11 = tail call %struct.sv* @Perl_newSVpv(i8* %8, i64 0) #2
  %call12 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call11) #2
  %incdec.ptr13 = getelementptr inbounds %struct.sv** %sp.1, i64 1
  store %struct.sv* %call12, %struct.sv** %incdec.ptr13, align 8, !tbaa !1
  %incdec.ptr14 = getelementptr inbounds i8** %argv.addr.027, i64 1
  %9 = load i8** %incdec.ptr14, align 8, !tbaa !1
  %tobool2 = icmp eq i8* %9, null
  br i1 %tobool2, label %while.end, label %while.body

while.end:                                        ; preds = %if.end9, %while.cond.preheader
  %sp.0.lcssa = phi %struct.sv** [ %0, %while.cond.preheader ], [ %incdec.ptr13, %if.end9 ]
  store %struct.sv** %sp.0.lcssa, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  br label %if.end15

if.end15:                                         ; preds = %if.end, %while.end
  %call.i = tail call %struct.cv* @Perl_get_cv(i8* %sub_name, i64 1) #2
  %10 = bitcast %struct.cv* %call.i to %struct.sv*
  %call1.i = tail call i64 @Perl_call_sv(%struct.sv* %10, i64 %flags) #2
  ret i64 %call1.i
}

declare void @Perl_markstack_grow() #3

declare %struct.sv** @Perl_stack_grow(%struct.sv**, %struct.sv**, i32) #3

declare %struct.sv* @Perl_sv_2mortal(%struct.sv*) #3

; Function Attrs: nounwind uwtable
define i64 @Perl_call_pv(i8* %sub_name, i64 %flags) #0 {
entry:
  %call = tail call %struct.cv* @Perl_get_cv(i8* %sub_name, i64 1)
  %0 = bitcast %struct.cv* %call to %struct.sv*
  %call1 = tail call i64 @Perl_call_sv(%struct.sv* %0, i64 %flags)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define i64 @Perl_call_sv(%struct.sv* %sv, i64 %flags) #0 {
entry:
  %myop = alloca %struct.logop, align 8
  %method_op = alloca %struct.unop, align 8
  %retval1 = alloca i64, align 8
  %cur_env = alloca %struct.jmpenv, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = bitcast %struct.logop* %myop to i8*
  call void @llvm.lifetime.start(i64 56, i8* %1) #2
  %2 = bitcast %struct.unop* %method_op to i8*
  call void @llvm.lifetime.start(i64 48, i8* %2) #2
  store volatile i64 0, i64* %retval1, align 8
  %3 = load %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %je_mustcatch = getelementptr inbounds %struct.jmpenv* %3, i64 0, i32 3
  %4 = load i8* %je_mustcatch, align 1, !tbaa !23
  %5 = load %struct.op** @PL_op, align 8, !tbaa !1
  %6 = bitcast %struct.jmpenv* %cur_env to i8*
  call void @llvm.lifetime.start(i64 216, i8* %6) #2
  %and = and i64 %flags, 2
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @Perl_push_scope() #2
  call void @Perl_save_int(i32* bitcast (i64* @PL_tmps_floor to i32*)) #2
  %7 = load i64* @PL_tmps_ix, align 8, !tbaa !20
  store i64 %7, i64* @PL_tmps_floor, align 8, !tbaa !20
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 56, i32 8, i1 false)
  %op_next = getelementptr inbounds %struct.logop* %myop, i64 0, i32 0
  store %struct.op* null, %struct.op** %op_next, align 8, !tbaa !82
  %and2 = and i64 %flags, 8
  %tobool3 = icmp eq i64 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %op_flags = getelementptr inbounds %struct.logop* %myop, i64 0, i32 6
  store i8 64, i8* %op_flags, align 4, !tbaa !84
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then4
  %8 = phi i8 [ 0, %if.end ], [ 64, %if.then4 ]
  %and7 = and i64 %flags, 128
  %tobool8 = icmp eq i64 %and7, 0
  br i1 %tobool8, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.end6
  %flags.tr = trunc i64 %flags to i8
  %9 = and i8 %flags.tr, 1
  %10 = or i8 %9, 2
  br label %cond.end

cond.end:                                         ; preds = %if.end6, %cond.false
  %cond11 = phi i8 [ %10, %cond.false ], [ 1, %if.end6 ]
  %op_flags12 = getelementptr inbounds %struct.logop* %myop, i64 0, i32 6
  %or14 = or i8 %8, %cond11
  store i8 %or14, i8* %op_flags12, align 4, !tbaa !84
  %call = call i32 (...)* @save_op() #2
  %11 = bitcast %struct.logop* %myop to %struct.op*
  store %struct.op* %11, %struct.op** @PL_op, align 8, !tbaa !1
  %12 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !1
  %13 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %12 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %13 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp, label %if.then17, label %if.end19

if.then17:                                        ; preds = %cond.end
  %call18 = call %struct.sv** @Perl_stack_grow(%struct.sv** %0, %struct.sv** %13, i32 1) #2
  %.pre = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %cond.end
  %14 = phi %struct.sv** [ %.pre, %if.then17 ], [ %13, %cond.end ]
  %incdec.ptr = getelementptr inbounds %struct.sv** %14, i64 1
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  store %struct.sv* %sv, %struct.sv** %incdec.ptr, align 8, !tbaa !1
  %15 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %16 = load i64* %15, align 8, !tbaa !20
  %17 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  %18 = load i64* @PL_perldb, align 8, !tbaa !20
  %and21 = and i64 %18, 1
  %tobool22 = icmp eq i64 %and21, 0
  br i1 %tobool22, label %if.end44, label %land.lhs.true23

land.lhs.true23:                                  ; preds = %if.end19
  %19 = load %struct.hv** @PL_curstash, align 8, !tbaa !1
  %20 = load %struct.hv** @PL_debstash, align 8, !tbaa !1
  %cmp24 = icmp eq %struct.hv* %19, %20
  br i1 %cmp24, label %if.end44, label %land.lhs.true26

land.lhs.true26:                                  ; preds = %land.lhs.true23
  %21 = load %struct.cv** @PL_DBcv, align 8, !tbaa !1
  %tobool27 = icmp eq %struct.cv* %21, null
  br i1 %tobool27, label %lor.lhs.false, label %land.lhs.true29

lor.lhs.false:                                    ; preds = %land.lhs.true26
  %22 = load %struct.gv** @PL_DBsub, align 8, !tbaa !1
  %sv_any = getelementptr inbounds %struct.gv* %22, i64 0, i32 0
  %23 = load %struct.xpvgv** %sv_any, align 8, !tbaa !65
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %23, i64 0, i32 7
  %24 = load %struct.gp** %xgv_gp, align 8, !tbaa !67
  %gp_cv = getelementptr inbounds %struct.gp* %24, i64 0, i32 7
  %25 = load %struct.cv** %gp_cv, align 8, !tbaa !81
  store %struct.cv* %25, %struct.cv** @PL_DBcv, align 8, !tbaa !1
  %tobool28 = icmp eq %struct.cv* %25, null
  br i1 %tobool28, label %if.end44, label %land.lhs.true29

land.lhs.true29:                                  ; preds = %lor.lhs.false, %land.lhs.true26
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %26 = load i64* %sv_flags, align 8, !tbaa !7
  %and30 = and i64 %26, 255
  %cmp31 = icmp eq i64 %and30, 12
  br i1 %cmp31, label %lor.lhs.false33, label %land.lhs.true37

lor.lhs.false33:                                  ; preds = %land.lhs.true29
  %sv_any34 = bitcast %struct.sv* %sv to %struct.xpvcv**
  %27 = load %struct.xpvcv** %sv_any34, align 8, !tbaa !34
  %xcv_stash = getelementptr inbounds %struct.xpvcv* %27, i64 0, i32 7
  %28 = load %struct.hv** %xcv_stash, align 8, !tbaa !85
  %cmp35 = icmp ne %struct.hv* %28, %20
  %and38 = and i64 %flags, 32
  %tobool39 = icmp eq i64 %and38, 0
  %or.cond320 = and i1 %cmp35, %tobool39
  br i1 %or.cond320, label %if.then40, label %if.end44

land.lhs.true37:                                  ; preds = %land.lhs.true29
  %.old = and i64 %flags, 32
  %tobool39.old = icmp eq i64 %.old, 0
  br i1 %tobool39.old, label %if.then40, label %if.end44

if.then40:                                        ; preds = %lor.lhs.false33, %land.lhs.true37
  %29 = load %struct.op** @PL_op, align 8, !tbaa !1
  %op_private = getelementptr inbounds %struct.op* %29, i64 0, i32 7
  %30 = load i8* %op_private, align 1, !tbaa !86
  %or42 = or i8 %30, 16
  store i8 %or42, i8* %op_private, align 1, !tbaa !86
  br label %if.end44

if.end44:                                         ; preds = %lor.lhs.false33, %land.lhs.true37, %lor.lhs.false, %land.lhs.true23, %if.end19, %if.then40
  %and45 = and i64 %flags, 64
  %tobool46 = icmp eq i64 %and45, 0
  br i1 %tobool46, label %if.end50, label %if.then47

if.then47:                                        ; preds = %if.end44
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 48, i32 8, i1 false)
  %31 = load %struct.op** @PL_op, align 8, !tbaa !1
  %op_next48 = getelementptr inbounds %struct.unop* %method_op, i64 0, i32 0
  store %struct.op* %31, %struct.op** %op_next48, align 8, !tbaa !88
  %32 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 165), align 8, !tbaa !1
  %op_ppaddr = getelementptr inbounds %struct.unop* %method_op, i64 0, i32 2
  store %struct.op* ()* %32, %struct.op* ()** %op_ppaddr, align 8, !tbaa !90
  %33 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 166), align 8, !tbaa !1
  %op_ppaddr49 = getelementptr inbounds %struct.logop* %myop, i64 0, i32 2
  store %struct.op* ()* %33, %struct.op* ()** %op_ppaddr49, align 8, !tbaa !91
  %34 = bitcast %struct.unop* %method_op to %struct.op*
  store %struct.op* %34, %struct.op** @PL_op, align 8, !tbaa !1
  br label %if.end50

if.end50:                                         ; preds = %if.end44, %if.then47
  %and51 = and i64 %flags, 4
  %tobool52 = icmp eq i64 %and51, 0
  br i1 %tobool52, label %if.then53, label %if.else

if.then53:                                        ; preds = %if.end50
  %35 = load %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %je_mustcatch54 = getelementptr inbounds %struct.jmpenv* %35, i64 0, i32 3
  store i8 1, i8* %je_mustcatch54, align 1, !tbaa !23
  %call55 = call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @call_body to i32 (%struct.op*, i32, ...)*)(%struct.op* %11, i32 0) #2
  %36 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %37 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr = getelementptr inbounds %struct.sv** %37, i64 %16
  %sub.ptr.lhs.cast56 = ptrtoint %struct.sv** %36 to i64
  %sub.ptr.rhs.cast57 = ptrtoint %struct.sv** %add.ptr to i64
  %sub.ptr.sub58 = sub i64 %sub.ptr.lhs.cast56, %sub.ptr.rhs.cast57
  %sub.ptr.div59 = ashr exact i64 %sub.ptr.sub58, 3
  store volatile i64 %sub.ptr.div59, i64* %retval1, align 8
  %38 = load %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %je_mustcatch60 = getelementptr inbounds %struct.jmpenv* %38, i64 0, i32 3
  store i8 %4, i8* %je_mustcatch60, align 1, !tbaa !23
  br label %if.end271

if.else:                                          ; preds = %if.end50
  %op_other = getelementptr inbounds %struct.logop* %myop, i64 0, i32 9
  store %struct.op* %11, %struct.op** %op_other, align 8, !tbaa !92
  %incdec.ptr61 = getelementptr inbounds i64* %15, i64 -1
  store i64* %incdec.ptr61, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %39 = load %struct.op** @PL_op, align 8, !tbaa !1
  %op_flags62 = getelementptr inbounds %struct.op* %39, i64 0, i32 6
  %40 = load i8* %op_flags62, align 1, !tbaa !93
  %conv63 = zext i8 %40 to i32
  %and64 = and i32 %conv63, 3
  %cmp65 = icmp eq i32 %and64, 1
  br i1 %cmp65, label %cond.end88, label %cond.false68

cond.false68:                                     ; preds = %if.else
  %cmp72 = icmp eq i32 %and64, 2
  br i1 %cmp72, label %cond.end88, label %cond.false75

cond.false75:                                     ; preds = %cond.false68
  %cmp79 = icmp eq i32 %and64, 3
  br i1 %cmp79, label %cond.end88, label %cond.false82

cond.false82:                                     ; preds = %cond.false75
  %call83 = call i64 @Perl_block_gimme() #2
  %phitmp = trunc i64 %call83 to i8
  br label %cond.end88

cond.end88:                                       ; preds = %cond.false68, %cond.false75, %cond.false82, %if.else
  %cond89 = phi i8 [ -128, %if.else ], [ 0, %cond.false68 ], [ %phitmp, %cond.false82 ], [ 1, %cond.false75 ]
  call void @Perl_push_scope() #2
  call void @Perl_save_int(i32* bitcast (i64* @PL_tmps_floor to i32*)) #2
  %41 = load i64* @PL_tmps_ix, align 8, !tbaa !20
  store i64 %41, i64* @PL_tmps_floor, align 8, !tbaa !20
  %call90 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @push_return to i32 (%struct.op*, ...)*)(%struct.op* null) #2
  %42 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  %si_cxix = getelementptr inbounds %struct.stackinfo* %42, i64 0, i32 2
  %43 = load i64* %si_cxix, align 8, !tbaa !46
  %si_cxmax = getelementptr inbounds %struct.stackinfo* %42, i64 0, i32 3
  %44 = load i64* %si_cxmax, align 8, !tbaa !94
  %cmp91 = icmp slt i64 %43, %44
  br i1 %cmp91, label %cond.true93, label %cond.false95

cond.true93:                                      ; preds = %cond.end88
  %inc = add nsw i64 %43, 1
  store i64 %inc, i64* %si_cxix, align 8, !tbaa !46
  br label %cond.end99

cond.false95:                                     ; preds = %cond.end88
  %call96 = call i32 (...)* @cxinc() #2
  %conv97 = sext i32 %call96 to i64
  %45 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  %si_cxix98 = getelementptr inbounds %struct.stackinfo* %45, i64 0, i32 2
  store i64 %conv97, i64* %si_cxix98, align 8, !tbaa !46
  br label %cond.end99

cond.end99:                                       ; preds = %cond.false95, %cond.true93
  %46 = phi i64 [ %conv97, %cond.false95 ], [ %inc, %cond.true93 ]
  %47 = phi %struct.stackinfo* [ %45, %cond.false95 ], [ %42, %cond.true93 ]
  %si_cxstack = getelementptr inbounds %struct.stackinfo* %47, i64 0, i32 1
  %48 = load %struct.context** %si_cxstack, align 8, !tbaa !95
  %cx_type = getelementptr inbounds %struct.context* %48, i64 %46, i32 0
  store i64 514, i64* %cx_type, align 8, !tbaa !96
  %49 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %50 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %sub.ptr.lhs.cast102 = ptrtoint %struct.sv** %49 to i64
  %sub.ptr.rhs.cast103 = ptrtoint %struct.sv** %50 to i64
  %sub.ptr.sub104 = sub i64 %sub.ptr.lhs.cast102, %sub.ptr.rhs.cast103
  %sub.ptr.div105 = ashr exact i64 %sub.ptr.sub104, 3
  %blku_oldsp = getelementptr inbounds %struct.context* %48, i64 %46, i32 1, i32 0, i32 0
  store i64 %sub.ptr.div105, i64* %blku_oldsp, align 8, !tbaa !98
  %51 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %blku_oldcop = getelementptr inbounds %struct.context* %48, i64 %46, i32 1, i32 0, i32 1
  store %struct.cop* %51, %struct.cop** %blku_oldcop, align 8, !tbaa !100
  %52 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %53 = load i64** @PL_markstack, align 8, !tbaa !1
  %sub.ptr.lhs.cast108 = ptrtoint i64* %52 to i64
  %sub.ptr.rhs.cast109 = ptrtoint i64* %53 to i64
  %sub.ptr.sub110 = sub i64 %sub.ptr.lhs.cast108, %sub.ptr.rhs.cast109
  %sub.ptr.div111 = ashr exact i64 %sub.ptr.sub110, 3
  %blku_oldmarksp = getelementptr inbounds %struct.context* %48, i64 %46, i32 1, i32 0, i32 3
  store i64 %sub.ptr.div111, i64* %blku_oldmarksp, align 8, !tbaa !101
  %54 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  %blku_oldscopesp = getelementptr inbounds %struct.context* %48, i64 %46, i32 1, i32 0, i32 4
  store i64 %54, i64* %blku_oldscopesp, align 8, !tbaa !102
  %55 = load i64* @PL_retstack_ix, align 8, !tbaa !20
  %blku_oldretsp = getelementptr inbounds %struct.context* %48, i64 %46, i32 1, i32 0, i32 2
  store i64 %55, i64* %blku_oldretsp, align 8, !tbaa !103
  %56 = load %struct.pmop** @PL_curpm, align 8, !tbaa !1
  %blku_oldpm = getelementptr inbounds %struct.context* %48, i64 %46, i32 1, i32 0, i32 5
  store %struct.pmop* %56, %struct.pmop** %blku_oldpm, align 8, !tbaa !104
  %blku_gimme = getelementptr inbounds %struct.context* %48, i64 %46, i32 1, i32 0, i32 6
  store i8 %cond89, i8* %blku_gimme, align 1, !tbaa !105
  %57 = load volatile i32* @PL_in_eval, align 4, !tbaa !5
  %conv123 = sext i32 %57 to i64
  %58 = getelementptr inbounds %struct.context* %48, i64 %46, i32 1, i32 0, i32 7, i32 0, i32 0
  %conv123.c = inttoptr i64 %conv123 to i8*
  store i8* %conv123.c, i8** %58, align 8, !tbaa !106
  %59 = load %struct.op** @PL_op, align 8, !tbaa !1
  %op_type = getelementptr inbounds %struct.op* %59, i64 0, i32 4
  %60 = load i16* %op_type, align 2, !tbaa !108
  %conv126 = zext i16 %60 to i64
  %61 = getelementptr inbounds %struct.context* %48, i64 %46, i32 1, i32 0, i32 7, i32 0, i32 1
  store i64 %conv126, i64* %61, align 8, !tbaa !109
  %old_namesv = getelementptr inbounds %struct.context* %48, i64 %46, i32 1, i32 0, i32 7, i32 0, i32 2
  store %struct.op* null, %struct.op** %old_namesv, align 8, !tbaa !110
  %62 = load %struct.op** @PL_eval_root, align 8, !tbaa !1
  %63 = getelementptr inbounds %struct.context* %48, i64 %46, i32 1, i32 0, i32 7, i32 0, i32 3
  store %struct.op* %62, %struct.op** %63, align 8, !tbaa !111
  %64 = load %struct.sv** @PL_linestr, align 8, !tbaa !1
  %cur_text = getelementptr inbounds %struct.context* %48, i64 %46, i32 1, i32 0, i32 7, i32 0, i32 4
  %.c = bitcast %struct.sv* %64 to %struct.op*
  store %struct.op* %.c, %struct.op** %cur_text, align 8, !tbaa !112
  %cv = getelementptr inbounds %struct.context* %48, i64 %46, i32 1, i32 0, i32 7, i32 0, i32 5
  store %struct.sv** null, %struct.sv*** %cv, align 8, !tbaa !113
  %65 = load %struct.op** @PL_op, align 8, !tbaa !1
  store %struct.op* %65, %struct.op** @PL_eval_root, align 8, !tbaa !1
  store volatile i32 1, i32* @PL_in_eval, align 4, !tbaa !5
  %and147 = and i64 %flags, 16
  %tobool148 = icmp ne i64 %and147, 0
  br i1 %tobool148, label %if.then149, label %if.else151

if.then149:                                       ; preds = %cond.end99
  %66 = load volatile i32* @PL_in_eval, align 4, !tbaa !5
  %or150 = or i32 %66, 4
  store volatile i32 %or150, i32* @PL_in_eval, align 4, !tbaa !5
  br label %if.end154

if.else151:                                       ; preds = %cond.end99
  %67 = load %struct.gv** @PL_errgv, align 8, !tbaa !1
  %sv_any152 = getelementptr inbounds %struct.gv* %67, i64 0, i32 0
  %68 = load %struct.xpvgv** %sv_any152, align 8, !tbaa !65
  %xgv_gp153 = getelementptr inbounds %struct.xpvgv* %68, i64 0, i32 7
  %69 = load %struct.gp** %xgv_gp153, align 8, !tbaa !67
  %gp_sv = getelementptr inbounds %struct.gp* %69, i64 0, i32 0
  %70 = load %struct.sv** %gp_sv, align 8, !tbaa !69
  call void @Perl_sv_setpv(%struct.sv* %70, i8* getelementptr inbounds ([1 x i8]* @.str1, i64 0, i64 0)) #2
  br label %if.end154

if.end154:                                        ; preds = %if.else151, %if.then149
  %71 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr155 = getelementptr inbounds i64* %71, i64 1
  store i64* %incdec.ptr155, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %72 = load %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %je_prev = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 1
  store %struct.jmpenv* %72, %struct.jmpenv** %je_prev, align 8, !tbaa !33
  %arraydecay = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 0, i64 0
  %call156 = call i32 @sigsetjmp(%struct.__jmp_buf_tag* %arraydecay, i32 0) #8
  %je_ret = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 2
  store i32 %call156, i32* %je_ret, align 8, !tbaa !21
  store %struct.jmpenv* %cur_env, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %je_mustcatch157 = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 3
  store i8 0, i8* %je_mustcatch157, align 4, !tbaa !23
  switch i32 %call156, label %sw.epilog [
    i32 0, label %redo_body
    i32 1, label %sw.bb173
    i32 2, label %sw.bb174
    i32 3, label %sw.bb189
  ]

redo_body:                                        ; preds = %if.end154, %if.then191
  %call160 = call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @call_body to i32 (%struct.op*, i32, ...)*)(%struct.op* %11, i32 0) #2
  %73 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %74 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr161 = getelementptr inbounds %struct.sv** %74, i64 %16
  %sub.ptr.lhs.cast162 = ptrtoint %struct.sv** %73 to i64
  %sub.ptr.rhs.cast163 = ptrtoint %struct.sv** %add.ptr161 to i64
  %sub.ptr.sub164 = sub i64 %sub.ptr.lhs.cast162, %sub.ptr.rhs.cast163
  %sub.ptr.div165 = ashr exact i64 %sub.ptr.sub164, 3
  store volatile i64 %sub.ptr.div165, i64* %retval1, align 8
  br i1 %tobool148, label %sw.epilog, label %if.then168

if.then168:                                       ; preds = %redo_body
  %75 = load %struct.gv** @PL_errgv, align 8, !tbaa !1
  %sv_any169 = getelementptr inbounds %struct.gv* %75, i64 0, i32 0
  %76 = load %struct.xpvgv** %sv_any169, align 8, !tbaa !65
  %xgv_gp170 = getelementptr inbounds %struct.xpvgv* %76, i64 0, i32 7
  %77 = load %struct.gp** %xgv_gp170, align 8, !tbaa !67
  %gp_sv171 = getelementptr inbounds %struct.gp* %77, i64 0, i32 0
  %78 = load %struct.sv** %gp_sv171, align 8, !tbaa !69
  call void @Perl_sv_setpv(%struct.sv* %78, i8* getelementptr inbounds ([1 x i8]* @.str1, i64 0, i64 0)) #2
  br label %sw.epilog

sw.bb173:                                         ; preds = %if.end154
  store i64 1, i64* @PL_statusvalue, align 8, !tbaa !20
  br label %sw.bb174

sw.bb174:                                         ; preds = %if.end154, %sw.bb173
  %79 = load %struct.hv** @PL_defstash, align 8, !tbaa !1
  store %struct.hv* %79, %struct.hv** @PL_curstash, align 8, !tbaa !1
  %80 = load i64* @PL_tmps_ix, align 8, !tbaa !20
  %81 = load i64* @PL_tmps_floor, align 8, !tbaa !20
  %cmp175 = icmp sgt i64 %80, %81
  br i1 %cmp175, label %if.then177, label %if.end178

if.then177:                                       ; preds = %sw.bb174
  call void @Perl_free_tmps() #2
  br label %if.end178

if.end178:                                        ; preds = %if.then177, %sw.bb174
  %82 = load %struct.jmpenv** %je_prev, align 8, !tbaa !33
  store %struct.jmpenv* %82, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %83 = load i64* @PL_statusvalue, align 8, !tbaa !20
  %tobool181 = icmp eq i64 %83, 0
  br i1 %tobool181, label %if.end187, label %land.lhs.true182

land.lhs.true182:                                 ; preds = %if.end178
  %84 = load i8* @PL_exit_flags, align 1, !tbaa !27
  %and184 = and i8 %84, 1
  %tobool185 = icmp eq i8 %and184, 0
  br i1 %tobool185, label %if.then186, label %if.end187

if.then186:                                       ; preds = %land.lhs.true182
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([21 x i8]* @.str12, i64 0, i64 0)) #2
  br label %if.end187

if.end187:                                        ; preds = %land.lhs.true182, %if.end178, %if.then186
  %call188 = call i32 (...)* @my_exit_jump() #2
  br label %sw.bb189

sw.bb189:                                         ; preds = %if.end154, %if.end187
  %85 = load %struct.op** @PL_restartop, align 8, !tbaa !1
  %tobool190 = icmp eq %struct.op* %85, null
  br i1 %tobool190, label %if.end192, label %if.then191

if.then191:                                       ; preds = %sw.bb189
  store %struct.op* %85, %struct.op** @PL_op, align 8, !tbaa !1
  store %struct.op* null, %struct.op** @PL_restartop, align 8, !tbaa !1
  br label %redo_body

if.end192:                                        ; preds = %sw.bb189
  %86 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr193 = getelementptr inbounds %struct.sv** %86, i64 %16
  store %struct.sv** %add.ptr193, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %and194 = and i64 %flags, 1
  %tobool195 = icmp eq i64 %and194, 0
  br i1 %tobool195, label %if.else197, label %if.then196

if.then196:                                       ; preds = %if.end192
  store volatile i64 0, i64* %retval1, align 8
  br label %sw.epilog

if.else197:                                       ; preds = %if.end192
  store volatile i64 1, i64* %retval1, align 8
  %87 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %incdec.ptr198 = getelementptr inbounds %struct.sv** %87, i64 1
  store %struct.sv** %incdec.ptr198, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr198, align 8, !tbaa !1
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then196, %if.else197, %redo_body, %if.then168, %if.end154
  %88 = load i64* @PL_scopestack_ix, align 8, !tbaa !20
  %cmp200 = icmp sgt i64 %88, %17
  br i1 %cmp200, label %if.then202, label %if.end268

if.then202:                                       ; preds = %sw.epilog
  %89 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  %si_cxix210 = getelementptr inbounds %struct.stackinfo* %89, i64 0, i32 2
  %90 = load i64* %si_cxix210, align 8, !tbaa !46
  %dec = add nsw i64 %90, -1
  store i64 %dec, i64* %si_cxix210, align 8, !tbaa !46
  %si_cxstack211 = getelementptr inbounds %struct.stackinfo* %89, i64 0, i32 1
  %91 = load %struct.context** %si_cxstack211, align 8, !tbaa !95
  %blku_oldcop219 = getelementptr inbounds %struct.context* %91, i64 %90, i32 1, i32 0, i32 1
  %92 = load %struct.cop** %blku_oldcop219, align 8, !tbaa !100
  store volatile %struct.cop* %92, %struct.cop** @PL_curcop, align 8, !tbaa !1
  %93 = load i64** @PL_markstack, align 8, !tbaa !1
  %blku_oldmarksp222 = getelementptr inbounds %struct.context* %91, i64 %90, i32 1, i32 0, i32 3
  %94 = load i64* %blku_oldmarksp222, align 8, !tbaa !101
  %add.ptr223 = getelementptr inbounds i64* %93, i64 %94
  store i64* %add.ptr223, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %blku_oldscopesp226 = getelementptr inbounds %struct.context* %91, i64 %90, i32 1, i32 0, i32 4
  %95 = load i64* %blku_oldscopesp226, align 8, !tbaa !102
  store i64 %95, i64* @PL_scopestack_ix, align 8, !tbaa !20
  %blku_oldretsp229 = getelementptr inbounds %struct.context* %91, i64 %90, i32 1, i32 0, i32 2
  %96 = load i64* %blku_oldretsp229, align 8, !tbaa !103
  store i64 %96, i64* @PL_retstack_ix, align 8, !tbaa !20
  %blku_oldpm232 = getelementptr inbounds %struct.context* %91, i64 %90, i32 1, i32 0, i32 5
  %97 = load %struct.pmop** %blku_oldpm232, align 8, !tbaa !104
  %blk_u239 = getelementptr inbounds %struct.context* %91, i64 %90, i32 1, i32 0, i32 7
  %old_in_eval241 = bitcast %union.anon.1* %blk_u239 to i64*
  %98 = load i64* %old_in_eval241, align 8, !tbaa !106
  %conv242 = trunc i64 %98 to i32
  store volatile i32 %conv242, i32* @PL_in_eval, align 4, !tbaa !5
  %99 = getelementptr inbounds %struct.context* %91, i64 %90, i32 1, i32 0, i32 7, i32 0, i32 3
  %100 = load %struct.op** %99, align 8, !tbaa !111
  store %struct.op* %100, %struct.op** @PL_eval_root, align 8, !tbaa !1
  %old_namesv257 = getelementptr inbounds %struct.context* %91, i64 %90, i32 1, i32 0, i32 7, i32 0, i32 2
  %101 = load %struct.op** %old_namesv257, align 8
  %tobool258 = icmp eq %struct.op* %101, null
  br i1 %tobool258, label %if.end266, label %if.then259

if.then259:                                       ; preds = %if.then202
  %102 = bitcast %struct.op* %101 to %struct.sv*
  %call265 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %102) #2
  br label %if.end266

if.end266:                                        ; preds = %if.then202, %if.then259
  %call267 = call i32 (...)* @pop_return() #2
  store %struct.pmop* %97, %struct.pmop** @PL_curpm, align 8, !tbaa !1
  call void @Perl_pop_scope() #2
  br label %if.end268

if.end268:                                        ; preds = %if.end266, %sw.epilog
  %103 = load %struct.jmpenv** %je_prev, align 8, !tbaa !33
  store %struct.jmpenv* %103, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  br label %if.end271

if.end271:                                        ; preds = %if.end268, %if.then53
  br i1 %tobool, label %if.then274, label %if.end280

if.then274:                                       ; preds = %if.end271
  %104 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr275 = getelementptr inbounds %struct.sv** %104, i64 %16
  store %struct.sv** %add.ptr275, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  store volatile i64 0, i64* %retval1, align 8
  %105 = load i64* @PL_tmps_ix, align 8, !tbaa !20
  %106 = load i64* @PL_tmps_floor, align 8, !tbaa !20
  %cmp276 = icmp sgt i64 %105, %106
  br i1 %cmp276, label %if.then278, label %if.end279

if.then278:                                       ; preds = %if.then274
  call void @Perl_free_tmps() #2
  br label %if.end279

if.end279:                                        ; preds = %if.then278, %if.then274
  call void @Perl_pop_scope() #2
  br label %if.end280

if.end280:                                        ; preds = %if.end279, %if.end271
  store %struct.op* %5, %struct.op** @PL_op, align 8, !tbaa !1
  %retval1.0.retval1.0. = load volatile i64* %retval1, align 8
  call void @llvm.lifetime.end(i64 216, i8* %6) #2
  call void @llvm.lifetime.end(i64 48, i8* %2) #2
  call void @llvm.lifetime.end(i64 56, i8* %1) #2
  ret i64 %retval1.0.retval1.0.
}

; Function Attrs: nounwind uwtable
define i64 @Perl_call_method(i8* %methname, i64 %flags) #0 {
entry:
  %call = tail call %struct.sv* @Perl_newSVpv(i8* %methname, i64 0) #2
  %call1 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call) #2
  %or = or i64 %flags, 64
  %call2 = tail call i64 @Perl_call_sv(%struct.sv* %call1, i64 %or)
  ret i64 %call2
}

declare void @Perl_save_int(i32*) #3

declare i32 @save_op(...) #3

declare i32 @call_body(...) #3

declare i64 @Perl_block_gimme() #3

declare i32 @push_return(...) #3

declare i32 @cxinc(...) #3

declare void @Perl_croak(i8*, ...) #3

declare i32 @my_exit_jump(...) #3

declare i32 @pop_return(...) #3

; Function Attrs: nounwind uwtable
define i64 @Perl_eval_sv(%struct.sv* %sv, i64 %flags) #0 {
entry:
  %myop = alloca %struct.unop, align 8
  %oldmark = alloca i64, align 8
  %retval1 = alloca i64, align 8
  %cur_env = alloca %struct.jmpenv, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = bitcast %struct.unop* %myop to i8*
  call void @llvm.lifetime.start(i64 48, i8* %1) #2
  %2 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  store volatile i64 %sub.ptr.div, i64* %oldmark, align 8
  store volatile i64 0, i64* %retval1, align 8
  %3 = load %struct.op** @PL_op, align 8, !tbaa !1
  %4 = bitcast %struct.jmpenv* %cur_env to i8*
  call void @llvm.lifetime.start(i64 216, i8* %4) #2
  %and = and i64 %flags, 2
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @Perl_push_scope() #2
  call void @Perl_save_int(i32* bitcast (i64* @PL_tmps_floor to i32*)) #2
  %5 = load i64* @PL_tmps_ix, align 8, !tbaa !20
  store i64 %5, i64* @PL_tmps_floor, align 8, !tbaa !20
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call = call i32 (...)* @save_op() #2
  %6 = bitcast %struct.unop* %myop to %struct.op*
  store %struct.op* %6, %struct.op** @PL_op, align 8, !tbaa !1
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 48, i32 8, i1 false)
  %7 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !1
  %8 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %sub.ptr.lhs.cast2 = ptrtoint %struct.sv** %7 to i64
  %sub.ptr.rhs.cast3 = ptrtoint %struct.sv** %8 to i64
  %sub.ptr.sub4 = sub i64 %sub.ptr.lhs.cast2, %sub.ptr.rhs.cast3
  %cmp = icmp slt i64 %sub.ptr.sub4, 8
  br i1 %cmp, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %call7 = call %struct.sv** @Perl_stack_grow(%struct.sv** %0, %struct.sv** %8, i32 1) #2
  %.pre = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %9 = phi %struct.sv** [ %.pre, %if.then6 ], [ %8, %if.end ]
  %incdec.ptr = getelementptr inbounds %struct.sv** %9, i64 1
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  store %struct.sv* %sv, %struct.sv** %incdec.ptr, align 8, !tbaa !1
  %and9 = and i64 %flags, 8
  %tobool10 = icmp eq i64 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  %op_flags = getelementptr inbounds %struct.unop* %myop, i64 0, i32 6
  store i8 64, i8* %op_flags, align 4, !tbaa !114
  br label %if.end12

if.end12:                                         ; preds = %if.end8, %if.then11
  %op_next = getelementptr inbounds %struct.unop* %myop, i64 0, i32 0
  store %struct.op* null, %struct.op** %op_next, align 8, !tbaa !88
  %op_type = getelementptr inbounds %struct.unop* %myop, i64 0, i32 4
  store i16 311, i16* %op_type, align 8, !tbaa !115
  %and13 = and i64 %flags, 128
  %tobool14 = icmp eq i64 %and13, 0
  br i1 %tobool14, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.end12
  %flags.tr = trunc i64 %flags to i8
  %10 = and i8 %flags.tr, 1
  %11 = or i8 %10, 2
  br label %cond.end

cond.end:                                         ; preds = %if.end12, %cond.false
  %cond17 = phi i8 [ %11, %cond.false ], [ 1, %if.end12 ]
  %op_flags18 = getelementptr inbounds %struct.unop* %myop, i64 0, i32 6
  %12 = load i8* %op_flags18, align 4, !tbaa !114
  %and20 = and i64 %flags, 16
  %tobool21 = icmp eq i64 %and20, 0
  %13 = trunc i64 %and20 to i8
  %14 = shl nuw i8 %13, 3
  %or = or i8 %cond17, %14
  %15 = or i8 %or, %12
  store i8 %15, i8* %op_flags18, align 4, !tbaa !114
  %16 = load i8* @PL_tainting, align 1, !tbaa !27
  %tobool28 = icmp eq i8 %16, 0
  br i1 %tobool28, label %if.end30, label %if.then29

if.then29:                                        ; preds = %cond.end
  call void @Perl_taint_proper(i8* null, i8* getelementptr inbounds ([10 x i8]* @.str13, i64 0, i64 0)) #2
  br label %if.end30

if.end30:                                         ; preds = %cond.end, %if.then29
  %17 = load %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %je_prev = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 1
  store %struct.jmpenv* %17, %struct.jmpenv** %je_prev, align 8, !tbaa !33
  %arraydecay = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 0, i64 0
  %call31 = call i32 @sigsetjmp(%struct.__jmp_buf_tag* %arraydecay, i32 0) #8
  %je_ret = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 2
  store i32 %call31, i32* %je_ret, align 8, !tbaa !21
  store %struct.jmpenv* %cur_env, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %je_mustcatch = getelementptr inbounds %struct.jmpenv* %cur_env, i64 0, i32 3
  store i8 0, i8* %je_mustcatch, align 4, !tbaa !23
  switch i32 %call31, label %sw.epilog [
    i32 0, label %redo_body
    i32 1, label %sw.bb42
    i32 2, label %sw.bb43
    i32 3, label %sw.bb57
  ]

redo_body:                                        ; preds = %if.end30, %if.then59
  %call33 = call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @call_body to i32 (%struct.op*, i32, ...)*)(%struct.op* %6, i32 1) #2
  %18 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %19 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %oldmark.0.oldmark.0. = load volatile i64* %oldmark, align 8
  %add.ptr = getelementptr inbounds %struct.sv** %19, i64 %oldmark.0.oldmark.0.
  %sub.ptr.lhs.cast34 = ptrtoint %struct.sv** %18 to i64
  %sub.ptr.rhs.cast35 = ptrtoint %struct.sv** %add.ptr to i64
  %sub.ptr.sub36 = sub i64 %sub.ptr.lhs.cast34, %sub.ptr.rhs.cast35
  %sub.ptr.div37 = ashr exact i64 %sub.ptr.sub36, 3
  store volatile i64 %sub.ptr.div37, i64* %retval1, align 8
  br i1 %tobool21, label %if.then40, label %sw.epilog

if.then40:                                        ; preds = %redo_body
  %20 = load %struct.gv** @PL_errgv, align 8, !tbaa !1
  %sv_any = getelementptr inbounds %struct.gv* %20, i64 0, i32 0
  %21 = load %struct.xpvgv** %sv_any, align 8, !tbaa !65
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %21, i64 0, i32 7
  %22 = load %struct.gp** %xgv_gp, align 8, !tbaa !67
  %gp_sv = getelementptr inbounds %struct.gp* %22, i64 0, i32 0
  %23 = load %struct.sv** %gp_sv, align 8, !tbaa !69
  call void @Perl_sv_setpv(%struct.sv* %23, i8* getelementptr inbounds ([1 x i8]* @.str1, i64 0, i64 0)) #2
  br label %sw.epilog

sw.bb42:                                          ; preds = %if.end30
  store i64 1, i64* @PL_statusvalue, align 8, !tbaa !20
  br label %sw.bb43

sw.bb43:                                          ; preds = %if.end30, %sw.bb42
  %24 = load %struct.hv** @PL_defstash, align 8, !tbaa !1
  store %struct.hv* %24, %struct.hv** @PL_curstash, align 8, !tbaa !1
  %25 = load i64* @PL_tmps_ix, align 8, !tbaa !20
  %26 = load i64* @PL_tmps_floor, align 8, !tbaa !20
  %cmp44 = icmp sgt i64 %25, %26
  br i1 %cmp44, label %if.then46, label %if.end47

if.then46:                                        ; preds = %sw.bb43
  call void @Perl_free_tmps() #2
  br label %if.end47

if.end47:                                         ; preds = %if.then46, %sw.bb43
  %27 = load %struct.jmpenv** %je_prev, align 8, !tbaa !33
  store %struct.jmpenv* %27, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  %28 = load i64* @PL_statusvalue, align 8, !tbaa !20
  %tobool50 = icmp eq i64 %28, 0
  br i1 %tobool50, label %if.end55, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end47
  %29 = load i8* @PL_exit_flags, align 1, !tbaa !27
  %and52 = and i8 %29, 1
  %tobool53 = icmp eq i8 %and52, 0
  br i1 %tobool53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %land.lhs.true
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([21 x i8]* @.str12, i64 0, i64 0)) #2
  br label %if.end55

if.end55:                                         ; preds = %land.lhs.true, %if.end47, %if.then54
  %call56 = call i32 (...)* @my_exit_jump() #2
  br label %sw.bb57

sw.bb57:                                          ; preds = %if.end30, %if.end55
  %30 = load %struct.op** @PL_restartop, align 8, !tbaa !1
  %tobool58 = icmp eq %struct.op* %30, null
  br i1 %tobool58, label %if.end60, label %if.then59

if.then59:                                        ; preds = %sw.bb57
  store %struct.op* %30, %struct.op** @PL_op, align 8, !tbaa !1
  store %struct.op* null, %struct.op** @PL_restartop, align 8, !tbaa !1
  br label %redo_body

if.end60:                                         ; preds = %sw.bb57
  %31 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %oldmark.0.oldmark.0.78 = load volatile i64* %oldmark, align 8
  %add.ptr61 = getelementptr inbounds %struct.sv** %31, i64 %oldmark.0.oldmark.0.78
  store %struct.sv** %add.ptr61, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %and62 = and i64 %flags, 1
  %tobool63 = icmp eq i64 %and62, 0
  br i1 %tobool63, label %if.else, label %if.then64

if.then64:                                        ; preds = %if.end60
  store volatile i64 0, i64* %retval1, align 8
  br label %sw.epilog

if.else:                                          ; preds = %if.end60
  store volatile i64 1, i64* %retval1, align 8
  %32 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %incdec.ptr65 = getelementptr inbounds %struct.sv** %32, i64 1
  store %struct.sv** %incdec.ptr65, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr65, align 8, !tbaa !1
  br label %sw.epilog

sw.epilog:                                        ; preds = %redo_body, %if.then64, %if.else, %if.then40, %if.end30
  %33 = load %struct.jmpenv** %je_prev, align 8, !tbaa !33
  store %struct.jmpenv* %33, %struct.jmpenv** @PL_top_env, align 8, !tbaa !1
  br i1 %tobool, label %if.then71, label %if.end77

if.then71:                                        ; preds = %sw.epilog
  %34 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %oldmark.0.oldmark.0.79 = load volatile i64* %oldmark, align 8
  %add.ptr72 = getelementptr inbounds %struct.sv** %34, i64 %oldmark.0.oldmark.0.79
  store %struct.sv** %add.ptr72, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  store volatile i64 0, i64* %retval1, align 8
  %35 = load i64* @PL_tmps_ix, align 8, !tbaa !20
  %36 = load i64* @PL_tmps_floor, align 8, !tbaa !20
  %cmp73 = icmp sgt i64 %35, %36
  br i1 %cmp73, label %if.then75, label %if.end76

if.then75:                                        ; preds = %if.then71
  call void @Perl_free_tmps() #2
  br label %if.end76

if.end76:                                         ; preds = %if.then75, %if.then71
  call void @Perl_pop_scope() #2
  br label %if.end77

if.end77:                                         ; preds = %if.end76, %sw.epilog
  store %struct.op* %3, %struct.op** @PL_op, align 8, !tbaa !1
  %retval1.0.retval1.0. = load volatile i64* %retval1, align 8
  call void @llvm.lifetime.end(i64 216, i8* %4) #2
  call void @llvm.lifetime.end(i64 48, i8* %1) #2
  ret i64 %retval1.0.retval1.0.
}

declare void @Perl_taint_proper(i8*, i8*) #3

; Function Attrs: nounwind uwtable
define %struct.sv* @Perl_eval_pv(i8* %p, i64 %croak_on_error) #0 {
entry:
  %n_a = alloca i64, align 8
  %call = call %struct.sv* @Perl_newSVpv(i8* %p, i64 0) #2
  %call1 = call i64 @Perl_eval_sv(%struct.sv* %call, i64 0)
  call void @Perl_sv_free(%struct.sv* %call) #2
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %1 = load %struct.sv** %0, align 8, !tbaa !1
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %tobool = icmp eq i64 %croak_on_error, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.gv** @PL_errgv, align 8, !tbaa !1
  %sv_any = getelementptr inbounds %struct.gv* %2, i64 0, i32 0
  %3 = load %struct.xpvgv** %sv_any, align 8, !tbaa !65
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %3, i64 0, i32 7
  %4 = load %struct.gp** %xgv_gp, align 8, !tbaa !67
  %gp_sv = getelementptr inbounds %struct.gp* %4, i64 0, i32 0
  %5 = load %struct.sv** %gp_sv, align 8, !tbaa !69
  %tobool2 = icmp eq %struct.sv* %5, null
  br i1 %tobool2, label %if.end, label %cond.false

cond.false:                                       ; preds = %land.lhs.true
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i64* %sv_flags, align 8, !tbaa !7
  %and = and i64 %6, 262144
  %tobool6 = icmp eq i64 %and, 0
  br i1 %tobool6, label %cond.false21, label %cond.true7

cond.true7:                                       ; preds = %cond.false
  %sv_any11 = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %7 = load i8** %sv_any11, align 8, !tbaa !24
  %8 = bitcast i8* %7 to %struct.xpv*
  store %struct.xpv* %8, %struct.xpv** @PL_Xpv, align 8, !tbaa !1
  %tobool12 = icmp eq i8* %7, null
  br i1 %tobool12, label %if.end, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %cond.true7
  %xpv_cur = getelementptr inbounds i8* %7, i64 8
  %9 = bitcast i8* %xpv_cur to i64*
  %10 = load i64* %9, align 8, !tbaa !28
  %cmp = icmp ugt i64 %10, 1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true13
  %tobool15 = icmp eq i64 %10, 0
  br i1 %tobool15, label %if.end, label %land.lhs.true16

land.lhs.true16:                                  ; preds = %lor.lhs.false
  %xpv_pv = bitcast i8* %7 to i8**
  %11 = load i8** %xpv_pv, align 8, !tbaa !25
  %12 = load i8* %11, align 1, !tbaa !27
  %cmp17 = icmp eq i8 %12, 48
  br i1 %cmp17, label %if.end, label %if.then

cond.false21:                                     ; preds = %cond.false
  %and26 = and i64 %6, 65536
  %tobool27 = icmp eq i64 %and26, 0
  br i1 %tobool27, label %cond.false35, label %cond.true28

cond.true28:                                      ; preds = %cond.false21
  %sv_any32 = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %13 = load i8** %sv_any32, align 8, !tbaa !24
  %xiv_iv = getelementptr inbounds i8* %13, i64 24
  %14 = bitcast i8* %xiv_iv to i64*
  %15 = load i64* %14, align 8, !tbaa !116
  %cmp33 = icmp eq i64 %15, 0
  br i1 %cmp33, label %if.end, label %if.then

cond.false35:                                     ; preds = %cond.false21
  %and40 = and i64 %6, 131072
  %tobool41 = icmp eq i64 %and40, 0
  br i1 %tobool41, label %cond.false49, label %cond.true42

cond.true42:                                      ; preds = %cond.false35
  %sv_any46 = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %16 = load i8** %sv_any46, align 8, !tbaa !24
  %xnv_nv = getelementptr inbounds i8* %16, i64 32
  %17 = bitcast i8* %xnv_nv to double*
  %18 = load double* %17, align 8, !tbaa !29
  %cmp47 = fcmp une double %18, 0.000000e+00
  br i1 %cmp47, label %if.then, label %if.end

cond.false49:                                     ; preds = %cond.false35
  %call53 = call signext i8 @Perl_sv_2bool(%struct.sv* %5) #2
  %tobool55 = icmp eq i8 %call53, 0
  br i1 %tobool55, label %if.end, label %cond.false49.if.then_crit_edge

cond.false49.if.then_crit_edge:                   ; preds = %cond.false49
  %.pre = load %struct.gv** @PL_errgv, align 8, !tbaa !1
  br label %if.then

if.then:                                          ; preds = %cond.false49.if.then_crit_edge, %land.lhs.true16, %cond.true28, %land.lhs.true13, %cond.true42
  %19 = phi %struct.gv* [ %.pre, %cond.false49.if.then_crit_edge ], [ %2, %land.lhs.true16 ], [ %2, %cond.true28 ], [ %2, %land.lhs.true13 ], [ %2, %cond.true42 ]
  %sv_any56 = getelementptr inbounds %struct.gv* %19, i64 0, i32 0
  %20 = load %struct.xpvgv** %sv_any56, align 8, !tbaa !65
  %xgv_gp57 = getelementptr inbounds %struct.xpvgv* %20, i64 0, i32 7
  %21 = load %struct.gp** %xgv_gp57, align 8, !tbaa !67
  %gp_sv58 = getelementptr inbounds %struct.gp* %21, i64 0, i32 0
  %22 = load %struct.sv** %gp_sv58, align 8, !tbaa !69
  store %struct.sv* %22, %struct.sv** @PL_Sv, align 8, !tbaa !1
  %sv_flags59 = getelementptr inbounds %struct.sv* %22, i64 0, i32 2
  %23 = load i64* %sv_flags59, align 8, !tbaa !7
  %and60 = and i64 %23, 262144
  %cmp61 = icmp eq i64 %and60, 0
  br i1 %cmp61, label %cond.false68, label %cond.true63

cond.true63:                                      ; preds = %if.then
  %sv_any64 = getelementptr inbounds %struct.sv* %22, i64 0, i32 0
  %24 = load i8** %sv_any64, align 8, !tbaa !24
  %xpv_cur65 = getelementptr inbounds i8* %24, i64 8
  %25 = bitcast i8* %xpv_cur65 to i64*
  %26 = load i64* %25, align 8, !tbaa !28
  store i64 %26, i64* %n_a, align 8, !tbaa !20
  %xpv_pv67 = bitcast i8* %24 to i8**
  %27 = load i8** %xpv_pv67, align 8, !tbaa !25
  br label %cond.end

cond.false68:                                     ; preds = %if.then
  %call69 = call i8* @Perl_sv_2pv_flags(%struct.sv* %22, i64* %n_a, i64 2) #2
  br label %cond.end

cond.end:                                         ; preds = %cond.false68, %cond.true63
  %cond = phi i8* [ %27, %cond.true63 ], [ %call69, %cond.false68 ]
  call void (i8*, ...)* @Perl_croak(i8* %cond) #2
  br label %if.end

if.end:                                           ; preds = %land.lhs.true16, %lor.lhs.false, %cond.true7, %cond.true28, %cond.false49, %land.lhs.true, %entry, %cond.end, %cond.true42
  ret %struct.sv* %1
}

declare signext i8 @Perl_sv_2bool(%struct.sv*) #3

declare i8* @Perl_sv_2pv_flags(%struct.sv*, i64*, i64) #3

; Function Attrs: nounwind uwtable
define void @Perl_require_pv(i8* %pv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  %si_next = getelementptr inbounds %struct.stackinfo* %1, i64 0, i32 6
  %2 = load %struct.stackinfo** %si_next, align 8, !tbaa !118
  %tobool = icmp eq %struct.stackinfo* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.stackinfo* @Perl_new_stackinfo(i64 32, i64 12) #2
  %3 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  %si_prev = getelementptr inbounds %struct.stackinfo* %call, i64 0, i32 5
  store %struct.stackinfo* %3, %struct.stackinfo** %si_prev, align 8, !tbaa !77
  %4 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  %si_next1 = getelementptr inbounds %struct.stackinfo* %4, i64 0, i32 6
  store %struct.stackinfo* %call, %struct.stackinfo** %si_next1, align 8, !tbaa !118
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %next.0 = phi %struct.stackinfo* [ %2, %entry ], [ %call, %if.then ]
  %si_type = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 4
  store i64 9, i64* %si_type, align 8, !tbaa !11
  %si_cxix = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !46
  %si_stack = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 0
  %5 = load %struct.av** %si_stack, align 8, !tbaa !13
  %sv_any = getelementptr inbounds %struct.av* %5, i64 0, i32 0
  %6 = load %struct.xpvav** %sv_any, align 8, !tbaa !14
  %xav_fill = getelementptr inbounds %struct.xpvav* %6, i64 0, i32 1
  store i64 0, i64* %xav_fill, align 8, !tbaa !64
  %7 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %7 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %8 = load %struct.av** @PL_curstack, align 8, !tbaa !1
  %sv_any2 = getelementptr inbounds %struct.av* %8, i64 0, i32 0
  %9 = load %struct.xpvav** %sv_any2, align 8, !tbaa !14
  %xav_fill3 = getelementptr inbounds %struct.xpvav* %9, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill3, align 8, !tbaa !64
  %xav_array = getelementptr inbounds %struct.xpvav* %6, i64 0, i32 0
  %10 = load i8** %xav_array, align 8, !tbaa !16
  %11 = bitcast i8* %10 to %struct.sv**
  store %struct.sv** %11, %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %12 = load %struct.av** %si_stack, align 8, !tbaa !13
  %sv_any7 = getelementptr inbounds %struct.av* %12, i64 0, i32 0
  %13 = load %struct.xpvav** %sv_any7, align 8, !tbaa !14
  %xav_max = getelementptr inbounds %struct.xpvav* %13, i64 0, i32 2
  %14 = load i64* %xav_max, align 8, !tbaa !19
  %add.ptr = getelementptr inbounds %struct.sv** %11, i64 %14
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_max, align 8, !tbaa !1
  %15 = load %struct.av** %si_stack, align 8, !tbaa !13
  %sv_any9 = getelementptr inbounds %struct.av* %15, i64 0, i32 0
  %16 = load %struct.xpvav** %sv_any9, align 8, !tbaa !14
  %xav_fill10 = getelementptr inbounds %struct.xpvav* %16, i64 0, i32 1
  %17 = load i64* %xav_fill10, align 8, !tbaa !64
  %add.ptr11 = getelementptr inbounds %struct.sv** %11, i64 %17
  store %struct.sv** %add.ptr11, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %18 = load %struct.av** %si_stack, align 8, !tbaa !13
  store %struct.av* %18, %struct.av** @PL_curstack, align 8, !tbaa !1
  store %struct.stackinfo* %next.0, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  store %struct.sv** %add.ptr11, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %call13 = tail call %struct.sv* @Perl_sv_newmortal() #2
  tail call void @Perl_sv_setpv(%struct.sv* %call13, i8* getelementptr inbounds ([10 x i8]* @.str14, i64 0, i64 0)) #2
  tail call void @Perl_sv_catpv(%struct.sv* %call13, i8* %pv) #2
  tail call void @Perl_sv_catpv(%struct.sv* %call13, i8* getelementptr inbounds ([2 x i8]* @.str15, i64 0, i64 0)) #2
  %call14 = tail call i64 @Perl_eval_sv(%struct.sv* %call13, i64 2)
  %19 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %20 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  %si_prev18 = getelementptr inbounds %struct.stackinfo* %20, i64 0, i32 5
  %21 = load %struct.stackinfo** %si_prev18, align 8, !tbaa !77
  %tobool19 = icmp eq %struct.stackinfo* %21, null
  br i1 %tobool19, label %if.then20, label %if.end38

if.then20:                                        ; preds = %if.end
  %22 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !1
  %tobool21 = icmp eq %struct.gv* %22, null
  br i1 %tobool21, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then20
  %sv_flags = getelementptr inbounds %struct.gv* %22, i64 0, i32 2
  %23 = load i64* %sv_flags, align 8, !tbaa !71
  %and = and i64 %23, 255
  %cmp = icmp eq i64 %and, 13
  br i1 %cmp, label %land.lhs.true22, label %cond.false

land.lhs.true22:                                  ; preds = %land.lhs.true
  %sv_any23 = getelementptr inbounds %struct.gv* %22, i64 0, i32 0
  %24 = load %struct.xpvgv** %sv_any23, align 8, !tbaa !65
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %24, i64 0, i32 7
  %25 = load %struct.gp** %xgv_gp, align 8, !tbaa !67
  %gp_io = getelementptr inbounds %struct.gp* %25, i64 0, i32 2
  %26 = load %struct.io** %gp_io, align 8, !tbaa !72
  %tobool24 = icmp eq %struct.io* %26, null
  br i1 %tobool24, label %cond.false, label %land.lhs.true25

land.lhs.true25:                                  ; preds = %land.lhs.true22
  %sv_any29 = getelementptr inbounds %struct.io* %26, i64 0, i32 0
  %27 = load %struct.xpvio** %sv_any29, align 8, !tbaa !73
  %xio_ofp = getelementptr inbounds %struct.xpvio* %27, i64 0, i32 8
  %28 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !75
  %tobool30 = icmp eq %struct._PerlIO** %28, null
  br i1 %tobool30, label %cond.false, label %cond.end

cond.false:                                       ; preds = %land.lhs.true25, %land.lhs.true22, %if.then20, %land.lhs.true
  %call36 = tail call %struct._PerlIO** @Perl_PerlIO_stderr() #2
  br label %cond.end

cond.end:                                         ; preds = %land.lhs.true25, %cond.false
  %cond = phi %struct._PerlIO** [ %call36, %cond.false ], [ %28, %land.lhs.true25 ]
  %call37 = tail call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond, i8* getelementptr inbounds ([17 x i8]* @.str10, i64 0, i64 0)) #2
  store i64 1, i64* @PL_statusvalue, align 8, !tbaa !20
  %call.i = tail call i32 (...)* @my_exit_jump() #2
  br label %if.end38

if.end38:                                         ; preds = %if.end, %cond.end
  %29 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %sub.ptr.lhs.cast39 = ptrtoint %struct.sv** %19 to i64
  %sub.ptr.rhs.cast40 = ptrtoint %struct.sv** %29 to i64
  %sub.ptr.sub41 = sub i64 %sub.ptr.lhs.cast39, %sub.ptr.rhs.cast40
  %sub.ptr.div42 = ashr exact i64 %sub.ptr.sub41, 3
  %30 = load %struct.av** @PL_curstack, align 8, !tbaa !1
  %sv_any43 = getelementptr inbounds %struct.av* %30, i64 0, i32 0
  %31 = load %struct.xpvav** %sv_any43, align 8, !tbaa !14
  %xav_fill44 = getelementptr inbounds %struct.xpvav* %31, i64 0, i32 1
  store i64 %sub.ptr.div42, i64* %xav_fill44, align 8, !tbaa !64
  %si_stack45 = getelementptr inbounds %struct.stackinfo* %21, i64 0, i32 0
  %32 = load %struct.av** %si_stack45, align 8, !tbaa !13
  %sv_any46 = getelementptr inbounds %struct.av* %32, i64 0, i32 0
  %33 = load %struct.xpvav** %sv_any46, align 8, !tbaa !14
  %xav_array47 = getelementptr inbounds %struct.xpvav* %33, i64 0, i32 0
  %34 = load i8** %xav_array47, align 8, !tbaa !16
  %35 = bitcast i8* %34 to %struct.sv**
  store %struct.sv** %35, %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %36 = load %struct.av** %si_stack45, align 8, !tbaa !13
  %sv_any49 = getelementptr inbounds %struct.av* %36, i64 0, i32 0
  %37 = load %struct.xpvav** %sv_any49, align 8, !tbaa !14
  %xav_max50 = getelementptr inbounds %struct.xpvav* %37, i64 0, i32 2
  %38 = load i64* %xav_max50, align 8, !tbaa !19
  %add.ptr51 = getelementptr inbounds %struct.sv** %35, i64 %38
  store %struct.sv** %add.ptr51, %struct.sv*** @PL_stack_max, align 8, !tbaa !1
  %39 = load %struct.av** %si_stack45, align 8, !tbaa !13
  %sv_any53 = getelementptr inbounds %struct.av* %39, i64 0, i32 0
  %40 = load %struct.xpvav** %sv_any53, align 8, !tbaa !14
  %xav_fill54 = getelementptr inbounds %struct.xpvav* %40, i64 0, i32 1
  %41 = load i64* %xav_fill54, align 8, !tbaa !64
  %add.ptr55 = getelementptr inbounds %struct.sv** %35, i64 %41
  store %struct.sv** %add.ptr55, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %42 = load %struct.av** %si_stack45, align 8, !tbaa !13
  store %struct.av* %42, %struct.av** @PL_curstack, align 8, !tbaa !1
  store %struct.stackinfo* %21, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !1
  ret void
}

declare %struct.stackinfo* @Perl_new_stackinfo(i64, i64) #3

declare %struct.sv* @Perl_sv_newmortal() #3

declare void @Perl_sv_catpv(%struct.sv*, i8*) #3

; Function Attrs: nounwind uwtable
define void @Perl_magicname(i8* %sym, i8* %name, i64 %namlen) #0 {
entry:
  %call = tail call %struct.gv* @Perl_gv_fetchpv(i8* %sym, i64 1, i64 4) #2
  %tobool = icmp eq %struct.gv* %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sv_any = getelementptr inbounds %struct.gv* %call, i64 0, i32 0
  %0 = load %struct.xpvgv** %sv_any, align 8, !tbaa !65
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %0, i64 0, i32 7
  %1 = load %struct.gp** %xgv_gp, align 8, !tbaa !67
  %gp_sv = getelementptr inbounds %struct.gp* %1, i64 0, i32 0
  %2 = load %struct.sv** %gp_sv, align 8, !tbaa !69
  %3 = bitcast %struct.gv* %call to %struct.sv*
  tail call void @Perl_sv_magic(%struct.sv* %2, %struct.sv* %3, i32 0, i8* %name, i64 %namlen) #2
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

declare void @Perl_sv_magic(%struct.sv*, %struct.sv*, i32, i8*, i64) #3

; Function Attrs: nounwind uwtable
define i8* @Perl_moreswitches(i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 8
  %numlen = alloca i64, align 8
  %flags = alloca i64, align 8
  %ch = alloca i8, align 1
  %flags523 = alloca i64, align 8
  store i8* %s, i8** %s.addr, align 8, !tbaa !1
  %0 = load i8* %s, align 1, !tbaa !27
  %conv = sext i8 %0 to i32
  switch i32 %conv, label %sw.default [
    i32 48, label %sw.bb
    i32 67, label %sw.bb142
    i32 70, label %sw.bb146
    i32 97, label %sw.bb169
    i32 99, label %sw.bb171
    i32 100, label %sw.bb173
    i32 68, label %sw.bb295
    i32 104, label %sw.bb350
    i32 105, label %sw.bb353
    i32 73, label %sw.bb399
    i32 108, label %sw.bb509
    i32 77, label %sw.bb549
    i32 109, label %sw.bb551
    i32 110, label %sw.bb642
    i32 112, label %sw.bb644
    i32 115, label %sw.bb646
    i32 116, label %sw.bb649
    i32 84, label %sw.bb654
    i32 117, label %sw.bb659
    i32 85, label %sw.bb661
    i32 118, label %sw.bb663
    i32 119, label %sw.bb671
    i32 87, label %sw.bb681
    i32 88, label %sw.bb693
    i32 42, label %sw.bb705
    i32 32, label %sw.bb705
    i32 45, label %return
    i32 0, label %return
    i32 13, label %return
    i32 10, label %return
    i32 9, label %return
    i32 80, label %sw.bb714
  ]

sw.bb:                                            ; preds = %entry
  store i64 0, i64* %flags, align 8, !tbaa !20
  %1 = load %struct.sv** @PL_rs, align 8, !tbaa !1
  call void @Perl_sv_free(%struct.sv* %1) #2
  %2 = load i8** %s.addr, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds i8* %2, i64 1
  %3 = load i8* %arrayidx, align 1, !tbaa !27
  %cmp = icmp eq i8 %3, 120
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %sw.bb
  %arrayidx3 = getelementptr inbounds i8* %2, i64 2
  %4 = load i8* %arrayidx3, align 1, !tbaa !27
  %tobool = icmp eq i8 %4, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i8* %arrayidx3, i8** %s.addr, align 8, !tbaa !1
  br label %for.cond

for.cond:                                         ; preds = %for.cond, %if.then
  %e.0 = phi i8* [ %arrayidx3, %if.then ], [ %incdec.ptr, %for.cond ]
  %5 = load i8* %e.0, align 1, !tbaa !27
  %tobool5 = icmp eq i8 %5, 0
  %incdec.ptr = getelementptr inbounds i8* %e.0, i64 1
  br i1 %tobool5, label %for.end, label %for.cond

for.end:                                          ; preds = %for.cond
  %sub.ptr.lhs.cast = ptrtoint i8* %e.0 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %arrayidx3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %numlen, align 8, !tbaa !20
  store i64 4, i64* %flags, align 8, !tbaa !20
  %call = call i64 @Perl_grok_hex(i8* %arrayidx3, i64* %numlen, i64* %flags, double* null) #2
  %6 = load i8** %s.addr, align 8, !tbaa !1
  %7 = load i64* %numlen, align 8, !tbaa !20
  %add.ptr6 = getelementptr inbounds i8* %6, i64 %7
  %cmp7 = icmp ult i8* %add.ptr6, %e.0
  br i1 %cmp7, label %if.then9, label %if.end

if.then9:                                         ; preds = %for.end
  store i64 0, i64* %numlen, align 8, !tbaa !20
  %incdec.ptr10 = getelementptr inbounds i8* %6, i64 -1
  store i8* %incdec.ptr10, i8** %s.addr, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %if.then9, %for.end
  %rschar.0 = phi i64 [ 0, %if.then9 ], [ %call, %for.end ]
  %call11 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([1 x i8]* @.str1, i64 0, i64 0), i64 0) #2
  store %struct.sv* %call11, %struct.sv** @PL_rs, align 8, !tbaa !1
  %sv_any = getelementptr inbounds %struct.sv* %call11, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !24
  %xpv_len = getelementptr inbounds i8* %8, i64 16
  %9 = bitcast i8* %xpv_len to i64*
  %10 = load i64* %9, align 8, !tbaa !119
  %cmp12 = icmp ult i64 %rschar.0, 128
  br i1 %cmp12, label %cond.end39, label %cond.false

cond.false:                                       ; preds = %if.end
  %cmp14 = icmp ult i64 %rschar.0, 2048
  br i1 %cmp14, label %cond.end39, label %cond.false17

cond.false17:                                     ; preds = %cond.false
  %cmp18 = icmp ult i64 %rschar.0, 65536
  br i1 %cmp18, label %cond.end39, label %cond.false21

cond.false21:                                     ; preds = %cond.false17
  %cmp22 = icmp ult i64 %rschar.0, 2097152
  br i1 %cmp22, label %cond.end39, label %cond.false25

cond.false25:                                     ; preds = %cond.false21
  %cmp26 = icmp ult i64 %rschar.0, 67108864
  br i1 %cmp26, label %cond.end39, label %cond.false29

cond.false29:                                     ; preds = %cond.false25
  %cmp30 = icmp ult i64 %rschar.0, 2147483648
  %phitmp796 = select i1 %cmp30, i64 7, i64 8
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false, %cond.false21, %cond.false25, %cond.false29, %cond.false17, %if.end
  %cond40 = phi i64 [ 2, %if.end ], [ 3, %cond.false ], [ 4, %cond.false17 ], [ 5, %cond.false21 ], [ %phitmp796, %cond.false29 ], [ 6, %cond.false25 ]
  %cmp42 = icmp ult i64 %10, %cond40
  br i1 %cmp42, label %cond.true44, label %cond.end83

cond.true44:                                      ; preds = %cond.end39
  br i1 %cmp12, label %cond.end76, label %cond.false48

cond.false48:                                     ; preds = %cond.true44
  %cmp49 = icmp ult i64 %rschar.0, 2048
  br i1 %cmp49, label %cond.end76, label %cond.false52

cond.false52:                                     ; preds = %cond.false48
  %cmp53 = icmp ult i64 %rschar.0, 65536
  br i1 %cmp53, label %cond.end76, label %cond.false56

cond.false56:                                     ; preds = %cond.false52
  %cmp57 = icmp ult i64 %rschar.0, 2097152
  br i1 %cmp57, label %cond.end76, label %cond.false60

cond.false60:                                     ; preds = %cond.false56
  %cmp61 = icmp ult i64 %rschar.0, 67108864
  br i1 %cmp61, label %cond.end76, label %cond.false64

cond.false64:                                     ; preds = %cond.false60
  %cmp65 = icmp ult i64 %rschar.0, 2147483648
  %phitmp799 = select i1 %cmp65, i64 7, i64 8
  br label %cond.end76

cond.end76:                                       ; preds = %cond.false48, %cond.false56, %cond.false60, %cond.false64, %cond.false52, %cond.true44
  %cond77 = phi i64 [ 2, %cond.true44 ], [ 3, %cond.false48 ], [ 4, %cond.false52 ], [ 5, %cond.false56 ], [ %phitmp799, %cond.false64 ], [ 6, %cond.false60 ]
  %call80 = call i8* @Perl_sv_grow(%struct.sv* %call11, i64 %cond77) #2
  %.pre = load %struct.sv** @PL_rs, align 8, !tbaa !1
  %sv_any85.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 0
  %.pre857 = load i8** %sv_any85.phi.trans.insert, align 8, !tbaa !24
  br label %cond.end83

cond.end83:                                       ; preds = %cond.end39, %cond.end76
  %11 = phi i8* [ %8, %cond.end39 ], [ %.pre857, %cond.end76 ]
  %xpv_pv86 = bitcast i8* %11 to i8**
  %12 = load i8** %xpv_pv86, align 8, !tbaa !25
  %call87 = call i8* @Perl_uvuni_to_utf8(i8* %12, i64 %rschar.0) #2
  br i1 %cmp12, label %cond.end119, label %cond.false91

cond.false91:                                     ; preds = %cond.end83
  %cmp92 = icmp ult i64 %rschar.0, 2048
  br i1 %cmp92, label %cond.end119, label %cond.false95

cond.false95:                                     ; preds = %cond.false91
  %cmp96 = icmp ult i64 %rschar.0, 65536
  br i1 %cmp96, label %cond.end119, label %cond.false99

cond.false99:                                     ; preds = %cond.false95
  %cmp100 = icmp ult i64 %rschar.0, 2097152
  br i1 %cmp100, label %cond.end119, label %cond.false103

cond.false103:                                    ; preds = %cond.false99
  %cmp104 = icmp ult i64 %rschar.0, 67108864
  br i1 %cmp104, label %cond.end119, label %cond.false107

cond.false107:                                    ; preds = %cond.false103
  %cmp108 = icmp ult i64 %rschar.0, 2147483648
  %phitmp797 = select i1 %cmp108, i64 6, i64 7
  br label %cond.end119

cond.end119:                                      ; preds = %cond.false91, %cond.false99, %cond.false103, %cond.false107, %cond.false95, %cond.end83
  %cond120 = phi i64 [ 1, %cond.end83 ], [ 2, %cond.false91 ], [ 3, %cond.false95 ], [ 4, %cond.false99 ], [ %phitmp797, %cond.false107 ], [ 5, %cond.false103 ]
  %13 = load %struct.sv** @PL_rs, align 8, !tbaa !1
  %sv_any122 = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %14 = load i8** %sv_any122, align 8, !tbaa !24
  %xpv_cur = getelementptr inbounds i8* %14, i64 8
  %15 = bitcast i8* %xpv_cur to i64*
  store i64 %cond120, i64* %15, align 8, !tbaa !28
  %sv_flags = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %16 = load i64* %sv_flags, align 8, !tbaa !7
  %or = or i64 %16, 536870912
  store i64 %or, i64* %sv_flags, align 8, !tbaa !7
  br label %if.end139

if.else:                                          ; preds = %land.lhs.true, %sw.bb
  store i64 4, i64* %numlen, align 8, !tbaa !20
  %call123 = call i64 @Perl_grok_oct(i8* %2, i64* %numlen, i64* %flags, double* null) #2
  %tobool124 = icmp ugt i64 %call123, 255
  br i1 %tobool124, label %if.then125, label %if.else126

if.then125:                                       ; preds = %if.else
  store %struct.sv* @PL_sv_undef, %struct.sv** @PL_rs, align 8, !tbaa !1
  br label %if.end139

if.else126:                                       ; preds = %if.else
  %tobool127 = icmp eq i64 %call123, 0
  %17 = load i64* %numlen, align 8
  %cmp129 = icmp ugt i64 %17, 1
  %or.cond = and i1 %tobool127, %cmp129
  br i1 %or.cond, label %if.then131, label %if.else133

if.then131:                                       ; preds = %if.else126
  %call132 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([1 x i8]* @.str1, i64 0, i64 0), i64 0) #2
  store %struct.sv* %call132, %struct.sv** @PL_rs, align 8, !tbaa !1
  br label %if.end139

if.else133:                                       ; preds = %if.else126
  %conv135 = trunc i64 %call123 to i8
  store i8 %conv135, i8* %ch, align 1, !tbaa !27
  %call136 = call %struct.sv* @Perl_newSVpvn(i8* %ch, i64 1) #2
  store %struct.sv* %call136, %struct.sv** @PL_rs, align 8, !tbaa !1
  br label %if.end139

if.end139:                                        ; preds = %if.then125, %if.else133, %if.then131, %cond.end119
  %call.i = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([2 x i8]* @.str16, i64 0, i64 0), i64 1, i64 4) #2
  %tobool.i = icmp eq %struct.gv* %call.i, null
  br i1 %tobool.i, label %Perl_get_sv.exit, label %if.then.i

if.then.i:                                        ; preds = %if.end139
  %sv_any.i = getelementptr inbounds %struct.gv* %call.i, i64 0, i32 0
  %18 = load %struct.xpvgv** %sv_any.i, align 8, !tbaa !65
  %xgv_gp.i = getelementptr inbounds %struct.xpvgv* %18, i64 0, i32 7
  %19 = load %struct.gp** %xgv_gp.i, align 8, !tbaa !67
  %gp_sv.i = getelementptr inbounds %struct.gp* %19, i64 0, i32 0
  %20 = load %struct.sv** %gp_sv.i, align 8, !tbaa !69
  br label %Perl_get_sv.exit

Perl_get_sv.exit:                                 ; preds = %if.end139, %if.then.i
  %retval.0.i = phi %struct.sv* [ %20, %if.then.i ], [ null, %if.end139 ]
  %21 = load %struct.sv** @PL_rs, align 8, !tbaa !1
  call void @Perl_sv_setsv_flags(%struct.sv* %retval.0.i, %struct.sv* %21, i64 2) #2
  %22 = load i8** %s.addr, align 8, !tbaa !1
  %23 = load i64* %numlen, align 8, !tbaa !20
  %add.ptr141 = getelementptr inbounds i8* %22, i64 %23
  br label %return

sw.bb142:                                         ; preds = %entry
  %incdec.ptr143 = getelementptr inbounds i8* %s, i64 1
  store i8* %incdec.ptr143, i8** %s.addr, align 8, !tbaa !1
  %call144 = call i32 (i8**, ...)* bitcast (i32 (...)* @parse_unicode_opts to i32 (i8**, ...)*)(i8** %s.addr) #2
  %conv145 = sext i32 %call144 to i64
  store i64 %conv145, i64* @PL_unicode, align 8, !tbaa !20
  %24 = load i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb146:                                         ; preds = %entry
  store i8 1, i8* @PL_minus_F, align 1, !tbaa !27
  %incdec.ptr147 = getelementptr inbounds i8* %s, i64 1
  store i8* %incdec.ptr147, i8** %s.addr, align 8, !tbaa !1
  store i8* %incdec.ptr147, i8** @PL_splitstr, align 8, !tbaa !1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %sw.bb146
  %25 = phi i8* [ %incdec.ptr167, %while.body ], [ %incdec.ptr147, %sw.bb146 ]
  %26 = load i8* %25, align 1, !tbaa !27
  %27 = icmp ult i8 %26, 33
  br i1 %27, label %land.end, label %while.body

land.end:                                         ; preds = %while.cond
  %switch.cast = zext i8 %26 to i33
  %switch.downshift = lshr i33 4294953470, %switch.cast
  %28 = and i33 %switch.downshift, 1
  %switch.masked = icmp eq i33 %28, 0
  br i1 %switch.masked, label %while.end, label %while.body

while.body:                                       ; preds = %while.cond, %land.end
  %incdec.ptr167 = getelementptr inbounds i8* %25, i64 1
  store i8* %incdec.ptr167, i8** %s.addr, align 8, !tbaa !1
  br label %while.cond

while.end:                                        ; preds = %land.end
  store i8 0, i8* %25, align 1, !tbaa !27
  %29 = load i8** @PL_splitstr, align 8, !tbaa !1
  %call168 = call i8* @Perl_savepv(i8* %29) #2
  store i8* %call168, i8** @PL_splitstr, align 8, !tbaa !1
  %30 = load i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb169:                                         ; preds = %entry
  store i8 1, i8* @PL_minus_a, align 1, !tbaa !27
  %incdec.ptr170 = getelementptr inbounds i8* %s, i64 1
  store i8* %incdec.ptr170, i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb171:                                         ; preds = %entry
  store i8 1, i8* @PL_minus_c, align 1, !tbaa !27
  %incdec.ptr172 = getelementptr inbounds i8* %s, i64 1
  store i8* %incdec.ptr172, i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb173:                                         ; preds = %entry
  %call174 = call i32 (i8*, ...)* bitcast (i32 (...)* @forbid_setid to i32 (i8*, ...)*)(i8* getelementptr inbounds ([3 x i8]* @.str17, i64 0, i64 0)) #2
  %31 = load i8** %s.addr, align 8, !tbaa !1
  %incdec.ptr175 = getelementptr inbounds i8* %31, i64 1
  store i8* %incdec.ptr175, i8** %s.addr, align 8, !tbaa !1
  %32 = load i8* %incdec.ptr175, align 1, !tbaa !27
  %cmp177 = icmp eq i8 %32, 116
  br i1 %cmp177, label %land.lhs.true179, label %if.end216

land.lhs.true179:                                 ; preds = %sw.bb173
  %arrayidx180 = getelementptr inbounds i8* %31, i64 2
  %33 = load i8* %arrayidx180, align 1, !tbaa !27
  %.off836 = add i8 %33, -65
  %34 = icmp ult i8 %.off836, 26
  %.off837 = add i8 %33, -97
  %35 = icmp ult i8 %.off837, 26
  %or.cond873 = or i1 %34, %35
  br i1 %or.cond873, label %if.end290, label %lor.lhs.false199

lor.lhs.false199:                                 ; preds = %land.lhs.true179
  %.off838 = add i8 %33, -48
  %36 = icmp ult i8 %.off838, 10
  %cmp212 = icmp eq i8 %33, 95
  %or.cond825 = or i1 %36, %cmp212
  br i1 %or.cond825, label %if.end290, label %if.then214

if.then214:                                       ; preds = %lor.lhs.false199
  store i8* %arrayidx180, i8** %s.addr, align 8, !tbaa !1
  call void @Perl_my_setenv(i8* getelementptr inbounds ([17 x i8]* @.str18, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8]* @.str19, i64 0, i64 0)) #2
  %.pre858 = load i8** %s.addr, align 8, !tbaa !1
  %.pre859 = load i8* %.pre858, align 1, !tbaa !27
  br label %if.end216

if.end216:                                        ; preds = %if.then214, %sw.bb173
  %37 = phi i8 [ %.pre859, %if.then214 ], [ %32, %sw.bb173 ]
  switch i8 %37, label %if.end290 [
    i8 58, label %if.then224
    i8 61, label %if.then224
  ]

if.then224:                                       ; preds = %if.end216, %if.end216
  %call227 = call %struct.sv* @Perl_newSVpv(i8* getelementptr inbounds ([12 x i8]* @.str20, i64 0, i64 0), i64 0) #2
  %38 = load i8** %s.addr, align 8, !tbaa !1
  %incdec.ptr228 = getelementptr inbounds i8* %38, i64 1
  br label %while.cond229

while.cond229:                                    ; preds = %while.body262, %if.then224
  %storemerge793 = phi i8* [ %incdec.ptr228, %if.then224 ], [ %incdec.ptr263, %while.body262 ]
  store i8* %storemerge793, i8** %s.addr, align 8, !tbaa !1
  %39 = load i8* %storemerge793, align 1, !tbaa !27
  %.off833 = add i8 %39, -65
  %40 = icmp ult i8 %.off833, 26
  %.off834 = add i8 %39, -97
  %41 = icmp ult i8 %.off834, 26
  %or.cond840 = or i1 %40, %41
  %.off835 = add i8 %39, -48
  %42 = icmp ult i8 %.off835, 10
  %or.cond842 = or i1 %or.cond840, %42
  br i1 %or.cond842, label %while.body262, label %lor.end261

lor.end261:                                       ; preds = %while.cond229
  switch i8 %39, label %if.then268 [
    i8 95, label %while.body262
    i8 58, label %while.body262
    i8 61, label %if.else269
  ]

while.body262:                                    ; preds = %lor.end261, %lor.end261, %while.cond229
  %incdec.ptr263 = getelementptr inbounds i8* %storemerge793, i64 1
  br label %while.cond229

if.then268:                                       ; preds = %lor.end261
  call void @Perl_sv_catpv(%struct.sv* %call227, i8* %incdec.ptr228) #2
  br label %if.end274

if.else269:                                       ; preds = %lor.end261
  %sub.ptr.lhs.cast270 = ptrtoint i8* %storemerge793 to i64
  %sub.ptr.rhs.cast271 = ptrtoint i8* %incdec.ptr228 to i64
  %sub.ptr.sub272 = sub i64 %sub.ptr.lhs.cast270, %sub.ptr.rhs.cast271
  call void @Perl_sv_catpvn_flags(%struct.sv* %call227, i8* %incdec.ptr228, i64 %sub.ptr.sub272, i64 2) #2
  call void @Perl_sv_catpv(%struct.sv* %call227, i8* getelementptr inbounds ([14 x i8]* @.str21, i64 0, i64 0)) #2
  %43 = load i8** %s.addr, align 8, !tbaa !1
  %incdec.ptr273 = getelementptr inbounds i8* %43, i64 1
  store i8* %incdec.ptr273, i8** %s.addr, align 8, !tbaa !1
  call void @Perl_sv_catpv(%struct.sv* %call227, i8* %incdec.ptr273) #2
  call void @Perl_sv_catpv(%struct.sv* %call227, i8* getelementptr inbounds ([3 x i8]* @.str22, i64 0, i64 0)) #2
  br label %if.end274

if.end274:                                        ; preds = %if.else269, %if.then268
  %44 = load i8** %s.addr, align 8, !tbaa !1
  %call275 = call i64 @strlen(i8* %44) #2
  %add.ptr276 = getelementptr inbounds i8* %44, i64 %call275
  store i8* %add.ptr276, i8** %s.addr, align 8, !tbaa !1
  %sv_flags277 = getelementptr inbounds %struct.sv* %call227, i64 0, i32 2
  %45 = load i64* %sv_flags277, align 8, !tbaa !7
  %and278 = and i64 %45, 262144
  %cmp279 = icmp eq i64 %and278, 0
  br i1 %cmp279, label %cond.false286, label %cond.true281

cond.true281:                                     ; preds = %if.end274
  %sv_any282 = getelementptr inbounds %struct.sv* %call227, i64 0, i32 0
  %46 = load i8** %sv_any282, align 8, !tbaa !24
  %xpv_cur283 = getelementptr inbounds i8* %46, i64 8
  %47 = bitcast i8* %xpv_cur283 to i64*
  %48 = load i64* %47, align 8, !tbaa !28
  store i64 %48, i64* @PL_na, align 8, !tbaa !20
  %xpv_pv285 = bitcast i8* %46 to i8**
  %49 = load i8** %xpv_pv285, align 8, !tbaa !25
  br label %cond.end288

cond.false286:                                    ; preds = %if.end274
  %call287 = call i8* @Perl_sv_2pv_flags(%struct.sv* %call227, i64* @PL_na, i64 2) #2
  br label %cond.end288

cond.end288:                                      ; preds = %cond.false286, %cond.true281
  %cond289 = phi i8* [ %49, %cond.true281 ], [ %call287, %cond.false286 ]
  call void @Perl_my_setenv(i8* getelementptr inbounds ([8 x i8]* @.str23, i64 0, i64 0), i8* %cond289) #2
  br label %if.end290

if.end290:                                        ; preds = %land.lhs.true179, %lor.lhs.false199, %if.end216, %cond.end288
  %50 = load i64* @PL_perldb, align 8, !tbaa !20
  %tobool291 = icmp eq i64 %50, 0
  br i1 %tobool291, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end290
  store i64 831, i64* @PL_perldb, align 8, !tbaa !20
  %call293 = call i32 (...)* @init_debugger() #2
  br label %if.end294

if.end294:                                        ; preds = %if.end290, %if.then292
  %51 = load i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb295:                                         ; preds = %entry
  %52 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings = getelementptr inbounds %struct.cop* %52, i64 0, i32 14
  %53 = load %struct.sv** %cop_warnings, align 8, !tbaa !42
  %cmp296 = icmp eq %struct.sv* %53, null
  br i1 %cmp296, label %if.then314, label %lor.lhs.false298

lor.lhs.false298:                                 ; preds = %sw.bb295
  %54 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings299 = getelementptr inbounds %struct.cop* %54, i64 0, i32 14
  %55 = load %struct.sv** %cop_warnings299, align 8, !tbaa !42
  %cmp300 = icmp eq %struct.sv* %55, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp300, label %if.then314, label %lor.lhs.false302

lor.lhs.false302:                                 ; preds = %lor.lhs.false298
  %56 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings303 = getelementptr inbounds %struct.cop* %56, i64 0, i32 14
  %57 = load %struct.sv** %cop_warnings303, align 8, !tbaa !42
  %cmp304 = icmp eq %struct.sv* %57, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp304, label %for.cond317.preheader, label %land.lhs.true306

land.lhs.true306:                                 ; preds = %lor.lhs.false302
  %58 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !1
  %cop_warnings307 = getelementptr inbounds %struct.cop* %58, i64 0, i32 14
  %59 = load %struct.sv** %cop_warnings307, align 8, !tbaa !42
  %sv_any308 = getelementptr inbounds %struct.sv* %59, i64 0, i32 0
  %60 = load i8** %sv_any308, align 8, !tbaa !24
  %xpv_pv309 = bitcast i8* %60 to i8**
  %61 = load i8** %xpv_pv309, align 8, !tbaa !25
  %arrayidx310 = getelementptr inbounds i8* %61, i64 5
  %62 = load i8* %arrayidx310, align 1, !tbaa !27
  %and312 = and i8 %62, 16
  %tobool313 = icmp eq i8 %and312, 0
  br i1 %tobool313, label %for.cond317.preheader, label %if.then314

if.then314:                                       ; preds = %land.lhs.true306, %lor.lhs.false298, %sw.bb295
  call void (i64, i8*, ...)* @Perl_warner(i64 22, i8* getelementptr inbounds ([70 x i8]* @.str24, i64 0, i64 0)) #2
  br label %for.cond317.preheader

for.cond317.preheader:                            ; preds = %land.lhs.true306, %lor.lhs.false302, %if.then314
  %.pn791.pre = load i8** %s.addr, align 8
  br label %for.cond317

for.cond317:                                      ; preds = %for.cond317, %lor.lhs.false333, %for.cond317.preheader
  %.pn791 = phi i8* [ %.pn791.pre, %for.cond317.preheader ], [ %storemerge790, %lor.lhs.false333 ], [ %storemerge790, %for.cond317 ]
  %storemerge790 = getelementptr inbounds i8* %.pn791, i64 1
  store i8* %storemerge790, i8** %s.addr, align 8, !tbaa !1
  %63 = load i8* %storemerge790, align 1, !tbaa !27
  %.off830 = add i8 %63, -65
  %64 = icmp ult i8 %.off830, 26
  %.off831 = add i8 %63, -97
  %65 = icmp ult i8 %.off831, 26
  %or.cond844 = or i1 %64, %65
  br i1 %or.cond844, label %for.cond317, label %lor.lhs.false333

lor.lhs.false333:                                 ; preds = %for.cond317
  %.off832 = add i8 %63, -48
  %66 = icmp ult i8 %.off832, 10
  %cmp343 = icmp eq i8 %63, 95
  %or.cond826 = or i1 %66, %cmp343
  br i1 %or.cond826, label %for.cond317, label %return

sw.bb350:                                         ; preds = %entry
  %67 = load i8*** @PL_origargv, align 8, !tbaa !1
  %68 = load i8** %67, align 8, !tbaa !1
  %call352 = call i32 (i8*, ...)* bitcast (i32 (...)* @usage to i32 (i8*, ...)*)(i8* %68) #2
  store i64 0, i64* @PL_statusvalue, align 8, !tbaa !20
  %call.i823 = call i32 (...)* @my_exit_jump() #2
  br label %sw.bb353

sw.bb353:                                         ; preds = %entry, %sw.bb350
  %69 = load i8** @PL_inplace, align 8, !tbaa !1
  %tobool354 = icmp eq i8* %69, null
  br i1 %tobool354, label %if.end356, label %if.then355

if.then355:                                       ; preds = %sw.bb353
  call void @Perl_safesysfree(i8* %69) #2
  br label %if.end356

if.end356:                                        ; preds = %sw.bb353, %if.then355
  %70 = load i8** %s.addr, align 8, !tbaa !1
  %add.ptr357 = getelementptr inbounds i8* %70, i64 1
  %call358 = call i8* @Perl_savepv(i8* %add.ptr357) #2
  store i8* %call358, i8** @PL_inplace, align 8, !tbaa !1
  br label %for.cond359

for.cond359:                                      ; preds = %for.inc386.critedge, %if.end356
  %71 = phi i8* [ %call358, %if.end356 ], [ %incdec.ptr387, %for.inc386.critedge ]
  store i8* %71, i8** %s.addr, align 8, !tbaa !1
  %72 = load i8* %71, align 1, !tbaa !27
  switch i8 %72, label %for.inc386.critedge [
    i8 0, label %return
    i8 9, label %if.then390
    i8 10, label %if.then390
    i8 12, label %if.then390
    i8 13, label %if.then390
    i8 32, label %if.then390
  ]

for.inc386.critedge:                              ; preds = %for.cond359
  %incdec.ptr387 = getelementptr inbounds i8* %71, i64 1
  br label %for.cond359

if.then390:                                       ; preds = %for.cond359, %for.cond359, %for.cond359, %for.cond359, %for.cond359
  %incdec.ptr391 = getelementptr inbounds i8* %71, i64 1
  store i8* %incdec.ptr391, i8** %s.addr, align 8, !tbaa !1
  store i8 0, i8* %71, align 1, !tbaa !27
  %73 = load i8** %s.addr, align 8, !tbaa !1
  %74 = load i8* %73, align 1, !tbaa !27
  %cmp393 = icmp eq i8 %74, 45
  br i1 %cmp393, label %if.then395, label %return

if.then395:                                       ; preds = %if.then390
  %incdec.ptr396 = getelementptr inbounds i8* %73, i64 1
  store i8* %incdec.ptr396, i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb399:                                         ; preds = %entry
  %call400 = call i32 (i8*, ...)* bitcast (i32 (...)* @forbid_setid to i32 (i8*, ...)*)(i8* getelementptr inbounds ([3 x i8]* @.str25, i64 0, i64 0)) #2
  %75 = load i8** %s.addr, align 8, !tbaa !1
  br label %while.cond402

while.cond402:                                    ; preds = %land.end426, %sw.bb399
  %.pn = phi i8* [ %75, %sw.bb399 ], [ %storemerge, %land.end426 ]
  %storemerge = getelementptr inbounds i8* %.pn, i64 1
  store i8* %storemerge, i8** %s.addr, align 8, !tbaa !1
  %76 = load i8* %storemerge, align 1, !tbaa !27
  %tobool404 = icmp eq i8 %76, 0
  br i1 %tobool404, label %if.else507, label %land.rhs405

land.rhs405:                                      ; preds = %while.cond402
  %switch.tableidx818 = add i8 %76, -9
  %77 = icmp ult i8 %switch.tableidx818, 24
  br i1 %77, label %land.end426, label %for.cond435

land.end426:                                      ; preds = %land.rhs405
  %switch.cast819 = zext i8 %switch.tableidx818 to i24
  %switch.downshift821 = lshr i24 -8388581, %switch.cast819
  %78 = and i24 %switch.downshift821, 1
  %switch.masked822 = icmp eq i24 %78, 0
  br i1 %switch.masked822, label %while.end429, label %while.cond402

while.end429:                                     ; preds = %land.end426
  br i1 %tobool404, label %if.else507, label %for.cond435

for.cond435:                                      ; preds = %while.end429, %land.rhs405, %for.cond435.backedge
  %79 = phi i8 [ %.pre863, %for.cond435.backedge ], [ %76, %land.rhs405 ], [ %76, %while.end429 ]
  %e433.0 = phi i8* [ %e433.0.be, %for.cond435.backedge ], [ %storemerge, %land.rhs405 ], [ %storemerge, %while.end429 ]
  switch i8 %79, label %for.inc462.critedge [
    i8 0, label %while.cond465
    i8 32, label %while.cond465
    i8 9, label %while.cond465
    i8 10, label %while.cond465
    i8 13, label %while.cond465
    i8 12, label %while.cond465
  ]

for.inc462.critedge:                              ; preds = %for.cond435
  %incdec.ptr463 = getelementptr inbounds i8* %e433.0, i64 1
  br label %for.cond435.backedge

for.cond435.backedge:                             ; preds = %while.cond465, %for.inc462.critedge
  %e433.0.be = phi i8* [ %incdec.ptr463, %for.inc462.critedge ], [ %p.1, %while.cond465 ]
  %.pre863 = load i8* %e433.0.be, align 1, !tbaa !27
  br label %for.cond435

while.cond465:                                    ; preds = %for.cond435, %for.cond435, %for.cond435, %for.cond435, %for.cond435, %for.cond435, %while.body486
  %80 = phi i8 [ %.pre864, %while.body486 ], [ %79, %for.cond435 ], [ %79, %for.cond435 ], [ %79, %for.cond435 ], [ %79, %for.cond435 ], [ %79, %for.cond435 ], [ %79, %for.cond435 ]
  %p.1 = phi i8* [ %incdec.ptr487, %while.body486 ], [ %e433.0, %for.cond435 ], [ %e433.0, %for.cond435 ], [ %e433.0, %for.cond435 ], [ %e433.0, %for.cond435 ], [ %e433.0, %for.cond435 ], [ %e433.0, %for.cond435 ]
  switch i8 %80, label %for.cond435.backedge [
    i8 32, label %while.body486
    i8 9, label %while.body486
    i8 10, label %while.body486
    i8 13, label %while.body486
    i8 12, label %while.body486
    i8 0, label %do.end
    i8 45, label %do.end
  ]

while.body486:                                    ; preds = %while.cond465, %while.cond465, %while.cond465, %while.cond465, %while.cond465
  %incdec.ptr487 = getelementptr inbounds i8* %p.1, i64 1
  %.pre864 = load i8* %incdec.ptr487, align 1, !tbaa !27
  br label %while.cond465

do.end:                                           ; preds = %while.cond465, %while.cond465
  %sub.ptr.lhs.cast496 = ptrtoint i8* %e433.0 to i64
  %sub.ptr.rhs.cast497 = ptrtoint i8* %storemerge to i64
  %sub.ptr.sub498 = sub i64 %sub.ptr.lhs.cast496, %sub.ptr.rhs.cast497
  %call499 = call i8* @Perl_savepvn(i8* %storemerge, i64 %sub.ptr.sub498) #2
  %call500 = call i32 (i8*, i32, i32, i32, ...)* bitcast (i32 (...)* @incpush to i32 (i8*, i32, i32, i32, ...)*)(i8* %call499, i32 1, i32 1, i32 0) #2
  call void @Perl_safesysfree(i8* %call499) #2
  store i8* %p.1, i8** %s.addr, align 8, !tbaa !1
  %81 = load i8* %p.1, align 1, !tbaa !27
  %cmp502 = icmp eq i8 %81, 45
  br i1 %cmp502, label %if.then504, label %return

if.then504:                                       ; preds = %do.end
  %incdec.ptr505 = getelementptr inbounds i8* %p.1, i64 1
  store i8* %incdec.ptr505, i8** %s.addr, align 8, !tbaa !1
  br label %return

if.else507:                                       ; preds = %while.cond402, %while.end429
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([30 x i8]* @.str26, i64 0, i64 0)) #2
  %.pre862 = load i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb509:                                         ; preds = %entry
  store i8 1, i8* @PL_minus_l, align 1, !tbaa !27
  %incdec.ptr510 = getelementptr inbounds i8* %s, i64 1
  store i8* %incdec.ptr510, i8** %s.addr, align 8, !tbaa !1
  %82 = load %struct.sv** @PL_ors_sv, align 8, !tbaa !1
  %tobool511 = icmp eq %struct.sv* %82, null
  br i1 %tobool511, label %if.end513, label %if.then512

if.then512:                                       ; preds = %sw.bb509
  call void @Perl_sv_free(%struct.sv* %82) #2
  store %struct.sv* null, %struct.sv** @PL_ors_sv, align 8, !tbaa !1
  %.pre865 = load i8** %s.addr, align 8, !tbaa !1
  br label %if.end513

if.end513:                                        ; preds = %sw.bb509, %if.then512
  %83 = phi i8* [ %incdec.ptr510, %sw.bb509 ], [ %.pre865, %if.then512 ]
  %84 = load i8* %83, align 1, !tbaa !27
  %.off829 = add i8 %84, -48
  %85 = icmp ult i8 %.off829, 10
  br i1 %85, label %if.then521, label %if.else535

if.then521:                                       ; preds = %if.end513
  store i64 0, i64* %flags523, align 8, !tbaa !20
  %call524 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([2 x i8]* @.str, i64 0, i64 0), i64 1) #2
  store %struct.sv* %call524, %struct.sv** @PL_ors_sv, align 8, !tbaa !1
  %86 = load i8** %s.addr, align 8, !tbaa !1
  %87 = load i8* %86, align 1, !tbaa !27
  %cmp526 = icmp eq i8 %87, 48
  %conv529 = select i1 %cmp526, i64 4, i64 3
  store i64 %conv529, i64* %numlen, align 8, !tbaa !20
  %call530 = call i64 @Perl_grok_oct(i8* %86, i64* %numlen, i64* %flags523, double* null) #2
  %conv531 = trunc i64 %call530 to i8
  %88 = load %struct.sv** @PL_ors_sv, align 8, !tbaa !1
  %sv_any532 = getelementptr inbounds %struct.sv* %88, i64 0, i32 0
  %89 = load i8** %sv_any532, align 8, !tbaa !24
  %xpv_pv533 = bitcast i8* %89 to i8**
  %90 = load i8** %xpv_pv533, align 8, !tbaa !25
  store i8 %conv531, i8* %90, align 1, !tbaa !27
  %91 = load i64* %numlen, align 8, !tbaa !20
  %92 = load i8** %s.addr, align 8, !tbaa !1
  %add.ptr534 = getelementptr inbounds i8* %92, i64 %91
  store i8* %add.ptr534, i8** %s.addr, align 8, !tbaa !1
  br label %if.end548

if.else535:                                       ; preds = %if.end513
  %93 = load %struct.sv** @PL_rs, align 8, !tbaa !1
  %sv_flags536 = getelementptr inbounds %struct.sv* %93, i64 0, i32 2
  %94 = load i64* %sv_flags536, align 8, !tbaa !7
  %and537 = and i64 %94, 262144
  %tobool538 = icmp eq i64 %and537, 0
  br i1 %tobool538, label %if.else545, label %land.lhs.true539

land.lhs.true539:                                 ; preds = %if.else535
  %sv_any540 = getelementptr inbounds %struct.sv* %93, i64 0, i32 0
  %95 = load i8** %sv_any540, align 8, !tbaa !24
  %xpv_cur541 = getelementptr inbounds i8* %95, i64 8
  %96 = bitcast i8* %xpv_cur541 to i64*
  %97 = load i64* %96, align 8, !tbaa !28
  %tobool542 = icmp eq i64 %97, 0
  br i1 %tobool542, label %if.then543, label %if.else545

if.then543:                                       ; preds = %land.lhs.true539
  %call544 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([3 x i8]* @.str27, i64 0, i64 0), i64 2) #2
  store %struct.sv* %call544, %struct.sv** @PL_ors_sv, align 8, !tbaa !1
  br label %if.end548

if.else545:                                       ; preds = %land.lhs.true539, %if.else535
  %call546 = call %struct.sv* @Perl_newSVsv(%struct.sv* %93) #2
  store %struct.sv* %call546, %struct.sv** @PL_ors_sv, align 8, !tbaa !1
  br label %if.end548

if.end548:                                        ; preds = %if.then543, %if.else545, %if.then521
  %98 = load i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb549:                                         ; preds = %entry
  %call550 = call i32 (i8*, ...)* bitcast (i32 (...)* @forbid_setid to i32 (i8*, ...)*)(i8* getelementptr inbounds ([3 x i8]* @.str28, i64 0, i64 0)) #2
  br label %sw.bb551

sw.bb551:                                         ; preds = %entry, %sw.bb549
  %call552 = call i32 (i8*, ...)* bitcast (i32 (...)* @forbid_setid to i32 (i8*, ...)*)(i8* getelementptr inbounds ([3 x i8]* @.str29, i64 0, i64 0)) #2
  %99 = load i8** %s.addr, align 8, !tbaa !1
  %incdec.ptr553 = getelementptr inbounds i8* %99, i64 1
  store i8* %incdec.ptr553, i8** %s.addr, align 8, !tbaa !1
  %100 = load i8* %incdec.ptr553, align 1, !tbaa !27
  switch i8 %100, label %if.end566 [
    i8 0, label %if.else638
    i8 45, label %if.then564
  ]

if.then564:                                       ; preds = %sw.bb551
  %incdec.ptr565 = getelementptr inbounds i8* %99, i64 2
  store i8* %incdec.ptr565, i8** %s.addr, align 8, !tbaa !1
  br label %if.end566

if.end566:                                        ; preds = %sw.bb551, %if.then564
  %use.0 = phi i8* [ getelementptr inbounds ([4 x i8]* @.str31, i64 0, i64 0), %if.then564 ], [ getelementptr inbounds ([5 x i8]* @.str30, i64 0, i64 0), %sw.bb551 ]
  %call567 = call %struct.sv* @Perl_newSVpv(i8* %use.0, i64 0) #2
  %101 = load i8** %s.addr, align 8, !tbaa !1
  br label %while.cond568

while.cond568:                                    ; preds = %while.body601, %if.end566
  %102 = phi i8* [ %incdec.ptr602, %while.body601 ], [ %101, %if.end566 ]
  %103 = load i8* %102, align 1, !tbaa !27
  %.off = add i8 %103, -65
  %104 = icmp ult i8 %.off, 26
  %.off827 = add i8 %103, -97
  %105 = icmp ult i8 %.off827, 26
  %or.cond846 = or i1 %104, %105
  %.off828 = add i8 %103, -48
  %106 = icmp ult i8 %.off828, 10
  %or.cond848 = or i1 %or.cond846, %106
  br i1 %or.cond848, label %while.body601, label %lor.end600

lor.end600:                                       ; preds = %while.cond568
  switch i8 %103, label %if.then607 [
    i8 95, label %while.body601
    i8 58, label %while.body601
    i8 61, label %if.else620
  ]

while.body601:                                    ; preds = %lor.end600, %lor.end600, %while.cond568
  %incdec.ptr602 = getelementptr inbounds i8* %102, i64 1
  store i8* %incdec.ptr602, i8** %s.addr, align 8, !tbaa !1
  br label %while.cond568

if.then607:                                       ; preds = %lor.end600
  call void @Perl_sv_catpv(%struct.sv* %call567, i8* %101) #2
  %add.ptr608 = getelementptr inbounds i8* %101, i64 -1
  %107 = load i8* %add.ptr608, align 1, !tbaa !27
  %cmp610 = icmp eq i8 %107, 109
  br i1 %cmp610, label %if.then612, label %if.end631

if.then612:                                       ; preds = %if.then607
  %108 = load i8** %s.addr, align 8, !tbaa !1
  %109 = load i8* %108, align 1, !tbaa !27
  %cmp614 = icmp eq i8 %109, 0
  br i1 %cmp614, label %if.end618, label %if.then616

if.then616:                                       ; preds = %if.then612
  %conv613 = sext i8 %109 to i32
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([28 x i8]* @.str32, i64 0, i64 0), i32 %conv613) #2
  br label %if.end618

if.end618:                                        ; preds = %if.then612, %if.then616
  call void @Perl_sv_catpv(%struct.sv* %call567, i8* getelementptr inbounds ([4 x i8]* @.str33, i64 0, i64 0)) #2
  br label %if.end631

if.else620:                                       ; preds = %lor.end600
  %cmp621 = icmp eq i8* %102, %101
  br i1 %cmp621, label %if.then623, label %if.end626

if.then623:                                       ; preds = %if.else620
  %arrayidx624 = getelementptr inbounds i8* %101, i64 -1
  %110 = load i8* %arrayidx624, align 1, !tbaa !27
  %conv625 = sext i8 %110 to i32
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([37 x i8]* @.str34, i64 0, i64 0), i32 %conv625) #2
  %.pre866 = load i8** %s.addr, align 8, !tbaa !1
  br label %if.end626

if.end626:                                        ; preds = %if.then623, %if.else620
  %111 = phi i8* [ %.pre866, %if.then623 ], [ %102, %if.else620 ]
  %sub.ptr.lhs.cast627 = ptrtoint i8* %111 to i64
  %sub.ptr.rhs.cast628 = ptrtoint i8* %101 to i64
  %sub.ptr.sub629 = sub i64 %sub.ptr.lhs.cast627, %sub.ptr.rhs.cast628
  call void @Perl_sv_catpvn_flags(%struct.sv* %call567, i8* %101, i64 %sub.ptr.sub629, i64 2) #2
  call void @Perl_sv_catpv(%struct.sv* %call567, i8* getelementptr inbounds ([13 x i8]* @.str35, i64 0, i64 0)) #2
  call void @Perl_sv_catpvn_flags(%struct.sv* %call567, i8* getelementptr inbounds ([3 x i8]* @.str36, i64 0, i64 0), i64 1, i64 2) #2
  %112 = load i8** %s.addr, align 8, !tbaa !1
  %incdec.ptr630 = getelementptr inbounds i8* %112, i64 1
  store i8* %incdec.ptr630, i8** %s.addr, align 8, !tbaa !1
  call void @Perl_sv_catpv(%struct.sv* %call567, i8* %incdec.ptr630) #2
  call void @Perl_sv_catpvn_flags(%struct.sv* %call567, i8* getelementptr inbounds ([3 x i8]* @.str36, i64 0, i64 0), i64 2, i64 2) #2
  br label %if.end631

if.end631:                                        ; preds = %if.then607, %if.end618, %if.end626
  %113 = load i8** %s.addr, align 8, !tbaa !1
  %call632 = call i64 @strlen(i8* %113) #2
  %add.ptr633 = getelementptr inbounds i8* %113, i64 %call632
  store i8* %add.ptr633, i8** %s.addr, align 8, !tbaa !1
  %114 = load %struct.av** @PL_preambleav, align 8, !tbaa !1
  %tobool634 = icmp eq %struct.av* %114, null
  br i1 %tobool634, label %if.then635, label %if.end637

if.then635:                                       ; preds = %if.end631
  %call636 = call %struct.av* @Perl_newAV() #2
  store %struct.av* %call636, %struct.av** @PL_preambleav, align 8, !tbaa !1
  br label %if.end637

if.end637:                                        ; preds = %if.end631, %if.then635
  %115 = phi %struct.av* [ %114, %if.end631 ], [ %call636, %if.then635 ]
  call void @Perl_av_push(%struct.av* %115, %struct.sv* %call567) #2
  br label %if.end641

if.else638:                                       ; preds = %sw.bb551
  %116 = load i8* %99, align 1, !tbaa !27
  %conv640 = sext i8 %116 to i32
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([24 x i8]* @.str37, i64 0, i64 0), i32 %conv640) #2
  br label %if.end641

if.end641:                                        ; preds = %if.else638, %if.end637
  %117 = load i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb642:                                         ; preds = %entry
  store i8 1, i8* @PL_minus_n, align 1, !tbaa !27
  %incdec.ptr643 = getelementptr inbounds i8* %s, i64 1
  store i8* %incdec.ptr643, i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb644:                                         ; preds = %entry
  store i8 1, i8* @PL_minus_p, align 1, !tbaa !27
  %incdec.ptr645 = getelementptr inbounds i8* %s, i64 1
  store i8* %incdec.ptr645, i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb646:                                         ; preds = %entry
  %call647 = call i32 (i8*, ...)* bitcast (i32 (...)* @forbid_setid to i32 (i8*, ...)*)(i8* getelementptr inbounds ([3 x i8]* @.str38, i64 0, i64 0)) #2
  store i8 1, i8* @PL_doswitches, align 1, !tbaa !27
  %118 = load i8** %s.addr, align 8, !tbaa !1
  %incdec.ptr648 = getelementptr inbounds i8* %118, i64 1
  store i8* %incdec.ptr648, i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb649:                                         ; preds = %entry
  %119 = load i8* @PL_tainting, align 1, !tbaa !27
  %tobool650 = icmp eq i8 %119, 0
  br i1 %tobool650, label %if.then651, label %if.end652

if.then651:                                       ; preds = %sw.bb649
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([68 x i8]* @.str39, i64 0, i64 0), i32 116, i8* getelementptr inbounds ([1 x i8]* @.str1, i64 0, i64 0)) #2
  %.pre867 = load i8** %s.addr, align 8, !tbaa !1
  br label %if.end652

if.end652:                                        ; preds = %sw.bb649, %if.then651
  %120 = phi i8* [ %s, %sw.bb649 ], [ %.pre867, %if.then651 ]
  %incdec.ptr653 = getelementptr inbounds i8* %120, i64 1
  store i8* %incdec.ptr653, i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb654:                                         ; preds = %entry
  %121 = load i8* @PL_tainting, align 1, !tbaa !27
  %tobool655 = icmp eq i8 %121, 0
  br i1 %tobool655, label %if.then656, label %if.end657

if.then656:                                       ; preds = %sw.bb654
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([68 x i8]* @.str39, i64 0, i64 0), i32 84, i8* getelementptr inbounds ([1 x i8]* @.str1, i64 0, i64 0)) #2
  %.pre868 = load i8** %s.addr, align 8, !tbaa !1
  br label %if.end657

if.end657:                                        ; preds = %sw.bb654, %if.then656
  %122 = phi i8* [ %s, %sw.bb654 ], [ %.pre868, %if.then656 ]
  %incdec.ptr658 = getelementptr inbounds i8* %122, i64 1
  store i8* %incdec.ptr658, i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb659:                                         ; preds = %entry
  store i8 1, i8* @PL_do_undump, align 1, !tbaa !27
  %incdec.ptr660 = getelementptr inbounds i8* %s, i64 1
  store i8* %incdec.ptr660, i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb661:                                         ; preds = %entry
  store i8 1, i8* @PL_unsafe, align 1, !tbaa !27
  %incdec.ptr662 = getelementptr inbounds i8* %s, i64 1
  store i8* %incdec.ptr662, i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb663:                                         ; preds = %entry
  %call664 = call %struct._PerlIO** @Perl_PerlIO_stdout() #2
  %123 = load %struct.sv** @PL_patchlevel, align 8, !tbaa !1
  %call665 = call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([33 x i8]* @.str40, i64 0, i64 0), %struct.sv* %123, i8* getelementptr inbounds ([9 x i8]* @.str41, i64 0, i64 0)) #2
  %call666 = call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %call664, i8* %call665) #2
  %call667 = call %struct._PerlIO** @Perl_PerlIO_stdout() #2
  %call668 = call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %call667, i8* getelementptr inbounds ([35 x i8]* @.str42, i64 0, i64 0)) #2
  %call669 = call %struct._PerlIO** @Perl_PerlIO_stdout() #2
  %call670 = call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %call669, i8* getelementptr inbounds ([377 x i8]* @.str43, i64 0, i64 0)) #2
  store i64 0, i64* @PL_statusvalue, align 8, !tbaa !20
  %call.i824 = call i32 (...)* @my_exit_jump() #2
  br label %sw.bb671

sw.bb671:                                         ; preds = %entry, %sw.bb663
  %124 = load i8* @PL_dowarn, align 1, !tbaa !27
  %and673 = and i8 %124, 6
  %tobool674 = icmp eq i8 %and673, 0
  br i1 %tobool674, label %if.then675, label %if.end679

if.then675:                                       ; preds = %sw.bb671
  %or677 = or i8 %124, 1
  store i8 %or677, i8* @PL_dowarn, align 1, !tbaa !27
  br label %if.end679

if.end679:                                        ; preds = %sw.bb671, %if.then675
  %125 = load i8** %s.addr, align 8, !tbaa !1
  %incdec.ptr680 = getelementptr inbounds i8* %125, i64 1
  store i8* %incdec.ptr680, i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb681:                                         ; preds = %entry
  store i8 3, i8* @PL_dowarn, align 1, !tbaa !27
  %126 = load %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !42
  %magicptr = ptrtoint %struct.sv* %126 to i64
  switch i64 %magicptr, label %if.then690 [
    i64 48, label %if.end691
    i64 24, label %if.end691
    i64 0, label %if.end691
  ]

if.then690:                                       ; preds = %sw.bb681
  call void @Perl_sv_free(%struct.sv* %126) #2
  %.pre869 = load i8** %s.addr, align 8, !tbaa !1
  br label %if.end691

if.end691:                                        ; preds = %sw.bb681, %sw.bb681, %sw.bb681, %if.then690
  %127 = phi i8* [ %s, %sw.bb681 ], [ %s, %sw.bb681 ], [ %s, %sw.bb681 ], [ %.pre869, %if.then690 ]
  store %struct.sv* inttoptr (i64 24 to %struct.sv*), %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !42
  %incdec.ptr692 = getelementptr inbounds i8* %127, i64 1
  store i8* %incdec.ptr692, i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb693:                                         ; preds = %entry
  store i8 4, i8* @PL_dowarn, align 1, !tbaa !27
  %128 = load %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !42
  %magicptr816 = ptrtoint %struct.sv* %128 to i64
  switch i64 %magicptr816, label %if.then702 [
    i64 48, label %if.end703
    i64 24, label %if.end703
    i64 0, label %if.end703
  ]

if.then702:                                       ; preds = %sw.bb693
  call void @Perl_sv_free(%struct.sv* %128) #2
  %.pre870 = load i8** %s.addr, align 8, !tbaa !1
  br label %if.end703

if.end703:                                        ; preds = %sw.bb693, %sw.bb693, %sw.bb693, %if.then702
  %129 = phi i8* [ %s, %sw.bb693 ], [ %s, %sw.bb693 ], [ %s, %sw.bb693 ], [ %.pre870, %if.then702 ]
  store %struct.sv* inttoptr (i64 48 to %struct.sv*), %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !42
  %incdec.ptr704 = getelementptr inbounds i8* %129, i64 1
  store i8* %incdec.ptr704, i8** %s.addr, align 8, !tbaa !1
  br label %return

sw.bb705:                                         ; preds = %entry, %entry
  %arrayidx706 = getelementptr inbounds i8* %s, i64 1
  %130 = load i8* %arrayidx706, align 1, !tbaa !27
  %cmp708 = icmp eq i8 %130, 45
  %add.ptr711 = getelementptr inbounds i8* %s, i64 2
  %add.ptr711. = select i1 %cmp708, i8* %add.ptr711, i8* null
  ret i8* %add.ptr711.

sw.bb714:                                         ; preds = %entry
  %131 = load i8* @PL_preprocess, align 1, !tbaa !27
  %tobool715 = icmp eq i8 %131, 0
  br i1 %tobool715, label %sw.default, label %if.then716

if.then716:                                       ; preds = %sw.bb714
  %add.ptr717 = getelementptr inbounds i8* %s, i64 1
  br label %return

sw.default:                                       ; preds = %sw.bb714, %entry
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str44, i64 0, i64 0), i8* %s) #2
  br label %return

return:                                           ; preds = %for.cond359, %lor.lhs.false333, %if.else507, %if.then504, %do.end, %if.then395, %if.then390, %sw.default, %entry, %entry, %entry, %entry, %entry, %if.then716, %if.end703, %if.end691, %if.end679, %sw.bb661, %sw.bb659, %if.end657, %if.end652, %sw.bb646, %sw.bb644, %sw.bb642, %if.end641, %if.end548, %if.end294, %sw.bb171, %sw.bb169, %while.end, %sw.bb142, %Perl_get_sv.exit
  %retval.0 = phi i8* [ %add.ptr717, %if.then716 ], [ %incdec.ptr704, %if.end703 ], [ %incdec.ptr692, %if.end691 ], [ %incdec.ptr680, %if.end679 ], [ %incdec.ptr662, %sw.bb661 ], [ %incdec.ptr660, %sw.bb659 ], [ %incdec.ptr658, %if.end657 ], [ %incdec.ptr653, %if.end652 ], [ %incdec.ptr648, %sw.bb646 ], [ %incdec.ptr645, %sw.bb644 ], [ %incdec.ptr643, %sw.bb642 ], [ %117, %if.end641 ], [ %98, %if.end548 ], [ %51, %if.end294 ], [ %incdec.ptr172, %sw.bb171 ], [ %incdec.ptr170, %sw.bb169 ], [ %30, %while.end ], [ %24, %sw.bb142 ], [ %add.ptr141, %Perl_get_sv.exit ], [ null, %entry ], [ null, %entry ], [ null, %entry ], [ null, %entry ], [ null, %entry ], [ null, %sw.default ], [ %73, %if.then390 ], [ %incdec.ptr396, %if.then395 ], [ %p.1, %do.end ], [ %incdec.ptr505, %if.then504 ], [ %.pre862, %if.else507 ], [ %storemerge790, %lor.lhs.false333 ], [ %71, %for.cond359 ]
  ret i8* %retval.0
}

declare i64 @Perl_grok_hex(i8*, i64*, i64*, double*) #3

declare i8* @Perl_sv_grow(%struct.sv*, i64) #3

declare i64 @Perl_grok_oct(i8*, i64*, i64*, double*) #3

declare void @Perl_sv_setsv_flags(%struct.sv*, %struct.sv*, i64) #3

declare i32 @parse_unicode_opts(...) #3

declare i32 @forbid_setid(...) #3

declare void @Perl_sv_catpvn_flags(%struct.sv*, i8*, i64, i64) #3

; Function Attrs: nounwind readonly
declare i64 @strlen(i8* nocapture) #6

declare i32 @init_debugger(...) #3

declare i32 @usage(...) #3

declare i8* @Perl_savepvn(i8*, i64) #3

declare i32 @incpush(...) #3

declare %struct.sv* @Perl_newSVsv(%struct.sv*) #3

declare void @Perl_av_push(%struct.av*, %struct.sv*) #3

declare %struct._PerlIO** @Perl_PerlIO_stdout() #3

declare i8* @Perl_form(i8*, ...) #3

; Function Attrs: nounwind readnone uwtable
define void @Perl_my_unexec() #4 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define signext i8 @Perl_doing_taint(i32 %argc, i8** nocapture readonly %argv, i8** nocapture readnone %envp) #0 {
entry:
  %call = tail call i32 @getuid() #2
  %call1 = tail call i32 @geteuid() #2
  %call2 = tail call i32 @getgid() #2
  %call3 = tail call i32 @getegid() #2
  %tobool = icmp eq i32 %call, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %cmp = icmp eq i32 %call1, %call
  %cmp4 = icmp eq i32 %call3, %call2
  %or.cond = and i1 %cmp, %cmp4
  br i1 %or.cond, label %if.end, label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %cmp5 = icmp sgt i32 %argc, 1
  br i1 %cmp5, label %land.lhs.true6, label %if.end23

land.lhs.true6:                                   ; preds = %if.end
  %arrayidx = getelementptr inbounds i8** %argv, i64 1
  %0 = load i8** %arrayidx, align 8, !tbaa !1
  %1 = load i8* %0, align 1, !tbaa !27
  %cmp8 = icmp eq i8 %1, 45
  br i1 %cmp8, label %land.lhs.true10, label %if.end23

land.lhs.true10:                                  ; preds = %land.lhs.true6
  %arrayidx12 = getelementptr inbounds i8* %0, i64 1
  %2 = load i8* %arrayidx12, align 1, !tbaa !27
  switch i8 %2, label %if.end23 [
    i8 116, label %return
    i8 84, label %return
  ]

if.end23:                                         ; preds = %land.lhs.true10, %land.lhs.true6, %if.end
  br label %return

return:                                           ; preds = %land.lhs.true10, %land.lhs.true10, %land.lhs.true, %if.end23
  %retval.0 = phi i8 [ 0, %if.end23 ], [ 1, %land.lhs.true ], [ 1, %land.lhs.true10 ], [ 1, %land.lhs.true10 ]
  ret i8 %retval.0
}

declare i32 @getuid() #3

declare i32 @geteuid() #3

declare i32 @getgid() #3

declare i32 @getegid() #3

; Function Attrs: nounwind uwtable
define void @Perl_init_debugger() #0 {
entry:
  %0 = load %struct.hv** @PL_curstash, align 8, !tbaa !1
  %1 = load %struct.hv** @PL_debstash, align 8, !tbaa !1
  store %struct.hv* %1, %struct.hv** @PL_curstash, align 8, !tbaa !1
  %call = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([9 x i8]* @.str45, i64 0, i64 0), i64 2, i64 10) #2
  %call1 = tail call %struct.gv* @Perl_gv_AVadd(%struct.gv* %call) #2
  %sv_any = getelementptr inbounds %struct.gv* %call1, i64 0, i32 0
  %2 = load %struct.xpvgv** %sv_any, align 8, !tbaa !65
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %2, i64 0, i32 7
  %3 = load %struct.gp** %xgv_gp, align 8, !tbaa !67
  %gp_av = getelementptr inbounds %struct.gp* %3, i64 0, i32 4
  %4 = load %struct.av** %gp_av, align 8, !tbaa !78
  store %struct.av* %4, %struct.av** @PL_dbargs, align 8, !tbaa !1
  %sv_any2 = getelementptr inbounds %struct.av* %4, i64 0, i32 0
  %5 = load %struct.xpvav** %sv_any2, align 8, !tbaa !14
  %xav_flags = getelementptr inbounds %struct.xpvav* %5, i64 0, i32 9
  %6 = load i8* %xav_flags, align 1, !tbaa !48
  %and = and i8 %6, -2
  store i8 %and, i8* %xav_flags, align 1, !tbaa !48
  %call4 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([7 x i8]* @.str46, i64 0, i64 0), i64 2, i64 13) #2
  store %struct.gv* %call4, %struct.gv** @PL_DBgv, align 8, !tbaa !1
  %call5 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([11 x i8]* @.str47, i64 0, i64 0), i64 2, i64 10) #2
  store %struct.gv* %call5, %struct.gv** @PL_DBline, align 8, !tbaa !1
  %call6 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([8 x i8]* @.str48, i64 0, i64 0), i64 2, i64 11) #2
  %call7 = tail call %struct.gv* @Perl_gv_HVadd(%struct.gv* %call6) #2
  store %struct.gv* %call7, %struct.gv** @PL_DBsub, align 8, !tbaa !1
  %sv_any8 = getelementptr inbounds %struct.gv* %call7, i64 0, i32 0
  %7 = load %struct.xpvgv** %sv_any8, align 8, !tbaa !65
  %xgv_gp9 = getelementptr inbounds %struct.xpvgv* %7, i64 0, i32 7
  %8 = load %struct.gp** %xgv_gp9, align 8, !tbaa !67
  %gp_sv = getelementptr inbounds %struct.gp* %8, i64 0, i32 0
  %9 = load %struct.sv** %gp_sv, align 8, !tbaa !69
  %call10 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %9, i64 1) #2
  %call11 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([11 x i8]* @.str49, i64 0, i64 0), i64 2, i64 4) #2
  %sv_any12 = getelementptr inbounds %struct.gv* %call11, i64 0, i32 0
  %10 = load %struct.xpvgv** %sv_any12, align 8, !tbaa !65
  %xgv_gp13 = getelementptr inbounds %struct.xpvgv* %10, i64 0, i32 7
  %11 = load %struct.gp** %xgv_gp13, align 8, !tbaa !67
  %gp_sv14 = getelementptr inbounds %struct.gp* %11, i64 0, i32 0
  %12 = load %struct.sv** %gp_sv14, align 8, !tbaa !69
  store %struct.sv* %12, %struct.sv** @PL_DBsingle, align 8, !tbaa !1
  tail call void @Perl_sv_setiv(%struct.sv* %12, i64 0) #2
  %call15 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([10 x i8]* @.str50, i64 0, i64 0), i64 2, i64 4) #2
  %sv_any16 = getelementptr inbounds %struct.gv* %call15, i64 0, i32 0
  %13 = load %struct.xpvgv** %sv_any16, align 8, !tbaa !65
  %xgv_gp17 = getelementptr inbounds %struct.xpvgv* %13, i64 0, i32 7
  %14 = load %struct.gp** %xgv_gp17, align 8, !tbaa !67
  %gp_sv18 = getelementptr inbounds %struct.gp* %14, i64 0, i32 0
  %15 = load %struct.sv** %gp_sv18, align 8, !tbaa !69
  store %struct.sv* %15, %struct.sv** @PL_DBtrace, align 8, !tbaa !1
  tail call void @Perl_sv_setiv(%struct.sv* %15, i64 0) #2
  %call19 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([11 x i8]* @.str51, i64 0, i64 0), i64 2, i64 4) #2
  %sv_any20 = getelementptr inbounds %struct.gv* %call19, i64 0, i32 0
  %16 = load %struct.xpvgv** %sv_any20, align 8, !tbaa !65
  %xgv_gp21 = getelementptr inbounds %struct.xpvgv* %16, i64 0, i32 7
  %17 = load %struct.gp** %xgv_gp21, align 8, !tbaa !67
  %gp_sv22 = getelementptr inbounds %struct.gp* %17, i64 0, i32 0
  %18 = load %struct.sv** %gp_sv22, align 8, !tbaa !69
  store %struct.sv* %18, %struct.sv** @PL_DBsignal, align 8, !tbaa !1
  tail call void @Perl_sv_setiv(%struct.sv* %18, i64 0) #2
  store %struct.hv* %0, %struct.hv** @PL_curstash, align 8, !tbaa !1
  ret void
}

declare void @Perl_sv_setiv(%struct.sv*, i64) #3

declare i8* @Perl_safesysmalloc(i64) #3

; Function Attrs: nounwind uwtable
define void @Perl_init_argv_symbols(i32 %argc, i8** nocapture readonly %argv) #0 {
entry:
  %dec = add nsw i32 %argc, -1
  %incdec.ptr = getelementptr inbounds i8** %argv, i64 1
  %0 = load i8* @PL_doswitches, align 1, !tbaa !27
  %tobool = icmp ne i8 %0, 0
  %cmp = icmp sgt i32 %dec, 0
  %or.cond = and i1 %tobool, %cmp
  br i1 %or.cond, label %land.rhs, label %if.end33

land.rhs:                                         ; preds = %entry, %for.inc
  %argv.addr.0 = phi i8** [ %incdec.ptr32, %for.inc ], [ %incdec.ptr, %entry ]
  %argc.addr.0 = phi i32 [ %dec31, %for.inc ], [ %dec, %entry ]
  %1 = load i8** %argv.addr.0, align 8, !tbaa !1
  %2 = load i8* %1, align 1, !tbaa !27
  %cmp1 = icmp eq i8 %2, 45
  br i1 %cmp1, label %for.body, label %if.end33

for.body:                                         ; preds = %land.rhs
  %arrayidx3 = getelementptr inbounds i8* %1, i64 1
  %3 = load i8* %arrayidx3, align 1, !tbaa !27
  switch i8 %3, label %if.end17 [
    i8 0, label %if.end33
    i8 45, label %land.lhs.true
  ]

land.lhs.true:                                    ; preds = %for.body
  %arrayidx12 = getelementptr inbounds i8* %1, i64 2
  %4 = load i8* %arrayidx12, align 1, !tbaa !27
  %tobool13 = icmp eq i8 %4, 0
  br i1 %tobool13, label %if.then14, label %if.end17

if.then14:                                        ; preds = %land.lhs.true
  %dec15 = add nsw i32 %argc.addr.0, -1
  %incdec.ptr16 = getelementptr inbounds i8** %argv.addr.0, i64 1
  br label %if.end33

if.end17:                                         ; preds = %for.body, %land.lhs.true
  %call = tail call i8* @strchr(i8* %1, i32 61) #2
  %tobool19 = icmp eq i8* %call, null
  br i1 %tobool19, label %if.else, label %if.then20

if.then20:                                        ; preds = %if.end17
  %incdec.ptr21 = getelementptr inbounds i8* %call, i64 1
  store i8 0, i8* %call, align 1, !tbaa !27
  %5 = load i8** %argv.addr.0, align 8, !tbaa !1
  %add.ptr = getelementptr inbounds i8* %5, i64 1
  %call23 = tail call %struct.gv* @Perl_gv_fetchpv(i8* %add.ptr, i64 1, i64 4) #2
  %sv_any = getelementptr inbounds %struct.gv* %call23, i64 0, i32 0
  %6 = load %struct.xpvgv** %sv_any, align 8, !tbaa !65
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %6, i64 0, i32 7
  %7 = load %struct.gp** %xgv_gp, align 8, !tbaa !67
  %gp_sv = getelementptr inbounds %struct.gp* %7, i64 0, i32 0
  %8 = load %struct.sv** %gp_sv, align 8, !tbaa !69
  tail call void @Perl_sv_setpv(%struct.sv* %8, i8* %incdec.ptr21) #2
  br label %for.inc

if.else:                                          ; preds = %if.end17
  %call26 = tail call %struct.gv* @Perl_gv_fetchpv(i8* %arrayidx3, i64 1, i64 4) #2
  %sv_any27 = getelementptr inbounds %struct.gv* %call26, i64 0, i32 0
  %9 = load %struct.xpvgv** %sv_any27, align 8, !tbaa !65
  %xgv_gp28 = getelementptr inbounds %struct.xpvgv* %9, i64 0, i32 7
  %10 = load %struct.gp** %xgv_gp28, align 8, !tbaa !67
  %gp_sv29 = getelementptr inbounds %struct.gp* %10, i64 0, i32 0
  %11 = load %struct.sv** %gp_sv29, align 8, !tbaa !69
  tail call void @Perl_sv_setiv(%struct.sv* %11, i64 1) #2
  br label %for.inc

for.inc:                                          ; preds = %if.then20, %if.else
  %dec31 = add nsw i32 %argc.addr.0, -1
  %incdec.ptr32 = getelementptr inbounds i8** %argv.addr.0, i64 1
  %cmp.old = icmp sgt i32 %dec31, 0
  br i1 %cmp.old, label %land.rhs, label %if.end33

if.end33:                                         ; preds = %for.body, %land.rhs, %for.inc, %if.then14, %entry
  %argv.addr.1 = phi i8** [ %incdec.ptr16, %if.then14 ], [ %incdec.ptr, %entry ], [ %argv.addr.0, %for.body ], [ %argv.addr.0, %land.rhs ], [ %incdec.ptr32, %for.inc ]
  %argc.addr.1 = phi i32 [ %dec15, %if.then14 ], [ %dec, %entry ], [ %argc.addr.0, %for.body ], [ %argc.addr.0, %land.rhs ], [ %dec31, %for.inc ]
  %call34 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([5 x i8]* @.str52, i64 0, i64 0), i64 1, i64 10) #2
  store %struct.gv* %call34, %struct.gv** @PL_argvgv, align 8, !tbaa !1
  %tobool35 = icmp eq %struct.gv* %call34, null
  br i1 %tobool35, label %if.end91, label %if.then36

if.then36:                                        ; preds = %if.end33
  %sv_any37 = getelementptr inbounds %struct.gv* %call34, i64 0, i32 0
  %12 = load %struct.xpvgv** %sv_any37, align 8, !tbaa !65
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %12, i64 0, i32 11
  %13 = load i8* %xgv_flags, align 1, !tbaa !120
  %or = or i8 %13, 2
  store i8 %or, i8* %xgv_flags, align 1, !tbaa !120
  %call40 = tail call %struct.gv* @Perl_gv_AVadd(%struct.gv* %call34) #2
  %14 = load %struct.gv** @PL_argvgv, align 8, !tbaa !1
  %sv_any41 = getelementptr inbounds %struct.gv* %14, i64 0, i32 0
  %15 = load %struct.xpvgv** %sv_any41, align 8, !tbaa !65
  %xgv_gp42 = getelementptr inbounds %struct.xpvgv* %15, i64 0, i32 7
  %16 = load %struct.gp** %xgv_gp42, align 8, !tbaa !67
  %gp_av = getelementptr inbounds %struct.gp* %16, i64 0, i32 4
  %17 = load %struct.av** %gp_av, align 8, !tbaa !78
  %tobool43 = icmp eq %struct.av* %17, null
  br i1 %tobool43, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.then36
  %call47 = tail call %struct.gv* @Perl_gv_AVadd(%struct.gv* %14) #2
  %sv_any48 = getelementptr inbounds %struct.gv* %call47, i64 0, i32 0
  %18 = load %struct.xpvgv** %sv_any48, align 8, !tbaa !65
  %xgv_gp49 = getelementptr inbounds %struct.xpvgv* %18, i64 0, i32 7
  %19 = load %struct.gp** %xgv_gp49, align 8, !tbaa !67
  %gp_av50 = getelementptr inbounds %struct.gp* %19, i64 0, i32 4
  %20 = load %struct.av** %gp_av50, align 8, !tbaa !78
  br label %cond.end

cond.end:                                         ; preds = %if.then36, %cond.false
  %cond = phi %struct.av* [ %20, %cond.false ], [ %17, %if.then36 ]
  tail call void @Perl_av_clear(%struct.av* %cond) #2
  %cmp52116 = icmp sgt i32 %argc.addr.1, 0
  br i1 %cmp52116, label %for.body54, label %if.end91

for.body54:                                       ; preds = %cond.end, %for.inc87
  %argc.addr.2118 = phi i32 [ %dec88, %for.inc87 ], [ %argc.addr.1, %cond.end ]
  %argv.addr.2117 = phi i8** [ %incdec.ptr89, %for.inc87 ], [ %argv.addr.1, %cond.end ]
  %21 = load i8** %argv.addr.2117, align 8, !tbaa !1
  %call56 = tail call %struct.sv* @Perl_newSVpv(i8* %21, i64 0) #2
  %22 = load %struct.gv** @PL_argvgv, align 8, !tbaa !1
  %sv_any57 = getelementptr inbounds %struct.gv* %22, i64 0, i32 0
  %23 = load %struct.xpvgv** %sv_any57, align 8, !tbaa !65
  %xgv_gp58 = getelementptr inbounds %struct.xpvgv* %23, i64 0, i32 7
  %24 = load %struct.gp** %xgv_gp58, align 8, !tbaa !67
  %gp_av59 = getelementptr inbounds %struct.gp* %24, i64 0, i32 4
  %25 = load %struct.av** %gp_av59, align 8, !tbaa !78
  %tobool60 = icmp eq %struct.av* %25, null
  br i1 %tobool60, label %cond.false65, label %cond.end70

cond.false65:                                     ; preds = %for.body54
  %call66 = tail call %struct.gv* @Perl_gv_AVadd(%struct.gv* %22) #2
  %sv_any67 = getelementptr inbounds %struct.gv* %call66, i64 0, i32 0
  %26 = load %struct.xpvgv** %sv_any67, align 8, !tbaa !65
  %xgv_gp68 = getelementptr inbounds %struct.xpvgv* %26, i64 0, i32 7
  %27 = load %struct.gp** %xgv_gp68, align 8, !tbaa !67
  %gp_av69 = getelementptr inbounds %struct.gp* %27, i64 0, i32 4
  %28 = load %struct.av** %gp_av69, align 8, !tbaa !78
  br label %cond.end70

cond.end70:                                       ; preds = %for.body54, %cond.false65
  %cond71 = phi %struct.av* [ %28, %cond.false65 ], [ %25, %for.body54 ]
  tail call void @Perl_av_push(%struct.av* %cond71, %struct.sv* %call56) #2
  %29 = load i64* @PL_unicode, align 8, !tbaa !20
  %and = and i64 %29, 64
  %tobool72 = icmp ne i64 %and, 0
  %30 = load i8* @PL_utf8locale, align 1
  %tobool74 = icmp eq i8 %30, 0
  %or.cond112 = and i1 %tobool72, %tobool74
  %and76 = and i64 %29, 32
  %tobool77 = icmp eq i64 %and76, 0
  %or.cond113 = or i1 %or.cond112, %tobool77
  br i1 %or.cond113, label %if.end81, label %if.then78

if.then78:                                        ; preds = %cond.end70
  %sv_flags = getelementptr inbounds %struct.sv* %call56, i64 0, i32 2
  %31 = load i64* %sv_flags, align 8, !tbaa !7
  %or79 = or i64 %31, 536870912
  store i64 %or79, i64* %sv_flags, align 8, !tbaa !7
  %.pre = load i64* @PL_unicode, align 8, !tbaa !20
  br label %if.end81

if.end81:                                         ; preds = %cond.end70, %if.then78
  %32 = phi i64 [ %29, %cond.end70 ], [ %.pre, %if.then78 ]
  %and82 = and i64 %32, 128
  %tobool83 = icmp eq i64 %and82, 0
  br i1 %tobool83, label %for.inc87, label %if.then84

if.then84:                                        ; preds = %if.end81
  %call85 = tail call signext i8 @Perl_sv_utf8_decode(%struct.sv* %call56) #2
  br label %for.inc87

for.inc87:                                        ; preds = %if.end81, %if.then84
  %dec88 = add nsw i32 %argc.addr.2118, -1
  %incdec.ptr89 = getelementptr inbounds i8** %argv.addr.2117, i64 1
  %cmp52 = icmp sgt i32 %dec88, 0
  br i1 %cmp52, label %for.body54, label %if.end91

if.end91:                                         ; preds = %for.inc87, %cond.end, %if.end33
  ret void
}

; Function Attrs: nounwind readonly
declare i8* @strchr(i8*, i32) #6

declare void @Perl_av_clear(%struct.av*) #3

declare signext i8 @Perl_sv_utf8_decode(%struct.sv*) #3

declare i64 @Perl_mg_size(%struct.sv*) #3

declare %struct.sv* @Perl_av_shift(%struct.av*) #3

declare void @Perl_save_freesv(%struct.sv*) #3

declare i32 @call_list_body(...) #3

declare void @Perl_sv_catpvf(%struct.sv*, i8*, ...) #3

; Function Attrs: noreturn
declare void @siglongjmp(%struct.__jmp_buf_tag*, i32) #7

; Function Attrs: noreturn
declare void @exit(i32) #7

; Function Attrs: nounwind uwtable
define void @Perl_my_failure_exit() #0 {
entry:
  %call = tail call i32* @__errno_location() #2
  %0 = load i32* %call, align 4, !tbaa !5
  %and = and i32 %0, 255
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call1 = tail call i32* @__errno_location() #2
  %1 = load i32* %call1, align 4, !tbaa !5
  %conv = sext i32 %1 to i64
  store i64 %conv, i64* @PL_statusvalue, align 8, !tbaa !20
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %if.end22, label %if.then3

if.then3:                                         ; preds = %if.then
  %and4 = and i64 %conv, 65535
  store i64 %and4, i64* @PL_statusvalue, align 8, !tbaa !20
  br label %if.end22

if.else:                                          ; preds = %entry
  %2 = load i64* @PL_statusvalue, align 8, !tbaa !20
  %shr25 = lshr i64 %2, 8
  %and6 = and i64 %shr25, 255
  %tobool7 = icmp eq i64 %and6, 0
  br i1 %tobool7, label %if.else15, label %if.then8

if.then8:                                         ; preds = %if.else
  %sext = shl i64 %shr25, 32
  %conv9 = ashr exact i64 %sext, 32
  store i64 %conv9, i64* @PL_statusvalue, align 8, !tbaa !20
  %cmp10 = icmp eq i64 %conv9, -1
  br i1 %cmp10, label %if.end22, label %if.then12

if.then12:                                        ; preds = %if.then8
  %and13 = and i64 %conv9, 65535
  store i64 %and13, i64* @PL_statusvalue, align 8, !tbaa !20
  br label %if.end22

if.else15:                                        ; preds = %if.else
  store i64 255, i64* @PL_statusvalue, align 8, !tbaa !20
  br label %if.end22

if.end22:                                         ; preds = %if.then, %if.then8, %if.then12, %if.else15, %if.then3
  %call23 = tail call i32 (...)* @my_exit_jump() #2
  ret void
}

declare i32* @__errno_location() #3

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind }
attributes #3 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { returns_twice "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { noreturn "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nounwind returns_twice }
attributes #9 = { noreturn nounwind }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5 (trunk)"}
!1 = metadata !{metadata !2, metadata !2, i64 0}
!2 = metadata !{metadata !"any pointer", metadata !3, i64 0}
!3 = metadata !{metadata !"omnipotent char", metadata !4, i64 0}
!4 = metadata !{metadata !"Simple C/C++ TBAA"}
!5 = metadata !{metadata !6, metadata !6, i64 0}
!6 = metadata !{metadata !"int", metadata !3, i64 0}
!7 = metadata !{metadata !8, metadata !9, i64 16}
!8 = metadata !{metadata !"sv", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16}
!9 = metadata !{metadata !"long", metadata !3, i64 0}
!10 = metadata !{metadata !8, metadata !9, i64 8}
!11 = metadata !{metadata !12, metadata !9, i64 32}
!12 = metadata !{metadata !"stackinfo", metadata !2, i64 0, metadata !2, i64 8, metadata !9, i64 16, metadata !9, i64 24, metadata !9, i64 32, metadata !2, i64 40, metadata !2, i64 48, metadata !9, i64 56}
!13 = metadata !{metadata !12, metadata !2, i64 0}
!14 = metadata !{metadata !15, metadata !2, i64 0}
!15 = metadata !{metadata !"av", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16}
!16 = metadata !{metadata !17, metadata !2, i64 0}
!17 = metadata !{metadata !"xpvav", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16, metadata !9, i64 24, metadata !18, i64 32, metadata !2, i64 40, metadata !2, i64 48, metadata !2, i64 56, metadata !2, i64 64, metadata !3, i64 72}
!18 = metadata !{metadata !"double", metadata !3, i64 0}
!19 = metadata !{metadata !17, metadata !9, i64 16}
!20 = metadata !{metadata !9, metadata !9, i64 0}
!21 = metadata !{metadata !22, metadata !6, i64 208}
!22 = metadata !{metadata !"jmpenv", metadata !3, i64 0, metadata !2, i64 200, metadata !6, i64 208, metadata !3, i64 212}
!23 = metadata !{metadata !22, metadata !3, i64 212}
!24 = metadata !{metadata !8, metadata !2, i64 0}
!25 = metadata !{metadata !26, metadata !2, i64 0}
!26 = metadata !{metadata !"xpv", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16}
!27 = metadata !{metadata !3, metadata !3, i64 0}
!28 = metadata !{metadata !26, metadata !9, i64 8}
!29 = metadata !{metadata !30, metadata !18, i64 32}
!30 = metadata !{metadata !"xpvnv", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16, metadata !9, i64 24, metadata !18, i64 32}
!31 = metadata !{metadata !32, metadata !9, i64 16}
!32 = metadata !{metadata !"hv", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16}
!33 = metadata !{metadata !22, metadata !2, i64 200}
!34 = metadata !{metadata !35, metadata !2, i64 0}
!35 = metadata !{metadata !"cv", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16}
!36 = metadata !{metadata !37, metadata !2, i64 120}
!37 = metadata !{metadata !"xpvcv", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16, metadata !9, i64 24, metadata !18, i64 32, metadata !2, i64 40, metadata !2, i64 48, metadata !2, i64 56, metadata !2, i64 64, metadata !2, i64 72, metadata !2, i64 80, metadata !3, i64 88, metadata !2, i64 96, metadata !2, i64 104, metadata !9, i64 112, metadata !2, i64 120, metadata !2, i64 128, metadata !38, i64 136, metadata !9, i64 144}
!38 = metadata !{metadata !"short", metadata !3, i64 0}
!39 = metadata !{metadata !40, metadata !2, i64 0}
!40 = metadata !{metadata !"exitlistentry", metadata !2, i64 0, metadata !2, i64 8}
!41 = metadata !{metadata !40, metadata !2, i64 8}
!42 = metadata !{metadata !43, metadata !2, i64 88}
!43 = metadata !{metadata !"cop", metadata !2, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !9, i64 24, metadata !38, i64 32, metadata !38, i64 34, metadata !3, i64 36, metadata !3, i64 37, metadata !2, i64 40, metadata !2, i64 48, metadata !2, i64 56, metadata !9, i64 64, metadata !9, i64 72, metadata !9, i64 80, metadata !2, i64 88, metadata !2, i64 96}
!44 = metadata !{metadata !43, metadata !2, i64 96}
!45 = metadata !{metadata !43, metadata !2, i64 56}
!46 = metadata !{metadata !12, metadata !9, i64 16}
!47 = metadata !{metadata !15, metadata !9, i64 16}
!48 = metadata !{metadata !17, metadata !3, i64 72}
!49 = metadata !{metadata !32, metadata !2, i64 0}
!50 = metadata !{metadata !51, metadata !9, i64 16}
!51 = metadata !{metadata !"xpvhv", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16, metadata !9, i64 24, metadata !18, i64 32, metadata !2, i64 40, metadata !2, i64 48, metadata !9, i64 56, metadata !2, i64 64, metadata !2, i64 72, metadata !2, i64 80}
!52 = metadata !{metadata !53, metadata !2, i64 16}
!53 = metadata !{metadata !"he", metadata !2, i64 0, metadata !2, i64 8, metadata !2, i64 16}
!54 = metadata !{metadata !53, metadata !2, i64 8}
!55 = metadata !{metadata !53, metadata !2, i64 0}
!56 = metadata !{metadata !57, metadata !2, i64 40}
!57 = metadata !{metadata !"xpvmg", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16, metadata !9, i64 24, metadata !18, i64 32, metadata !2, i64 40, metadata !2, i64 48}
!58 = metadata !{metadata !59, metadata !2, i64 0}
!59 = metadata !{metadata !"magic", metadata !2, i64 0, metadata !2, i64 8, metadata !38, i64 16, metadata !3, i64 18, metadata !3, i64 19, metadata !2, i64 24, metadata !2, i64 32, metadata !9, i64 40}
!60 = metadata !{metadata !59, metadata !2, i64 32}
!61 = metadata !{metadata !59, metadata !3, i64 18}
!62 = metadata !{metadata !59, metadata !9, i64 40}
!63 = metadata !{metadata !43, metadata !9, i64 80}
!64 = metadata !{metadata !17, metadata !9, i64 8}
!65 = metadata !{metadata !66, metadata !2, i64 0}
!66 = metadata !{metadata !"gv", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16}
!67 = metadata !{metadata !68, metadata !2, i64 56}
!68 = metadata !{metadata !"xpvgv", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16, metadata !9, i64 24, metadata !18, i64 32, metadata !2, i64 40, metadata !2, i64 48, metadata !2, i64 56, metadata !2, i64 64, metadata !9, i64 72, metadata !2, i64 80, metadata !3, i64 88}
!69 = metadata !{metadata !70, metadata !2, i64 0}
!70 = metadata !{metadata !"gp", metadata !2, i64 0, metadata !9, i64 8, metadata !2, i64 16, metadata !2, i64 24, metadata !2, i64 32, metadata !2, i64 40, metadata !2, i64 48, metadata !2, i64 56, metadata !9, i64 64, metadata !9, i64 72, metadata !9, i64 80, metadata !2, i64 88}
!71 = metadata !{metadata !66, metadata !9, i64 16}
!72 = metadata !{metadata !70, metadata !2, i64 16}
!73 = metadata !{metadata !74, metadata !2, i64 0}
!74 = metadata !{metadata !"io", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16}
!75 = metadata !{metadata !76, metadata !2, i64 64}
!76 = metadata !{metadata !"xpvio", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16, metadata !9, i64 24, metadata !18, i64 32, metadata !2, i64 40, metadata !2, i64 48, metadata !2, i64 56, metadata !2, i64 64, metadata !3, i64 72, metadata !9, i64 80, metadata !9, i64 88, metadata !9, i64 96, metadata !9, i64 104, metadata !2, i64 112, metadata !2, i64 120, metadata !2, i64 128, metadata !2, i64 136, metadata !2, i64 144, metadata !2, i64 152, metadata !38, i64 160, metadata !3, i64 162, metadata !3, i64 163}
!77 = metadata !{metadata !12, metadata !2, i64 40}
!78 = metadata !{metadata !70, metadata !2, i64 32}
!79 = metadata !{metadata !70, metadata !2, i64 40}
!80 = metadata !{metadata !70, metadata !9, i64 64}
!81 = metadata !{metadata !70, metadata !2, i64 56}
!82 = metadata !{metadata !83, metadata !2, i64 0}
!83 = metadata !{metadata !"logop", metadata !2, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !9, i64 24, metadata !38, i64 32, metadata !38, i64 34, metadata !3, i64 36, metadata !3, i64 37, metadata !2, i64 40, metadata !2, i64 48}
!84 = metadata !{metadata !83, metadata !3, i64 36}
!85 = metadata !{metadata !37, metadata !2, i64 56}
!86 = metadata !{metadata !87, metadata !3, i64 37}
!87 = metadata !{metadata !"op", metadata !2, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !9, i64 24, metadata !38, i64 32, metadata !38, i64 34, metadata !3, i64 36, metadata !3, i64 37}
!88 = metadata !{metadata !89, metadata !2, i64 0}
!89 = metadata !{metadata !"unop", metadata !2, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !9, i64 24, metadata !38, i64 32, metadata !38, i64 34, metadata !3, i64 36, metadata !3, i64 37, metadata !2, i64 40}
!90 = metadata !{metadata !89, metadata !2, i64 16}
!91 = metadata !{metadata !83, metadata !2, i64 16}
!92 = metadata !{metadata !83, metadata !2, i64 48}
!93 = metadata !{metadata !87, metadata !3, i64 36}
!94 = metadata !{metadata !12, metadata !9, i64 24}
!95 = metadata !{metadata !12, metadata !2, i64 8}
!96 = metadata !{metadata !97, metadata !9, i64 0}
!97 = metadata !{metadata !"context", metadata !9, i64 0, metadata !3, i64 8}
!98 = metadata !{metadata !99, metadata !9, i64 0}
!99 = metadata !{metadata !"block", metadata !9, i64 0, metadata !2, i64 8, metadata !9, i64 16, metadata !9, i64 24, metadata !9, i64 32, metadata !2, i64 40, metadata !3, i64 48, metadata !3, i64 56}
!100 = metadata !{metadata !99, metadata !2, i64 8}
!101 = metadata !{metadata !99, metadata !9, i64 24}
!102 = metadata !{metadata !99, metadata !9, i64 32}
!103 = metadata !{metadata !99, metadata !9, i64 16}
!104 = metadata !{metadata !99, metadata !2, i64 40}
!105 = metadata !{metadata !99, metadata !3, i64 48}
!106 = metadata !{metadata !107, metadata !9, i64 0}
!107 = metadata !{metadata !"block_eval", metadata !9, i64 0, metadata !9, i64 8, metadata !2, i64 16, metadata !2, i64 24, metadata !2, i64 32, metadata !2, i64 40}
!108 = metadata !{metadata !87, metadata !38, i64 32}
!109 = metadata !{metadata !107, metadata !9, i64 8}
!110 = metadata !{metadata !107, metadata !2, i64 16}
!111 = metadata !{metadata !107, metadata !2, i64 24}
!112 = metadata !{metadata !107, metadata !2, i64 32}
!113 = metadata !{metadata !107, metadata !2, i64 40}
!114 = metadata !{metadata !89, metadata !3, i64 36}
!115 = metadata !{metadata !89, metadata !38, i64 32}
!116 = metadata !{metadata !117, metadata !9, i64 24}
!117 = metadata !{metadata !"xpviv", metadata !2, i64 0, metadata !9, i64 8, metadata !9, i64 16, metadata !9, i64 24}
!118 = metadata !{metadata !12, metadata !2, i64 48}
!119 = metadata !{metadata !26, metadata !9, i64 16}
!120 = metadata !{metadata !68, metadata !3, i64 88}
