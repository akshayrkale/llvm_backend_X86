; ModuleID = 'HiRes.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.sv = type { i8*, i64, i64 }
%struct.op = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8 }
%struct.timeval = type { i64, i64 }
%struct.fd_set = type { [16 x i64] }
%struct.cv = type { %struct.xpvcv*, i64, i64 }
%struct.xpvcv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.hv*, %struct.op*, %struct.op*, {}*, %union.any, %struct.gv*, i8*, i64, %struct.av*, %struct.cv*, i16, i64 }
%struct.magic = type { %struct.magic*, %struct.mgvtbl*, i16, i8, i8, %struct.sv*, i8*, i64 }
%struct.mgvtbl = type { i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i64 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)*, i32 (%struct.magic*, %struct.clone_params*)* }
%struct.clone_params = type { %struct.av*, i64, %struct.interpreter* }
%struct.interpreter = type { i8 }
%struct.hv = type { %struct.xpvhv*, i64, i64 }
%struct.xpvhv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, i64, %struct.he*, %struct.pmop*, i8* }
%struct.he = type { %struct.he*, %struct.hek*, %struct.sv* }
%struct.hek = type { i64, i64, [1 x i8] }
%struct.pmop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.pmop*, %struct.regexp*, i64, i64, i8, %struct.hv* }
%struct.regexp = type { i64*, i64*, %struct.regnode*, %struct.reg_substr_data*, i8*, %struct.reg_data*, i8*, i64*, i64, i64, i64, i64, i64, i64, i64, i64, [1 x %struct.regnode] }
%struct.regnode = type { i8, i8, i16 }
%struct.reg_substr_data = type opaque
%struct.reg_data = type opaque
%union.any = type { i8* }
%struct.gv = type { %struct.xpvgv*, i64, i64 }
%struct.xpvgv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.gp*, i8*, i64, %struct.hv*, i8 }
%struct.gp = type { %struct.sv*, i64, %struct.io*, %struct.cv*, %struct.av*, %struct.hv*, %struct.gv*, %struct.cv*, i64, i64, i64, i8* }
%struct.io = type { %struct.xpvio*, i64, i64 }
%struct.xpvio = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct._PerlIO**, %struct._PerlIO**, %union.anon, i64, i64, i64, i64, i8*, %struct.gv*, i8*, %struct.gv*, i8*, %struct.gv*, i16, i8, i8 }
%struct._PerlIO = type opaque
%union.anon = type { %struct.__dirstream* }
%struct.__dirstream = type opaque
%struct.av = type { %struct.xpvav*, i64, i64 }
%struct.xpvav = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.sv**, %struct.sv*, i8 }

@PL_stack_sp = external global %struct.sv**
@PL_stack_base = external global %struct.sv**
@PL_markstack_ptr = external global i64*
@.str = private unnamed_addr constant [33 x i8] c"Usage: Time::HiRes::constant(sv)\00", align 1
@PL_op = external global %struct.op*
@PL_curpad = external global %struct.sv**
@.str1 = private unnamed_addr constant [36 x i8] c"%s is not a valid Time::HiRes macro\00", align 1
@.str2 = private unnamed_addr constant [55 x i8] c"Your vendor has not defined Time::HiRes macro %s, used\00", align 1
@PL_stack_max = external global %struct.sv**
@PL_sv_undef = external global %struct.sv
@.str4 = private unnamed_addr constant [37 x i8] c"Usage: Time::HiRes::usleep(useconds)\00", align 1
@.str5 = private unnamed_addr constant [56 x i8] c"Time::HiRes::usleep(%g): negative time not invented yet\00", align 1
@.str6 = private unnamed_addr constant [79 x i8] c"Time::HiRes::sleep(%g): internal error: useconds < 0 (unsigned %lu signed %ld)\00", align 1
@.str7 = private unnamed_addr constant [55 x i8] c"Time::HiRes::sleep(%g): negative time not invented yet\00", align 1
@.str8 = private unnamed_addr constant [35 x i8] c"Usage: Time::HiRes::gettimeofday()\00", align 1
@.str9 = private unnamed_addr constant [27 x i8] c"Usage: Time::HiRes::time()\00", align 1
@.str10 = private unnamed_addr constant [8 x i8] c"HiRes.c\00", align 1
@.str11 = private unnamed_addr constant [22 x i8] c"Time::HiRes::constant\00", align 1
@.str12 = private unnamed_addr constant [2 x i8] c"$\00", align 1
@.str13 = private unnamed_addr constant [20 x i8] c"Time::HiRes::usleep\00", align 1
@.str14 = private unnamed_addr constant [19 x i8] c"Time::HiRes::sleep\00", align 1
@.str15 = private unnamed_addr constant [3 x i8] c";@\00", align 1
@.str16 = private unnamed_addr constant [26 x i8] c"Time::HiRes::gettimeofday\00", align 1
@.str17 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str18 = private unnamed_addr constant [18 x i8] c"Time::HiRes::time\00", align 1
@PL_sv_yes = external global %struct.sv
@.str19 = private unnamed_addr constant [8 x i8] c"d_ualar\00", align 1
@.str20 = private unnamed_addr constant [8 x i8] c"d_uslee\00", align 1
@.str21 = private unnamed_addr constant [15 x i8] c"ITIMER_VIRTUAL\00", align 1
@.str22 = private unnamed_addr constant [15 x i8] c"d_gettimeofday\00", align 1
@.str23 = private unnamed_addr constant [16 x i8] c"ITIMER_REALPROF\00", align 1
@.str24 = private unnamed_addr constant [12 x i8] c"ITIMER_PROF\00", align 1
@.str25 = private unnamed_addr constant [12 x i8] c"ITIMER_REAL\00", align 1
@.str26 = private unnamed_addr constant [12 x i8] c"d_getitimer\00", align 1
@.str27 = private unnamed_addr constant [12 x i8] c"d_setitimer\00", align 1
@.str28 = private unnamed_addr constant [12 x i8] c"d_nanosleep\00", align 1

; Function Attrs: nounwind uwtable
define void @hrt_usleep(i64 %usec) #0 {
entry:
  %tv = alloca %struct.timeval, align 8
  %tv_sec = getelementptr inbounds %struct.timeval* %tv, i64 0, i32 0
  store i64 0, i64* %tv_sec, align 8, !tbaa !1
  %tv_usec = getelementptr inbounds %struct.timeval* %tv, i64 0, i32 1
  store i64 %usec, i64* %tv_usec, align 8, !tbaa !6
  %call = call i32 @select(i32 0, %struct.fd_set* null, %struct.fd_set* null, %struct.fd_set* null, %struct.timeval* %tv) #4
  ret void
}

declare i32 @select(i32, %struct.fd_set*, %struct.fd_set*, %struct.fd_set*, %struct.timeval*) #1

; Function Attrs: nounwind uwtable
define void @XS_Time__HiRes_constant(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !7
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !7
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !7
  %3 = load i64* %2, align 8, !tbaa !9
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %sub.ptr.div4 = ashr exact i64 %sub.ptr.sub3, 3
  %cmp = icmp eq i64 %sub.ptr.div4, 1
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([33 x i8]* @.str, i64 0, i64 0)) #4
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %idx.neg = sub i64 0, %sub.ptr.div4
  %add.ptr5 = getelementptr inbounds %struct.sv** %0, i64 %idx.neg
  %4 = load %struct.op** @PL_op, align 8, !tbaa !7
  %op_private = getelementptr inbounds %struct.op* %4, i64 0, i32 7
  %5 = load i8* %op_private, align 1, !tbaa !10
  %and = and i8 %5, 32
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %op_targ = getelementptr inbounds %struct.op* %4, i64 0, i32 3
  %6 = load i64* %op_targ, align 8, !tbaa !13
  %7 = load %struct.sv*** @PL_curpad, align 8, !tbaa !7
  %arrayidx = getelementptr inbounds %struct.sv** %7, i64 %6
  %8 = load %struct.sv** %arrayidx, align 8, !tbaa !7
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = call %struct.sv* @Perl_sv_newmortal() #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %8, %cond.true ], [ %call, %cond.false ]
  %9 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  %arrayidx7 = getelementptr inbounds %struct.sv** %9, i64 %add
  %10 = load %struct.sv** %arrayidx7, align 8, !tbaa !7
  %sv_flags = getelementptr inbounds %struct.sv* %10, i64 0, i32 2
  %11 = load i64* %sv_flags, align 8, !tbaa !14
  %and8 = and i64 %11, 262144
  %cmp9 = icmp eq i64 %and8, 0
  br i1 %cmp9, label %cond.false13, label %cond.true11

cond.true11:                                      ; preds = %cond.end
  %sv_any = getelementptr inbounds %struct.sv* %10, i64 0, i32 0
  %12 = load i8** %sv_any, align 8, !tbaa !16
  %xpv_cur = getelementptr inbounds i8* %12, i64 8
  %13 = bitcast i8* %xpv_cur to i64*
  %14 = load i64* %13, align 8, !tbaa !17
  store i64 %14, i64* %len, align 8, !tbaa !9
  %xpv_pv = bitcast i8* %12 to i8**
  %15 = load i8** %xpv_pv, align 8, !tbaa !19
  br label %cond.end15

cond.false13:                                     ; preds = %cond.end
  %call14 = call i8* @Perl_sv_2pv_flags(%struct.sv* %10, i64* %len, i64 2) #4
  %.pr = load i64* %len, align 8, !tbaa !9
  br label %cond.end15

cond.end15:                                       ; preds = %cond.false13, %cond.true11
  %16 = phi i64 [ %.pr, %cond.false13 ], [ %14, %cond.true11 ]
  %cond16 = phi i8* [ %call14, %cond.false13 ], [ %15, %cond.true11 ]
  switch i64 %16, label %sw.bb [
    i64 8, label %sw.bb.i
    i64 11, label %sw.bb7.i
    i64 14, label %sw.bb9.i
    i64 15, label %sw.bb23.i
  ]

sw.bb.i:                                          ; preds = %cond.end15
  %arrayidx.i = getelementptr inbounds i8* %cond16, i64 7
  %17 = load i8* %arrayidx.i, align 1, !tbaa !20
  %conv.i = sext i8 %17 to i32
  switch i32 %conv.i, label %sw.bb [
    i32 109, label %sw.bb1.i
    i32 112, label %sw.bb2.i
  ]

sw.bb1.i:                                         ; preds = %sw.bb.i
  %call.i = call i32 @memcmp(i8* %cond16, i8* getelementptr inbounds ([8 x i8]* @.str19, i64 0, i64 0), i64 7) #4
  %tobool.i = icmp eq i32 %call.i, 0
  br i1 %tobool.i, label %sw.bb25, label %sw.bb

sw.bb2.i:                                         ; preds = %sw.bb.i
  %call3.i = call i32 @memcmp(i8* %cond16, i8* getelementptr inbounds ([8 x i8]* @.str20, i64 0, i64 0), i64 7) #4
  %tobool4.i = icmp eq i32 %call3.i, 0
  br i1 %tobool4.i, label %sw.bb25, label %sw.bb

sw.bb7.i:                                         ; preds = %cond.end15
  %arrayidx.i.i = getelementptr inbounds i8* %cond16, i64 7
  %18 = load i8* %arrayidx.i.i, align 1, !tbaa !20
  %conv.i.i = sext i8 %18 to i32
  switch i32 %conv.i.i, label %sw.bb [
    i32 80, label %sw.bb.i.i
    i32 82, label %sw.bb1.i.i
    i32 105, label %sw.bb6.i.i
    i32 108, label %sw.bb15.i.i
  ]

sw.bb.i.i:                                        ; preds = %sw.bb7.i
  %call.i.i = call i32 @memcmp(i8* %cond16, i8* getelementptr inbounds ([12 x i8]* @.str24, i64 0, i64 0), i64 11) #4
  %tobool.i.i = icmp eq i32 %call.i.i, 0
  br i1 %tobool.i.i, label %sw.bb25, label %sw.bb

sw.bb1.i.i:                                       ; preds = %sw.bb7.i
  %call2.i.i = call i32 @memcmp(i8* %cond16, i8* getelementptr inbounds ([12 x i8]* @.str25, i64 0, i64 0), i64 11) #4
  %tobool3.i.i = icmp eq i32 %call2.i.i, 0
  br i1 %tobool3.i.i, label %sw.bb25, label %sw.bb

sw.bb6.i.i:                                       ; preds = %sw.bb7.i
  %call7.i.i = call i32 @memcmp(i8* %cond16, i8* getelementptr inbounds ([12 x i8]* @.str26, i64 0, i64 0), i64 11) #4
  %tobool8.i.i = icmp eq i32 %call7.i.i, 0
  br i1 %tobool8.i.i, label %sw.bb25, label %if.end10.i.i

if.end10.i.i:                                     ; preds = %sw.bb6.i.i
  %call11.i.i = call i32 @memcmp(i8* %cond16, i8* getelementptr inbounds ([12 x i8]* @.str27, i64 0, i64 0), i64 11) #4
  %tobool12.i.i = icmp eq i32 %call11.i.i, 0
  br i1 %tobool12.i.i, label %sw.bb25, label %sw.bb

sw.bb15.i.i:                                      ; preds = %sw.bb7.i
  %call16.i.i = call i32 @memcmp(i8* %cond16, i8* getelementptr inbounds ([12 x i8]* @.str28, i64 0, i64 0), i64 11) #4
  %tobool17.i.i = icmp eq i32 %call16.i.i, 0
  br i1 %tobool17.i.i, label %sw.bb25, label %sw.bb

sw.bb9.i:                                         ; preds = %cond.end15
  %arrayidx10.i = getelementptr inbounds i8* %cond16, i64 6
  %19 = load i8* %arrayidx10.i, align 1, !tbaa !20
  %conv11.i = sext i8 %19 to i32
  switch i32 %conv11.i, label %sw.bb [
    i32 95, label %sw.bb12.i
    i32 105, label %sw.bb17.i
  ]

sw.bb12.i:                                        ; preds = %sw.bb9.i
  %call13.i = call i32 @memcmp(i8* %cond16, i8* getelementptr inbounds ([15 x i8]* @.str21, i64 0, i64 0), i64 14) #4
  %tobool14.i = icmp eq i32 %call13.i, 0
  br i1 %tobool14.i, label %sw.bb25, label %sw.bb

sw.bb17.i:                                        ; preds = %sw.bb9.i
  %call18.i = call i32 @memcmp(i8* %cond16, i8* getelementptr inbounds ([15 x i8]* @.str22, i64 0, i64 0), i64 14) #4
  %tobool19.i = icmp eq i32 %call18.i, 0
  br i1 %tobool19.i, label %sw.bb25, label %sw.bb

sw.bb23.i:                                        ; preds = %cond.end15
  %call24.i = call i32 @memcmp(i8* %cond16, i8* getelementptr inbounds ([16 x i8]* @.str23, i64 0, i64 0), i64 15) #4
  %tobool25.i = icmp eq i32 %call24.i, 0
  br i1 %tobool25.i, label %sw.bb21, label %sw.bb

sw.bb:                                            ; preds = %cond.end15, %sw.bb.i, %sw.bb1.i, %sw.bb2.i, %sw.bb9.i, %sw.bb12.i, %sw.bb17.i, %sw.bb23.i, %sw.bb.i.i, %sw.bb1.i.i, %if.end10.i.i, %sw.bb15.i.i, %sw.bb7.i
  %call18 = call %struct.sv* (i8*, ...)* @Perl_newSVpvf(i8* getelementptr inbounds ([36 x i8]* @.str1, i64 0, i64 0), i8* %cond16) #4
  %call19 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call18) #4
  %add.ptr5.sum70 = sub i64 1, %sub.ptr.div4
  %incdec.ptr20 = getelementptr inbounds %struct.sv** %0, i64 %add.ptr5.sum70
  store %struct.sv* %call19, %struct.sv** %incdec.ptr20, align 8, !tbaa !7
  br label %sw.epilog

sw.bb21:                                          ; preds = %sw.bb23.i
  %call22 = call %struct.sv* (i8*, ...)* @Perl_newSVpvf(i8* getelementptr inbounds ([55 x i8]* @.str2, i64 0, i64 0), i8* %cond16) #4
  %call23 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call22) #4
  %add.ptr5.sum = sub i64 1, %sub.ptr.div4
  %incdec.ptr24 = getelementptr inbounds %struct.sv** %0, i64 %add.ptr5.sum
  store %struct.sv* %call23, %struct.sv** %incdec.ptr24, align 8, !tbaa !7
  br label %sw.epilog

sw.bb25:                                          ; preds = %sw.bb15.i.i, %if.end10.i.i, %sw.bb1.i.i, %sw.bb.i.i, %sw.bb1.i, %sw.bb2.i, %sw.bb6.i.i, %sw.bb12.i, %sw.bb17.i
  %iv.0.load72.ph = phi i64 [ 0, %sw.bb1.i ], [ 0, %sw.bb2.i ], [ 0, %sw.bb6.i.i ], [ 1, %sw.bb12.i ], [ 1, %sw.bb17.i ], [ 2, %sw.bb.i.i ], [ 0, %sw.bb1.i.i ], [ 0, %if.end10.i.i ], [ 0, %sw.bb15.i.i ]
  %20 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !7
  %sub.ptr.lhs.cast26 = ptrtoint %struct.sv** %20 to i64
  %sub.ptr.rhs.cast27 = ptrtoint %struct.sv** %add.ptr5 to i64
  %sub.ptr.sub28 = sub i64 %sub.ptr.lhs.cast26, %sub.ptr.rhs.cast27
  %cmp30 = icmp slt i64 %sub.ptr.sub28, 8
  br i1 %cmp30, label %if.then32, label %if.end34

if.then32:                                        ; preds = %sw.bb25
  %call33 = call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr5, %struct.sv** %add.ptr5, i32 1) #4
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %sw.bb25
  %sp.0 = phi %struct.sv** [ %call33, %if.then32 ], [ %add.ptr5, %sw.bb25 ]
  %incdec.ptr35 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr35, align 8, !tbaa !7
  call void @Perl_sv_setiv(%struct.sv* %cond, i64 %iv.0.load72.ph) #4
  %sv_flags36 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %21 = load i64* %sv_flags36, align 8, !tbaa !14
  %and37 = and i64 %21, 16384
  %tobool38 = icmp eq i64 %and37, 0
  br i1 %tobool38, label %if.end41, label %if.then39

if.then39:                                        ; preds = %if.end34
  %call40 = call i32 @Perl_mg_set(%struct.sv* %cond) #4
  br label %if.end41

if.end41:                                         ; preds = %if.end34, %if.then39
  %incdec.ptr42 = getelementptr inbounds %struct.sv** %sp.0, i64 2
  store %struct.sv* %cond, %struct.sv** %incdec.ptr42, align 8, !tbaa !7
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end41, %sw.bb21, %sw.bb
  %sp.1 = phi %struct.sv** [ %incdec.ptr42, %if.end41 ], [ %incdec.ptr24, %sw.bb21 ], [ %incdec.ptr20, %sw.bb ]
  store %struct.sv** %sp.1, %struct.sv*** @PL_stack_sp, align 8, !tbaa !7
  ret void
}

declare void @Perl_croak(i8*, ...) #1

declare %struct.sv* @Perl_sv_newmortal() #1

declare i8* @Perl_sv_2pv_flags(%struct.sv*, i64*, i64) #1

declare %struct.sv* @Perl_sv_2mortal(%struct.sv*) #1

declare %struct.sv* @Perl_newSVpvf(i8*, ...) #1

declare %struct.sv** @Perl_stack_grow(%struct.sv**, %struct.sv**, i32) #1

declare void @Perl_sv_setiv(%struct.sv*, i64) #1

declare i32 @Perl_mg_set(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define void @XS_Time__HiRes_usleep(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %tv.i = alloca %struct.timeval, align 8
  %Ta = alloca %struct.timeval, align 8
  %Tb = alloca %struct.timeval, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !7
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !7
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !7
  %3 = load i64* %2, align 8, !tbaa !9
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp eq i64 %sub.ptr.sub3, 8
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([37 x i8]* @.str4, i64 0, i64 0)) #4
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !7
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i64* %sv_flags, align 8, !tbaa !14
  %and = and i64 %6, 131072
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %7 = load i8** %sv_any, align 8, !tbaa !16
  %xnv_nv = getelementptr inbounds i8* %7, i64 32
  %8 = bitcast i8* %xnv_nv to double*
  %9 = load double* %8, align 8, !tbaa !21
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = call double @Perl_sv_2nv(%struct.sv* %5) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %9, %cond.true ], [ %call, %cond.false ]
  %10 = load %struct.op** @PL_op, align 8, !tbaa !7
  %op_private = getelementptr inbounds %struct.op* %10, i64 0, i32 7
  %11 = load i8* %op_private, align 1, !tbaa !10
  %and10 = and i8 %11, 32
  %tobool11 = icmp eq i8 %and10, 0
  br i1 %tobool11, label %cond.false14, label %cond.true12

cond.true12:                                      ; preds = %cond.end
  %op_targ = getelementptr inbounds %struct.op* %10, i64 0, i32 3
  %12 = load i64* %op_targ, align 8, !tbaa !13
  %13 = load %struct.sv*** @PL_curpad, align 8, !tbaa !7
  %arrayidx13 = getelementptr inbounds %struct.sv** %13, i64 %12
  %14 = load %struct.sv** %arrayidx13, align 8, !tbaa !7
  br label %cond.end16

cond.false14:                                     ; preds = %cond.end
  %call15 = call %struct.sv* @Perl_sv_newmortal() #4
  br label %cond.end16

cond.end16:                                       ; preds = %cond.false14, %cond.true12
  %cond17 = phi %struct.sv* [ %14, %cond.true12 ], [ %call15, %cond.false14 ]
  %call18 = call i32 @gettimeofday(%struct.timeval* %Ta, i8* null) #4
  %cmp19 = icmp sgt i64 %sub.ptr.sub3, 0
  br i1 %cmp19, label %if.then21, label %if.else38

if.then21:                                        ; preds = %cond.end16
  %cmp22 = fcmp ogt double %cond, 1.000000e+06
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %if.then21
  %div = fdiv double %cond, 1.000000e+06
  %conv25 = fptosi double %div to i64
  %tobool26 = icmp eq i64 %conv25, 0
  br i1 %tobool26, label %if.end36, label %if.then27

if.then27:                                        ; preds = %if.then24
  %conv28 = trunc i64 %conv25 to i32
  %call29 = call i32 @sleep(i32 %conv28) #4
  %conv30 = sitofp i64 %conv25 to double
  %mul = fmul double %conv30, 1.000000e+06
  %sub = fsub double %cond, %mul
  br label %if.end36

if.else:                                          ; preds = %if.then21
  %cmp32 = fcmp olt double %cond, 0.000000e+00
  br i1 %cmp32, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.else
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([56 x i8]* @.str5, i64 0, i64 0), double %cond) #4
  br label %if.end36

if.end36:                                         ; preds = %if.then24, %if.else, %if.then34, %if.then27
  %useconds.0 = phi double [ %sub, %if.then27 ], [ %cond, %if.then24 ], [ %cond, %if.then34 ], [ %cond, %if.else ]
  %conv37 = fptoui double %useconds.0 to i64
  %15 = bitcast %struct.timeval* %tv.i to i8*
  call void @llvm.lifetime.start(i64 16, i8* %15) #4
  %tv_sec.i = getelementptr inbounds %struct.timeval* %tv.i, i64 0, i32 0
  store i64 0, i64* %tv_sec.i, align 8, !tbaa !1
  %tv_usec.i = getelementptr inbounds %struct.timeval* %tv.i, i64 0, i32 1
  store i64 %conv37, i64* %tv_usec.i, align 8, !tbaa !6
  %call.i = call i32 @select(i32 0, %struct.fd_set* null, %struct.fd_set* null, %struct.fd_set* null, %struct.timeval* %tv.i) #4
  call void @llvm.lifetime.end(i64 16, i8* %15) #4
  br label %if.end40

if.else38:                                        ; preds = %cond.end16
  %call39 = call i32 @sleep(i32 2147450879) #4
  br label %if.end40

if.end40:                                         ; preds = %if.else38, %if.end36
  %call41 = call i32 @gettimeofday(%struct.timeval* %Tb, i8* null) #4
  %tv_sec = getelementptr inbounds %struct.timeval* %Tb, i64 0, i32 0
  %16 = load i64* %tv_sec, align 8, !tbaa !1
  %tv_sec42 = getelementptr inbounds %struct.timeval* %Ta, i64 0, i32 0
  %17 = load i64* %tv_sec42, align 8, !tbaa !1
  %sub43 = sub nsw i64 %16, %17
  %conv44 = sitofp i64 %sub43 to double
  %mul45 = fmul double %conv44, 1.000000e+06
  %tv_usec = getelementptr inbounds %struct.timeval* %Tb, i64 0, i32 1
  %18 = load i64* %tv_usec, align 8, !tbaa !6
  %tv_usec46 = getelementptr inbounds %struct.timeval* %Ta, i64 0, i32 1
  %19 = load i64* %tv_usec46, align 8, !tbaa !6
  %sub47 = sub nsw i64 %18, %19
  %conv48 = sitofp i64 %sub47 to double
  %add49 = fadd double %mul45, %conv48
  %20 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  call void @Perl_sv_setnv(%struct.sv* %cond17, double %add49) #4
  %sv_flags52 = getelementptr inbounds %struct.sv* %cond17, i64 0, i32 2
  %21 = load i64* %sv_flags52, align 8, !tbaa !14
  %and53 = and i64 %21, 16384
  %tobool54 = icmp eq i64 %and53, 0
  br i1 %tobool54, label %if.end57, label %if.then55

if.then55:                                        ; preds = %if.end40
  %call56 = call i32 @Perl_mg_set(%struct.sv* %cond17) #4
  br label %if.end57

if.end57:                                         ; preds = %if.end40, %if.then55
  %incdec.ptr58 = getelementptr inbounds %struct.sv** %20, i64 %add
  store %struct.sv* %cond17, %struct.sv** %incdec.ptr58, align 8, !tbaa !7
  %22 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  %add.ptr60 = getelementptr inbounds %struct.sv** %22, i64 %add
  store %struct.sv** %add.ptr60, %struct.sv*** @PL_stack_sp, align 8, !tbaa !7
  ret void
}

declare double @Perl_sv_2nv(%struct.sv*) #1

; Function Attrs: nounwind
declare i32 @gettimeofday(%struct.timeval* nocapture, i8* nocapture) #2

declare i32 @sleep(i32) #1

declare void @Perl_sv_setnv(%struct.sv*, double) #1

; Function Attrs: nounwind uwtable
define void @XS_Time__HiRes_sleep(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %tv.i = alloca %struct.timeval, align 8
  %Ta = alloca %struct.timeval, align 8
  %Tb = alloca %struct.timeval, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !7
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !7
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !7
  %3 = load i64* %2, align 8, !tbaa !9
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %4 = load %struct.op** @PL_op, align 8, !tbaa !7
  %op_private = getelementptr inbounds %struct.op* %4, i64 0, i32 7
  %5 = load i8* %op_private, align 1, !tbaa !10
  %and = and i8 %5, 32
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %4, i64 0, i32 3
  %6 = load i64* %op_targ, align 8, !tbaa !13
  %7 = load %struct.sv*** @PL_curpad, align 8, !tbaa !7
  %arrayidx = getelementptr inbounds %struct.sv** %7, i64 %6
  %8 = load %struct.sv** %arrayidx, align 8, !tbaa !7
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call %struct.sv* @Perl_sv_newmortal() #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %8, %cond.true ], [ %call, %cond.false ]
  %call5 = call i32 @gettimeofday(%struct.timeval* %Ta, i8* null) #4
  %cmp = icmp sgt i64 %sub.ptr.sub3, 0
  br i1 %cmp, label %if.then, label %if.else41

if.then:                                          ; preds = %cond.end
  %9 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  %arrayidx8 = getelementptr inbounds %struct.sv** %9, i64 %add
  %10 = load %struct.sv** %arrayidx8, align 8, !tbaa !7
  %sv_flags = getelementptr inbounds %struct.sv* %10, i64 0, i32 2
  %11 = load i64* %sv_flags, align 8, !tbaa !14
  %and9 = and i64 %11, 131072
  %tobool10 = icmp eq i64 %and9, 0
  br i1 %tobool10, label %cond.false14, label %cond.true11

cond.true11:                                      ; preds = %if.then
  %sv_any = getelementptr inbounds %struct.sv* %10, i64 0, i32 0
  %12 = load i8** %sv_any, align 8, !tbaa !16
  %xnv_nv = getelementptr inbounds i8* %12, i64 32
  %13 = bitcast i8* %xnv_nv to double*
  %14 = load double* %13, align 8, !tbaa !21
  br label %cond.end18

cond.false14:                                     ; preds = %if.then
  %call17 = call double @Perl_sv_2nv(%struct.sv* %10) #4
  br label %cond.end18

cond.end18:                                       ; preds = %cond.false14, %cond.true11
  %cond19 = phi double [ %14, %cond.true11 ], [ %call17, %cond.false14 ]
  %cmp20 = fcmp ult double %cond19, 0.000000e+00
  br i1 %cmp20, label %if.else, label %if.then22

if.then22:                                        ; preds = %cond.end18
  %conv23 = fptoui double %cond19 to i64
  %conv24 = uitofp i64 %conv23 to double
  %sub = fsub double %cond19, %conv24
  %mul = fmul double %sub, 1.000000e+06
  %conv25 = fptoui double %mul to i64
  %cmp26 = fcmp ult double %cond19, 1.000000e+00
  br i1 %cmp26, label %if.end, label %if.then28

if.then28:                                        ; preds = %if.then22
  %conv30 = trunc i64 %conv23 to i32
  %call31 = call i32 @sleep(i32 %conv30) #4
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then28
  %cmp32 = icmp slt i64 %conv25, 0
  br i1 %cmp32, label %if.then37, label %if.end39

if.then37:                                        ; preds = %if.end
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([79 x i8]* @.str6, i64 0, i64 0), double %cond19, i64 %conv25, i64 %conv25) #4
  br label %if.end39

if.end39:                                         ; preds = %if.then37, %if.end
  %15 = bitcast %struct.timeval* %tv.i to i8*
  call void @llvm.lifetime.start(i64 16, i8* %15) #4
  %tv_sec.i = getelementptr inbounds %struct.timeval* %tv.i, i64 0, i32 0
  store i64 0, i64* %tv_sec.i, align 8, !tbaa !1
  %tv_usec.i = getelementptr inbounds %struct.timeval* %tv.i, i64 0, i32 1
  store i64 %conv25, i64* %tv_usec.i, align 8, !tbaa !6
  %call.i = call i32 @select(i32 0, %struct.fd_set* null, %struct.fd_set* null, %struct.fd_set* null, %struct.timeval* %tv.i) #4
  call void @llvm.lifetime.end(i64 16, i8* %15) #4
  br label %if.end43

if.else:                                          ; preds = %cond.end18
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([55 x i8]* @.str7, i64 0, i64 0), double %cond19) #4
  br label %if.end43

if.else41:                                        ; preds = %cond.end
  %call42 = call i32 @sleep(i32 2147450879) #4
  br label %if.end43

if.end43:                                         ; preds = %if.end39, %if.else, %if.else41
  %call44 = call i32 @gettimeofday(%struct.timeval* %Tb, i8* null) #4
  %tv_sec = getelementptr inbounds %struct.timeval* %Tb, i64 0, i32 0
  %16 = load i64* %tv_sec, align 8, !tbaa !1
  %tv_sec45 = getelementptr inbounds %struct.timeval* %Ta, i64 0, i32 0
  %17 = load i64* %tv_sec45, align 8, !tbaa !1
  %sub46 = sub nsw i64 %16, %17
  %conv47 = sitofp i64 %sub46 to double
  %tv_usec = getelementptr inbounds %struct.timeval* %Tb, i64 0, i32 1
  %18 = load i64* %tv_usec, align 8, !tbaa !6
  %tv_usec48 = getelementptr inbounds %struct.timeval* %Ta, i64 0, i32 1
  %19 = load i64* %tv_usec48, align 8, !tbaa !6
  %sub49 = sub nsw i64 %18, %19
  %conv50 = sitofp i64 %sub49 to double
  %mul51 = fmul double %conv50, 1.000000e-06
  %add52 = fadd double %conv47, %mul51
  %20 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  call void @Perl_sv_setnv(%struct.sv* %cond, double %add52) #4
  %sv_flags55 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %21 = load i64* %sv_flags55, align 8, !tbaa !14
  %and56 = and i64 %21, 16384
  %tobool57 = icmp eq i64 %and56, 0
  br i1 %tobool57, label %if.end60, label %if.then58

if.then58:                                        ; preds = %if.end43
  %call59 = call i32 @Perl_mg_set(%struct.sv* %cond) #4
  br label %if.end60

if.end60:                                         ; preds = %if.end43, %if.then58
  %incdec.ptr61 = getelementptr inbounds %struct.sv** %20, i64 %add
  store %struct.sv* %cond, %struct.sv** %incdec.ptr61, align 8, !tbaa !7
  %22 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  %add.ptr63 = getelementptr inbounds %struct.sv** %22, i64 %add
  store %struct.sv** %add.ptr63, %struct.sv*** @PL_stack_sp, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind uwtable
define void @XS_Time__HiRes_gettimeofday(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %Tp = alloca %struct.timeval, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !7
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !7
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !7
  %3 = load i64* %2, align 8, !tbaa !9
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %sub.ptr.div4 = ashr exact i64 %sub.ptr.sub3, 3
  %cmp = icmp eq i64 %sub.ptr.div4, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([35 x i8]* @.str8, i64 0, i64 0)) #4
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %idx.neg = sub i64 0, %sub.ptr.div4
  %add.ptr5 = getelementptr inbounds %struct.sv** %0, i64 %idx.neg
  %call = call i32 @gettimeofday(%struct.timeval* %Tp, i8* null) #4
  %4 = load %struct.op** @PL_op, align 8, !tbaa !7
  %op_flags = getelementptr inbounds %struct.op* %4, i64 0, i32 6
  %5 = load i8* %op_flags, align 1, !tbaa !24
  %conv = zext i8 %5 to i32
  %and = and i32 %conv, 3
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %cmp9 = icmp eq i32 %and, 3
  %conv11 = zext i1 %cmp9 to i64
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call12 = tail call i64 @Perl_dowantarray() #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond13 = phi i64 [ %conv11, %cond.true ], [ %call12, %cond.false ]
  %cmp14 = icmp eq i64 %cond13, 1
  %6 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !7
  %sub.ptr.lhs.cast17 = ptrtoint %struct.sv** %6 to i64
  %sub.ptr.rhs.cast18 = ptrtoint %struct.sv** %add.ptr5 to i64
  %sub.ptr.sub19 = sub i64 %sub.ptr.lhs.cast17, %sub.ptr.rhs.cast18
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %cond.end
  %cmp21 = icmp slt i64 %sub.ptr.sub19, 16
  br i1 %cmp21, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.then16
  %call24 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr5, %struct.sv** %add.ptr5, i32 2) #4
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.then16
  %sp.0 = phi %struct.sv** [ %call24, %if.then23 ], [ %add.ptr5, %if.then16 ]
  %tv_sec = getelementptr inbounds %struct.timeval* %Tp, i64 0, i32 0
  %7 = load i64* %tv_sec, align 8, !tbaa !1
  %call26 = tail call %struct.sv* @Perl_newSViv(i64 %7) #4
  %call27 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call26) #4
  %incdec.ptr28 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %call27, %struct.sv** %incdec.ptr28, align 8, !tbaa !7
  %tv_usec = getelementptr inbounds %struct.timeval* %Tp, i64 0, i32 1
  %8 = load i64* %tv_usec, align 8, !tbaa !6
  %call29 = tail call %struct.sv* @Perl_newSViv(i64 %8) #4
  %call30 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call29) #4
  %incdec.ptr31 = getelementptr inbounds %struct.sv** %sp.0, i64 2
  store %struct.sv* %call30, %struct.sv** %incdec.ptr31, align 8, !tbaa !7
  br label %if.end49

if.else:                                          ; preds = %cond.end
  %cmp36 = icmp slt i64 %sub.ptr.sub19, 8
  br i1 %cmp36, label %if.then38, label %if.end40

if.then38:                                        ; preds = %if.else
  %call39 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr5, %struct.sv** %add.ptr5, i32 1) #4
  br label %if.end40

if.end40:                                         ; preds = %if.then38, %if.else
  %sp.1 = phi %struct.sv** [ %call39, %if.then38 ], [ %add.ptr5, %if.else ]
  %tv_sec41 = getelementptr inbounds %struct.timeval* %Tp, i64 0, i32 0
  %9 = load i64* %tv_sec41, align 8, !tbaa !1
  %conv42 = sitofp i64 %9 to double
  %tv_usec43 = getelementptr inbounds %struct.timeval* %Tp, i64 0, i32 1
  %10 = load i64* %tv_usec43, align 8, !tbaa !6
  %conv44 = sitofp i64 %10 to double
  %div = fdiv double %conv44, 1.000000e+06
  %add45 = fadd double %conv42, %div
  %call46 = tail call %struct.sv* @Perl_newSVnv(double %add45) #4
  %call47 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call46) #4
  %incdec.ptr48 = getelementptr inbounds %struct.sv** %sp.1, i64 1
  store %struct.sv* %call47, %struct.sv** %incdec.ptr48, align 8, !tbaa !7
  br label %if.end49

if.end49:                                         ; preds = %if.end40, %if.end25
  %sp.2 = phi %struct.sv** [ %incdec.ptr31, %if.end25 ], [ %incdec.ptr48, %if.end40 ]
  store %struct.sv** %sp.2, %struct.sv*** @PL_stack_sp, align 8, !tbaa !7
  ret void
}

declare i64 @Perl_dowantarray() #1

declare %struct.sv* @Perl_newSViv(i64) #1

declare %struct.sv* @Perl_newSVnv(double) #1

; Function Attrs: nounwind uwtable
define void @XS_Time__HiRes_time(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %Tp = alloca %struct.timeval, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !7
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !7
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !7
  %3 = load i64* %2, align 8, !tbaa !9
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add i64 %sub.ptr.div, 1
  %cmp = icmp eq %struct.sv** %0, %add.ptr
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([27 x i8]* @.str9, i64 0, i64 0)) #4
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = load %struct.op** @PL_op, align 8, !tbaa !7
  %op_private = getelementptr inbounds %struct.op* %4, i64 0, i32 7
  %5 = load i8* %op_private, align 1, !tbaa !10
  %and = and i8 %5, 32
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %op_targ = getelementptr inbounds %struct.op* %4, i64 0, i32 3
  %6 = load i64* %op_targ, align 8, !tbaa !13
  %7 = load %struct.sv*** @PL_curpad, align 8, !tbaa !7
  %arrayidx = getelementptr inbounds %struct.sv** %7, i64 %6
  %8 = load %struct.sv** %arrayidx, align 8, !tbaa !7
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = tail call %struct.sv* @Perl_sv_newmortal() #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %8, %cond.true ], [ %call, %cond.false ]
  %call5 = call i32 @gettimeofday(%struct.timeval* %Tp, i8* null) #4
  %tv_sec = getelementptr inbounds %struct.timeval* %Tp, i64 0, i32 0
  %9 = load i64* %tv_sec, align 8, !tbaa !1
  %conv6 = sitofp i64 %9 to double
  %tv_usec = getelementptr inbounds %struct.timeval* %Tp, i64 0, i32 1
  %10 = load i64* %tv_usec, align 8, !tbaa !6
  %conv7 = sitofp i64 %10 to double
  %div = fdiv double %conv7, 1.000000e+06
  %add8 = fadd double %conv6, %div
  %11 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  tail call void @Perl_sv_setnv(%struct.sv* %cond, double %add8) #4
  %sv_flags = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %12 = load i64* %sv_flags, align 8, !tbaa !14
  %and11 = and i64 %12, 16384
  %tobool12 = icmp eq i64 %and11, 0
  br i1 %tobool12, label %if.end15, label %if.then13

if.then13:                                        ; preds = %cond.end
  %call14 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #4
  br label %if.end15

if.end15:                                         ; preds = %cond.end, %if.then13
  %incdec.ptr16 = getelementptr inbounds %struct.sv** %11, i64 %add
  store %struct.sv* %cond, %struct.sv** %incdec.ptr16, align 8, !tbaa !7
  %13 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  %add.ptr18 = getelementptr inbounds %struct.sv** %13, i64 %add
  store %struct.sv** %add.ptr18, %struct.sv*** @PL_stack_sp, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind uwtable
define void @boot_Time__HiRes(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load i64** @PL_markstack_ptr, align 8, !tbaa !7
  %incdec.ptr = getelementptr inbounds i64* %0, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !7
  %1 = load i64* %0, align 8, !tbaa !9
  %add.ptr.idx = shl nuw i64 %1, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %call = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([22 x i8]* @.str11, i64 0, i64 0), void (%struct.cv*)* @XS_Time__HiRes_constant, i8* getelementptr inbounds ([8 x i8]* @.str10, i64 0, i64 0)) #4
  %2 = bitcast %struct.cv* %call to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %2, i8* getelementptr inbounds ([2 x i8]* @.str12, i64 0, i64 0)) #4
  %call5 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([20 x i8]* @.str13, i64 0, i64 0), void (%struct.cv*)* @XS_Time__HiRes_usleep, i8* getelementptr inbounds ([8 x i8]* @.str10, i64 0, i64 0)) #4
  %3 = bitcast %struct.cv* %call5 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %3, i8* getelementptr inbounds ([2 x i8]* @.str12, i64 0, i64 0)) #4
  %call6 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([19 x i8]* @.str14, i64 0, i64 0), void (%struct.cv*)* @XS_Time__HiRes_sleep, i8* getelementptr inbounds ([8 x i8]* @.str10, i64 0, i64 0)) #4
  %4 = bitcast %struct.cv* %call6 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %4, i8* getelementptr inbounds ([3 x i8]* @.str15, i64 0, i64 0)) #4
  %call7 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([26 x i8]* @.str16, i64 0, i64 0), void (%struct.cv*)* @XS_Time__HiRes_gettimeofday, i8* getelementptr inbounds ([8 x i8]* @.str10, i64 0, i64 0)) #4
  %5 = bitcast %struct.cv* %call7 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %5, i8* getelementptr inbounds ([1 x i8]* @.str17, i64 0, i64 0)) #4
  %call8 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([18 x i8]* @.str18, i64 0, i64 0), void (%struct.cv*)* @XS_Time__HiRes_time, i8* getelementptr inbounds ([8 x i8]* @.str10, i64 0, i64 0)) #4
  %6 = bitcast %struct.cv* %call8 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %6, i8* getelementptr inbounds ([1 x i8]* @.str17, i64 0, i64 0)) #4
  %7 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  %arrayidx = getelementptr inbounds %struct.sv** %7, i64 %add
  store %struct.sv* @PL_sv_yes, %struct.sv** %arrayidx, align 8, !tbaa !7
  %8 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !7
  %add.ptr10 = getelementptr inbounds %struct.sv** %8, i64 %add
  store %struct.sv** %add.ptr10, %struct.sv*** @PL_stack_sp, align 8, !tbaa !7
  ret void
}

declare void @Perl_sv_setpv(%struct.sv*, i8*) #1

declare %struct.cv* @Perl_newXS(i8*, void (%struct.cv*)*, i8*) #1

; Function Attrs: nounwind readonly
declare i32 @memcmp(i8* nocapture, i8* nocapture, i64) #3

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #4

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #4

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5 (trunk)"}
!1 = metadata !{metadata !2, metadata !3, i64 0}
!2 = metadata !{metadata !"timeval", metadata !3, i64 0, metadata !3, i64 8}
!3 = metadata !{metadata !"long", metadata !4, i64 0}
!4 = metadata !{metadata !"omnipotent char", metadata !5, i64 0}
!5 = metadata !{metadata !"Simple C/C++ TBAA"}
!6 = metadata !{metadata !2, metadata !3, i64 8}
!7 = metadata !{metadata !8, metadata !8, i64 0}
!8 = metadata !{metadata !"any pointer", metadata !4, i64 0}
!9 = metadata !{metadata !3, metadata !3, i64 0}
!10 = metadata !{metadata !11, metadata !4, i64 37}
!11 = metadata !{metadata !"op", metadata !8, i64 0, metadata !8, i64 8, metadata !8, i64 16, metadata !3, i64 24, metadata !12, i64 32, metadata !12, i64 34, metadata !4, i64 36, metadata !4, i64 37}
!12 = metadata !{metadata !"short", metadata !4, i64 0}
!13 = metadata !{metadata !11, metadata !3, i64 24}
!14 = metadata !{metadata !15, metadata !3, i64 16}
!15 = metadata !{metadata !"sv", metadata !8, i64 0, metadata !3, i64 8, metadata !3, i64 16}
!16 = metadata !{metadata !15, metadata !8, i64 0}
!17 = metadata !{metadata !18, metadata !3, i64 8}
!18 = metadata !{metadata !"xpv", metadata !8, i64 0, metadata !3, i64 8, metadata !3, i64 16}
!19 = metadata !{metadata !18, metadata !8, i64 0}
!20 = metadata !{metadata !4, metadata !4, i64 0}
!21 = metadata !{metadata !22, metadata !23, i64 32}
!22 = metadata !{metadata !"xpvnv", metadata !8, i64 0, metadata !3, i64 8, metadata !3, i64 16, metadata !3, i64 24, metadata !23, i64 32}
!23 = metadata !{metadata !"double", metadata !4, i64 0}
!24 = metadata !{metadata !11, metadata !4, i64 36}
