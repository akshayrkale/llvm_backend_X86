; ModuleID = 'av.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.sv = type { i8*, i64, i64 }
%struct.stackinfo = type { %struct.av*, %struct.context*, i64, i64, i64, %struct.stackinfo*, %struct.stackinfo*, i64 }
%struct.av = type { %struct.xpvav*, i64, i64 }
%struct.xpvav = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.sv**, %struct.sv*, i8 }
%struct.magic = type { %struct.magic*, %struct.mgvtbl*, i16, i8, i8, %struct.sv*, i8*, i64 }
%struct.mgvtbl = type { i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i64 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)*, i32 (%struct.magic*, %struct.clone_params*)* }
%struct.clone_params = type { %struct.av*, i64, %struct.interpreter* }
%struct.interpreter = type { i8 }
%struct.hv = type { %struct.xpvhv*, i64, i64 }
%struct.xpvhv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, i64, %struct.he*, %struct.pmop*, i8* }
%struct.he = type { %struct.he*, %struct.hek*, %struct.sv* }
%struct.hek = type { i64, i64, [1 x i8] }
%struct.pmop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.pmop*, %struct.regexp*, i64, i64, i8, %struct.hv* }
%struct.op = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8 }
%struct.regexp = type { i64*, i64*, %struct.regnode*, %struct.reg_substr_data*, i8*, %struct.reg_data*, i8*, i64*, i64, i64, i64, i64, i64, i64, i64, i64, [1 x %struct.regnode] }
%struct.regnode = type { i8, i8, i16 }
%struct.reg_substr_data = type opaque
%struct.reg_data = type opaque
%struct.context = type { i64, %union.anon }
%union.anon = type { %struct.block }
%struct.block = type { i64, %struct.cop*, i64, i64, i64, %struct.pmop*, i8, %union.anon.1 }
%struct.cop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, i8*, %struct.hv*, %struct.gv*, i64, i64, i64, %struct.sv*, %struct.sv* }
%struct.gv = type { %struct.xpvgv*, i64, i64 }
%struct.xpvgv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.gp*, i8*, i64, %struct.hv*, i8 }
%struct.gp = type { %struct.sv*, i64, %struct.io*, %struct.cv*, %struct.av*, %struct.hv*, %struct.gv*, %struct.cv*, i64, i64, i64, i8* }
%struct.io = type { %struct.xpvio*, i64, i64 }
%struct.xpvio = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct._PerlIO**, %struct._PerlIO**, %union.anon.0, i64, i64, i64, i64, i8*, %struct.gv*, i8*, %struct.gv*, i8*, %struct.gv*, i16, i8, i8 }
%struct._PerlIO = type opaque
%union.anon.0 = type { %struct.__dirstream* }
%struct.__dirstream = type opaque
%struct.cv = type { %struct.xpvcv*, i64, i64 }
%struct.xpvcv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.hv*, %struct.op*, %struct.op*, void (%struct.cv*)*, %union.any, %struct.gv*, i8*, i64, %struct.av*, %struct.cv*, i16, i64 }
%union.any = type { i8* }
%union.anon.1 = type { %struct.block_loop }
%struct.block_loop = type { i8*, i64, %struct.op*, %struct.op*, %struct.op*, %struct.sv**, %struct.sv*, %struct.sv*, %struct.av*, i64, i64 }
%struct.xpv = type { i8*, i64, i64 }

@PL_sv_undef = external global %struct.sv
@PL_Sv = external global %struct.sv*
@PL_stack_sp = external global %struct.sv**
@PL_tmps_floor = external global i64
@PL_tmps_ix = external global i64
@PL_curstackinfo = external global %struct.stackinfo*
@PL_stack_base = external global %struct.sv**
@PL_curstack = external global %struct.av*
@PL_stack_max = external global %struct.sv**
@PL_markstack_ptr = external global i64*
@PL_markstack_max = external global i64*
@.str = private unnamed_addr constant [7 x i8] c"EXTEND\00", align 1
@PL_stderrgv = external global %struct.gv*
@.str1 = private unnamed_addr constant [17 x i8] c"panic: POPSTACK\0A\00", align 1
@PL_nice_chunk_size = external global i64
@PL_nice_chunk = external global i8*
@.str2 = private unnamed_addr constant [17 x i8] c"NEGATIVE_INDICES\00", align 1
@PL_Xpv = external global %struct.xpv*
@PL_no_modify = external constant [0 x i8]
@.str3 = private unnamed_addr constant [5 x i8] c"PUSH\00", align 1
@.str4 = private unnamed_addr constant [4 x i8] c"POP\00", align 1
@.str5 = private unnamed_addr constant [8 x i8] c"UNSHIFT\00", align 1
@.str6 = private unnamed_addr constant [6 x i8] c"SHIFT\00", align 1
@.str7 = private unnamed_addr constant [18 x i8] c"panic: null array\00", align 1
@.str8 = private unnamed_addr constant [10 x i8] c"STORESIZE\00", align 1
@PL_curcop = external global %struct.cop*
@PL_dowarn = external global i8
@.str9 = private unnamed_addr constant [11 x i8] c"pseudohash\00", align 1
@.str10 = private unnamed_addr constant [29 x i8] c"Pseudo-hashes are deprecated\00", align 1
@.str11 = private unnamed_addr constant [29 x i8] c"Can't coerce array into hash\00", align 1

; Function Attrs: nounwind uwtable
define void @Perl_av_reify(%struct.av* nocapture readonly %av) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %0 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_flags = getelementptr inbounds %struct.xpvav* %0, i64 0, i32 9
  %1 = load i8* %xav_flags, align 1, !tbaa !7
  %and = and i8 %1, 1
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %xav_max = getelementptr inbounds %struct.xpvav* %0, i64 0, i32 2
  %2 = load i64* %xav_max, align 8, !tbaa !10
  %add = add nsw i64 %2, 1
  %xav_fill59 = getelementptr inbounds %struct.xpvav* %0, i64 0, i32 1
  %3 = load i64* %xav_fill59, align 8, !tbaa !11
  %add360 = add nsw i64 %3, 1
  %cmp61 = icmp slt i64 %2, %add360
  br i1 %cmp61, label %while.cond6.preheader, label %while.body

while.cond6.preheader:                            ; preds = %while.body, %if.end
  %4 = phi %struct.xpvav* [ %0, %if.end ], [ %8, %while.body ]
  %key.0.lcssa = phi i64 [ %add, %if.end ], [ %dec, %while.body ]
  %tobool757 = icmp eq i64 %key.0.lcssa, 0
  br i1 %tobool757, label %while.end19, label %while.body8

while.body:                                       ; preds = %if.end, %while.body
  %5 = phi %struct.xpvav* [ %8, %while.body ], [ %0, %if.end ]
  %key.062 = phi i64 [ %dec, %while.body ], [ %add, %if.end ]
  %dec = add nsw i64 %key.062, -1
  %xav_array = getelementptr inbounds %struct.xpvav* %5, i64 0, i32 0
  %6 = load i8** %xav_array, align 8, !tbaa !12
  %7 = bitcast i8* %6 to %struct.sv**
  %arrayidx = getelementptr inbounds %struct.sv** %7, i64 %dec
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx, align 8, !tbaa !13
  %8 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_fill = getelementptr inbounds %struct.xpvav* %8, i64 0, i32 1
  %9 = load i64* %xav_fill, align 8, !tbaa !11
  %add3 = add nsw i64 %9, 1
  %cmp = icmp sgt i64 %dec, %add3
  br i1 %cmp, label %while.body, label %while.cond6.preheader

while.body8:                                      ; preds = %while.cond6.preheader, %while.cond6.backedge
  %10 = phi %struct.xpvav* [ %.pre, %while.cond6.backedge ], [ %4, %while.cond6.preheader ]
  %key.158 = phi i64 [ %dec9, %while.cond6.backedge ], [ %key.0.lcssa, %while.cond6.preheader ]
  %dec9 = add nsw i64 %key.158, -1
  %xav_array11 = getelementptr inbounds %struct.xpvav* %10, i64 0, i32 0
  %11 = load i8** %xav_array11, align 8, !tbaa !12
  %12 = bitcast i8* %11 to %struct.sv**
  %arrayidx12 = getelementptr inbounds %struct.sv** %12, i64 %dec9
  %13 = load %struct.sv** %arrayidx12, align 8, !tbaa !13
  %cmp13 = icmp eq %struct.sv* %13, @PL_sv_undef
  br i1 %cmp13, label %while.cond6.backedge, label %if.then15

while.cond6.backedge:                             ; preds = %while.body8, %if.then15, %land.rhs
  %tobool7 = icmp eq i64 %dec9, 0
  %.pre = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  br i1 %tobool7, label %while.end19, label %while.body8

if.then15:                                        ; preds = %while.body8
  store %struct.sv* %13, %struct.sv** @PL_Sv, align 8, !tbaa !13
  %tobool16 = icmp eq %struct.sv* %13, null
  br i1 %tobool16, label %while.cond6.backedge, label %land.rhs

land.rhs:                                         ; preds = %if.then15
  %sv_refcnt = getelementptr inbounds %struct.sv* %13, i64 0, i32 1
  %14 = load i64* %sv_refcnt, align 8, !tbaa !14
  %inc = add i64 %14, 1
  store i64 %inc, i64* %sv_refcnt, align 8, !tbaa !14
  br label %while.cond6.backedge

while.end19:                                      ; preds = %while.cond6.backedge, %while.cond6.preheader
  %15 = phi %struct.xpvav* [ %4, %while.cond6.preheader ], [ %.pre, %while.cond6.backedge ]
  %xav_array21 = getelementptr inbounds %struct.xpvav* %15, i64 0, i32 0
  %16 = load i8** %xav_array21, align 8, !tbaa !12
  %xav_alloc = getelementptr inbounds %struct.xpvav* %15, i64 0, i32 7
  %17 = load %struct.sv*** %xav_alloc, align 8, !tbaa !16
  %sub.ptr.lhs.cast = ptrtoint i8* %16 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %17 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %tobool2455 = icmp eq i64 %sub.ptr.div, 0
  br i1 %tobool2455, label %while.end30, label %while.body25

while.body25:                                     ; preds = %while.end19, %while.body25.while.body25_crit_edge
  %18 = phi %struct.sv** [ %.pre65, %while.body25.while.body25_crit_edge ], [ %17, %while.end19 ]
  %key.256 = phi i64 [ %dec26, %while.body25.while.body25_crit_edge ], [ %sub.ptr.div, %while.end19 ]
  %dec26 = add nsw i64 %key.256, -1
  %arrayidx29 = getelementptr inbounds %struct.sv** %18, i64 %dec26
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx29, align 8, !tbaa !13
  %tobool24 = icmp eq i64 %dec26, 0
  %.pre63 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  br i1 %tobool24, label %while.end30, label %while.body25.while.body25_crit_edge

while.body25.while.body25_crit_edge:              ; preds = %while.body25
  %xav_alloc28.phi.trans.insert = getelementptr inbounds %struct.xpvav* %.pre63, i64 0, i32 7
  %.pre65 = load %struct.sv*** %xav_alloc28.phi.trans.insert, align 8, !tbaa !16
  br label %while.body25

while.end30:                                      ; preds = %while.body25, %while.end19
  %19 = phi %struct.xpvav* [ %15, %while.end19 ], [ %.pre63, %while.body25 ]
  %xav_flags32 = getelementptr inbounds %struct.xpvav* %19, i64 0, i32 9
  %20 = load i8* %xav_flags32, align 1, !tbaa !7
  %and34 = and i8 %20, -4
  %or = or i8 %and34, 1
  store i8 %or, i8* %xav_flags32, align 1, !tbaa !7
  br label %return

return:                                           ; preds = %entry, %while.end30
  ret void
}

; Function Attrs: nounwind uwtable
define void @Perl_av_extend(%struct.av* %av, i64 %key) #0 {
entry:
  %0 = bitcast %struct.av* %av to %struct.sv*
  %1 = getelementptr inbounds %struct.av* %av, i64 0, i32 2
  %2 = load i64* %1, align 8, !tbaa !17
  %and = and i64 %2, 32768
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.end99, label %cond.end

cond.end:                                         ; preds = %entry
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %0, i32 80) #2
  %tobool1 = icmp eq %struct.magic* %call, null
  br i1 %tobool1, label %if.end99, label %if.then

if.then:                                          ; preds = %cond.end
  %3 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  tail call void @Perl_push_scope() #2
  tail call void @Perl_save_int(i32* bitcast (i64* @PL_tmps_floor to i32*)) #2
  %4 = load i64* @PL_tmps_ix, align 8, !tbaa !18
  store i64 %4, i64* @PL_tmps_floor, align 8, !tbaa !18
  %5 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_next = getelementptr inbounds %struct.stackinfo* %5, i64 0, i32 6
  %6 = load %struct.stackinfo** %si_next, align 8, !tbaa !19
  %tobool2 = icmp eq %struct.stackinfo* %6, null
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %call4 = tail call %struct.stackinfo* @Perl_new_stackinfo(i64 32, i64 12) #2
  %7 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_prev = getelementptr inbounds %struct.stackinfo* %call4, i64 0, i32 5
  store %struct.stackinfo* %7, %struct.stackinfo** %si_prev, align 8, !tbaa !21
  %8 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_next5 = getelementptr inbounds %struct.stackinfo* %8, i64 0, i32 6
  store %struct.stackinfo* %call4, %struct.stackinfo** %si_next5, align 8, !tbaa !19
  br label %if.end

if.end:                                           ; preds = %if.then, %if.then3
  %next.0 = phi %struct.stackinfo* [ %6, %if.then ], [ %call4, %if.then3 ]
  %si_type = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 4
  store i64 2, i64* %si_type, align 8, !tbaa !22
  %si_cxix = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !23
  %si_stack = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 0
  %9 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any = getelementptr inbounds %struct.av* %9, i64 0, i32 0
  %10 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_fill = getelementptr inbounds %struct.xpvav* %10, i64 0, i32 1
  store i64 0, i64* %xav_fill, align 8, !tbaa !11
  %11 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %3 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %11 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %12 = load %struct.av** @PL_curstack, align 8, !tbaa !13
  %sv_any6 = getelementptr inbounds %struct.av* %12, i64 0, i32 0
  %13 = load %struct.xpvav** %sv_any6, align 8, !tbaa !1
  %xav_fill7 = getelementptr inbounds %struct.xpvav* %13, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill7, align 8, !tbaa !11
  %xav_array = getelementptr inbounds %struct.xpvav* %10, i64 0, i32 0
  %14 = load i8** %xav_array, align 8, !tbaa !12
  %15 = bitcast i8* %14 to %struct.sv**
  store %struct.sv** %15, %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %16 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any11 = getelementptr inbounds %struct.av* %16, i64 0, i32 0
  %17 = load %struct.xpvav** %sv_any11, align 8, !tbaa !1
  %xav_max = getelementptr inbounds %struct.xpvav* %17, i64 0, i32 2
  %18 = load i64* %xav_max, align 8, !tbaa !10
  %add.ptr = getelementptr inbounds %struct.sv** %15, i64 %18
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  %19 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any13 = getelementptr inbounds %struct.av* %19, i64 0, i32 0
  %20 = load %struct.xpvav** %sv_any13, align 8, !tbaa !1
  %xav_fill14 = getelementptr inbounds %struct.xpvav* %20, i64 0, i32 1
  %21 = load i64* %xav_fill14, align 8, !tbaa !11
  %add.ptr15 = getelementptr inbounds %struct.sv** %15, i64 %21
  store %struct.sv** %add.ptr15, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %22 = load %struct.av** %si_stack, align 8, !tbaa !24
  store %struct.av* %22, %struct.av** @PL_curstack, align 8, !tbaa !13
  store %struct.stackinfo* %next.0, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %23 = load i64** @PL_markstack_ptr, align 8, !tbaa !13
  %incdec.ptr = getelementptr inbounds i64* %23, i64 1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !13
  %24 = load i64** @PL_markstack_max, align 8, !tbaa !13
  %cmp = icmp eq i64* %incdec.ptr, %24
  br i1 %cmp, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end
  tail call void @Perl_markstack_grow() #2
  %.pre369 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %.pre370 = load i64** @PL_markstack_ptr, align 8, !tbaa !13
  %.pre371 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end
  %25 = phi %struct.sv** [ %.pre371, %if.then17 ], [ %add.ptr, %if.end ]
  %26 = phi i64* [ %.pre370, %if.then17 ], [ %incdec.ptr, %if.end ]
  %27 = phi %struct.sv** [ %.pre369, %if.then17 ], [ %15, %if.end ]
  %sub.ptr.lhs.cast20 = ptrtoint %struct.sv** %add.ptr15 to i64
  %sub.ptr.rhs.cast21 = ptrtoint %struct.sv** %27 to i64
  %sub.ptr.sub22 = sub i64 %sub.ptr.lhs.cast20, %sub.ptr.rhs.cast21
  %sub.ptr.div23 = ashr exact i64 %sub.ptr.sub22, 3
  store i64 %sub.ptr.div23, i64* %26, align 8, !tbaa !18
  %sub.ptr.lhs.cast24 = ptrtoint %struct.sv** %25 to i64
  %sub.ptr.sub26 = sub i64 %sub.ptr.lhs.cast24, %sub.ptr.lhs.cast20
  %cmp28 = icmp slt i64 %sub.ptr.sub26, 16
  br i1 %cmp28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end18
  %call30 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr15, %struct.sv** %add.ptr15, i32 2) #2
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end18
  %sp.0 = phi %struct.sv** [ %call30, %if.then29 ], [ %add.ptr15, %if.end18 ]
  %mg_obj = getelementptr inbounds %struct.magic* %call, i64 0, i32 5
  %28 = load %struct.sv** %mg_obj, align 8, !tbaa !25
  %tobool32 = icmp eq %struct.sv* %28, null
  br i1 %tobool32, label %cond.false35, label %cond.end38

cond.false35:                                     ; preds = %if.end31
  %call36 = tail call %struct.sv* @Perl_newRV(%struct.sv* %0) #2
  %call37 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call36) #2
  br label %cond.end38

cond.end38:                                       ; preds = %if.end31, %cond.false35
  %cond39 = phi %struct.sv* [ %call37, %cond.false35 ], [ %28, %if.end31 ]
  %incdec.ptr40 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %cond39, %struct.sv** %incdec.ptr40, align 8, !tbaa !13
  %add = add nsw i64 %key, 1
  %call41 = tail call %struct.sv* @Perl_newSViv(i64 %add) #2
  %call42 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call41) #2
  %incdec.ptr43 = getelementptr inbounds %struct.sv** %sp.0, i64 2
  store %struct.sv* %call42, %struct.sv** %incdec.ptr43, align 8, !tbaa !13
  store %struct.sv** %incdec.ptr43, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %call44 = tail call i64 @Perl_call_method(i8* getelementptr inbounds ([7 x i8]* @.str, i64 0, i64 0), i64 2) #2
  %29 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %30 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_prev48 = getelementptr inbounds %struct.stackinfo* %30, i64 0, i32 5
  %31 = load %struct.stackinfo** %si_prev48, align 8, !tbaa !21
  %tobool49 = icmp eq %struct.stackinfo* %31, null
  br i1 %tobool49, label %if.then50, label %if.end75

if.then50:                                        ; preds = %cond.end38
  %32 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !13
  %tobool51 = icmp eq %struct.gv* %32, null
  br i1 %tobool51, label %cond.false70, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then50
  %sv_flags52 = getelementptr inbounds %struct.gv* %32, i64 0, i32 2
  %33 = load i64* %sv_flags52, align 8, !tbaa !28
  %and53 = and i64 %33, 255
  %cmp54 = icmp eq i64 %and53, 13
  br i1 %cmp54, label %land.lhs.true55, label %cond.false70

land.lhs.true55:                                  ; preds = %land.lhs.true
  %sv_any56 = getelementptr inbounds %struct.gv* %32, i64 0, i32 0
  %34 = load %struct.xpvgv** %sv_any56, align 8, !tbaa !30
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %34, i64 0, i32 7
  %35 = load %struct.gp** %xgv_gp, align 8, !tbaa !31
  %gp_io = getelementptr inbounds %struct.gp* %35, i64 0, i32 2
  %36 = load %struct.io** %gp_io, align 8, !tbaa !33
  %tobool57 = icmp eq %struct.io* %36, null
  br i1 %tobool57, label %cond.false70, label %land.lhs.true58

land.lhs.true58:                                  ; preds = %land.lhs.true55
  %sv_any62 = getelementptr inbounds %struct.io* %36, i64 0, i32 0
  %37 = load %struct.xpvio** %sv_any62, align 8, !tbaa !35
  %xio_ofp = getelementptr inbounds %struct.xpvio* %37, i64 0, i32 8
  %38 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !37
  %tobool63 = icmp eq %struct._PerlIO** %38, null
  br i1 %tobool63, label %cond.false70, label %cond.end72

cond.false70:                                     ; preds = %land.lhs.true58, %land.lhs.true55, %if.then50, %land.lhs.true
  %call71 = tail call %struct._PerlIO** @Perl_PerlIO_stderr() #2
  br label %cond.end72

cond.end72:                                       ; preds = %land.lhs.true58, %cond.false70
  %cond73 = phi %struct._PerlIO** [ %call71, %cond.false70 ], [ %38, %land.lhs.true58 ]
  %call74 = tail call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond73, i8* getelementptr inbounds ([17 x i8]* @.str1, i64 0, i64 0)) #2
  tail call void @Perl_my_exit(i64 1) #2
  br label %if.end75

if.end75:                                         ; preds = %cond.end38, %cond.end72
  %39 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %sub.ptr.lhs.cast76 = ptrtoint %struct.sv** %29 to i64
  %sub.ptr.rhs.cast77 = ptrtoint %struct.sv** %39 to i64
  %sub.ptr.sub78 = sub i64 %sub.ptr.lhs.cast76, %sub.ptr.rhs.cast77
  %sub.ptr.div79 = ashr exact i64 %sub.ptr.sub78, 3
  %40 = load %struct.av** @PL_curstack, align 8, !tbaa !13
  %sv_any80 = getelementptr inbounds %struct.av* %40, i64 0, i32 0
  %41 = load %struct.xpvav** %sv_any80, align 8, !tbaa !1
  %xav_fill81 = getelementptr inbounds %struct.xpvav* %41, i64 0, i32 1
  store i64 %sub.ptr.div79, i64* %xav_fill81, align 8, !tbaa !11
  %si_stack82 = getelementptr inbounds %struct.stackinfo* %31, i64 0, i32 0
  %42 = load %struct.av** %si_stack82, align 8, !tbaa !24
  %sv_any83 = getelementptr inbounds %struct.av* %42, i64 0, i32 0
  %43 = load %struct.xpvav** %sv_any83, align 8, !tbaa !1
  %xav_array84 = getelementptr inbounds %struct.xpvav* %43, i64 0, i32 0
  %44 = load i8** %xav_array84, align 8, !tbaa !12
  %45 = bitcast i8* %44 to %struct.sv**
  store %struct.sv** %45, %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %46 = load %struct.av** %si_stack82, align 8, !tbaa !24
  %sv_any86 = getelementptr inbounds %struct.av* %46, i64 0, i32 0
  %47 = load %struct.xpvav** %sv_any86, align 8, !tbaa !1
  %xav_max87 = getelementptr inbounds %struct.xpvav* %47, i64 0, i32 2
  %48 = load i64* %xav_max87, align 8, !tbaa !10
  %add.ptr88 = getelementptr inbounds %struct.sv** %45, i64 %48
  store %struct.sv** %add.ptr88, %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  %49 = load %struct.av** %si_stack82, align 8, !tbaa !24
  %sv_any90 = getelementptr inbounds %struct.av* %49, i64 0, i32 0
  %50 = load %struct.xpvav** %sv_any90, align 8, !tbaa !1
  %xav_fill91 = getelementptr inbounds %struct.xpvav* %50, i64 0, i32 1
  %51 = load i64* %xav_fill91, align 8, !tbaa !11
  %add.ptr92 = getelementptr inbounds %struct.sv** %45, i64 %51
  store %struct.sv** %add.ptr92, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %52 = load %struct.av** %si_stack82, align 8, !tbaa !24
  store %struct.av* %52, %struct.av** @PL_curstack, align 8, !tbaa !13
  store %struct.stackinfo* %31, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %53 = load i64* @PL_tmps_ix, align 8, !tbaa !18
  %54 = load i64* @PL_tmps_floor, align 8, !tbaa !18
  %cmp96 = icmp sgt i64 %53, %54
  br i1 %cmp96, label %if.then97, label %if.end98

if.then97:                                        ; preds = %if.end75
  tail call void @Perl_free_tmps() #2
  br label %if.end98

if.end98:                                         ; preds = %if.then97, %if.end75
  tail call void @Perl_pop_scope() #2
  br label %if.end276

if.end99:                                         ; preds = %entry, %cond.end
  %sv_any100 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %55 = load %struct.xpvav** %sv_any100, align 8, !tbaa !1
  %xav_max101 = getelementptr inbounds %struct.xpvav* %55, i64 0, i32 2
  %56 = load i64* %xav_max101, align 8, !tbaa !10
  %cmp102 = icmp slt i64 %56, %key
  br i1 %cmp102, label %if.then103, label %if.end276

if.then103:                                       ; preds = %if.end99
  %xav_alloc = getelementptr inbounds %struct.xpvav* %55, i64 0, i32 7
  %57 = load %struct.sv*** %xav_alloc, align 8, !tbaa !16
  %xav_array110 = getelementptr inbounds %struct.xpvav* %55, i64 0, i32 0
  %58 = load i8** %xav_array110, align 8, !tbaa !12
  %59 = bitcast i8* %58 to %struct.sv**
  %cmp111 = icmp eq %struct.sv** %57, %59
  br i1 %cmp111, label %if.else, label %if.then112

if.then112:                                       ; preds = %if.then103
  %xav_fill116 = getelementptr inbounds %struct.xpvav* %55, i64 0, i32 1
  %60 = load i64* %xav_fill116, align 8, !tbaa !11
  %sub.ptr.lhs.cast123 = ptrtoint i8* %58 to i64
  %sub.ptr.rhs.cast124 = ptrtoint %struct.sv** %57 to i64
  %sub.ptr.sub125 = sub i64 %sub.ptr.lhs.cast123, %sub.ptr.rhs.cast124
  %sub.ptr.div126 = ashr exact i64 %sub.ptr.sub125, 3
  %61 = bitcast %struct.sv** %57 to i8*
  %add133 = shl i64 %60, 3
  %mul = add i64 %add133, 8
  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %61, i8* %58, i64 %mul, i32 1, i1 false)
  %62 = load %struct.xpvav** %sv_any100, align 8, !tbaa !1
  %xav_max135 = getelementptr inbounds %struct.xpvav* %62, i64 0, i32 2
  %63 = load i64* %xav_max135, align 8, !tbaa !10
  %add136 = add nsw i64 %63, %sub.ptr.div126
  store i64 %add136, i64* %xav_max135, align 8, !tbaa !10
  %xav_alloc138 = getelementptr inbounds %struct.xpvav* %62, i64 0, i32 7
  %64 = load %struct.sv*** %xav_alloc138, align 8, !tbaa !16
  %65 = bitcast %struct.sv** %64 to i8*
  %xpv_pv = getelementptr inbounds %struct.xpvav* %62, i64 0, i32 0
  store i8* %65, i8** %xpv_pv, align 8, !tbaa !39
  %xav_flags = getelementptr inbounds %struct.xpvav* %62, i64 0, i32 9
  %66 = load i8* %xav_flags, align 1, !tbaa !7
  %and141 = and i8 %66, 1
  %tobool142 = icmp ne i8 %and141, 0
  %tobool144 = icmp ne i64 %sub.ptr.div126, 0
  %or.cond = and i1 %tobool142, %tobool144
  br i1 %or.cond, label %while.body, label %if.end145

while.body:                                       ; preds = %if.then112, %while.body
  %tmp106.0 = phi i64 [ %dec, %while.body ], [ %sub.ptr.div126, %if.then112 ]
  %dec = add nsw i64 %tmp106.0, -1
  %add.ptr118.sum = add i64 %tmp106.0, %60
  %arrayidx = getelementptr inbounds %struct.sv** %57, i64 %add.ptr118.sum
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx, align 8, !tbaa !13
  %tobool144.old = icmp eq i64 %dec, 0
  br i1 %tobool144.old, label %if.end145.loopexit, label %while.body

if.end145.loopexit:                               ; preds = %while.body
  %.pre367 = load %struct.xpvav** %sv_any100, align 8, !tbaa !1
  %xav_max147.phi.trans.insert = getelementptr inbounds %struct.xpvav* %.pre367, i64 0, i32 2
  %.pre368 = load i64* %xav_max147.phi.trans.insert, align 8, !tbaa !10
  br label %if.end145

if.end145:                                        ; preds = %if.end145.loopexit, %if.then112
  %67 = phi i64 [ %.pre368, %if.end145.loopexit ], [ %add136, %if.then112 ]
  %sub = add nsw i64 %67, -10
  %cmp148 = icmp slt i64 %sub, %key
  br i1 %cmp148, label %resize, label %if.end276

if.else:                                          ; preds = %if.then103
  %tobool157 = icmp eq %struct.sv** %57, null
  br i1 %tobool157, label %if.else237, label %if.then158

if.then158:                                       ; preds = %if.else
  %div = sdiv i64 %56, 5
  br label %resize

resize:                                           ; preds = %if.end145, %if.then158
  %.pn = phi i64 [ %div, %if.then158 ], [ %67, %if.end145 ]
  %newmax.0 = add nsw i64 %.pn, %key
  %add164 = shl i64 %newmax.0, 3
  %mul165 = add i64 %add164, 8
  br label %while.cond166

while.cond166:                                    ; preds = %while.cond166, %resize
  %itmp.0 = phi i64 [ 16, %resize ], [ %add171, %while.cond166 ]
  %sub167 = add nsw i64 %itmp.0, -16
  %cmp168 = icmp ult i64 %sub167, %mul165
  %add171 = shl nsw i64 %itmp.0, 1
  br i1 %cmp168, label %while.cond166, label %while.end172

while.end172:                                     ; preds = %while.cond166
  %div174 = lshr i64 %sub167, 3
  %sub175 = add nsw i64 %div174, -1
  %mul177 = shl nuw i64 %div174, 3
  %call178 = tail call i8* @Perl_safesysmalloc(i64 %mul177) #2
  %68 = bitcast i8* %call178 to %struct.sv**
  %69 = load %struct.xpvav** %sv_any100, align 8, !tbaa !1
  %xav_alloc180 = getelementptr inbounds %struct.xpvav* %69, i64 0, i32 7
  %70 = load %struct.sv*** %xav_alloc180, align 8, !tbaa !16
  %71 = bitcast %struct.sv** %70 to i8*
  %xav_max182 = getelementptr inbounds %struct.xpvav* %69, i64 0, i32 2
  %72 = load i64* %xav_max182, align 8, !tbaa !10
  %add183 = shl i64 %72, 3
  %mul184 = add i64 %add183, 8
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %call178, i8* %71, i64 %mul184, i32 1, i1 false)
  %73 = load %struct.xpvav** %sv_any100, align 8, !tbaa !1
  %xav_max186 = getelementptr inbounds %struct.xpvav* %73, i64 0, i32 2
  %74 = load i64* %xav_max186, align 8, !tbaa !10
  %cmp187 = icmp sgt i64 %74, 64
  %xav_alloc193 = getelementptr inbounds %struct.xpvav* %73, i64 0, i32 7
  %75 = load %struct.sv*** %xav_alloc193, align 8, !tbaa !16
  %76 = bitcast %struct.sv** %75 to i8*
  br i1 %cmp187, label %if.then189, label %if.else208

if.then189:                                       ; preds = %while.end172
  %add196 = shl i64 %74, 3
  %mul197 = add i64 %add196, 8
  %77 = load i64* @PL_nice_chunk_size, align 8, !tbaa !18
  %cmp198 = icmp ugt i64 %mul197, %77
  br i1 %cmp198, label %if.then200, label %if.else204

if.then200:                                       ; preds = %if.then189
  %78 = load i8** @PL_nice_chunk, align 8, !tbaa !13
  %tobool201 = icmp eq i8* %78, null
  br i1 %tobool201, label %if.end203, label %if.then202

if.then202:                                       ; preds = %if.then200
  tail call void @Perl_safesysfree(i8* %78) #2
  br label %if.end203

if.end203:                                        ; preds = %if.then200, %if.then202
  store i8* %76, i8** @PL_nice_chunk, align 8, !tbaa !13
  store i64 %mul197, i64* @PL_nice_chunk_size, align 8, !tbaa !18
  br label %if.end211

if.else204:                                       ; preds = %if.then189
  tail call void @Perl_safesysfree(i8* %76) #2
  br label %if.end211

if.else208:                                       ; preds = %while.end172
  tail call void @Perl_safesysfree(i8* %76) #2
  br label %if.end211

if.end211:                                        ; preds = %if.end203, %if.else204, %if.else208
  %79 = load %struct.xpvav** %sv_any100, align 8, !tbaa !1
  %xav_alloc213 = getelementptr inbounds %struct.xpvav* %79, i64 0, i32 7
  store %struct.sv** %68, %struct.sv*** %xav_alloc213, align 8, !tbaa !16
  %xav_max217 = getelementptr inbounds %struct.xpvav* %79, i64 0, i32 2
  %80 = load i64* %xav_max217, align 8, !tbaa !10
  %add.ptr218.sum = add i64 %80, 1
  %add.ptr219 = getelementptr inbounds %struct.sv** %68, i64 %add.ptr218.sum
  %sub222 = sub nsw i64 %sub175, %80
  %81 = load %struct.av** @PL_curstack, align 8, !tbaa !13
  %cmp223 = icmp eq %struct.av* %81, %av
  br i1 %cmp223, label %if.then225, label %if.end255

if.then225:                                       ; preds = %if.end211
  %82 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %83 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %sub.ptr.lhs.cast228 = ptrtoint %struct.sv** %82 to i64
  %sub.ptr.rhs.cast229 = ptrtoint %struct.sv** %83 to i64
  %sub.ptr.sub230 = sub i64 %sub.ptr.lhs.cast228, %sub.ptr.rhs.cast229
  %sub.ptr.div231 = ashr exact i64 %sub.ptr.sub230, 3
  %add.ptr232 = getelementptr inbounds %struct.sv** %68, i64 %sub.ptr.div231
  store %struct.sv** %add.ptr232, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %84 = load %struct.xpvav** %sv_any100, align 8, !tbaa !1
  %xav_alloc234 = getelementptr inbounds %struct.xpvav* %84, i64 0, i32 7
  %85 = load %struct.sv*** %xav_alloc234, align 8, !tbaa !16
  store %struct.sv** %85, %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %add.ptr235 = getelementptr inbounds %struct.sv** %85, i64 %sub175
  store %struct.sv** %add.ptr235, %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  br label %if.end255

if.else237:                                       ; preds = %if.else
  %cmp238 = icmp slt i64 %key, 3
  %cond243 = select i1 %cmp238, i64 3, i64 %key
  %add244 = shl i64 %cond243, 3
  %mul245 = add i64 %add244, 8
  %call246 = tail call i8* @Perl_safesysmalloc(i64 %mul245) #2
  %86 = bitcast i8* %call246 to %struct.sv**
  %87 = load %struct.xpvav** %sv_any100, align 8, !tbaa !1
  %xav_alloc248 = getelementptr inbounds %struct.xpvav* %87, i64 0, i32 7
  store %struct.sv** %86, %struct.sv*** %xav_alloc248, align 8, !tbaa !16
  %add.ptr251 = getelementptr inbounds i8* %call246, i64 8
  %88 = bitcast i8* %add.ptr251 to %struct.sv**
  store %struct.sv* @PL_sv_undef, %struct.sv** %86, align 8, !tbaa !13
  br label %if.end255

if.end255:                                        ; preds = %if.end211, %if.then225, %if.else237
  %ary.0 = phi %struct.sv** [ %add.ptr219, %if.then225 ], [ %add.ptr219, %if.end211 ], [ %88, %if.else237 ]
  %tmp106.1 = phi i64 [ %sub222, %if.then225 ], [ %sub222, %if.end211 ], [ %cond243, %if.else237 ]
  %newmax.1 = phi i64 [ %sub175, %if.then225 ], [ %sub175, %if.end211 ], [ %cond243, %if.else237 ]
  %89 = load %struct.xpvav** %sv_any100, align 8, !tbaa !1
  %xav_flags257 = getelementptr inbounds %struct.xpvav* %89, i64 0, i32 9
  %90 = load i8* %xav_flags257, align 1, !tbaa !7
  %and259 = and i8 %90, 1
  %tobool260 = icmp ne i8 %and259, 0
  %tobool263 = icmp ne i64 %tmp106.1, 0
  %or.cond278 = and i1 %tobool260, %tobool263
  br i1 %or.cond278, label %while.body264, label %if.end268

while.body264:                                    ; preds = %if.end255, %while.body264
  %tmp106.2 = phi i64 [ %dec265, %while.body264 ], [ %tmp106.1, %if.end255 ]
  %dec265 = add nsw i64 %tmp106.2, -1
  %arrayidx266 = getelementptr inbounds %struct.sv** %ary.0, i64 %dec265
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx266, align 8, !tbaa !13
  %tobool263.old = icmp eq i64 %dec265, 0
  br i1 %tobool263.old, label %if.end268.loopexit, label %while.body264

if.end268.loopexit:                               ; preds = %while.body264
  %.pre = load %struct.xpvav** %sv_any100, align 8, !tbaa !1
  br label %if.end268

if.end268:                                        ; preds = %if.end268.loopexit, %if.end255
  %91 = phi %struct.xpvav* [ %.pre, %if.end268.loopexit ], [ %89, %if.end255 ]
  %xav_alloc270 = getelementptr inbounds %struct.xpvav* %91, i64 0, i32 7
  %92 = load %struct.sv*** %xav_alloc270, align 8, !tbaa !16
  %93 = bitcast %struct.sv** %92 to i8*
  %xpv_pv272 = getelementptr inbounds %struct.xpvav* %91, i64 0, i32 0
  store i8* %93, i8** %xpv_pv272, align 8, !tbaa !39
  %xav_max274 = getelementptr inbounds %struct.xpvav* %91, i64 0, i32 2
  store i64 %newmax.1, i64* %xav_max274, align 8, !tbaa !10
  br label %if.end276

if.end276:                                        ; preds = %if.end268, %if.end145, %if.end98, %if.end99
  ret void
}

declare %struct.magic* @Perl_mg_find(%struct.sv*, i32) #1

declare void @Perl_push_scope() #1

declare void @Perl_save_int(i32*) #1

declare %struct.stackinfo* @Perl_new_stackinfo(i64, i64) #1

declare void @Perl_markstack_grow() #1

declare %struct.sv** @Perl_stack_grow(%struct.sv**, %struct.sv**, i32) #1

declare %struct.sv* @Perl_sv_2mortal(%struct.sv*) #1

declare %struct.sv* @Perl_newRV(%struct.sv*) #1

declare %struct.sv* @Perl_newSViv(i64) #1

declare i64 @Perl_call_method(i8*, i64) #1

declare i32 @PerlIO_printf(%struct._PerlIO**, i8*, ...) #1

declare %struct._PerlIO** @Perl_PerlIO_stderr() #1

declare void @Perl_my_exit(i64) #1

declare void @Perl_free_tmps() #1

declare void @Perl_pop_scope() #1

; Function Attrs: nounwind
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #2

declare i8* @Perl_safesysmalloc(i64) #1

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #2

declare void @Perl_safesysfree(i8*) #1

; Function Attrs: nounwind uwtable
define %struct.sv** @Perl_av_fetch(%struct.av* %av, i64 %key, i64 %lval) #0 {
entry:
  %tobool = icmp eq %struct.av* %av, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.av* %av, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !41
  %and = and i64 %0, 32768
  %tobool1 = icmp eq i64 %and, 0
  br i1 %tobool1, label %if.end109, label %if.then2

if.then2:                                         ; preds = %if.end
  %1 = bitcast %struct.av* %av to %struct.sv*
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %1, i32 80) #2
  %tobool3 = icmp eq %struct.magic* %call, null
  br i1 %tobool3, label %lor.lhs.false, label %if.then6

lor.lhs.false:                                    ; preds = %if.then2
  %call4 = tail call %struct.magic* @Perl_mg_find(%struct.sv* %1, i32 68) #2
  %tobool5 = icmp eq %struct.magic* %call4, null
  br i1 %tobool5, label %if.end109, label %if.end80

if.then6:                                         ; preds = %if.then2
  %cmp = icmp slt i64 %key, 0
  br i1 %cmp, label %if.then8, label %if.end100

if.then8:                                         ; preds = %if.then6
  %mg_obj = getelementptr inbounds %struct.magic* %call, i64 0, i32 5
  %2 = load %struct.sv** %mg_obj, align 8, !tbaa !25
  %tobool9 = icmp eq %struct.sv* %2, null
  br i1 %tobool9, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.then8
  %call11 = tail call %struct.sv* @Perl_newRV(%struct.sv* %1) #2
  %call12 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call11) #2
  br label %cond.end

cond.end:                                         ; preds = %if.then8, %cond.false
  %cond = phi %struct.sv* [ %call12, %cond.false ], [ %2, %if.then8 ]
  %sv_any = getelementptr inbounds %struct.sv* %cond, i64 0, i32 0
  %3 = load i8** %sv_any, align 8, !tbaa !42
  %xrv_rv = bitcast i8* %3 to %struct.sv**
  %4 = load %struct.sv** %xrv_rv, align 8, !tbaa !43
  %sv_any13 = getelementptr inbounds %struct.sv* %4, i64 0, i32 0
  %5 = load i8** %sv_any13, align 8, !tbaa !42
  %xmg_stash = getelementptr inbounds i8* %5, i64 48
  %6 = bitcast i8* %xmg_stash to %struct.hv**
  %7 = load %struct.hv** %6, align 8, !tbaa !45
  %call14 = tail call %struct.sv** @Perl_hv_fetch(%struct.hv* %7, i8* getelementptr inbounds ([17 x i8]* @.str2, i64 0, i64 0), i64 16, i64 0) #2
  %tobool15 = icmp eq %struct.sv** %call14, null
  br i1 %tobool15, label %if.then85, label %land.lhs.true16

land.lhs.true16:                                  ; preds = %cond.end
  %8 = load %struct.sv** %call14, align 8, !tbaa !13
  %sv_any17 = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %9 = load i8** %sv_any17, align 8, !tbaa !42
  %xgv_gp = getelementptr inbounds i8* %9, i64 56
  %10 = bitcast i8* %xgv_gp to %struct.gp**
  %11 = load %struct.gp** %10, align 8, !tbaa !31
  %gp_sv = getelementptr inbounds %struct.gp* %11, i64 0, i32 0
  %12 = load %struct.sv** %gp_sv, align 8, !tbaa !47
  %tobool18 = icmp eq %struct.sv* %12, null
  br i1 %tobool18, label %if.then85, label %cond.false20

cond.false20:                                     ; preds = %land.lhs.true16
  %sv_flags24 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i64* %sv_flags24, align 8, !tbaa !17
  %and25 = and i64 %13, 262144
  %tobool26 = icmp eq i64 %and25, 0
  br i1 %tobool26, label %cond.false43, label %cond.true27

cond.true27:                                      ; preds = %cond.false20
  %sv_any31 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %14 = load i8** %sv_any31, align 8, !tbaa !42
  %15 = bitcast i8* %14 to %struct.xpv*
  store %struct.xpv* %15, %struct.xpv** @PL_Xpv, align 8, !tbaa !13
  %tobool32 = icmp eq i8* %14, null
  br i1 %tobool32, label %if.then85, label %land.lhs.true33

land.lhs.true33:                                  ; preds = %cond.true27
  %xpv_cur = getelementptr inbounds i8* %14, i64 8
  %16 = bitcast i8* %xpv_cur to i64*
  %17 = load i64* %16, align 8, !tbaa !48
  %cmp34 = icmp ugt i64 %17, 1
  br i1 %cmp34, label %if.end100, label %lor.lhs.false35

lor.lhs.false35:                                  ; preds = %land.lhs.true33
  %tobool37 = icmp eq i64 %17, 0
  br i1 %tobool37, label %if.then85, label %land.lhs.true38

land.lhs.true38:                                  ; preds = %lor.lhs.false35
  %xpv_pv = bitcast i8* %14 to i8**
  %18 = load i8** %xpv_pv, align 8, !tbaa !39
  %19 = load i8* %18, align 1, !tbaa !49
  %cmp39 = icmp eq i8 %19, 48
  br i1 %cmp39, label %if.then85, label %if.end100

cond.false43:                                     ; preds = %cond.false20
  %and48 = and i64 %13, 65536
  %tobool49 = icmp eq i64 %and48, 0
  br i1 %tobool49, label %cond.false57, label %cond.true50

cond.true50:                                      ; preds = %cond.false43
  %sv_any54 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %20 = load i8** %sv_any54, align 8, !tbaa !42
  %xiv_iv = getelementptr inbounds i8* %20, i64 24
  %21 = bitcast i8* %xiv_iv to i64*
  %22 = load i64* %21, align 8, !tbaa !50
  %cmp55 = icmp eq i64 %22, 0
  br i1 %cmp55, label %if.then85, label %if.end100

cond.false57:                                     ; preds = %cond.false43
  %and62 = and i64 %13, 131072
  %tobool63 = icmp eq i64 %and62, 0
  br i1 %tobool63, label %cond.false71, label %cond.true64

cond.true64:                                      ; preds = %cond.false57
  %sv_any68 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %23 = load i8** %sv_any68, align 8, !tbaa !42
  %xnv_nv = getelementptr inbounds i8* %23, i64 32
  %24 = bitcast i8* %xnv_nv to double*
  %25 = load double* %24, align 8, !tbaa !52
  %cmp69 = fcmp une double %25, 0.000000e+00
  br i1 %cmp69, label %if.end100, label %if.then85

cond.false71:                                     ; preds = %cond.false57
  %call75 = tail call signext i8 @Perl_sv_2bool(%struct.sv* %12) #2
  %tobool77 = icmp eq i8 %call75, 0
  br i1 %tobool77, label %if.then85, label %if.end100

if.end80:                                         ; preds = %lor.lhs.false
  %cmp226 = icmp slt i64 %key, 0
  br i1 %cmp226, label %if.then85, label %if.end100

if.then85:                                        ; preds = %cond.end, %land.lhs.true16, %cond.false71, %cond.true64, %cond.true50, %cond.true27, %lor.lhs.false35, %land.lhs.true38, %if.end80
  %26 = load i64* %sv_flags, align 8, !tbaa !17
  %and87 = and i64 %26, 32768
  %tobool88 = icmp eq i64 %and87, 0
  br i1 %tobool88, label %cond.false91, label %cond.true89

cond.true89:                                      ; preds = %if.then85
  %call90 = tail call i64 @Perl_mg_size(%struct.sv* %1) #2
  br label %cond.end93

cond.false91:                                     ; preds = %if.then85
  %sv_any92 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %27 = load %struct.xpvav** %sv_any92, align 8, !tbaa !1
  %xav_fill = getelementptr inbounds %struct.xpvav* %27, i64 0, i32 1
  %28 = load i64* %xav_fill, align 8, !tbaa !11
  br label %cond.end93

cond.end93:                                       ; preds = %cond.false91, %cond.true89
  %cond94 = phi i64 [ %call90, %cond.true89 ], [ %28, %cond.false91 ]
  %add = add i64 %key, 1
  %add95 = add i64 %add, %cond94
  %cmp96 = icmp slt i64 %add95, 0
  br i1 %cmp96, label %return, label %if.end100

if.end100:                                        ; preds = %if.then6, %land.lhs.true38, %cond.true50, %cond.false71, %land.lhs.true33, %cond.true64, %cond.end93, %if.end80
  %key.addr.0 = phi i64 [ %add95, %cond.end93 ], [ %key, %if.end80 ], [ %key, %cond.true64 ], [ %key, %land.lhs.true33 ], [ %key, %cond.false71 ], [ %key, %cond.true50 ], [ %key, %land.lhs.true38 ], [ %key, %if.then6 ]
  %call101 = tail call %struct.sv* @Perl_sv_newmortal() #2
  %call102 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %call101, i64 9) #2
  %call103 = tail call i32 @Perl_mg_copy(%struct.sv* %1, %struct.sv* %call101, i8* null, i64 %key.addr.0) #2
  %sv_any104 = getelementptr inbounds %struct.sv* %call101, i64 0, i32 0
  %29 = load i8** %sv_any104, align 8, !tbaa !42
  %30 = getelementptr inbounds i8* %29, i64 80
  store i8 116, i8* %30, align 1, !tbaa !54
  %xlv_targ = getelementptr inbounds i8* %29, i64 72
  %31 = bitcast i8* %xlv_targ to %struct.sv**
  store %struct.sv* %call101, %struct.sv** %31, align 8, !tbaa !56
  br label %return

if.end109:                                        ; preds = %lor.lhs.false, %if.end
  %cmp110 = icmp slt i64 %key, 0
  br i1 %cmp110, label %if.then112, label %if.end129

if.then112:                                       ; preds = %if.end109
  %32 = load i64* %sv_flags, align 8, !tbaa !17
  %and114 = and i64 %32, 32768
  %tobool115 = icmp eq i64 %and114, 0
  br i1 %tobool115, label %cond.false118, label %cond.true116

cond.true116:                                     ; preds = %if.then112
  %33 = bitcast %struct.av* %av to %struct.sv*
  %call117 = tail call i64 @Perl_mg_size(%struct.sv* %33) #2
  br label %cond.end121

cond.false118:                                    ; preds = %if.then112
  %sv_any119 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %34 = load %struct.xpvav** %sv_any119, align 8, !tbaa !1
  %xav_fill120 = getelementptr inbounds %struct.xpvav* %34, i64 0, i32 1
  %35 = load i64* %xav_fill120, align 8, !tbaa !11
  br label %cond.end121

cond.end121:                                      ; preds = %cond.false118, %cond.true116
  %cond122 = phi i64 [ %call117, %cond.true116 ], [ %35, %cond.false118 ]
  %add123 = add i64 %key, 1
  %add124 = add i64 %add123, %cond122
  %cmp125 = icmp slt i64 %add124, 0
  br i1 %cmp125, label %return, label %if.end129

if.end129:                                        ; preds = %cond.end121, %if.end109
  %key.addr.1 = phi i64 [ %add124, %cond.end121 ], [ %key, %if.end109 ]
  %sv_any130 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %36 = load %struct.xpvav** %sv_any130, align 8, !tbaa !1
  %xav_fill131 = getelementptr inbounds %struct.xpvav* %36, i64 0, i32 1
  %37 = load i64* %xav_fill131, align 8, !tbaa !11
  %cmp132 = icmp sgt i64 %key.addr.1, %37
  br i1 %cmp132, label %if.then134, label %if.end140

if.then134:                                       ; preds = %if.end129
  %tobool135 = icmp eq i64 %lval, 0
  br i1 %tobool135, label %return, label %if.end137

if.end137:                                        ; preds = %if.then134
  %call138 = tail call %struct.sv* @Perl_newSV(i64 0) #2
  %call139 = tail call %struct.sv** @Perl_av_store(%struct.av* %av, i64 %key.addr.1, %struct.sv* %call138)
  br label %return

if.end140:                                        ; preds = %if.end129
  %xav_array = getelementptr inbounds %struct.xpvav* %36, i64 0, i32 0
  %38 = load i8** %xav_array, align 8, !tbaa !12
  %39 = bitcast i8* %38 to %struct.sv**
  %arrayidx = getelementptr inbounds %struct.sv** %39, i64 %key.addr.1
  %40 = load %struct.sv** %arrayidx, align 8, !tbaa !13
  %cmp142 = icmp eq %struct.sv* %40, @PL_sv_undef
  br i1 %cmp142, label %emptyness, label %if.else

emptyness:                                        ; preds = %if.end140, %if.then167
  %tobool145 = icmp eq i64 %lval, 0
  br i1 %tobool145, label %return, label %if.then146

if.then146:                                       ; preds = %emptyness
  %call147 = tail call %struct.sv* @Perl_newSV(i64 0) #2
  %call148 = tail call %struct.sv** @Perl_av_store(%struct.av* %av, i64 %key.addr.1, %struct.sv* %call147)
  br label %return

if.else:                                          ; preds = %if.end140
  %xav_flags = getelementptr inbounds %struct.xpvav* %36, i64 0, i32 9
  %41 = load i8* %xav_flags, align 1, !tbaa !7
  %and152 = and i8 %41, 2
  %tobool153 = icmp eq i8 %and152, 0
  br i1 %tobool153, label %return, label %land.lhs.true154

land.lhs.true154:                                 ; preds = %if.else
  %tobool158 = icmp eq %struct.sv* %40, null
  br i1 %tobool158, label %if.then167, label %lor.lhs.false159

lor.lhs.false159:                                 ; preds = %land.lhs.true154
  %sv_flags163 = getelementptr inbounds %struct.sv* %40, i64 0, i32 2
  %42 = load i64* %sv_flags163, align 8, !tbaa !17
  %and164 = and i64 %42, 255
  %cmp165 = icmp eq i64 %and164, 255
  br i1 %cmp165, label %if.then167, label %return

if.then167:                                       ; preds = %land.lhs.true154, %lor.lhs.false159
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx, align 8, !tbaa !13
  br label %emptyness

return:                                           ; preds = %lor.lhs.false159, %if.else, %emptyness, %if.then134, %cond.end121, %cond.end93, %entry, %if.then146, %if.end137, %if.end100
  %retval.0 = phi %struct.sv** [ %31, %if.end100 ], [ %call139, %if.end137 ], [ %call148, %if.then146 ], [ null, %entry ], [ null, %cond.end93 ], [ null, %cond.end121 ], [ null, %if.then134 ], [ null, %emptyness ], [ %arrayidx, %if.else ], [ %arrayidx, %lor.lhs.false159 ]
  ret %struct.sv** %retval.0
}

declare %struct.sv** @Perl_hv_fetch(%struct.hv*, i8*, i64, i64) #1

declare signext i8 @Perl_sv_2bool(%struct.sv*) #1

declare i64 @Perl_mg_size(%struct.sv*) #1

declare %struct.sv* @Perl_sv_newmortal() #1

declare signext i8 @Perl_sv_upgrade(%struct.sv*, i64) #1

declare i32 @Perl_mg_copy(%struct.sv*, %struct.sv*, i8*, i64) #1

declare %struct.sv* @Perl_newSV(i64) #1

; Function Attrs: nounwind uwtable
define %struct.sv** @Perl_av_store(%struct.av* %av, i64 %key, %struct.sv* %val) #0 {
entry:
  %tobool = icmp eq %struct.av* %av, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tobool1 = icmp eq %struct.sv* %val, null
  %PL_sv_undef.val = select i1 %tobool1, %struct.sv* @PL_sv_undef, %struct.sv* %val
  %sv_flags = getelementptr inbounds %struct.av* %av, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !41
  %and = and i64 %0, 32768
  %tobool4 = icmp eq i64 %and, 0
  br i1 %tobool4, label %if.end102, label %if.then5

if.then5:                                         ; preds = %if.end
  %1 = bitcast %struct.av* %av to %struct.sv*
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %1, i32 80) #2
  %tobool6 = icmp eq %struct.magic* %call, null
  br i1 %tobool6, label %if.end102, label %if.then7

if.then7:                                         ; preds = %if.then5
  %cmp = icmp slt i64 %key, 0
  br i1 %cmp, label %if.then8, label %if.end95

if.then8:                                         ; preds = %if.then7
  %mg_obj = getelementptr inbounds %struct.magic* %call, i64 0, i32 5
  %2 = load %struct.sv** %mg_obj, align 8, !tbaa !25
  %tobool9 = icmp eq %struct.sv* %2, null
  br i1 %tobool9, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.then8
  %call11 = tail call %struct.sv* @Perl_newRV(%struct.sv* %1) #2
  %call12 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call11) #2
  br label %cond.end

cond.end:                                         ; preds = %if.then8, %cond.false
  %cond = phi %struct.sv* [ %call12, %cond.false ], [ %2, %if.then8 ]
  %sv_any = getelementptr inbounds %struct.sv* %cond, i64 0, i32 0
  %3 = load i8** %sv_any, align 8, !tbaa !42
  %xrv_rv = bitcast i8* %3 to %struct.sv**
  %4 = load %struct.sv** %xrv_rv, align 8, !tbaa !43
  %sv_any13 = getelementptr inbounds %struct.sv* %4, i64 0, i32 0
  %5 = load i8** %sv_any13, align 8, !tbaa !42
  %xmg_stash = getelementptr inbounds i8* %5, i64 48
  %6 = bitcast i8* %xmg_stash to %struct.hv**
  %7 = load %struct.hv** %6, align 8, !tbaa !45
  %call14 = tail call %struct.sv** @Perl_hv_fetch(%struct.hv* %7, i8* getelementptr inbounds ([17 x i8]* @.str2, i64 0, i64 0), i64 16, i64 0) #2
  %tobool15 = icmp eq %struct.sv** %call14, null
  br i1 %tobool15, label %if.then79, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.end
  %8 = load %struct.sv** %call14, align 8, !tbaa !13
  %sv_any16 = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %9 = load i8** %sv_any16, align 8, !tbaa !42
  %xgv_gp = getelementptr inbounds i8* %9, i64 56
  %10 = bitcast i8* %xgv_gp to %struct.gp**
  %11 = load %struct.gp** %10, align 8, !tbaa !31
  %gp_sv = getelementptr inbounds %struct.gp* %11, i64 0, i32 0
  %12 = load %struct.sv** %gp_sv, align 8, !tbaa !47
  %tobool17 = icmp eq %struct.sv* %12, null
  br i1 %tobool17, label %if.then79, label %cond.false19

cond.false19:                                     ; preds = %land.lhs.true
  %sv_flags23 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i64* %sv_flags23, align 8, !tbaa !17
  %and24 = and i64 %13, 262144
  %tobool25 = icmp eq i64 %and24, 0
  br i1 %tobool25, label %cond.false41, label %cond.true26

cond.true26:                                      ; preds = %cond.false19
  %sv_any30 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %14 = load i8** %sv_any30, align 8, !tbaa !42
  %15 = bitcast i8* %14 to %struct.xpv*
  store %struct.xpv* %15, %struct.xpv** @PL_Xpv, align 8, !tbaa !13
  %tobool31 = icmp eq i8* %14, null
  br i1 %tobool31, label %if.then79, label %land.lhs.true32

land.lhs.true32:                                  ; preds = %cond.true26
  %xpv_cur = getelementptr inbounds i8* %14, i64 8
  %16 = bitcast i8* %xpv_cur to i64*
  %17 = load i64* %16, align 8, !tbaa !48
  %cmp33 = icmp ugt i64 %17, 1
  br i1 %cmp33, label %if.end95, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true32
  %tobool35 = icmp eq i64 %17, 0
  br i1 %tobool35, label %if.then79, label %land.lhs.true36

land.lhs.true36:                                  ; preds = %lor.lhs.false
  %xpv_pv = bitcast i8* %14 to i8**
  %18 = load i8** %xpv_pv, align 8, !tbaa !39
  %19 = load i8* %18, align 1, !tbaa !49
  %cmp37 = icmp eq i8 %19, 48
  br i1 %cmp37, label %if.then79, label %if.end95

cond.false41:                                     ; preds = %cond.false19
  %and46 = and i64 %13, 65536
  %tobool47 = icmp eq i64 %and46, 0
  br i1 %tobool47, label %cond.false55, label %cond.true48

cond.true48:                                      ; preds = %cond.false41
  %sv_any52 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %20 = load i8** %sv_any52, align 8, !tbaa !42
  %xiv_iv = getelementptr inbounds i8* %20, i64 24
  %21 = bitcast i8* %xiv_iv to i64*
  %22 = load i64* %21, align 8, !tbaa !50
  %cmp53 = icmp eq i64 %22, 0
  br i1 %cmp53, label %if.then79, label %if.end95

cond.false55:                                     ; preds = %cond.false41
  %and60 = and i64 %13, 131072
  %tobool61 = icmp eq i64 %and60, 0
  br i1 %tobool61, label %cond.false69, label %cond.true62

cond.true62:                                      ; preds = %cond.false55
  %sv_any66 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %23 = load i8** %sv_any66, align 8, !tbaa !42
  %xnv_nv = getelementptr inbounds i8* %23, i64 32
  %24 = bitcast i8* %xnv_nv to double*
  %25 = load double* %24, align 8, !tbaa !52
  %cmp67 = fcmp une double %25, 0.000000e+00
  br i1 %cmp67, label %if.end95, label %if.then79

cond.false69:                                     ; preds = %cond.false55
  %call73 = tail call signext i8 @Perl_sv_2bool(%struct.sv* %12) #2
  %tobool75 = icmp eq i8 %call73, 0
  br i1 %tobool75, label %if.then79, label %if.end95

if.then79:                                        ; preds = %cond.true62, %cond.end, %land.lhs.true, %cond.false69, %cond.true48, %cond.true26, %lor.lhs.false, %land.lhs.true36
  %26 = load i64* %sv_flags, align 8, !tbaa !17
  %and81 = and i64 %26, 32768
  %tobool82 = icmp eq i64 %and81, 0
  br i1 %tobool82, label %cond.false85, label %cond.true83

cond.true83:                                      ; preds = %if.then79
  %call84 = tail call i64 @Perl_mg_size(%struct.sv* %1) #2
  br label %cond.end87

cond.false85:                                     ; preds = %if.then79
  %sv_any86 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %27 = load %struct.xpvav** %sv_any86, align 8, !tbaa !1
  %xav_fill = getelementptr inbounds %struct.xpvav* %27, i64 0, i32 1
  %28 = load i64* %xav_fill, align 8, !tbaa !11
  br label %cond.end87

cond.end87:                                       ; preds = %cond.false85, %cond.true83
  %cond88 = phi i64 [ %call84, %cond.true83 ], [ %28, %cond.false85 ]
  %add = add i64 %key, 1
  %add89 = add i64 %add, %cond88
  %cmp90 = icmp slt i64 %add89, 0
  br i1 %cmp90, label %return, label %if.end95

if.end95:                                         ; preds = %cond.true62, %land.lhs.true32, %cond.false69, %cond.true48, %land.lhs.true36, %cond.end87, %if.then7
  %key.addr.0 = phi i64 [ %add89, %cond.end87 ], [ %key, %if.then7 ], [ %key, %land.lhs.true36 ], [ %key, %cond.true48 ], [ %key, %cond.false69 ], [ %key, %land.lhs.true32 ], [ %key, %cond.true62 ]
  %cmp96 = icmp eq %struct.sv* %PL_sv_undef.val, @PL_sv_undef
  br i1 %cmp96, label %return, label %if.then98

if.then98:                                        ; preds = %if.end95
  %call99 = tail call i32 @Perl_mg_copy(%struct.sv* %1, %struct.sv* %PL_sv_undef.val, i8* null, i64 %key.addr.0) #2
  br label %return

if.end102:                                        ; preds = %if.then5, %if.end
  %cmp103 = icmp slt i64 %key, 0
  br i1 %cmp103, label %if.then105, label %if.end122

if.then105:                                       ; preds = %if.end102
  %29 = load i64* %sv_flags, align 8, !tbaa !17
  %and107 = and i64 %29, 32768
  %tobool108 = icmp eq i64 %and107, 0
  br i1 %tobool108, label %cond.false111, label %cond.true109

cond.true109:                                     ; preds = %if.then105
  %30 = bitcast %struct.av* %av to %struct.sv*
  %call110 = tail call i64 @Perl_mg_size(%struct.sv* %30) #2
  br label %cond.end114

cond.false111:                                    ; preds = %if.then105
  %sv_any112 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %31 = load %struct.xpvav** %sv_any112, align 8, !tbaa !1
  %xav_fill113 = getelementptr inbounds %struct.xpvav* %31, i64 0, i32 1
  %32 = load i64* %xav_fill113, align 8, !tbaa !11
  br label %cond.end114

cond.end114:                                      ; preds = %cond.false111, %cond.true109
  %cond115 = phi i64 [ %call110, %cond.true109 ], [ %32, %cond.false111 ]
  %add116 = add i64 %key, 1
  %add117 = add i64 %add116, %cond115
  %cmp118 = icmp slt i64 %add117, 0
  br i1 %cmp118, label %return, label %if.end122

if.end122:                                        ; preds = %cond.end114, %if.end102
  %key.addr.1 = phi i64 [ %add117, %cond.end114 ], [ %key, %if.end102 ]
  %33 = load i64* %sv_flags, align 8, !tbaa !41
  %and124 = and i64 %33, 8388608
  %tobool125 = icmp eq i64 %and124, 0
  br i1 %tobool125, label %if.end140, label %land.lhs.true126

land.lhs.true126:                                 ; preds = %if.end122
  %and128 = and i64 %33, 32768
  %tobool129 = icmp eq i64 %and128, 0
  br i1 %tobool129, label %cond.false132, label %cond.true130

cond.true130:                                     ; preds = %land.lhs.true126
  %34 = bitcast %struct.av* %av to %struct.sv*
  %call131 = tail call i64 @Perl_mg_size(%struct.sv* %34) #2
  br label %cond.end135

cond.false132:                                    ; preds = %land.lhs.true126
  %sv_any133 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %35 = load %struct.xpvav** %sv_any133, align 8, !tbaa !1
  %xav_fill134 = getelementptr inbounds %struct.xpvav* %35, i64 0, i32 1
  %36 = load i64* %xav_fill134, align 8, !tbaa !11
  br label %cond.end135

cond.end135:                                      ; preds = %cond.false132, %cond.true130
  %cond136 = phi i64 [ %call131, %cond.true130 ], [ %36, %cond.false132 ]
  %cmp137 = icmp slt i64 %key.addr.1, %cond136
  br i1 %cmp137, label %if.end140, label %if.then139

if.then139:                                       ; preds = %cond.end135
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([0 x i8]* @PL_no_modify, i64 0, i64 0)) #2
  br label %if.end140

if.end140:                                        ; preds = %cond.end135, %if.end122, %if.then139
  %sv_any141 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %37 = load %struct.xpvav** %sv_any141, align 8, !tbaa !1
  %xav_flags = getelementptr inbounds %struct.xpvav* %37, i64 0, i32 9
  %38 = load i8* %xav_flags, align 1, !tbaa !7
  %39 = and i8 %38, 3
  %40 = icmp eq i8 %39, 2
  br i1 %40, label %if.then151, label %if.end153

if.then151:                                       ; preds = %if.end140
  %call152 = tail call i32 (%struct.av*, ...)* bitcast (i32 (...)* @av_reify to i32 (%struct.av*, ...)*)(%struct.av* %av) #2
  %.pre = load %struct.xpvav** %sv_any141, align 8, !tbaa !1
  br label %if.end153

if.end153:                                        ; preds = %if.end140, %if.then151
  %41 = phi %struct.xpvav* [ %37, %if.end140 ], [ %.pre, %if.then151 ]
  %xav_max = getelementptr inbounds %struct.xpvav* %41, i64 0, i32 2
  %42 = load i64* %xav_max, align 8, !tbaa !10
  %cmp155 = icmp sgt i64 %key.addr.1, %42
  br i1 %cmp155, label %if.then157, label %if.end158

if.then157:                                       ; preds = %if.end153
  tail call void @Perl_av_extend(%struct.av* %av, i64 %key.addr.1)
  %.pre290 = load %struct.xpvav** %sv_any141, align 8, !tbaa !1
  br label %if.end158

if.end158:                                        ; preds = %if.then157, %if.end153
  %43 = phi %struct.xpvav* [ %.pre290, %if.then157 ], [ %41, %if.end153 ]
  %xav_array = getelementptr inbounds %struct.xpvav* %43, i64 0, i32 0
  %44 = load i8** %xav_array, align 8, !tbaa !12
  %45 = bitcast i8* %44 to %struct.sv**
  %xav_fill161 = getelementptr inbounds %struct.xpvav* %43, i64 0, i32 1
  %46 = load i64* %xav_fill161, align 8, !tbaa !11
  %cmp162 = icmp slt i64 %46, %key.addr.1
  %xav_flags166 = getelementptr inbounds %struct.xpvav* %43, i64 0, i32 9
  %47 = load i8* %xav_flags166, align 1, !tbaa !7
  %and168 = and i8 %47, 1
  %tobool169 = icmp ne i8 %and168, 0
  br i1 %cmp162, label %if.then164, label %if.else

if.then164:                                       ; preds = %if.end158
  br i1 %tobool169, label %if.end184, label %if.then170

if.then170:                                       ; preds = %if.then164
  %48 = load %struct.av** @PL_curstack, align 8, !tbaa !13
  %cmp171 = icmp eq %struct.av* %48, %av
  br i1 %cmp171, label %land.lhs.true173, label %do.body

land.lhs.true173:                                 ; preds = %if.then170
  %49 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %50 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %49 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %50 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %cmp174 = icmp sgt i64 %key.addr.1, %sub.ptr.div
  br i1 %cmp174, label %if.then176, label %do.body

if.then176:                                       ; preds = %land.lhs.true173
  %add.ptr = getelementptr inbounds %struct.sv** %50, i64 %key.addr.1
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %.pre291.pre = load %struct.xpvav** %sv_any141, align 8, !tbaa !1
  %xav_fill179.phi.trans.insert.phi.trans.insert = getelementptr inbounds %struct.xpvav* %.pre291.pre, i64 0, i32 1
  %.pre292.pre = load i64* %xav_fill179.phi.trans.insert.phi.trans.insert, align 8, !tbaa !11
  br label %do.body

do.body:                                          ; preds = %if.then170, %land.lhs.true173, %if.then176, %do.body
  %51 = phi i64 [ %54, %do.body ], [ %46, %if.then170 ], [ %46, %land.lhs.true173 ], [ %.pre292.pre, %if.then176 ]
  %52 = phi %struct.xpvav* [ %53, %do.body ], [ %43, %if.then170 ], [ %43, %land.lhs.true173 ], [ %.pre291.pre, %if.then176 ]
  %xav_fill179 = getelementptr inbounds %struct.xpvav* %52, i64 0, i32 1
  %inc = add nsw i64 %51, 1
  store i64 %inc, i64* %xav_fill179, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds %struct.sv** %45, i64 %inc
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx, align 8, !tbaa !13
  %53 = load %struct.xpvav** %sv_any141, align 8, !tbaa !1
  %xav_fill181 = getelementptr inbounds %struct.xpvav* %53, i64 0, i32 1
  %54 = load i64* %xav_fill181, align 8, !tbaa !11
  %cmp182 = icmp slt i64 %54, %key.addr.1
  br i1 %cmp182, label %do.body, label %if.end184

if.end184:                                        ; preds = %do.body, %if.then164
  %55 = phi %struct.xpvav* [ %43, %if.then164 ], [ %53, %do.body ]
  %xav_fill186 = getelementptr inbounds %struct.xpvav* %55, i64 0, i32 1
  store i64 %key.addr.1, i64* %xav_fill186, align 8, !tbaa !11
  br label %if.end195

if.else:                                          ; preds = %if.end158
  br i1 %tobool169, label %if.then192, label %if.end195

if.then192:                                       ; preds = %if.else
  %arrayidx193 = getelementptr inbounds %struct.sv** %45, i64 %key.addr.1
  %56 = load %struct.sv** %arrayidx193, align 8, !tbaa !13
  tail call void @Perl_sv_free(%struct.sv* %56) #2
  br label %if.end195

if.end195:                                        ; preds = %if.else, %if.then192, %if.end184
  %arrayidx196 = getelementptr inbounds %struct.sv** %45, i64 %key.addr.1
  store %struct.sv* %PL_sv_undef.val, %struct.sv** %arrayidx196, align 8, !tbaa !13
  %57 = load i64* %sv_flags, align 8, !tbaa !41
  %and198 = and i64 %57, 16384
  %tobool199 = icmp eq i64 %and198, 0
  br i1 %tobool199, label %return, label %if.then200

if.then200:                                       ; preds = %if.end195
  %cmp201 = icmp eq %struct.sv* %PL_sv_undef.val, @PL_sv_undef
  br i1 %cmp201, label %if.then200.if.end222_crit_edge, label %if.then203

if.then200.if.end222_crit_edge:                   ; preds = %if.then200
  %.pre295 = bitcast %struct.av* %av to %struct.sv*
  br label %if.end222

if.then203:                                       ; preds = %if.then200
  %58 = load %struct.xpvav** %sv_any141, align 8, !tbaa !1
  %59 = getelementptr inbounds %struct.xpvav* %58, i64 0, i32 5
  %60 = load %struct.magic** %59, align 8, !tbaa !57
  %61 = bitcast %struct.av* %av to %struct.sv*
  %mg_type = getelementptr inbounds %struct.magic* %60, i64 0, i32 3
  %62 = load i8* %mg_type, align 1, !tbaa !58
  %conv205 = sext i8 %62 to i32
  %.off = add i8 %62, -65
  %63 = icmp ult i8 %.off, 26
  %add216 = add nsw i32 %conv205, 32
  %add216.conv205 = select i1 %63, i32 %add216, i32 %conv205
  tail call void @Perl_sv_magic(%struct.sv* %PL_sv_undef.val, %struct.sv* %61, i32 %add216.conv205, i8* null, i64 %key.addr.1) #2
  br label %if.end222

if.end222:                                        ; preds = %if.then200.if.end222_crit_edge, %if.then203
  %.pre-phi = phi %struct.sv* [ %.pre295, %if.then200.if.end222_crit_edge ], [ %61, %if.then203 ]
  %call223 = tail call i32 @Perl_mg_set(%struct.sv* %.pre-phi) #2
  br label %return

return:                                           ; preds = %if.end222, %if.end195, %cond.end114, %if.then98, %if.end95, %cond.end87, %entry
  %retval.0 = phi %struct.sv** [ null, %entry ], [ null, %cond.end87 ], [ null, %if.end95 ], [ null, %if.then98 ], [ null, %cond.end114 ], [ %arrayidx196, %if.end195 ], [ %arrayidx196, %if.end222 ]
  ret %struct.sv** %retval.0
}

declare void @Perl_croak(i8*, ...) #1

declare i32 @av_reify(...) #1

declare void @Perl_sv_free(%struct.sv*) #1

declare void @Perl_sv_magic(%struct.sv*, %struct.sv*, i32, i8*, i64) #1

declare i32 @Perl_mg_set(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.av* @Perl_newAV() #0 {
entry:
  %call = tail call %struct.sv* @Perl_newSV(i64 0) #2
  %0 = bitcast %struct.sv* %call to %struct.av*
  %call1 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %call, i64 10) #2
  %sv_any = bitcast %struct.sv* %call to %struct.xpvav**
  %1 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_flags = getelementptr inbounds %struct.xpvav* %1, i64 0, i32 9
  %2 = load i8* %xav_flags, align 1, !tbaa !7
  %or = or i8 %2, 1
  store i8 %or, i8* %xav_flags, align 1, !tbaa !7
  %xav_alloc = getelementptr inbounds %struct.xpvav* %1, i64 0, i32 7
  store %struct.sv** null, %struct.sv*** %xav_alloc, align 8, !tbaa !16
  %xpv_pv = getelementptr inbounds %struct.xpvav* %1, i64 0, i32 0
  store i8* null, i8** %xpv_pv, align 8, !tbaa !39
  %xav_fill = getelementptr inbounds %struct.xpvav* %1, i64 0, i32 1
  %3 = bitcast i64* %xav_fill to i8*
  call void @llvm.memset.p0i8.i64(i8* %3, i8 -1, i64 16, i32 8, i1 false)
  ret %struct.av* %0
}

; Function Attrs: nounwind uwtable
define %struct.av* @Perl_av_make(i64 %size, %struct.sv** nocapture readonly %strp) #0 {
entry:
  %call = tail call %struct.sv* @Perl_newSV(i64 0) #2
  %0 = bitcast %struct.sv* %call to %struct.av*
  %call1 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %call, i64 10) #2
  %sv_any = bitcast %struct.sv* %call to %struct.xpvav**
  %1 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_flags = getelementptr inbounds %struct.xpvav* %1, i64 0, i32 9
  store i8 1, i8* %xav_flags, align 1, !tbaa !7
  %tobool = icmp eq i64 %size, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %mul = shl i64 %size, 3
  %call2 = tail call i8* @Perl_safesysmalloc(i64 %mul) #2
  %2 = bitcast i8* %call2 to %struct.sv**
  %3 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_alloc = getelementptr inbounds %struct.xpvav* %3, i64 0, i32 7
  store %struct.sv** %2, %struct.sv*** %xav_alloc, align 8, !tbaa !16
  %xpv_pv = getelementptr inbounds %struct.xpvav* %3, i64 0, i32 0
  store i8* %call2, i8** %xpv_pv, align 8, !tbaa !39
  %sub = add nsw i64 %size, -1
  %xav_fill = getelementptr inbounds %struct.xpvav* %3, i64 0, i32 1
  store i64 %sub, i64* %xav_fill, align 8, !tbaa !11
  %xav_max = getelementptr inbounds %struct.xpvav* %3, i64 0, i32 2
  store i64 %sub, i64* %xav_max, align 8, !tbaa !10
  %cmp27 = icmp sgt i64 %size, 0
  br i1 %cmp27, label %for.body, label %if.end

for.body:                                         ; preds = %if.then, %for.body
  %strp.addr.029 = phi %struct.sv** [ %incdec.ptr, %for.body ], [ %strp, %if.then ]
  %i.028 = phi i64 [ %inc, %for.body ], [ 0, %if.then ]
  %call8 = tail call %struct.sv* @Perl_newSV(i64 0) #2
  %arrayidx = getelementptr inbounds %struct.sv** %2, i64 %i.028
  store %struct.sv* %call8, %struct.sv** %arrayidx, align 8, !tbaa !13
  %4 = load %struct.sv** %strp.addr.029, align 8, !tbaa !13
  tail call void @Perl_sv_setsv_flags(%struct.sv* %call8, %struct.sv* %4, i64 2) #2
  %incdec.ptr = getelementptr inbounds %struct.sv** %strp.addr.029, i64 1
  %inc = add nsw i64 %i.028, 1
  %exitcond = icmp eq i64 %inc, %size
  br i1 %exitcond, label %if.end, label %for.body

if.end:                                           ; preds = %for.body, %if.then, %entry
  ret %struct.av* %0
}

declare void @Perl_sv_setsv_flags(%struct.sv*, %struct.sv*, i64) #1

; Function Attrs: nounwind uwtable
define %struct.av* @Perl_av_fake(i64 %size, %struct.sv** nocapture readonly %strp) #0 {
entry:
  %call = tail call %struct.sv* @Perl_newSV(i64 0) #2
  %0 = bitcast %struct.sv* %call to %struct.av*
  %call1 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %call, i64 10) #2
  %add = shl i64 %size, 3
  %mul = add i64 %add, 8
  %call2 = tail call i8* @Perl_safesysmalloc(i64 %mul) #2
  %1 = bitcast i8* %call2 to %struct.sv**
  %sv_any = bitcast %struct.sv* %call to %struct.xpvav**
  %2 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_alloc = getelementptr inbounds %struct.xpvav* %2, i64 0, i32 7
  store %struct.sv** %1, %struct.sv*** %xav_alloc, align 8, !tbaa !16
  %3 = bitcast %struct.sv** %strp to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %call2, i8* %3, i64 %add, i32 1, i1 false)
  %4 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_flags = getelementptr inbounds %struct.xpvav* %4, i64 0, i32 9
  store i8 2, i8* %xav_flags, align 1, !tbaa !7
  %xpv_pv = getelementptr inbounds %struct.xpvav* %4, i64 0, i32 0
  store i8* %call2, i8** %xpv_pv, align 8, !tbaa !39
  %sub = add nsw i64 %size, -1
  %xav_fill = getelementptr inbounds %struct.xpvav* %4, i64 0, i32 1
  store i64 %sub, i64* %xav_fill, align 8, !tbaa !11
  %xav_max = getelementptr inbounds %struct.xpvav* %4, i64 0, i32 2
  store i64 %sub, i64* %xav_max, align 8, !tbaa !10
  %tobool23 = icmp eq i64 %size, 0
  br i1 %tobool23, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %while.body
  %size.addr.025 = phi i64 [ %dec, %while.body ], [ %size, %entry ]
  %strp.addr.024 = phi %struct.sv** [ %incdec.ptr, %while.body ], [ %strp, %entry ]
  %dec = add nsw i64 %size.addr.025, -1
  %5 = load %struct.sv** %strp.addr.024, align 8, !tbaa !13
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i64* %sv_flags, align 8, !tbaa !17
  %and = and i64 %6, -2049
  store i64 %and, i64* %sv_flags, align 8, !tbaa !17
  %incdec.ptr = getelementptr inbounds %struct.sv** %strp.addr.024, i64 1
  %tobool = icmp eq i64 %dec, 0
  br i1 %tobool, label %while.end, label %while.body

while.end:                                        ; preds = %while.body, %entry
  ret %struct.av* %0
}

; Function Attrs: nounwind uwtable
define void @Perl_av_clear(%struct.av* %av) #0 {
entry:
  %tobool = icmp eq %struct.av* %av, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.av* %av, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !41
  %and = and i64 %0, 8388608
  %tobool1 = icmp eq i64 %and, 0
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([0 x i8]* @PL_no_modify, i64 0, i64 0)) #2
  %.pre = load i64* %sv_flags, align 8, !tbaa !41
  br label %if.end3

if.end3:                                          ; preds = %if.end, %if.then2
  %1 = phi i64 [ %0, %if.end ], [ %.pre, %if.then2 ]
  %and5 = and i64 %1, 32768
  %tobool6 = icmp eq i64 %and5, 0
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end3
  %2 = bitcast %struct.av* %av to %struct.sv*
  %call = tail call i32 @Perl_mg_clear(%struct.sv* %2) #2
  br label %if.end8

if.end8:                                          ; preds = %if.end3, %if.then7
  %sv_any = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %3 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_max = getelementptr inbounds %struct.xpvav* %3, i64 0, i32 2
  %4 = load i64* %xav_max, align 8, !tbaa !10
  %cmp = icmp slt i64 %4, 0
  br i1 %cmp, label %return, label %if.end10

if.end10:                                         ; preds = %if.end8
  %xav_flags = getelementptr inbounds %struct.xpvav* %3, i64 0, i32 9
  %5 = load i8* %xav_flags, align 1, !tbaa !7
  %and12 = and i8 %5, 1
  %tobool13 = icmp eq i8 %and12, 0
  br i1 %tobool13, label %if.end19, label %if.then14

if.then14:                                        ; preds = %if.end10
  %xav_array = getelementptr inbounds %struct.xpvav* %3, i64 0, i32 0
  %6 = load i8** %xav_array, align 8, !tbaa !12
  %7 = bitcast i8* %6 to %struct.sv**
  %xav_fill = getelementptr inbounds %struct.xpvav* %3, i64 0, i32 1
  %8 = load i64* %xav_fill, align 8, !tbaa !11
  %add = add nsw i64 %8, 1
  %tobool1751 = icmp eq i64 %add, 0
  br i1 %tobool1751, label %if.end19, label %while.body

while.body:                                       ; preds = %if.then14, %while.body
  %key.052 = phi i64 [ %dec, %while.body ], [ %add, %if.then14 ]
  %dec = add nsw i64 %key.052, -1
  %arrayidx = getelementptr inbounds %struct.sv** %7, i64 %dec
  %9 = load %struct.sv** %arrayidx, align 8, !tbaa !13
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx, align 8, !tbaa !13
  tail call void @Perl_sv_free(%struct.sv* %9) #2
  %tobool17 = icmp eq i64 %dec, 0
  br i1 %tobool17, label %while.cond.if.end19.loopexit_crit_edge, label %while.body

while.cond.if.end19.loopexit_crit_edge:           ; preds = %while.body
  %.pre53.pre = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  br label %if.end19

if.end19:                                         ; preds = %if.then14, %while.cond.if.end19.loopexit_crit_edge, %if.end10
  %10 = phi %struct.xpvav* [ %3, %if.end10 ], [ %.pre53.pre, %while.cond.if.end19.loopexit_crit_edge ], [ %3, %if.then14 ]
  %xav_array21 = getelementptr inbounds %struct.xpvav* %10, i64 0, i32 0
  %11 = load i8** %xav_array21, align 8, !tbaa !12
  %xav_alloc = getelementptr inbounds %struct.xpvav* %10, i64 0, i32 7
  %12 = load %struct.sv*** %xav_alloc, align 8, !tbaa !16
  %sub.ptr.lhs.cast = ptrtoint i8* %11 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %12 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %tobool23 = icmp eq i64 %sub.ptr.div, 0
  br i1 %tobool23, label %if.end31, label %if.then24

if.then24:                                        ; preds = %if.end19
  %xav_max26 = getelementptr inbounds %struct.xpvav* %10, i64 0, i32 2
  %13 = load i64* %xav_max26, align 8, !tbaa !10
  %add27 = add nsw i64 %13, %sub.ptr.div
  store i64 %add27, i64* %xav_max26, align 8, !tbaa !10
  %14 = bitcast %struct.sv** %12 to i8*
  store i8* %14, i8** %xav_array21, align 8, !tbaa !39
  br label %if.end31

if.end31:                                         ; preds = %if.end19, %if.then24
  %xav_fill33 = getelementptr inbounds %struct.xpvav* %10, i64 0, i32 1
  store i64 -1, i64* %xav_fill33, align 8, !tbaa !11
  br label %return

return:                                           ; preds = %entry, %if.end8, %if.end31
  ret void
}

declare i32 @Perl_mg_clear(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define void @Perl_av_undef(%struct.av* %av) #0 {
entry:
  %tobool = icmp eq %struct.av* %av, null
  br i1 %tobool, label %if.end26, label %if.end

if.end:                                           ; preds = %entry
  %0 = getelementptr inbounds %struct.av* %av, i64 0, i32 2
  %1 = load i64* %0, align 8, !tbaa !17
  %and = and i64 %1, 32768
  %tobool1 = icmp eq i64 %and, 0
  br i1 %tobool1, label %if.end4, label %cond.true

cond.true:                                        ; preds = %if.end
  %2 = bitcast %struct.av* %av to %struct.sv*
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %2, i32 80) #2
  %tobool2 = icmp eq %struct.magic* %call, null
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %cond.true
  tail call void @Perl_av_fill(%struct.av* %av, i64 -1)
  br label %if.end4

if.end4:                                          ; preds = %cond.true, %if.end, %if.then3
  %sv_any = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %3 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_flags = getelementptr inbounds %struct.xpvav* %3, i64 0, i32 9
  %4 = load i8* %xav_flags, align 1, !tbaa !7
  %and5 = and i8 %4, 1
  %tobool6 = icmp eq i8 %and5, 0
  br i1 %tobool6, label %if.end11, label %if.then7

if.then7:                                         ; preds = %if.end4
  %xav_fill = getelementptr inbounds %struct.xpvav* %3, i64 0, i32 1
  %5 = load i64* %xav_fill, align 8, !tbaa !11
  %add = add nsw i64 %5, 1
  %tobool942 = icmp eq i64 %add, 0
  br i1 %tobool942, label %if.end11, label %while.body

while.body:                                       ; preds = %if.then7, %while.body
  %6 = phi %struct.xpvav* [ %.pre.pre, %while.body ], [ %3, %if.then7 ]
  %key.043 = phi i64 [ %dec, %while.body ], [ %add, %if.then7 ]
  %dec = add nsw i64 %key.043, -1
  %xav_array = getelementptr inbounds %struct.xpvav* %6, i64 0, i32 0
  %7 = load i8** %xav_array, align 8, !tbaa !12
  %8 = bitcast i8* %7 to %struct.sv**
  %arrayidx = getelementptr inbounds %struct.sv** %8, i64 %dec
  %9 = load %struct.sv** %arrayidx, align 8, !tbaa !13
  tail call void @Perl_sv_free(%struct.sv* %9) #2
  %tobool9 = icmp eq i64 %dec, 0
  %.pre.pre = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  br i1 %tobool9, label %if.end11, label %while.body

if.end11:                                         ; preds = %while.body, %if.then7, %if.end4
  %10 = phi %struct.xpvav* [ %3, %if.end4 ], [ %3, %if.then7 ], [ %.pre.pre, %while.body ]
  %xav_alloc = getelementptr inbounds %struct.xpvav* %10, i64 0, i32 7
  %11 = load %struct.sv*** %xav_alloc, align 8, !tbaa !16
  %12 = bitcast %struct.sv** %11 to i8*
  tail call void @Perl_safesysfree(i8* %12) #2
  %13 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_alloc14 = getelementptr inbounds %struct.xpvav* %13, i64 0, i32 7
  store %struct.sv** null, %struct.sv*** %xav_alloc14, align 8, !tbaa !16
  %xpv_pv = getelementptr inbounds %struct.xpvav* %13, i64 0, i32 0
  store i8* null, i8** %xpv_pv, align 8, !tbaa !39
  %xav_fill17 = getelementptr inbounds %struct.xpvav* %13, i64 0, i32 1
  %xav_arylen = getelementptr inbounds %struct.xpvav* %13, i64 0, i32 8
  %14 = bitcast i64* %xav_fill17 to i8*
  call void @llvm.memset.p0i8.i64(i8* %14, i8 -1, i64 16, i32 8, i1 false)
  %15 = load %struct.sv** %xav_arylen, align 8, !tbaa !59
  %tobool20 = icmp eq %struct.sv* %15, null
  br i1 %tobool20, label %if.end26, label %if.then21

if.then21:                                        ; preds = %if.end11
  tail call void @Perl_sv_free(%struct.sv* %15) #2
  %16 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_arylen25 = getelementptr inbounds %struct.xpvav* %16, i64 0, i32 8
  store %struct.sv* null, %struct.sv** %xav_arylen25, align 8, !tbaa !59
  br label %if.end26

if.end26:                                         ; preds = %if.end11, %entry, %if.then21
  ret void
}

; Function Attrs: nounwind uwtable
define void @Perl_av_fill(%struct.av* %av, i64 %fill) #0 {
entry:
  %tobool = icmp eq %struct.av* %av, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([18 x i8]* @.str7, i64 0, i64 0)) #2
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %cmp = icmp sgt i64 %fill, -1
  %.fill = select i1 %cmp, i64 %fill, i64 -1
  %0 = bitcast %struct.av* %av to %struct.sv*
  %1 = getelementptr inbounds %struct.av* %av, i64 0, i32 2
  %2 = load i64* %1, align 8, !tbaa !17
  %and = and i64 %2, 32768
  %tobool3 = icmp eq i64 %and, 0
  br i1 %tobool3, label %if.end105, label %cond.end

cond.end:                                         ; preds = %if.end
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %0, i32 80) #2
  %tobool4 = icmp eq %struct.magic* %call, null
  br i1 %tobool4, label %if.end105, label %if.then5

if.then5:                                         ; preds = %cond.end
  %3 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  tail call void @Perl_push_scope() #2
  tail call void @Perl_save_int(i32* bitcast (i64* @PL_tmps_floor to i32*)) #2
  %4 = load i64* @PL_tmps_ix, align 8, !tbaa !18
  store i64 %4, i64* @PL_tmps_floor, align 8, !tbaa !18
  %5 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_next = getelementptr inbounds %struct.stackinfo* %5, i64 0, i32 6
  %6 = load %struct.stackinfo** %si_next, align 8, !tbaa !19
  %tobool6 = icmp eq %struct.stackinfo* %6, null
  br i1 %tobool6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.then5
  %call8 = tail call %struct.stackinfo* @Perl_new_stackinfo(i64 32, i64 12) #2
  %7 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_prev = getelementptr inbounds %struct.stackinfo* %call8, i64 0, i32 5
  store %struct.stackinfo* %7, %struct.stackinfo** %si_prev, align 8, !tbaa !21
  %8 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_next9 = getelementptr inbounds %struct.stackinfo* %8, i64 0, i32 6
  store %struct.stackinfo* %call8, %struct.stackinfo** %si_next9, align 8, !tbaa !19
  br label %if.end10

if.end10:                                         ; preds = %if.then5, %if.then7
  %next.0 = phi %struct.stackinfo* [ %6, %if.then5 ], [ %call8, %if.then7 ]
  %si_type = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 4
  store i64 2, i64* %si_type, align 8, !tbaa !22
  %si_cxix = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !23
  %si_stack = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 0
  %9 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any = getelementptr inbounds %struct.av* %9, i64 0, i32 0
  %10 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_fill = getelementptr inbounds %struct.xpvav* %10, i64 0, i32 1
  store i64 0, i64* %xav_fill, align 8, !tbaa !11
  %11 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %3 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %11 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %12 = load %struct.av** @PL_curstack, align 8, !tbaa !13
  %sv_any11 = getelementptr inbounds %struct.av* %12, i64 0, i32 0
  %13 = load %struct.xpvav** %sv_any11, align 8, !tbaa !1
  %xav_fill12 = getelementptr inbounds %struct.xpvav* %13, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill12, align 8, !tbaa !11
  %xav_array = getelementptr inbounds %struct.xpvav* %10, i64 0, i32 0
  %14 = load i8** %xav_array, align 8, !tbaa !12
  %15 = bitcast i8* %14 to %struct.sv**
  store %struct.sv** %15, %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %16 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any16 = getelementptr inbounds %struct.av* %16, i64 0, i32 0
  %17 = load %struct.xpvav** %sv_any16, align 8, !tbaa !1
  %xav_max = getelementptr inbounds %struct.xpvav* %17, i64 0, i32 2
  %18 = load i64* %xav_max, align 8, !tbaa !10
  %add.ptr = getelementptr inbounds %struct.sv** %15, i64 %18
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  %19 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any18 = getelementptr inbounds %struct.av* %19, i64 0, i32 0
  %20 = load %struct.xpvav** %sv_any18, align 8, !tbaa !1
  %xav_fill19 = getelementptr inbounds %struct.xpvav* %20, i64 0, i32 1
  %21 = load i64* %xav_fill19, align 8, !tbaa !11
  %add.ptr20 = getelementptr inbounds %struct.sv** %15, i64 %21
  store %struct.sv** %add.ptr20, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %22 = load %struct.av** %si_stack, align 8, !tbaa !24
  store %struct.av* %22, %struct.av** @PL_curstack, align 8, !tbaa !13
  store %struct.stackinfo* %next.0, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %23 = load i64** @PL_markstack_ptr, align 8, !tbaa !13
  %incdec.ptr = getelementptr inbounds i64* %23, i64 1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !13
  %24 = load i64** @PL_markstack_max, align 8, !tbaa !13
  %cmp22 = icmp eq i64* %incdec.ptr, %24
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end10
  tail call void @Perl_markstack_grow() #2
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %.pre192 = load i64** @PL_markstack_ptr, align 8, !tbaa !13
  %.pre193 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.end10
  %25 = phi %struct.sv** [ %.pre193, %if.then23 ], [ %add.ptr, %if.end10 ]
  %26 = phi i64* [ %.pre192, %if.then23 ], [ %incdec.ptr, %if.end10 ]
  %27 = phi %struct.sv** [ %.pre, %if.then23 ], [ %15, %if.end10 ]
  %sub.ptr.lhs.cast26 = ptrtoint %struct.sv** %add.ptr20 to i64
  %sub.ptr.rhs.cast27 = ptrtoint %struct.sv** %27 to i64
  %sub.ptr.sub28 = sub i64 %sub.ptr.lhs.cast26, %sub.ptr.rhs.cast27
  %sub.ptr.div29 = ashr exact i64 %sub.ptr.sub28, 3
  store i64 %sub.ptr.div29, i64* %26, align 8, !tbaa !18
  %sub.ptr.lhs.cast30 = ptrtoint %struct.sv** %25 to i64
  %sub.ptr.sub32 = sub i64 %sub.ptr.lhs.cast30, %sub.ptr.lhs.cast26
  %cmp34 = icmp slt i64 %sub.ptr.sub32, 16
  br i1 %cmp34, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end24
  %call36 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr20, %struct.sv** %add.ptr20, i32 2) #2
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %if.end24
  %sp.0 = phi %struct.sv** [ %call36, %if.then35 ], [ %add.ptr20, %if.end24 ]
  %mg_obj = getelementptr inbounds %struct.magic* %call, i64 0, i32 5
  %28 = load %struct.sv** %mg_obj, align 8, !tbaa !25
  %tobool38 = icmp eq %struct.sv* %28, null
  br i1 %tobool38, label %cond.false41, label %cond.end44

cond.false41:                                     ; preds = %if.end37
  %call42 = tail call %struct.sv* @Perl_newRV(%struct.sv* %0) #2
  %call43 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call42) #2
  br label %cond.end44

cond.end44:                                       ; preds = %if.end37, %cond.false41
  %cond45 = phi %struct.sv* [ %call43, %cond.false41 ], [ %28, %if.end37 ]
  %incdec.ptr46 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %cond45, %struct.sv** %incdec.ptr46, align 8, !tbaa !13
  %add = add nsw i64 %.fill, 1
  %call47 = tail call %struct.sv* @Perl_newSViv(i64 %add) #2
  %call48 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call47) #2
  %incdec.ptr49 = getelementptr inbounds %struct.sv** %sp.0, i64 2
  store %struct.sv* %call48, %struct.sv** %incdec.ptr49, align 8, !tbaa !13
  store %struct.sv** %incdec.ptr49, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %call50 = tail call i64 @Perl_call_method(i8* getelementptr inbounds ([10 x i8]* @.str8, i64 0, i64 0), i64 2) #2
  %29 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %30 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_prev54 = getelementptr inbounds %struct.stackinfo* %30, i64 0, i32 5
  %31 = load %struct.stackinfo** %si_prev54, align 8, !tbaa !21
  %tobool55 = icmp eq %struct.stackinfo* %31, null
  br i1 %tobool55, label %if.then56, label %if.end81

if.then56:                                        ; preds = %cond.end44
  %32 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !13
  %tobool57 = icmp eq %struct.gv* %32, null
  br i1 %tobool57, label %cond.false76, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then56
  %sv_flags58 = getelementptr inbounds %struct.gv* %32, i64 0, i32 2
  %33 = load i64* %sv_flags58, align 8, !tbaa !28
  %and59 = and i64 %33, 255
  %cmp60 = icmp eq i64 %and59, 13
  br i1 %cmp60, label %land.lhs.true61, label %cond.false76

land.lhs.true61:                                  ; preds = %land.lhs.true
  %sv_any62 = getelementptr inbounds %struct.gv* %32, i64 0, i32 0
  %34 = load %struct.xpvgv** %sv_any62, align 8, !tbaa !30
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %34, i64 0, i32 7
  %35 = load %struct.gp** %xgv_gp, align 8, !tbaa !31
  %gp_io = getelementptr inbounds %struct.gp* %35, i64 0, i32 2
  %36 = load %struct.io** %gp_io, align 8, !tbaa !33
  %tobool63 = icmp eq %struct.io* %36, null
  br i1 %tobool63, label %cond.false76, label %land.lhs.true64

land.lhs.true64:                                  ; preds = %land.lhs.true61
  %sv_any68 = getelementptr inbounds %struct.io* %36, i64 0, i32 0
  %37 = load %struct.xpvio** %sv_any68, align 8, !tbaa !35
  %xio_ofp = getelementptr inbounds %struct.xpvio* %37, i64 0, i32 8
  %38 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !37
  %tobool69 = icmp eq %struct._PerlIO** %38, null
  br i1 %tobool69, label %cond.false76, label %cond.end78

cond.false76:                                     ; preds = %land.lhs.true64, %land.lhs.true61, %if.then56, %land.lhs.true
  %call77 = tail call %struct._PerlIO** @Perl_PerlIO_stderr() #2
  br label %cond.end78

cond.end78:                                       ; preds = %land.lhs.true64, %cond.false76
  %cond79 = phi %struct._PerlIO** [ %call77, %cond.false76 ], [ %38, %land.lhs.true64 ]
  %call80 = tail call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond79, i8* getelementptr inbounds ([17 x i8]* @.str1, i64 0, i64 0)) #2
  tail call void @Perl_my_exit(i64 1) #2
  br label %if.end81

if.end81:                                         ; preds = %cond.end44, %cond.end78
  %39 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %sub.ptr.lhs.cast82 = ptrtoint %struct.sv** %29 to i64
  %sub.ptr.rhs.cast83 = ptrtoint %struct.sv** %39 to i64
  %sub.ptr.sub84 = sub i64 %sub.ptr.lhs.cast82, %sub.ptr.rhs.cast83
  %sub.ptr.div85 = ashr exact i64 %sub.ptr.sub84, 3
  %40 = load %struct.av** @PL_curstack, align 8, !tbaa !13
  %sv_any86 = getelementptr inbounds %struct.av* %40, i64 0, i32 0
  %41 = load %struct.xpvav** %sv_any86, align 8, !tbaa !1
  %xav_fill87 = getelementptr inbounds %struct.xpvav* %41, i64 0, i32 1
  store i64 %sub.ptr.div85, i64* %xav_fill87, align 8, !tbaa !11
  %si_stack88 = getelementptr inbounds %struct.stackinfo* %31, i64 0, i32 0
  %42 = load %struct.av** %si_stack88, align 8, !tbaa !24
  %sv_any89 = getelementptr inbounds %struct.av* %42, i64 0, i32 0
  %43 = load %struct.xpvav** %sv_any89, align 8, !tbaa !1
  %xav_array90 = getelementptr inbounds %struct.xpvav* %43, i64 0, i32 0
  %44 = load i8** %xav_array90, align 8, !tbaa !12
  %45 = bitcast i8* %44 to %struct.sv**
  store %struct.sv** %45, %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %46 = load %struct.av** %si_stack88, align 8, !tbaa !24
  %sv_any92 = getelementptr inbounds %struct.av* %46, i64 0, i32 0
  %47 = load %struct.xpvav** %sv_any92, align 8, !tbaa !1
  %xav_max93 = getelementptr inbounds %struct.xpvav* %47, i64 0, i32 2
  %48 = load i64* %xav_max93, align 8, !tbaa !10
  %add.ptr94 = getelementptr inbounds %struct.sv** %45, i64 %48
  store %struct.sv** %add.ptr94, %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  %49 = load %struct.av** %si_stack88, align 8, !tbaa !24
  %sv_any96 = getelementptr inbounds %struct.av* %49, i64 0, i32 0
  %50 = load %struct.xpvav** %sv_any96, align 8, !tbaa !1
  %xav_fill97 = getelementptr inbounds %struct.xpvav* %50, i64 0, i32 1
  %51 = load i64* %xav_fill97, align 8, !tbaa !11
  %add.ptr98 = getelementptr inbounds %struct.sv** %45, i64 %51
  store %struct.sv** %add.ptr98, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %52 = load %struct.av** %si_stack88, align 8, !tbaa !24
  store %struct.av* %52, %struct.av** @PL_curstack, align 8, !tbaa !13
  store %struct.stackinfo* %31, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %53 = load i64* @PL_tmps_ix, align 8, !tbaa !18
  %54 = load i64* @PL_tmps_floor, align 8, !tbaa !18
  %cmp102 = icmp sgt i64 %53, %54
  br i1 %cmp102, label %if.then103, label %if.end104

if.then103:                                       ; preds = %if.end81
  tail call void @Perl_free_tmps() #2
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %if.end81
  tail call void @Perl_pop_scope() #2
  br label %if.end140

if.end105:                                        ; preds = %if.end, %cond.end
  %sv_any106 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %55 = load %struct.xpvav** %sv_any106, align 8, !tbaa !1
  %xav_max107 = getelementptr inbounds %struct.xpvav* %55, i64 0, i32 2
  %56 = load i64* %xav_max107, align 8, !tbaa !10
  %cmp108 = icmp sgt i64 %.fill, %56
  br i1 %cmp108, label %if.else138, label %if.then109

if.then109:                                       ; preds = %if.end105
  %xav_fill112 = getelementptr inbounds %struct.xpvav* %55, i64 0, i32 1
  %57 = load i64* %xav_fill112, align 8, !tbaa !11
  %xav_array115 = getelementptr inbounds %struct.xpvav* %55, i64 0, i32 0
  %58 = load i8** %xav_array115, align 8, !tbaa !12
  %59 = bitcast i8* %58 to %struct.sv**
  %xav_flags = getelementptr inbounds %struct.xpvav* %55, i64 0, i32 9
  %60 = load i8* %xav_flags, align 1, !tbaa !7
  %and117 = and i8 %60, 1
  %tobool118 = icmp eq i8 %and117, 0
  br i1 %tobool118, label %while.cond123.preheader, label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.then109
  %cmp120190 = icmp sgt i64 %57, %.fill
  br i1 %cmp120190, label %while.body, label %if.end129

while.cond123.preheader:                          ; preds = %if.then109
  %cmp124188 = icmp slt i64 %57, %.fill
  br i1 %cmp124188, label %while.body126, label %if.end129

while.body:                                       ; preds = %while.cond.preheader, %while.body
  %key.0191 = phi i64 [ %dec, %while.body ], [ %57, %while.cond.preheader ]
  %arrayidx = getelementptr inbounds %struct.sv** %59, i64 %key.0191
  %61 = load %struct.sv** %arrayidx, align 8, !tbaa !13
  tail call void @Perl_sv_free(%struct.sv* %61) #2
  %dec = add nsw i64 %key.0191, -1
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx, align 8, !tbaa !13
  %cmp120 = icmp sgt i64 %dec, %.fill
  br i1 %cmp120, label %while.body, label %if.end129

while.body126:                                    ; preds = %while.cond123.preheader, %while.body126
  %key.1189 = phi i64 [ %inc, %while.body126 ], [ %57, %while.cond123.preheader ]
  %inc = add nsw i64 %key.1189, 1
  %arrayidx127 = getelementptr inbounds %struct.sv** %59, i64 %inc
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx127, align 8, !tbaa !13
  %cmp124 = icmp slt i64 %inc, %.fill
  br i1 %cmp124, label %while.body126, label %if.end129

if.end129:                                        ; preds = %while.body, %while.body126, %while.cond.preheader, %while.cond123.preheader
  %62 = load %struct.xpvav** %sv_any106, align 8, !tbaa !1
  %xav_fill131 = getelementptr inbounds %struct.xpvav* %62, i64 0, i32 1
  store i64 %.fill, i64* %xav_fill131, align 8, !tbaa !11
  %63 = load i64* %1, align 8, !tbaa !41
  %and133 = and i64 %63, 16384
  %tobool134 = icmp eq i64 %and133, 0
  br i1 %tobool134, label %if.end140, label %if.then135

if.then135:                                       ; preds = %if.end129
  %call136 = tail call i32 @Perl_mg_set(%struct.sv* %0) #2
  br label %if.end140

if.else138:                                       ; preds = %if.end105
  %call139 = tail call %struct.sv** @Perl_av_store(%struct.av* %av, i64 %.fill, %struct.sv* @PL_sv_undef)
  br label %if.end140

if.end140:                                        ; preds = %if.end129, %if.then135, %if.end104, %if.else138
  ret void
}

; Function Attrs: nounwind uwtable
define void @Perl_av_push(%struct.av* %av, %struct.sv* %val) #0 {
entry:
  %tobool = icmp eq %struct.av* %av, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.av* %av, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !41
  %and = and i64 %0, 8388608
  %tobool1 = icmp eq i64 %and, 0
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([0 x i8]* @PL_no_modify, i64 0, i64 0)) #2
  %.pre = load i64* %sv_flags, align 8, !tbaa !17
  br label %if.end3

if.end3:                                          ; preds = %if.end, %if.then2
  %1 = phi i64 [ %0, %if.end ], [ %.pre, %if.then2 ]
  %2 = bitcast %struct.av* %av to %struct.sv*
  %and5 = and i64 %1, 32768
  %tobool6 = icmp eq i64 %and5, 0
  br i1 %tobool6, label %if.end102, label %cond.end

cond.end:                                         ; preds = %if.end3
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %2, i32 80) #2
  %tobool7 = icmp eq %struct.magic* %call, null
  br i1 %tobool7, label %if.end102, label %if.then8

if.then8:                                         ; preds = %cond.end
  %3 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %4 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_next = getelementptr inbounds %struct.stackinfo* %4, i64 0, i32 6
  %5 = load %struct.stackinfo** %si_next, align 8, !tbaa !19
  %tobool9 = icmp eq %struct.stackinfo* %5, null
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.then8
  %call11 = tail call %struct.stackinfo* @Perl_new_stackinfo(i64 32, i64 12) #2
  %6 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_prev = getelementptr inbounds %struct.stackinfo* %call11, i64 0, i32 5
  store %struct.stackinfo* %6, %struct.stackinfo** %si_prev, align 8, !tbaa !21
  %7 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_next12 = getelementptr inbounds %struct.stackinfo* %7, i64 0, i32 6
  store %struct.stackinfo* %call11, %struct.stackinfo** %si_next12, align 8, !tbaa !19
  br label %if.end13

if.end13:                                         ; preds = %if.then8, %if.then10
  %next.0 = phi %struct.stackinfo* [ %5, %if.then8 ], [ %call11, %if.then10 ]
  %si_type = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 4
  store i64 2, i64* %si_type, align 8, !tbaa !22
  %si_cxix = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !23
  %si_stack = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 0
  %8 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any = getelementptr inbounds %struct.av* %8, i64 0, i32 0
  %9 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_fill = getelementptr inbounds %struct.xpvav* %9, i64 0, i32 1
  store i64 0, i64* %xav_fill, align 8, !tbaa !11
  %10 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %3 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %10 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %11 = load %struct.av** @PL_curstack, align 8, !tbaa !13
  %sv_any14 = getelementptr inbounds %struct.av* %11, i64 0, i32 0
  %12 = load %struct.xpvav** %sv_any14, align 8, !tbaa !1
  %xav_fill15 = getelementptr inbounds %struct.xpvav* %12, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill15, align 8, !tbaa !11
  %xav_array = getelementptr inbounds %struct.xpvav* %9, i64 0, i32 0
  %13 = load i8** %xav_array, align 8, !tbaa !12
  %14 = bitcast i8* %13 to %struct.sv**
  store %struct.sv** %14, %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %15 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any19 = getelementptr inbounds %struct.av* %15, i64 0, i32 0
  %16 = load %struct.xpvav** %sv_any19, align 8, !tbaa !1
  %xav_max = getelementptr inbounds %struct.xpvav* %16, i64 0, i32 2
  %17 = load i64* %xav_max, align 8, !tbaa !10
  %add.ptr = getelementptr inbounds %struct.sv** %14, i64 %17
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  %18 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any21 = getelementptr inbounds %struct.av* %18, i64 0, i32 0
  %19 = load %struct.xpvav** %sv_any21, align 8, !tbaa !1
  %xav_fill22 = getelementptr inbounds %struct.xpvav* %19, i64 0, i32 1
  %20 = load i64* %xav_fill22, align 8, !tbaa !11
  %add.ptr23 = getelementptr inbounds %struct.sv** %14, i64 %20
  store %struct.sv** %add.ptr23, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %21 = load %struct.av** %si_stack, align 8, !tbaa !24
  store %struct.av* %21, %struct.av** @PL_curstack, align 8, !tbaa !13
  store %struct.stackinfo* %next.0, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %22 = load i64** @PL_markstack_ptr, align 8, !tbaa !13
  %incdec.ptr = getelementptr inbounds i64* %22, i64 1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !13
  %23 = load i64** @PL_markstack_max, align 8, !tbaa !13
  %cmp = icmp eq i64* %incdec.ptr, %23
  br i1 %cmp, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end13
  tail call void @Perl_markstack_grow() #2
  %.pre137 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %.pre138 = load i64** @PL_markstack_ptr, align 8, !tbaa !13
  %.pre139 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %if.end13
  %24 = phi %struct.sv** [ %.pre139, %if.then25 ], [ %add.ptr, %if.end13 ]
  %25 = phi i64* [ %.pre138, %if.then25 ], [ %incdec.ptr, %if.end13 ]
  %26 = phi %struct.sv** [ %.pre137, %if.then25 ], [ %14, %if.end13 ]
  %sub.ptr.lhs.cast28 = ptrtoint %struct.sv** %add.ptr23 to i64
  %sub.ptr.rhs.cast29 = ptrtoint %struct.sv** %26 to i64
  %sub.ptr.sub30 = sub i64 %sub.ptr.lhs.cast28, %sub.ptr.rhs.cast29
  %sub.ptr.div31 = ashr exact i64 %sub.ptr.sub30, 3
  store i64 %sub.ptr.div31, i64* %25, align 8, !tbaa !18
  %sub.ptr.lhs.cast32 = ptrtoint %struct.sv** %24 to i64
  %sub.ptr.sub34 = sub i64 %sub.ptr.lhs.cast32, %sub.ptr.lhs.cast28
  %cmp36 = icmp slt i64 %sub.ptr.sub34, 16
  br i1 %cmp36, label %if.then37, label %if.end39

if.then37:                                        ; preds = %if.end26
  %call38 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr23, %struct.sv** %add.ptr23, i32 2) #2
  br label %if.end39

if.end39:                                         ; preds = %if.then37, %if.end26
  %sp.0 = phi %struct.sv** [ %call38, %if.then37 ], [ %add.ptr23, %if.end26 ]
  %mg_obj = getelementptr inbounds %struct.magic* %call, i64 0, i32 5
  %27 = load %struct.sv** %mg_obj, align 8, !tbaa !25
  %tobool40 = icmp eq %struct.sv* %27, null
  br i1 %tobool40, label %cond.false43, label %cond.end46

cond.false43:                                     ; preds = %if.end39
  %call44 = tail call %struct.sv* @Perl_newRV(%struct.sv* %2) #2
  %call45 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call44) #2
  br label %cond.end46

cond.end46:                                       ; preds = %if.end39, %cond.false43
  %cond47 = phi %struct.sv* [ %call45, %cond.false43 ], [ %27, %if.end39 ]
  %incdec.ptr48 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %cond47, %struct.sv** %incdec.ptr48, align 8, !tbaa !13
  %incdec.ptr49 = getelementptr inbounds %struct.sv** %sp.0, i64 2
  store %struct.sv* %val, %struct.sv** %incdec.ptr49, align 8, !tbaa !13
  store %struct.sv** %incdec.ptr49, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  tail call void @Perl_push_scope() #2
  %call50 = tail call i64 @Perl_call_method(i8* getelementptr inbounds ([5 x i8]* @.str3, i64 0, i64 0), i64 2) #2
  tail call void @Perl_pop_scope() #2
  %28 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %29 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_prev54 = getelementptr inbounds %struct.stackinfo* %29, i64 0, i32 5
  %30 = load %struct.stackinfo** %si_prev54, align 8, !tbaa !21
  %tobool55 = icmp eq %struct.stackinfo* %30, null
  br i1 %tobool55, label %if.then56, label %if.end81

if.then56:                                        ; preds = %cond.end46
  %31 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !13
  %tobool57 = icmp eq %struct.gv* %31, null
  br i1 %tobool57, label %cond.false76, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then56
  %sv_flags58 = getelementptr inbounds %struct.gv* %31, i64 0, i32 2
  %32 = load i64* %sv_flags58, align 8, !tbaa !28
  %and59 = and i64 %32, 255
  %cmp60 = icmp eq i64 %and59, 13
  br i1 %cmp60, label %land.lhs.true61, label %cond.false76

land.lhs.true61:                                  ; preds = %land.lhs.true
  %sv_any62 = getelementptr inbounds %struct.gv* %31, i64 0, i32 0
  %33 = load %struct.xpvgv** %sv_any62, align 8, !tbaa !30
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %33, i64 0, i32 7
  %34 = load %struct.gp** %xgv_gp, align 8, !tbaa !31
  %gp_io = getelementptr inbounds %struct.gp* %34, i64 0, i32 2
  %35 = load %struct.io** %gp_io, align 8, !tbaa !33
  %tobool63 = icmp eq %struct.io* %35, null
  br i1 %tobool63, label %cond.false76, label %land.lhs.true64

land.lhs.true64:                                  ; preds = %land.lhs.true61
  %sv_any68 = getelementptr inbounds %struct.io* %35, i64 0, i32 0
  %36 = load %struct.xpvio** %sv_any68, align 8, !tbaa !35
  %xio_ofp = getelementptr inbounds %struct.xpvio* %36, i64 0, i32 8
  %37 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !37
  %tobool69 = icmp eq %struct._PerlIO** %37, null
  br i1 %tobool69, label %cond.false76, label %cond.end78

cond.false76:                                     ; preds = %land.lhs.true64, %land.lhs.true61, %if.then56, %land.lhs.true
  %call77 = tail call %struct._PerlIO** @Perl_PerlIO_stderr() #2
  br label %cond.end78

cond.end78:                                       ; preds = %land.lhs.true64, %cond.false76
  %cond79 = phi %struct._PerlIO** [ %call77, %cond.false76 ], [ %37, %land.lhs.true64 ]
  %call80 = tail call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond79, i8* getelementptr inbounds ([17 x i8]* @.str1, i64 0, i64 0)) #2
  tail call void @Perl_my_exit(i64 1) #2
  br label %if.end81

if.end81:                                         ; preds = %cond.end46, %cond.end78
  %38 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %sub.ptr.lhs.cast82 = ptrtoint %struct.sv** %28 to i64
  %sub.ptr.rhs.cast83 = ptrtoint %struct.sv** %38 to i64
  %sub.ptr.sub84 = sub i64 %sub.ptr.lhs.cast82, %sub.ptr.rhs.cast83
  %sub.ptr.div85 = ashr exact i64 %sub.ptr.sub84, 3
  %39 = load %struct.av** @PL_curstack, align 8, !tbaa !13
  %sv_any86 = getelementptr inbounds %struct.av* %39, i64 0, i32 0
  %40 = load %struct.xpvav** %sv_any86, align 8, !tbaa !1
  %xav_fill87 = getelementptr inbounds %struct.xpvav* %40, i64 0, i32 1
  store i64 %sub.ptr.div85, i64* %xav_fill87, align 8, !tbaa !11
  %si_stack88 = getelementptr inbounds %struct.stackinfo* %30, i64 0, i32 0
  %41 = load %struct.av** %si_stack88, align 8, !tbaa !24
  %sv_any89 = getelementptr inbounds %struct.av* %41, i64 0, i32 0
  %42 = load %struct.xpvav** %sv_any89, align 8, !tbaa !1
  %xav_array90 = getelementptr inbounds %struct.xpvav* %42, i64 0, i32 0
  %43 = load i8** %xav_array90, align 8, !tbaa !12
  %44 = bitcast i8* %43 to %struct.sv**
  store %struct.sv** %44, %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %45 = load %struct.av** %si_stack88, align 8, !tbaa !24
  %sv_any92 = getelementptr inbounds %struct.av* %45, i64 0, i32 0
  %46 = load %struct.xpvav** %sv_any92, align 8, !tbaa !1
  %xav_max93 = getelementptr inbounds %struct.xpvav* %46, i64 0, i32 2
  %47 = load i64* %xav_max93, align 8, !tbaa !10
  %add.ptr94 = getelementptr inbounds %struct.sv** %44, i64 %47
  store %struct.sv** %add.ptr94, %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  %48 = load %struct.av** %si_stack88, align 8, !tbaa !24
  %sv_any96 = getelementptr inbounds %struct.av* %48, i64 0, i32 0
  %49 = load %struct.xpvav** %sv_any96, align 8, !tbaa !1
  %xav_fill97 = getelementptr inbounds %struct.xpvav* %49, i64 0, i32 1
  %50 = load i64* %xav_fill97, align 8, !tbaa !11
  %add.ptr98 = getelementptr inbounds %struct.sv** %44, i64 %50
  store %struct.sv** %add.ptr98, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %51 = load %struct.av** %si_stack88, align 8, !tbaa !24
  store %struct.av* %51, %struct.av** @PL_curstack, align 8, !tbaa !13
  store %struct.stackinfo* %30, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  br label %return

if.end102:                                        ; preds = %if.end3, %cond.end
  %sv_any103 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %52 = load %struct.xpvav** %sv_any103, align 8, !tbaa !1
  %xav_fill104 = getelementptr inbounds %struct.xpvav* %52, i64 0, i32 1
  %53 = load i64* %xav_fill104, align 8, !tbaa !11
  %add = add nsw i64 %53, 1
  %call105 = tail call %struct.sv** @Perl_av_store(%struct.av* %av, i64 %add, %struct.sv* %val)
  br label %return

return:                                           ; preds = %entry, %if.end102, %if.end81
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.sv* @Perl_av_pop(%struct.av* %av) #0 {
entry:
  %tobool = icmp eq %struct.av* %av, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.av* %av, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !41
  %and = and i64 %0, 8388608
  %tobool2 = icmp eq i64 %and, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([0 x i8]* @PL_no_modify, i64 0, i64 0)) #2
  %.pre = load i64* %sv_flags, align 8, !tbaa !17
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.then3
  %1 = phi i64 [ %0, %if.end ], [ %.pre, %if.then3 ]
  %2 = bitcast %struct.av* %av to %struct.sv*
  %and6 = and i64 %1, 32768
  %tobool7 = icmp eq i64 %and6, 0
  br i1 %tobool7, label %if.end108, label %cond.end

cond.end:                                         ; preds = %if.end4
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %2, i32 80) #2
  %tobool8 = icmp eq %struct.magic* %call, null
  br i1 %tobool8, label %cond.end.if.end108_crit_edge, label %if.then9

cond.end.if.end108_crit_edge:                     ; preds = %cond.end
  %.pre173 = load i64* %sv_flags, align 8, !tbaa !17
  br label %if.end108

if.then9:                                         ; preds = %cond.end
  %3 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %4 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_next = getelementptr inbounds %struct.stackinfo* %4, i64 0, i32 6
  %5 = load %struct.stackinfo** %si_next, align 8, !tbaa !19
  %tobool10 = icmp eq %struct.stackinfo* %5, null
  br i1 %tobool10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %if.then9
  %call12 = tail call %struct.stackinfo* @Perl_new_stackinfo(i64 32, i64 12) #2
  %6 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_prev = getelementptr inbounds %struct.stackinfo* %call12, i64 0, i32 5
  store %struct.stackinfo* %6, %struct.stackinfo** %si_prev, align 8, !tbaa !21
  %7 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_next13 = getelementptr inbounds %struct.stackinfo* %7, i64 0, i32 6
  store %struct.stackinfo* %call12, %struct.stackinfo** %si_next13, align 8, !tbaa !19
  br label %if.end14

if.end14:                                         ; preds = %if.then9, %if.then11
  %next.0 = phi %struct.stackinfo* [ %5, %if.then9 ], [ %call12, %if.then11 ]
  %si_type = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 4
  store i64 2, i64* %si_type, align 8, !tbaa !22
  %si_cxix = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !23
  %si_stack = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 0
  %8 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any = getelementptr inbounds %struct.av* %8, i64 0, i32 0
  %9 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_fill = getelementptr inbounds %struct.xpvav* %9, i64 0, i32 1
  store i64 0, i64* %xav_fill, align 8, !tbaa !11
  %10 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %3 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %10 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %11 = load %struct.av** @PL_curstack, align 8, !tbaa !13
  %sv_any15 = getelementptr inbounds %struct.av* %11, i64 0, i32 0
  %12 = load %struct.xpvav** %sv_any15, align 8, !tbaa !1
  %xav_fill16 = getelementptr inbounds %struct.xpvav* %12, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill16, align 8, !tbaa !11
  %xav_array = getelementptr inbounds %struct.xpvav* %9, i64 0, i32 0
  %13 = load i8** %xav_array, align 8, !tbaa !12
  %14 = bitcast i8* %13 to %struct.sv**
  store %struct.sv** %14, %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %15 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any20 = getelementptr inbounds %struct.av* %15, i64 0, i32 0
  %16 = load %struct.xpvav** %sv_any20, align 8, !tbaa !1
  %xav_max = getelementptr inbounds %struct.xpvav* %16, i64 0, i32 2
  %17 = load i64* %xav_max, align 8, !tbaa !10
  %add.ptr = getelementptr inbounds %struct.sv** %14, i64 %17
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  %18 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any22 = getelementptr inbounds %struct.av* %18, i64 0, i32 0
  %19 = load %struct.xpvav** %sv_any22, align 8, !tbaa !1
  %xav_fill23 = getelementptr inbounds %struct.xpvav* %19, i64 0, i32 1
  %20 = load i64* %xav_fill23, align 8, !tbaa !11
  %add.ptr24 = getelementptr inbounds %struct.sv** %14, i64 %20
  store %struct.sv** %add.ptr24, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %21 = load %struct.av** %si_stack, align 8, !tbaa !24
  store %struct.av* %21, %struct.av** @PL_curstack, align 8, !tbaa !13
  store %struct.stackinfo* %next.0, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %22 = load i64** @PL_markstack_ptr, align 8, !tbaa !13
  %incdec.ptr = getelementptr inbounds i64* %22, i64 1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !13
  %23 = load i64** @PL_markstack_max, align 8, !tbaa !13
  %cmp = icmp eq i64* %incdec.ptr, %23
  br i1 %cmp, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end14
  tail call void @Perl_markstack_grow() #2
  %.pre174 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %.pre175 = load i64** @PL_markstack_ptr, align 8, !tbaa !13
  %.pre176 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %if.end14
  %24 = phi %struct.sv** [ %.pre176, %if.then26 ], [ %add.ptr, %if.end14 ]
  %25 = phi i64* [ %.pre175, %if.then26 ], [ %incdec.ptr, %if.end14 ]
  %26 = phi %struct.sv** [ %.pre174, %if.then26 ], [ %14, %if.end14 ]
  %sub.ptr.lhs.cast29 = ptrtoint %struct.sv** %add.ptr24 to i64
  %sub.ptr.rhs.cast30 = ptrtoint %struct.sv** %26 to i64
  %sub.ptr.sub31 = sub i64 %sub.ptr.lhs.cast29, %sub.ptr.rhs.cast30
  %sub.ptr.div32 = ashr exact i64 %sub.ptr.sub31, 3
  store i64 %sub.ptr.div32, i64* %25, align 8, !tbaa !18
  %sub.ptr.lhs.cast33 = ptrtoint %struct.sv** %24 to i64
  %sub.ptr.sub35 = sub i64 %sub.ptr.lhs.cast33, %sub.ptr.lhs.cast29
  %cmp37 = icmp slt i64 %sub.ptr.sub35, 8
  br i1 %cmp37, label %if.then38, label %if.end40

if.then38:                                        ; preds = %if.end27
  %call39 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr24, %struct.sv** %add.ptr24, i32 1) #2
  br label %if.end40

if.end40:                                         ; preds = %if.then38, %if.end27
  %sp.0 = phi %struct.sv** [ %call39, %if.then38 ], [ %add.ptr24, %if.end27 ]
  %mg_obj = getelementptr inbounds %struct.magic* %call, i64 0, i32 5
  %27 = load %struct.sv** %mg_obj, align 8, !tbaa !25
  %tobool42 = icmp eq %struct.sv* %27, null
  br i1 %tobool42, label %cond.false45, label %cond.end48

cond.false45:                                     ; preds = %if.end40
  %call46 = tail call %struct.sv* @Perl_newRV(%struct.sv* %2) #2
  %call47 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call46) #2
  br label %cond.end48

cond.end48:                                       ; preds = %if.end40, %cond.false45
  %cond49 = phi %struct.sv* [ %call47, %cond.false45 ], [ %27, %if.end40 ]
  %incdec.ptr50 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %cond49, %struct.sv** %incdec.ptr50, align 8, !tbaa !13
  store %struct.sv** %incdec.ptr50, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  tail call void @Perl_push_scope() #2
  %call51 = tail call i64 @Perl_call_method(i8* getelementptr inbounds ([4 x i8]* @.str4, i64 0, i64 0), i64 0) #2
  %tobool52 = icmp eq i64 %call51, 0
  br i1 %tobool52, label %if.end56, label %if.then53

if.then53:                                        ; preds = %cond.end48
  %28 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %incdec.ptr54 = getelementptr inbounds %struct.sv** %28, i64 -1
  store %struct.sv** %incdec.ptr54, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %29 = load %struct.sv** %28, align 8, !tbaa !13
  %call55 = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %29) #2
  br label %if.end56

if.end56:                                         ; preds = %cond.end48, %if.then53
  %retval1.0 = phi %struct.sv* [ %call55, %if.then53 ], [ @PL_sv_undef, %cond.end48 ]
  tail call void @Perl_pop_scope() #2
  %30 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %31 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_prev60 = getelementptr inbounds %struct.stackinfo* %31, i64 0, i32 5
  %32 = load %struct.stackinfo** %si_prev60, align 8, !tbaa !21
  %tobool61 = icmp eq %struct.stackinfo* %32, null
  br i1 %tobool61, label %if.then62, label %if.end87

if.then62:                                        ; preds = %if.end56
  %33 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !13
  %tobool63 = icmp eq %struct.gv* %33, null
  br i1 %tobool63, label %cond.false82, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then62
  %sv_flags64 = getelementptr inbounds %struct.gv* %33, i64 0, i32 2
  %34 = load i64* %sv_flags64, align 8, !tbaa !28
  %and65 = and i64 %34, 255
  %cmp66 = icmp eq i64 %and65, 13
  br i1 %cmp66, label %land.lhs.true67, label %cond.false82

land.lhs.true67:                                  ; preds = %land.lhs.true
  %sv_any68 = getelementptr inbounds %struct.gv* %33, i64 0, i32 0
  %35 = load %struct.xpvgv** %sv_any68, align 8, !tbaa !30
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %35, i64 0, i32 7
  %36 = load %struct.gp** %xgv_gp, align 8, !tbaa !31
  %gp_io = getelementptr inbounds %struct.gp* %36, i64 0, i32 2
  %37 = load %struct.io** %gp_io, align 8, !tbaa !33
  %tobool69 = icmp eq %struct.io* %37, null
  br i1 %tobool69, label %cond.false82, label %land.lhs.true70

land.lhs.true70:                                  ; preds = %land.lhs.true67
  %sv_any74 = getelementptr inbounds %struct.io* %37, i64 0, i32 0
  %38 = load %struct.xpvio** %sv_any74, align 8, !tbaa !35
  %xio_ofp = getelementptr inbounds %struct.xpvio* %38, i64 0, i32 8
  %39 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !37
  %tobool75 = icmp eq %struct._PerlIO** %39, null
  br i1 %tobool75, label %cond.false82, label %cond.end84

cond.false82:                                     ; preds = %land.lhs.true70, %land.lhs.true67, %if.then62, %land.lhs.true
  %call83 = tail call %struct._PerlIO** @Perl_PerlIO_stderr() #2
  br label %cond.end84

cond.end84:                                       ; preds = %land.lhs.true70, %cond.false82
  %cond85 = phi %struct._PerlIO** [ %call83, %cond.false82 ], [ %39, %land.lhs.true70 ]
  %call86 = tail call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond85, i8* getelementptr inbounds ([17 x i8]* @.str1, i64 0, i64 0)) #2
  tail call void @Perl_my_exit(i64 1) #2
  br label %if.end87

if.end87:                                         ; preds = %if.end56, %cond.end84
  %40 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %sub.ptr.lhs.cast88 = ptrtoint %struct.sv** %30 to i64
  %sub.ptr.rhs.cast89 = ptrtoint %struct.sv** %40 to i64
  %sub.ptr.sub90 = sub i64 %sub.ptr.lhs.cast88, %sub.ptr.rhs.cast89
  %sub.ptr.div91 = ashr exact i64 %sub.ptr.sub90, 3
  %41 = load %struct.av** @PL_curstack, align 8, !tbaa !13
  %sv_any92 = getelementptr inbounds %struct.av* %41, i64 0, i32 0
  %42 = load %struct.xpvav** %sv_any92, align 8, !tbaa !1
  %xav_fill93 = getelementptr inbounds %struct.xpvav* %42, i64 0, i32 1
  store i64 %sub.ptr.div91, i64* %xav_fill93, align 8, !tbaa !11
  %si_stack94 = getelementptr inbounds %struct.stackinfo* %32, i64 0, i32 0
  %43 = load %struct.av** %si_stack94, align 8, !tbaa !24
  %sv_any95 = getelementptr inbounds %struct.av* %43, i64 0, i32 0
  %44 = load %struct.xpvav** %sv_any95, align 8, !tbaa !1
  %xav_array96 = getelementptr inbounds %struct.xpvav* %44, i64 0, i32 0
  %45 = load i8** %xav_array96, align 8, !tbaa !12
  %46 = bitcast i8* %45 to %struct.sv**
  store %struct.sv** %46, %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %47 = load %struct.av** %si_stack94, align 8, !tbaa !24
  %sv_any98 = getelementptr inbounds %struct.av* %47, i64 0, i32 0
  %48 = load %struct.xpvav** %sv_any98, align 8, !tbaa !1
  %xav_max99 = getelementptr inbounds %struct.xpvav* %48, i64 0, i32 2
  %49 = load i64* %xav_max99, align 8, !tbaa !10
  %add.ptr100 = getelementptr inbounds %struct.sv** %46, i64 %49
  store %struct.sv** %add.ptr100, %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  %50 = load %struct.av** %si_stack94, align 8, !tbaa !24
  %sv_any102 = getelementptr inbounds %struct.av* %50, i64 0, i32 0
  %51 = load %struct.xpvav** %sv_any102, align 8, !tbaa !1
  %xav_fill103 = getelementptr inbounds %struct.xpvav* %51, i64 0, i32 1
  %52 = load i64* %xav_fill103, align 8, !tbaa !11
  %add.ptr104 = getelementptr inbounds %struct.sv** %46, i64 %52
  store %struct.sv** %add.ptr104, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %53 = load %struct.av** %si_stack94, align 8, !tbaa !24
  store %struct.av* %53, %struct.av** @PL_curstack, align 8, !tbaa !13
  store %struct.stackinfo* %32, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  br label %return

if.end108:                                        ; preds = %cond.end.if.end108_crit_edge, %if.end4
  %54 = phi i64 [ %.pre173, %cond.end.if.end108_crit_edge ], [ %1, %if.end4 ]
  %and110 = and i64 %54, 32768
  %tobool111 = icmp eq i64 %and110, 0
  br i1 %tobool111, label %cond.false114, label %cond.true112

cond.true112:                                     ; preds = %if.end108
  %call113 = tail call i64 @Perl_mg_size(%struct.sv* %2) #2
  br label %cond.end117

cond.false114:                                    ; preds = %if.end108
  %sv_any115 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %55 = load %struct.xpvav** %sv_any115, align 8, !tbaa !1
  %xav_fill116 = getelementptr inbounds %struct.xpvav* %55, i64 0, i32 1
  %56 = load i64* %xav_fill116, align 8, !tbaa !11
  br label %cond.end117

cond.end117:                                      ; preds = %cond.false114, %cond.true112
  %cond118 = phi i64 [ %call113, %cond.true112 ], [ %56, %cond.false114 ]
  %cmp119 = icmp slt i64 %cond118, 0
  br i1 %cmp119, label %return, label %if.end121

if.end121:                                        ; preds = %cond.end117
  %sv_any122 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %57 = load %struct.xpvav** %sv_any122, align 8, !tbaa !1
  %xav_fill123 = getelementptr inbounds %struct.xpvav* %57, i64 0, i32 1
  %58 = load i64* %xav_fill123, align 8, !tbaa !11
  %xav_array125 = getelementptr inbounds %struct.xpvav* %57, i64 0, i32 0
  %59 = load i8** %xav_array125, align 8, !tbaa !12
  %60 = bitcast i8* %59 to %struct.sv**
  %arrayidx = getelementptr inbounds %struct.sv** %60, i64 %58
  %61 = load %struct.sv** %arrayidx, align 8, !tbaa !13
  %dec = add nsw i64 %58, -1
  store i64 %dec, i64* %xav_fill123, align 8, !tbaa !11
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx, align 8, !tbaa !13
  %62 = load i64* %sv_flags, align 8, !tbaa !41
  %and132 = and i64 %62, 16384
  %tobool133 = icmp eq i64 %and132, 0
  br i1 %tobool133, label %return, label %if.then134

if.then134:                                       ; preds = %if.end121
  %call135 = tail call i32 @Perl_mg_set(%struct.sv* %2) #2
  br label %return

return:                                           ; preds = %if.then134, %if.end121, %cond.end117, %entry, %if.end87
  %retval.0 = phi %struct.sv* [ %retval1.0, %if.end87 ], [ @PL_sv_undef, %entry ], [ @PL_sv_undef, %cond.end117 ], [ %61, %if.end121 ], [ %61, %if.then134 ]
  ret %struct.sv* %retval.0
}

declare %struct.sv* @Perl_newSVsv(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define void @Perl_av_unshift(%struct.av* %av, i64 %num) #0 {
entry:
  %tobool = icmp eq %struct.av* %av, null
  br i1 %tobool, label %if.end183, label %if.end

if.end:                                           ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.av* %av, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !41
  %and = and i64 %0, 8388608
  %tobool1 = icmp eq i64 %and, 0
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([0 x i8]* @PL_no_modify, i64 0, i64 0)) #2
  %.pre = load i64* %sv_flags, align 8, !tbaa !17
  br label %if.end3

if.end3:                                          ; preds = %if.end, %if.then2
  %1 = phi i64 [ %0, %if.end ], [ %.pre, %if.then2 ]
  %2 = bitcast %struct.av* %av to %struct.sv*
  %and5 = and i64 %1, 32768
  %tobool6 = icmp eq i64 %and5, 0
  br i1 %tobool6, label %if.end109, label %cond.end

cond.end:                                         ; preds = %if.end3
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %2, i32 80) #2
  %tobool7 = icmp eq %struct.magic* %call, null
  br i1 %tobool7, label %if.end109, label %if.then8

if.then8:                                         ; preds = %cond.end
  %3 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %4 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_next = getelementptr inbounds %struct.stackinfo* %4, i64 0, i32 6
  %5 = load %struct.stackinfo** %si_next, align 8, !tbaa !19
  %tobool9 = icmp eq %struct.stackinfo* %5, null
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.then8
  %call11 = tail call %struct.stackinfo* @Perl_new_stackinfo(i64 32, i64 12) #2
  %6 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_prev = getelementptr inbounds %struct.stackinfo* %call11, i64 0, i32 5
  store %struct.stackinfo* %6, %struct.stackinfo** %si_prev, align 8, !tbaa !21
  %7 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_next12 = getelementptr inbounds %struct.stackinfo* %7, i64 0, i32 6
  store %struct.stackinfo* %call11, %struct.stackinfo** %si_next12, align 8, !tbaa !19
  br label %if.end13

if.end13:                                         ; preds = %if.then8, %if.then10
  %next.0 = phi %struct.stackinfo* [ %5, %if.then8 ], [ %call11, %if.then10 ]
  %si_type = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 4
  store i64 2, i64* %si_type, align 8, !tbaa !22
  %si_cxix = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !23
  %si_stack = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 0
  %8 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any = getelementptr inbounds %struct.av* %8, i64 0, i32 0
  %9 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_fill = getelementptr inbounds %struct.xpvav* %9, i64 0, i32 1
  store i64 0, i64* %xav_fill, align 8, !tbaa !11
  %10 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %3 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %10 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %11 = load %struct.av** @PL_curstack, align 8, !tbaa !13
  %sv_any14 = getelementptr inbounds %struct.av* %11, i64 0, i32 0
  %12 = load %struct.xpvav** %sv_any14, align 8, !tbaa !1
  %xav_fill15 = getelementptr inbounds %struct.xpvav* %12, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill15, align 8, !tbaa !11
  %xav_array = getelementptr inbounds %struct.xpvav* %9, i64 0, i32 0
  %13 = load i8** %xav_array, align 8, !tbaa !12
  %14 = bitcast i8* %13 to %struct.sv**
  store %struct.sv** %14, %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %15 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any19 = getelementptr inbounds %struct.av* %15, i64 0, i32 0
  %16 = load %struct.xpvav** %sv_any19, align 8, !tbaa !1
  %xav_max = getelementptr inbounds %struct.xpvav* %16, i64 0, i32 2
  %17 = load i64* %xav_max, align 8, !tbaa !10
  %add.ptr = getelementptr inbounds %struct.sv** %14, i64 %17
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  %18 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any21 = getelementptr inbounds %struct.av* %18, i64 0, i32 0
  %19 = load %struct.xpvav** %sv_any21, align 8, !tbaa !1
  %xav_fill22 = getelementptr inbounds %struct.xpvav* %19, i64 0, i32 1
  %20 = load i64* %xav_fill22, align 8, !tbaa !11
  %add.ptr23 = getelementptr inbounds %struct.sv** %14, i64 %20
  store %struct.sv** %add.ptr23, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %21 = load %struct.av** %si_stack, align 8, !tbaa !24
  store %struct.av* %21, %struct.av** @PL_curstack, align 8, !tbaa !13
  store %struct.stackinfo* %next.0, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %22 = load i64** @PL_markstack_ptr, align 8, !tbaa !13
  %incdec.ptr = getelementptr inbounds i64* %22, i64 1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !13
  %23 = load i64** @PL_markstack_max, align 8, !tbaa !13
  %cmp = icmp eq i64* %incdec.ptr, %23
  br i1 %cmp, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end13
  tail call void @Perl_markstack_grow() #2
  %.pre259 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %.pre260 = load i64** @PL_markstack_ptr, align 8, !tbaa !13
  %.pre261 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %if.end13
  %24 = phi %struct.sv** [ %.pre261, %if.then25 ], [ %add.ptr, %if.end13 ]
  %25 = phi i64* [ %.pre260, %if.then25 ], [ %incdec.ptr, %if.end13 ]
  %26 = phi %struct.sv** [ %.pre259, %if.then25 ], [ %14, %if.end13 ]
  %sub.ptr.lhs.cast28 = ptrtoint %struct.sv** %add.ptr23 to i64
  %sub.ptr.rhs.cast29 = ptrtoint %struct.sv** %26 to i64
  %sub.ptr.sub30 = sub i64 %sub.ptr.lhs.cast28, %sub.ptr.rhs.cast29
  %sub.ptr.div31 = ashr exact i64 %sub.ptr.sub30, 3
  store i64 %sub.ptr.div31, i64* %25, align 8, !tbaa !18
  %sub.ptr.lhs.cast32 = ptrtoint %struct.sv** %24 to i64
  %sub.ptr.sub34 = sub i64 %sub.ptr.lhs.cast32, %sub.ptr.lhs.cast28
  %sub.ptr.div35 = ashr exact i64 %sub.ptr.sub34, 3
  %add = add i64 %num, 1
  %sext = shl i64 %add, 32
  %conv36 = ashr exact i64 %sext, 32
  %cmp37 = icmp slt i64 %sub.ptr.div35, %conv36
  br i1 %cmp37, label %if.then39, label %if.end43

if.then39:                                        ; preds = %if.end26
  %conv = trunc i64 %add to i32
  %call42 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr23, %struct.sv** %add.ptr23, i32 %conv) #2
  br label %if.end43

if.end43:                                         ; preds = %if.then39, %if.end26
  %sp.0 = phi %struct.sv** [ %call42, %if.then39 ], [ %add.ptr23, %if.end26 ]
  %mg_obj = getelementptr inbounds %struct.magic* %call, i64 0, i32 5
  %27 = load %struct.sv** %mg_obj, align 8, !tbaa !25
  %tobool44 = icmp eq %struct.sv* %27, null
  br i1 %tobool44, label %cond.false47, label %cond.end50

cond.false47:                                     ; preds = %if.end43
  %call48 = tail call %struct.sv* @Perl_newRV(%struct.sv* %2) #2
  %call49 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call48) #2
  br label %cond.end50

cond.end50:                                       ; preds = %if.end43, %cond.false47
  %cond51 = phi %struct.sv* [ %call49, %cond.false47 ], [ %27, %if.end43 ]
  %incdec.ptr52 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %cond51, %struct.sv** %incdec.ptr52, align 8, !tbaa !13
  %cmp53255 = icmp sgt i64 %num, 0
  br i1 %cmp53255, label %while.body, label %while.end

while.body:                                       ; preds = %cond.end50, %while.body
  %num.addr.0257 = phi i64 [ %dec, %while.body ], [ %num, %cond.end50 ]
  %sp.1256 = phi %struct.sv** [ %incdec.ptr55, %while.body ], [ %incdec.ptr52, %cond.end50 ]
  %dec = add nsw i64 %num.addr.0257, -1
  %incdec.ptr55 = getelementptr inbounds %struct.sv** %sp.1256, i64 1
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr55, align 8, !tbaa !13
  %cmp53 = icmp sgt i64 %dec, 0
  br i1 %cmp53, label %while.body, label %while.cond.while.end_crit_edge

while.cond.while.end_crit_edge:                   ; preds = %while.body
  %scevgep = getelementptr %struct.sv** %sp.0, i64 %add
  br label %while.end

while.end:                                        ; preds = %while.cond.while.end_crit_edge, %cond.end50
  %sp.1.lcssa = phi %struct.sv** [ %scevgep, %while.cond.while.end_crit_edge ], [ %incdec.ptr52, %cond.end50 ]
  store %struct.sv** %sp.1.lcssa, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  tail call void @Perl_push_scope() #2
  %call56 = tail call i64 @Perl_call_method(i8* getelementptr inbounds ([8 x i8]* @.str5, i64 0, i64 0), i64 2) #2
  tail call void @Perl_pop_scope() #2
  %28 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %29 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_prev60 = getelementptr inbounds %struct.stackinfo* %29, i64 0, i32 5
  %30 = load %struct.stackinfo** %si_prev60, align 8, !tbaa !21
  %tobool61 = icmp eq %struct.stackinfo* %30, null
  br i1 %tobool61, label %if.then62, label %if.end88

if.then62:                                        ; preds = %while.end
  %31 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !13
  %tobool63 = icmp eq %struct.gv* %31, null
  br i1 %tobool63, label %cond.false83, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then62
  %sv_flags64 = getelementptr inbounds %struct.gv* %31, i64 0, i32 2
  %32 = load i64* %sv_flags64, align 8, !tbaa !28
  %and65 = and i64 %32, 255
  %cmp66 = icmp eq i64 %and65, 13
  br i1 %cmp66, label %land.lhs.true68, label %cond.false83

land.lhs.true68:                                  ; preds = %land.lhs.true
  %sv_any69 = getelementptr inbounds %struct.gv* %31, i64 0, i32 0
  %33 = load %struct.xpvgv** %sv_any69, align 8, !tbaa !30
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %33, i64 0, i32 7
  %34 = load %struct.gp** %xgv_gp, align 8, !tbaa !31
  %gp_io = getelementptr inbounds %struct.gp* %34, i64 0, i32 2
  %35 = load %struct.io** %gp_io, align 8, !tbaa !33
  %tobool70 = icmp eq %struct.io* %35, null
  br i1 %tobool70, label %cond.false83, label %land.lhs.true71

land.lhs.true71:                                  ; preds = %land.lhs.true68
  %sv_any75 = getelementptr inbounds %struct.io* %35, i64 0, i32 0
  %36 = load %struct.xpvio** %sv_any75, align 8, !tbaa !35
  %xio_ofp = getelementptr inbounds %struct.xpvio* %36, i64 0, i32 8
  %37 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !37
  %tobool76 = icmp eq %struct._PerlIO** %37, null
  br i1 %tobool76, label %cond.false83, label %cond.end85

cond.false83:                                     ; preds = %land.lhs.true71, %land.lhs.true68, %if.then62, %land.lhs.true
  %call84 = tail call %struct._PerlIO** @Perl_PerlIO_stderr() #2
  br label %cond.end85

cond.end85:                                       ; preds = %land.lhs.true71, %cond.false83
  %cond86 = phi %struct._PerlIO** [ %call84, %cond.false83 ], [ %37, %land.lhs.true71 ]
  %call87 = tail call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond86, i8* getelementptr inbounds ([17 x i8]* @.str1, i64 0, i64 0)) #2
  tail call void @Perl_my_exit(i64 1) #2
  br label %if.end88

if.end88:                                         ; preds = %while.end, %cond.end85
  %38 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %sub.ptr.lhs.cast89 = ptrtoint %struct.sv** %28 to i64
  %sub.ptr.rhs.cast90 = ptrtoint %struct.sv** %38 to i64
  %sub.ptr.sub91 = sub i64 %sub.ptr.lhs.cast89, %sub.ptr.rhs.cast90
  %sub.ptr.div92 = ashr exact i64 %sub.ptr.sub91, 3
  %39 = load %struct.av** @PL_curstack, align 8, !tbaa !13
  %sv_any93 = getelementptr inbounds %struct.av* %39, i64 0, i32 0
  %40 = load %struct.xpvav** %sv_any93, align 8, !tbaa !1
  %xav_fill94 = getelementptr inbounds %struct.xpvav* %40, i64 0, i32 1
  store i64 %sub.ptr.div92, i64* %xav_fill94, align 8, !tbaa !11
  %si_stack95 = getelementptr inbounds %struct.stackinfo* %30, i64 0, i32 0
  %41 = load %struct.av** %si_stack95, align 8, !tbaa !24
  %sv_any96 = getelementptr inbounds %struct.av* %41, i64 0, i32 0
  %42 = load %struct.xpvav** %sv_any96, align 8, !tbaa !1
  %xav_array97 = getelementptr inbounds %struct.xpvav* %42, i64 0, i32 0
  %43 = load i8** %xav_array97, align 8, !tbaa !12
  %44 = bitcast i8* %43 to %struct.sv**
  store %struct.sv** %44, %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %45 = load %struct.av** %si_stack95, align 8, !tbaa !24
  %sv_any99 = getelementptr inbounds %struct.av* %45, i64 0, i32 0
  %46 = load %struct.xpvav** %sv_any99, align 8, !tbaa !1
  %xav_max100 = getelementptr inbounds %struct.xpvav* %46, i64 0, i32 2
  %47 = load i64* %xav_max100, align 8, !tbaa !10
  %add.ptr101 = getelementptr inbounds %struct.sv** %44, i64 %47
  store %struct.sv** %add.ptr101, %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  %48 = load %struct.av** %si_stack95, align 8, !tbaa !24
  %sv_any103 = getelementptr inbounds %struct.av* %48, i64 0, i32 0
  %49 = load %struct.xpvav** %sv_any103, align 8, !tbaa !1
  %xav_fill104 = getelementptr inbounds %struct.xpvav* %49, i64 0, i32 1
  %50 = load i64* %xav_fill104, align 8, !tbaa !11
  %add.ptr105 = getelementptr inbounds %struct.sv** %44, i64 %50
  store %struct.sv** %add.ptr105, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %51 = load %struct.av** %si_stack95, align 8, !tbaa !24
  store %struct.av* %51, %struct.av** @PL_curstack, align 8, !tbaa !13
  store %struct.stackinfo* %30, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  br label %if.end183

if.end109:                                        ; preds = %if.end3, %cond.end
  %cmp110 = icmp slt i64 %num, 1
  br i1 %cmp110, label %if.end183, label %if.end113

if.end113:                                        ; preds = %if.end109
  %sv_any114 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %52 = load %struct.xpvav** %sv_any114, align 8, !tbaa !1
  %xav_flags = getelementptr inbounds %struct.xpvav* %52, i64 0, i32 9
  %53 = load i8* %xav_flags, align 1, !tbaa !7
  %54 = and i8 %53, 3
  %55 = icmp eq i8 %54, 2
  br i1 %55, label %if.then124, label %if.end126

if.then124:                                       ; preds = %if.end113
  %call125 = tail call i32 (%struct.av*, ...)* bitcast (i32 (...)* @av_reify to i32 (%struct.av*, ...)*)(%struct.av* %av) #2
  %.pre258 = load %struct.xpvav** %sv_any114, align 8, !tbaa !1
  br label %if.end126

if.end126:                                        ; preds = %if.end113, %if.then124
  %56 = phi %struct.xpvav* [ %52, %if.end113 ], [ %.pre258, %if.then124 ]
  %xav_array128 = getelementptr inbounds %struct.xpvav* %56, i64 0, i32 0
  %57 = load i8** %xav_array128, align 8, !tbaa !12
  %xav_alloc = getelementptr inbounds %struct.xpvav* %56, i64 0, i32 7
  %58 = load %struct.sv*** %xav_alloc, align 8, !tbaa !16
  %sub.ptr.lhs.cast130 = ptrtoint i8* %57 to i64
  %sub.ptr.rhs.cast131 = ptrtoint %struct.sv** %58 to i64
  %sub.ptr.sub132 = sub i64 %sub.ptr.lhs.cast130, %sub.ptr.rhs.cast131
  %sub.ptr.div133 = ashr exact i64 %sub.ptr.sub132, 3
  %tobool134 = icmp eq i64 %sub.ptr.div133, 0
  br i1 %tobool134, label %if.end150, label %if.then135

if.then135:                                       ; preds = %if.end126
  %cmp136 = icmp sgt i64 %sub.ptr.div133, %num
  %num.sub.ptr.div133 = select i1 %cmp136, i64 %num, i64 %sub.ptr.div133
  %sub = sub nsw i64 %num, %num.sub.ptr.div133
  %xav_fill144 = getelementptr inbounds %struct.xpvav* %56, i64 0, i32 1
  %59 = bitcast i64* %xav_fill144 to <2 x i64>*
  %60 = load <2 x i64>* %59, align 8, !tbaa !18
  %61 = insertelement <2 x i64> undef, i64 %num.sub.ptr.div133, i32 0
  %62 = insertelement <2 x i64> %61, i64 %num.sub.ptr.div133, i32 1
  %63 = add <2 x i64> %60, %62
  %64 = bitcast i64* %xav_fill144 to <2 x i64>*
  store <2 x i64> %63, <2 x i64>* %64, align 8, !tbaa !18
  %65 = bitcast i8* %57 to %struct.sv**
  %idx.neg = sub i64 0, %num.sub.ptr.div133
  %add.ptr148 = getelementptr inbounds %struct.sv** %65, i64 %idx.neg
  %66 = bitcast %struct.sv** %add.ptr148 to i8*
  store i8* %66, i8** %xav_array128, align 8, !tbaa !39
  br label %if.end150

if.end150:                                        ; preds = %if.end126, %if.then135
  %num.addr.1 = phi i64 [ %sub, %if.then135 ], [ %num, %if.end126 ]
  %tobool151 = icmp eq i64 %num.addr.1, 0
  br i1 %tobool151, label %if.end183, label %if.then152

if.then152:                                       ; preds = %if.end150
  %xav_fill154 = getelementptr inbounds %struct.xpvav* %56, i64 0, i32 1
  %67 = load i64* %xav_fill154, align 8, !tbaa !11
  %cmp155 = icmp sgt i64 %67, 0
  %cond160 = select i1 %cmp155, i64 %67, i64 0
  %add161 = add nsw i64 %cond160, %num.addr.1
  %add162 = add nsw i64 %add161, %67
  tail call void @Perl_av_extend(%struct.av* %av, i64 %add162)
  %68 = load %struct.xpvav** %sv_any114, align 8, !tbaa !1
  %xav_fill164 = getelementptr inbounds %struct.xpvav* %68, i64 0, i32 1
  %69 = load i64* %xav_fill164, align 8, !tbaa !11
  %add165 = add nsw i64 %69, %add161
  store i64 %add165, i64* %xav_fill164, align 8, !tbaa !11
  %xav_array167 = getelementptr inbounds %struct.xpvav* %68, i64 0, i32 0
  %70 = load i8** %xav_array167, align 8, !tbaa !12
  %71 = bitcast i8* %70 to %struct.sv**
  %add.ptr168 = getelementptr inbounds %struct.sv** %71, i64 %add161
  %72 = bitcast %struct.sv** %add.ptr168 to i8*
  %add169 = shl i64 %67, 3
  %mul = add i64 %add169, 8
  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %72, i8* %70, i64 %mul, i32 1, i1 false)
  br label %do.body

do.body:                                          ; preds = %do.body, %if.then152
  %num.addr.2 = phi i64 [ %add161, %if.then152 ], [ %dec170, %do.body ]
  %dec170 = add nsw i64 %num.addr.2, -1
  %arrayidx = getelementptr inbounds %struct.sv** %71, i64 %dec170
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx, align 8, !tbaa !13
  %tobool171 = icmp eq i64 %dec170, 0
  br i1 %tobool171, label %do.end, label %do.body

do.end:                                           ; preds = %do.body
  %73 = load %struct.xpvav** %sv_any114, align 8, !tbaa !1
  %xav_fill176 = getelementptr inbounds %struct.xpvav* %73, i64 0, i32 1
  %74 = bitcast i64* %xav_fill176 to <2 x i64>*
  %75 = load <2 x i64>* %74, align 8, !tbaa !18
  %76 = insertelement <2 x i64> undef, i64 %cond160, i32 0
  %77 = insertelement <2 x i64> %76, i64 %cond160, i32 1
  %78 = sub <2 x i64> %75, %77
  %79 = bitcast i64* %xav_fill176 to <2 x i64>*
  store <2 x i64> %78, <2 x i64>* %79, align 8, !tbaa !18
  %xav_array179 = getelementptr inbounds %struct.xpvav* %73, i64 0, i32 0
  %80 = load i8** %xav_array179, align 8, !tbaa !12
  %81 = bitcast i8* %80 to %struct.sv**
  %add.ptr180 = getelementptr inbounds %struct.sv** %81, i64 %cond160
  %82 = bitcast %struct.sv** %add.ptr180 to i8*
  store i8* %82, i8** %xav_array179, align 8, !tbaa !39
  br label %if.end183

if.end183:                                        ; preds = %if.end150, %entry, %if.end109, %if.end88, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.sv* @Perl_av_shift(%struct.av* %av) #0 {
entry:
  %tobool = icmp eq %struct.av* %av, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.av* %av, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !41
  %and = and i64 %0, 8388608
  %tobool2 = icmp eq i64 %and, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([0 x i8]* @PL_no_modify, i64 0, i64 0)) #2
  %.pre = load i64* %sv_flags, align 8, !tbaa !17
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.then3
  %1 = phi i64 [ %0, %if.end ], [ %.pre, %if.then3 ]
  %2 = bitcast %struct.av* %av to %struct.sv*
  %and6 = and i64 %1, 32768
  %tobool7 = icmp eq i64 %and6, 0
  br i1 %tobool7, label %if.end108, label %cond.end

cond.end:                                         ; preds = %if.end4
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %2, i32 80) #2
  %tobool8 = icmp eq %struct.magic* %call, null
  br i1 %tobool8, label %cond.end.if.end108_crit_edge, label %if.then9

cond.end.if.end108_crit_edge:                     ; preds = %cond.end
  %.pre185 = load i64* %sv_flags, align 8, !tbaa !17
  br label %if.end108

if.then9:                                         ; preds = %cond.end
  %3 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %4 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_next = getelementptr inbounds %struct.stackinfo* %4, i64 0, i32 6
  %5 = load %struct.stackinfo** %si_next, align 8, !tbaa !19
  %tobool10 = icmp eq %struct.stackinfo* %5, null
  br i1 %tobool10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %if.then9
  %call12 = tail call %struct.stackinfo* @Perl_new_stackinfo(i64 32, i64 12) #2
  %6 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_prev = getelementptr inbounds %struct.stackinfo* %call12, i64 0, i32 5
  store %struct.stackinfo* %6, %struct.stackinfo** %si_prev, align 8, !tbaa !21
  %7 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_next13 = getelementptr inbounds %struct.stackinfo* %7, i64 0, i32 6
  store %struct.stackinfo* %call12, %struct.stackinfo** %si_next13, align 8, !tbaa !19
  br label %if.end14

if.end14:                                         ; preds = %if.then9, %if.then11
  %next.0 = phi %struct.stackinfo* [ %5, %if.then9 ], [ %call12, %if.then11 ]
  %si_type = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 4
  store i64 2, i64* %si_type, align 8, !tbaa !22
  %si_cxix = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !23
  %si_stack = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 0
  %8 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any = getelementptr inbounds %struct.av* %8, i64 0, i32 0
  %9 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_fill = getelementptr inbounds %struct.xpvav* %9, i64 0, i32 1
  store i64 0, i64* %xav_fill, align 8, !tbaa !11
  %10 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %3 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %10 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %11 = load %struct.av** @PL_curstack, align 8, !tbaa !13
  %sv_any15 = getelementptr inbounds %struct.av* %11, i64 0, i32 0
  %12 = load %struct.xpvav** %sv_any15, align 8, !tbaa !1
  %xav_fill16 = getelementptr inbounds %struct.xpvav* %12, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill16, align 8, !tbaa !11
  %xav_array = getelementptr inbounds %struct.xpvav* %9, i64 0, i32 0
  %13 = load i8** %xav_array, align 8, !tbaa !12
  %14 = bitcast i8* %13 to %struct.sv**
  store %struct.sv** %14, %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %15 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any20 = getelementptr inbounds %struct.av* %15, i64 0, i32 0
  %16 = load %struct.xpvav** %sv_any20, align 8, !tbaa !1
  %xav_max = getelementptr inbounds %struct.xpvav* %16, i64 0, i32 2
  %17 = load i64* %xav_max, align 8, !tbaa !10
  %add.ptr = getelementptr inbounds %struct.sv** %14, i64 %17
  store %struct.sv** %add.ptr, %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  %18 = load %struct.av** %si_stack, align 8, !tbaa !24
  %sv_any22 = getelementptr inbounds %struct.av* %18, i64 0, i32 0
  %19 = load %struct.xpvav** %sv_any22, align 8, !tbaa !1
  %xav_fill23 = getelementptr inbounds %struct.xpvav* %19, i64 0, i32 1
  %20 = load i64* %xav_fill23, align 8, !tbaa !11
  %add.ptr24 = getelementptr inbounds %struct.sv** %14, i64 %20
  store %struct.sv** %add.ptr24, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %21 = load %struct.av** %si_stack, align 8, !tbaa !24
  store %struct.av* %21, %struct.av** @PL_curstack, align 8, !tbaa !13
  store %struct.stackinfo* %next.0, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %22 = load i64** @PL_markstack_ptr, align 8, !tbaa !13
  %incdec.ptr = getelementptr inbounds i64* %22, i64 1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !13
  %23 = load i64** @PL_markstack_max, align 8, !tbaa !13
  %cmp = icmp eq i64* %incdec.ptr, %23
  br i1 %cmp, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end14
  tail call void @Perl_markstack_grow() #2
  %.pre188 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %.pre189 = load i64** @PL_markstack_ptr, align 8, !tbaa !13
  %.pre190 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %if.end14
  %24 = phi %struct.sv** [ %.pre190, %if.then26 ], [ %add.ptr, %if.end14 ]
  %25 = phi i64* [ %.pre189, %if.then26 ], [ %incdec.ptr, %if.end14 ]
  %26 = phi %struct.sv** [ %.pre188, %if.then26 ], [ %14, %if.end14 ]
  %sub.ptr.lhs.cast29 = ptrtoint %struct.sv** %add.ptr24 to i64
  %sub.ptr.rhs.cast30 = ptrtoint %struct.sv** %26 to i64
  %sub.ptr.sub31 = sub i64 %sub.ptr.lhs.cast29, %sub.ptr.rhs.cast30
  %sub.ptr.div32 = ashr exact i64 %sub.ptr.sub31, 3
  store i64 %sub.ptr.div32, i64* %25, align 8, !tbaa !18
  %sub.ptr.lhs.cast33 = ptrtoint %struct.sv** %24 to i64
  %sub.ptr.sub35 = sub i64 %sub.ptr.lhs.cast33, %sub.ptr.lhs.cast29
  %cmp37 = icmp slt i64 %sub.ptr.sub35, 8
  br i1 %cmp37, label %if.then38, label %if.end40

if.then38:                                        ; preds = %if.end27
  %call39 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr24, %struct.sv** %add.ptr24, i32 1) #2
  br label %if.end40

if.end40:                                         ; preds = %if.then38, %if.end27
  %sp.0 = phi %struct.sv** [ %call39, %if.then38 ], [ %add.ptr24, %if.end27 ]
  %mg_obj = getelementptr inbounds %struct.magic* %call, i64 0, i32 5
  %27 = load %struct.sv** %mg_obj, align 8, !tbaa !25
  %tobool42 = icmp eq %struct.sv* %27, null
  br i1 %tobool42, label %cond.false45, label %cond.end48

cond.false45:                                     ; preds = %if.end40
  %call46 = tail call %struct.sv* @Perl_newRV(%struct.sv* %2) #2
  %call47 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call46) #2
  br label %cond.end48

cond.end48:                                       ; preds = %if.end40, %cond.false45
  %cond49 = phi %struct.sv* [ %call47, %cond.false45 ], [ %27, %if.end40 ]
  %incdec.ptr50 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %cond49, %struct.sv** %incdec.ptr50, align 8, !tbaa !13
  store %struct.sv** %incdec.ptr50, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  tail call void @Perl_push_scope() #2
  %call51 = tail call i64 @Perl_call_method(i8* getelementptr inbounds ([6 x i8]* @.str6, i64 0, i64 0), i64 0) #2
  %tobool52 = icmp eq i64 %call51, 0
  br i1 %tobool52, label %if.end56, label %if.then53

if.then53:                                        ; preds = %cond.end48
  %28 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %incdec.ptr54 = getelementptr inbounds %struct.sv** %28, i64 -1
  store %struct.sv** %incdec.ptr54, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %29 = load %struct.sv** %28, align 8, !tbaa !13
  %call55 = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %29) #2
  br label %if.end56

if.end56:                                         ; preds = %cond.end48, %if.then53
  %retval1.0 = phi %struct.sv* [ %call55, %if.then53 ], [ @PL_sv_undef, %cond.end48 ]
  tail call void @Perl_pop_scope() #2
  %30 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %31 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  %si_prev60 = getelementptr inbounds %struct.stackinfo* %31, i64 0, i32 5
  %32 = load %struct.stackinfo** %si_prev60, align 8, !tbaa !21
  %tobool61 = icmp eq %struct.stackinfo* %32, null
  br i1 %tobool61, label %if.then62, label %if.end87

if.then62:                                        ; preds = %if.end56
  %33 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !13
  %tobool63 = icmp eq %struct.gv* %33, null
  br i1 %tobool63, label %cond.false82, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then62
  %sv_flags64 = getelementptr inbounds %struct.gv* %33, i64 0, i32 2
  %34 = load i64* %sv_flags64, align 8, !tbaa !28
  %and65 = and i64 %34, 255
  %cmp66 = icmp eq i64 %and65, 13
  br i1 %cmp66, label %land.lhs.true67, label %cond.false82

land.lhs.true67:                                  ; preds = %land.lhs.true
  %sv_any68 = getelementptr inbounds %struct.gv* %33, i64 0, i32 0
  %35 = load %struct.xpvgv** %sv_any68, align 8, !tbaa !30
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %35, i64 0, i32 7
  %36 = load %struct.gp** %xgv_gp, align 8, !tbaa !31
  %gp_io = getelementptr inbounds %struct.gp* %36, i64 0, i32 2
  %37 = load %struct.io** %gp_io, align 8, !tbaa !33
  %tobool69 = icmp eq %struct.io* %37, null
  br i1 %tobool69, label %cond.false82, label %land.lhs.true70

land.lhs.true70:                                  ; preds = %land.lhs.true67
  %sv_any74 = getelementptr inbounds %struct.io* %37, i64 0, i32 0
  %38 = load %struct.xpvio** %sv_any74, align 8, !tbaa !35
  %xio_ofp = getelementptr inbounds %struct.xpvio* %38, i64 0, i32 8
  %39 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !37
  %tobool75 = icmp eq %struct._PerlIO** %39, null
  br i1 %tobool75, label %cond.false82, label %cond.end84

cond.false82:                                     ; preds = %land.lhs.true70, %land.lhs.true67, %if.then62, %land.lhs.true
  %call83 = tail call %struct._PerlIO** @Perl_PerlIO_stderr() #2
  br label %cond.end84

cond.end84:                                       ; preds = %land.lhs.true70, %cond.false82
  %cond85 = phi %struct._PerlIO** [ %call83, %cond.false82 ], [ %39, %land.lhs.true70 ]
  %call86 = tail call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond85, i8* getelementptr inbounds ([17 x i8]* @.str1, i64 0, i64 0)) #2
  tail call void @Perl_my_exit(i64 1) #2
  br label %if.end87

if.end87:                                         ; preds = %if.end56, %cond.end84
  %40 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %sub.ptr.lhs.cast88 = ptrtoint %struct.sv** %30 to i64
  %sub.ptr.rhs.cast89 = ptrtoint %struct.sv** %40 to i64
  %sub.ptr.sub90 = sub i64 %sub.ptr.lhs.cast88, %sub.ptr.rhs.cast89
  %sub.ptr.div91 = ashr exact i64 %sub.ptr.sub90, 3
  %41 = load %struct.av** @PL_curstack, align 8, !tbaa !13
  %sv_any92 = getelementptr inbounds %struct.av* %41, i64 0, i32 0
  %42 = load %struct.xpvav** %sv_any92, align 8, !tbaa !1
  %xav_fill93 = getelementptr inbounds %struct.xpvav* %42, i64 0, i32 1
  store i64 %sub.ptr.div91, i64* %xav_fill93, align 8, !tbaa !11
  %si_stack94 = getelementptr inbounds %struct.stackinfo* %32, i64 0, i32 0
  %43 = load %struct.av** %si_stack94, align 8, !tbaa !24
  %sv_any95 = getelementptr inbounds %struct.av* %43, i64 0, i32 0
  %44 = load %struct.xpvav** %sv_any95, align 8, !tbaa !1
  %xav_array96 = getelementptr inbounds %struct.xpvav* %44, i64 0, i32 0
  %45 = load i8** %xav_array96, align 8, !tbaa !12
  %46 = bitcast i8* %45 to %struct.sv**
  store %struct.sv** %46, %struct.sv*** @PL_stack_base, align 8, !tbaa !13
  %47 = load %struct.av** %si_stack94, align 8, !tbaa !24
  %sv_any98 = getelementptr inbounds %struct.av* %47, i64 0, i32 0
  %48 = load %struct.xpvav** %sv_any98, align 8, !tbaa !1
  %xav_max99 = getelementptr inbounds %struct.xpvav* %48, i64 0, i32 2
  %49 = load i64* %xav_max99, align 8, !tbaa !10
  %add.ptr100 = getelementptr inbounds %struct.sv** %46, i64 %49
  store %struct.sv** %add.ptr100, %struct.sv*** @PL_stack_max, align 8, !tbaa !13
  %50 = load %struct.av** %si_stack94, align 8, !tbaa !24
  %sv_any102 = getelementptr inbounds %struct.av* %50, i64 0, i32 0
  %51 = load %struct.xpvav** %sv_any102, align 8, !tbaa !1
  %xav_fill103 = getelementptr inbounds %struct.xpvav* %51, i64 0, i32 1
  %52 = load i64* %xav_fill103, align 8, !tbaa !11
  %add.ptr104 = getelementptr inbounds %struct.sv** %46, i64 %52
  store %struct.sv** %add.ptr104, %struct.sv*** @PL_stack_sp, align 8, !tbaa !13
  %53 = load %struct.av** %si_stack94, align 8, !tbaa !24
  store %struct.av* %53, %struct.av** @PL_curstack, align 8, !tbaa !13
  store %struct.stackinfo* %32, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !13
  br label %return

if.end108:                                        ; preds = %cond.end.if.end108_crit_edge, %if.end4
  %54 = phi i64 [ %.pre185, %cond.end.if.end108_crit_edge ], [ %1, %if.end4 ]
  %and110 = and i64 %54, 32768
  %tobool111 = icmp eq i64 %and110, 0
  br i1 %tobool111, label %cond.false114, label %cond.true112

cond.true112:                                     ; preds = %if.end108
  %call113 = tail call i64 @Perl_mg_size(%struct.sv* %2) #2
  br label %cond.end117

cond.false114:                                    ; preds = %if.end108
  %sv_any115 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %55 = load %struct.xpvav** %sv_any115, align 8, !tbaa !1
  %xav_fill116 = getelementptr inbounds %struct.xpvav* %55, i64 0, i32 1
  %56 = load i64* %xav_fill116, align 8, !tbaa !11
  br label %cond.end117

cond.end117:                                      ; preds = %cond.false114, %cond.true112
  %cond118 = phi i64 [ %call113, %cond.true112 ], [ %56, %cond.false114 ]
  %cmp119 = icmp slt i64 %cond118, 0
  br i1 %cmp119, label %return, label %if.end121

if.end121:                                        ; preds = %cond.end117
  %sv_any122 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %57 = load %struct.xpvav** %sv_any122, align 8, !tbaa !1
  %xav_array123 = getelementptr inbounds %struct.xpvav* %57, i64 0, i32 0
  %58 = load i8** %xav_array123, align 8, !tbaa !12
  %59 = bitcast i8* %58 to %struct.sv**
  %60 = load %struct.sv** %59, align 8, !tbaa !13
  %xav_flags = getelementptr inbounds %struct.xpvav* %57, i64 0, i32 9
  %61 = load i8* %xav_flags, align 1, !tbaa !7
  %and125 = and i8 %61, 1
  %tobool126 = icmp eq i8 %and125, 0
  br i1 %tobool126, label %if.end130, label %if.then127

if.then127:                                       ; preds = %if.end121
  store %struct.sv* @PL_sv_undef, %struct.sv** %59, align 8, !tbaa !13
  %.pre186 = load %struct.xpvav** %sv_any122, align 8, !tbaa !1
  %xav_array132.phi.trans.insert = getelementptr inbounds %struct.xpvav* %.pre186, i64 0, i32 0
  %.pre187 = load i8** %xav_array132.phi.trans.insert, align 8, !tbaa !12
  br label %if.end130

if.end130:                                        ; preds = %if.end121, %if.then127
  %62 = phi i8* [ %58, %if.end121 ], [ %.pre187, %if.then127 ]
  %63 = phi %struct.xpvav* [ %57, %if.end121 ], [ %.pre186, %if.then127 ]
  %xav_array132 = getelementptr inbounds %struct.xpvav* %63, i64 0, i32 0
  %add.ptr133 = getelementptr inbounds i8* %62, i64 8
  store i8* %add.ptr133, i8** %xav_array132, align 8, !tbaa !39
  %xav_fill138 = getelementptr inbounds %struct.xpvav* %63, i64 0, i32 1
  %64 = bitcast i64* %xav_fill138 to <2 x i64>*
  %65 = load <2 x i64>* %64, align 8, !tbaa !18
  %66 = add <2 x i64> %65, <i64 -1, i64 -1>
  %67 = bitcast i64* %xav_fill138 to <2 x i64>*
  store <2 x i64> %66, <2 x i64>* %67, align 8, !tbaa !18
  %68 = load i64* %sv_flags, align 8, !tbaa !41
  %and141 = and i64 %68, 16384
  %tobool142 = icmp eq i64 %and141, 0
  br i1 %tobool142, label %return, label %if.then143

if.then143:                                       ; preds = %if.end130
  %call144 = tail call i32 @Perl_mg_set(%struct.sv* %2) #2
  br label %return

return:                                           ; preds = %if.then143, %if.end130, %cond.end117, %entry, %if.end87
  %retval.0 = phi %struct.sv* [ %retval1.0, %if.end87 ], [ @PL_sv_undef, %entry ], [ @PL_sv_undef, %cond.end117 ], [ %60, %if.end130 ], [ %60, %if.then143 ]
  ret %struct.sv* %retval.0
}

; Function Attrs: nounwind uwtable
define i64 @Perl_av_len(%struct.av* %av) #0 {
entry:
  %0 = getelementptr inbounds %struct.av* %av, i64 0, i32 2
  %1 = load i64* %0, align 8, !tbaa !17
  %and = and i64 %1, 32768
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %2 = bitcast %struct.av* %av to %struct.sv*
  %call = tail call i64 @Perl_mg_size(%struct.sv* %2) #2
  br label %cond.end

cond.false:                                       ; preds = %entry
  %sv_any = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %3 = load %struct.xpvav** %sv_any, align 8, !tbaa !1
  %xav_fill = getelementptr inbounds %struct.xpvav* %3, i64 0, i32 1
  %4 = load i64* %xav_fill, align 8, !tbaa !11
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ %4, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define %struct.sv* @Perl_av_delete(%struct.av* %av, i64 %key, i64 %flags) #0 {
entry:
  %tobool = icmp eq %struct.av* %av, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.av* %av, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !41
  %and = and i64 %0, 8388608
  %tobool1 = icmp eq i64 %and, 0
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([0 x i8]* @PL_no_modify, i64 0, i64 0)) #2
  %.pre = load i64* %sv_flags, align 8, !tbaa !41
  br label %if.end3

if.end3:                                          ; preds = %if.end, %if.then2
  %1 = phi i64 [ %0, %if.end ], [ %.pre, %if.then2 ]
  %and5 = and i64 %1, 32768
  %tobool6 = icmp eq i64 %and5, 0
  br i1 %tobool6, label %if.end115, label %if.then7

if.then7:                                         ; preds = %if.end3
  %2 = bitcast %struct.av* %av to %struct.sv*
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %2, i32 80) #2
  %tobool8 = icmp ne %struct.magic* %call, null
  br i1 %tobool8, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then7
  %call9 = tail call %struct.magic* @Perl_mg_find(%struct.sv* %2, i32 68) #2
  %tobool10 = icmp eq %struct.magic* %call9, null
  br i1 %tobool10, label %if.end115, label %if.then11

if.then11:                                        ; preds = %lor.lhs.false, %if.then7
  %cmp = icmp slt i64 %key, 0
  br i1 %cmp, label %if.then12, label %if.end103

if.then12:                                        ; preds = %if.then11
  br i1 %tobool8, label %if.then14, label %if.then87

if.then14:                                        ; preds = %if.then12
  %mg_obj = getelementptr inbounds %struct.magic* %call, i64 0, i32 5
  %3 = load %struct.sv** %mg_obj, align 8, !tbaa !25
  %tobool15 = icmp eq %struct.sv* %3, null
  br i1 %tobool15, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.then14
  %call17 = tail call %struct.sv* @Perl_newRV(%struct.sv* %2) #2
  %call18 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call17) #2
  br label %cond.end

cond.end:                                         ; preds = %if.then14, %cond.false
  %cond = phi %struct.sv* [ %call18, %cond.false ], [ %3, %if.then14 ]
  %sv_any = getelementptr inbounds %struct.sv* %cond, i64 0, i32 0
  %4 = load i8** %sv_any, align 8, !tbaa !42
  %xrv_rv = bitcast i8* %4 to %struct.sv**
  %5 = load %struct.sv** %xrv_rv, align 8, !tbaa !43
  %sv_any19 = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %6 = load i8** %sv_any19, align 8, !tbaa !42
  %xmg_stash = getelementptr inbounds i8* %6, i64 48
  %7 = bitcast i8* %xmg_stash to %struct.hv**
  %8 = load %struct.hv** %7, align 8, !tbaa !45
  %call20 = tail call %struct.sv** @Perl_hv_fetch(%struct.hv* %8, i8* getelementptr inbounds ([17 x i8]* @.str2, i64 0, i64 0), i64 16, i64 0) #2
  %tobool21 = icmp eq %struct.sv** %call20, null
  br i1 %tobool21, label %if.then87, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.end
  %9 = load %struct.sv** %call20, align 8, !tbaa !13
  %sv_any22 = getelementptr inbounds %struct.sv* %9, i64 0, i32 0
  %10 = load i8** %sv_any22, align 8, !tbaa !42
  %xgv_gp = getelementptr inbounds i8* %10, i64 56
  %11 = bitcast i8* %xgv_gp to %struct.gp**
  %12 = load %struct.gp** %11, align 8, !tbaa !31
  %gp_sv = getelementptr inbounds %struct.gp* %12, i64 0, i32 0
  %13 = load %struct.sv** %gp_sv, align 8, !tbaa !47
  %tobool23 = icmp eq %struct.sv* %13, null
  br i1 %tobool23, label %if.then87, label %cond.false25

cond.false25:                                     ; preds = %land.lhs.true
  %sv_flags29 = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %14 = load i64* %sv_flags29, align 8, !tbaa !17
  %and30 = and i64 %14, 262144
  %tobool31 = icmp eq i64 %and30, 0
  br i1 %tobool31, label %cond.false48, label %cond.true32

cond.true32:                                      ; preds = %cond.false25
  %sv_any36 = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %15 = load i8** %sv_any36, align 8, !tbaa !42
  %16 = bitcast i8* %15 to %struct.xpv*
  store %struct.xpv* %16, %struct.xpv** @PL_Xpv, align 8, !tbaa !13
  %tobool37 = icmp eq i8* %15, null
  br i1 %tobool37, label %if.then87, label %land.lhs.true38

land.lhs.true38:                                  ; preds = %cond.true32
  %xpv_cur = getelementptr inbounds i8* %15, i64 8
  %17 = bitcast i8* %xpv_cur to i64*
  %18 = load i64* %17, align 8, !tbaa !48
  %cmp39 = icmp ugt i64 %18, 1
  br i1 %cmp39, label %if.end103, label %lor.lhs.false40

lor.lhs.false40:                                  ; preds = %land.lhs.true38
  %tobool42 = icmp eq i64 %18, 0
  br i1 %tobool42, label %if.then87, label %land.lhs.true43

land.lhs.true43:                                  ; preds = %lor.lhs.false40
  %xpv_pv = bitcast i8* %15 to i8**
  %19 = load i8** %xpv_pv, align 8, !tbaa !39
  %20 = load i8* %19, align 1, !tbaa !49
  %cmp44 = icmp eq i8 %20, 48
  br i1 %cmp44, label %if.then87, label %if.end103

cond.false48:                                     ; preds = %cond.false25
  %and53 = and i64 %14, 65536
  %tobool54 = icmp eq i64 %and53, 0
  br i1 %tobool54, label %cond.false62, label %cond.true55

cond.true55:                                      ; preds = %cond.false48
  %sv_any59 = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %21 = load i8** %sv_any59, align 8, !tbaa !42
  %xiv_iv = getelementptr inbounds i8* %21, i64 24
  %22 = bitcast i8* %xiv_iv to i64*
  %23 = load i64* %22, align 8, !tbaa !50
  %cmp60 = icmp eq i64 %23, 0
  br i1 %cmp60, label %if.then87, label %if.end103

cond.false62:                                     ; preds = %cond.false48
  %and67 = and i64 %14, 131072
  %tobool68 = icmp eq i64 %and67, 0
  br i1 %tobool68, label %cond.false76, label %cond.true69

cond.true69:                                      ; preds = %cond.false62
  %sv_any73 = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %24 = load i8** %sv_any73, align 8, !tbaa !42
  %xnv_nv = getelementptr inbounds i8* %24, i64 32
  %25 = bitcast i8* %xnv_nv to double*
  %26 = load double* %25, align 8, !tbaa !52
  %cmp74 = fcmp une double %26, 0.000000e+00
  br i1 %cmp74, label %if.end103, label %if.then87

cond.false76:                                     ; preds = %cond.false62
  %call80 = tail call signext i8 @Perl_sv_2bool(%struct.sv* %13) #2
  %tobool82 = icmp eq i8 %call80, 0
  br i1 %tobool82, label %if.then87, label %if.end103

if.then87:                                        ; preds = %if.then12, %cond.true69, %cond.end, %land.lhs.true, %cond.false76, %cond.true55, %cond.true32, %lor.lhs.false40, %land.lhs.true43
  %27 = load i64* %sv_flags, align 8, !tbaa !17
  %and89 = and i64 %27, 32768
  %tobool90 = icmp eq i64 %and89, 0
  br i1 %tobool90, label %cond.false93, label %cond.true91

cond.true91:                                      ; preds = %if.then87
  %call92 = tail call i64 @Perl_mg_size(%struct.sv* %2) #2
  br label %cond.end95

cond.false93:                                     ; preds = %if.then87
  %sv_any94 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %28 = load %struct.xpvav** %sv_any94, align 8, !tbaa !1
  %xav_fill = getelementptr inbounds %struct.xpvav* %28, i64 0, i32 1
  %29 = load i64* %xav_fill, align 8, !tbaa !11
  br label %cond.end95

cond.end95:                                       ; preds = %cond.false93, %cond.true91
  %cond96 = phi i64 [ %call92, %cond.true91 ], [ %29, %cond.false93 ]
  %add = add i64 %key, 1
  %add97 = add i64 %add, %cond96
  %cmp98 = icmp slt i64 %add97, 0
  br i1 %cmp98, label %return, label %if.end103

if.end103:                                        ; preds = %cond.true69, %land.lhs.true38, %cond.false76, %cond.true55, %land.lhs.true43, %cond.end95, %if.then11
  %key.addr.0 = phi i64 [ %add97, %cond.end95 ], [ %key, %if.then11 ], [ %key, %land.lhs.true43 ], [ %key, %cond.true55 ], [ %key, %cond.false76 ], [ %key, %land.lhs.true38 ], [ %key, %cond.true69 ]
  %call104 = tail call %struct.sv** @Perl_av_fetch(%struct.av* %av, i64 %key.addr.0, i64 1)
  %tobool105 = icmp eq %struct.sv** %call104, null
  br i1 %tobool105, label %if.end115, label %if.then106

if.then106:                                       ; preds = %if.end103
  %30 = load %struct.sv** %call104, align 8, !tbaa !13
  %call107 = tail call i32 @Perl_mg_clear(%struct.sv* %30) #2
  %call108 = tail call %struct.magic* @Perl_mg_find(%struct.sv* %30, i32 112) #2
  %tobool109 = icmp eq %struct.magic* %call108, null
  br i1 %tobool109, label %return, label %if.then110

if.then110:                                       ; preds = %if.then106
  %call111 = tail call i32 @Perl_sv_unmagic(%struct.sv* %30, i32 112) #2
  br label %return

if.end115:                                        ; preds = %if.end103, %lor.lhs.false, %if.end3
  %key.addr.1 = phi i64 [ %key.addr.0, %if.end103 ], [ %key, %lor.lhs.false ], [ %key, %if.end3 ]
  %cmp116 = icmp slt i64 %key.addr.1, 0
  br i1 %cmp116, label %if.then118, label %if.end135

if.then118:                                       ; preds = %if.end115
  %31 = load i64* %sv_flags, align 8, !tbaa !17
  %and120 = and i64 %31, 32768
  %tobool121 = icmp eq i64 %and120, 0
  br i1 %tobool121, label %cond.false124, label %cond.true122

cond.true122:                                     ; preds = %if.then118
  %32 = bitcast %struct.av* %av to %struct.sv*
  %call123 = tail call i64 @Perl_mg_size(%struct.sv* %32) #2
  br label %cond.end127

cond.false124:                                    ; preds = %if.then118
  %sv_any125 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %33 = load %struct.xpvav** %sv_any125, align 8, !tbaa !1
  %xav_fill126 = getelementptr inbounds %struct.xpvav* %33, i64 0, i32 1
  %34 = load i64* %xav_fill126, align 8, !tbaa !11
  br label %cond.end127

cond.end127:                                      ; preds = %cond.false124, %cond.true122
  %cond128 = phi i64 [ %call123, %cond.true122 ], [ %34, %cond.false124 ]
  %add129 = add i64 %key.addr.1, 1
  %add130 = add i64 %add129, %cond128
  %cmp131 = icmp slt i64 %add130, 0
  br i1 %cmp131, label %return, label %if.end135

if.end135:                                        ; preds = %cond.end127, %if.end115
  %key.addr.2 = phi i64 [ %add130, %cond.end127 ], [ %key.addr.1, %if.end115 ]
  %sv_any136 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %35 = load %struct.xpvav** %sv_any136, align 8, !tbaa !1
  %xav_fill137 = getelementptr inbounds %struct.xpvav* %35, i64 0, i32 1
  %36 = load i64* %xav_fill137, align 8, !tbaa !11
  %cmp138 = icmp sgt i64 %key.addr.2, %36
  br i1 %cmp138, label %return, label %if.else

if.else:                                          ; preds = %if.end135
  %xav_flags = getelementptr inbounds %struct.xpvav* %35, i64 0, i32 9
  %37 = load i8* %xav_flags, align 1, !tbaa !7
  %38 = and i8 %37, 3
  %39 = icmp eq i8 %38, 2
  br i1 %39, label %if.then151, label %if.end153

if.then151:                                       ; preds = %if.else
  %call152 = tail call i32 (%struct.av*, ...)* bitcast (i32 (...)* @av_reify to i32 (%struct.av*, ...)*)(%struct.av* %av) #2
  %.pre248 = load %struct.xpvav** %sv_any136, align 8, !tbaa !1
  %xav_fill156.phi.trans.insert = getelementptr inbounds %struct.xpvav* %.pre248, i64 0, i32 1
  %.pre249 = load i64* %xav_fill156.phi.trans.insert, align 8, !tbaa !11
  br label %if.end153

if.end153:                                        ; preds = %if.else, %if.then151
  %40 = phi i64 [ %36, %if.else ], [ %.pre249, %if.then151 ]
  %41 = phi %struct.xpvav* [ %35, %if.else ], [ %.pre248, %if.then151 ]
  %xav_array = getelementptr inbounds %struct.xpvav* %41, i64 0, i32 0
  %42 = load i8** %xav_array, align 8, !tbaa !12
  %43 = bitcast i8* %42 to %struct.sv**
  %arrayidx = getelementptr inbounds %struct.sv** %43, i64 %key.addr.2
  %44 = load %struct.sv** %arrayidx, align 8, !tbaa !13
  %cmp157 = icmp eq i64 %key.addr.2, %40
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx, align 8, !tbaa !13
  br i1 %cmp157, label %do.body.preheader, label %if.end177

do.body.preheader:                                ; preds = %if.end153
  %45 = load %struct.xpvav** %sv_any136, align 8, !tbaa !1
  %xav_fill164 = getelementptr inbounds %struct.xpvav* %45, i64 0, i32 1
  %xav_fill164.promoted = load i64* %xav_fill164, align 8, !tbaa !11
  %xav_array169 = getelementptr inbounds %struct.xpvav* %45, i64 0, i32 0
  br label %do.body

do.body:                                          ; preds = %do.body.preheader, %land.rhs
  %dec247 = phi i64 [ %dec, %land.rhs ], [ %xav_fill164.promoted, %do.body.preheader ]
  %key.addr.3 = phi i64 [ %dec165, %land.rhs ], [ %key.addr.2, %do.body.preheader ]
  %dec = add nsw i64 %dec247, -1
  %dec165 = add nsw i64 %key.addr.3, -1
  %cmp166 = icmp sgt i64 %key.addr.3, 0
  br i1 %cmp166, label %land.rhs, label %if.end177.loopexit

land.rhs:                                         ; preds = %do.body
  %46 = load i8** %xav_array169, align 8, !tbaa !12
  %47 = bitcast i8* %46 to %struct.sv**
  %arrayidx170 = getelementptr inbounds %struct.sv** %47, i64 %dec165
  %48 = load %struct.sv** %arrayidx170, align 8, !tbaa !13
  %cmp171 = icmp eq %struct.sv* %48, @PL_sv_undef
  br i1 %cmp171, label %do.body, label %if.end177.loopexit

if.end177.loopexit:                               ; preds = %land.rhs, %do.body
  store i64 %dec, i64* %xav_fill164, align 8, !tbaa !11
  br label %if.end177

if.end177:                                        ; preds = %if.end177.loopexit, %if.end153
  %49 = load i64* %sv_flags, align 8, !tbaa !41
  %and179 = and i64 %49, 16384
  %tobool180 = icmp eq i64 %and179, 0
  br i1 %tobool180, label %if.end184, label %if.then181

if.then181:                                       ; preds = %if.end177
  %50 = bitcast %struct.av* %av to %struct.sv*
  %call182 = tail call i32 @Perl_mg_set(%struct.sv* %50) #2
  br label %if.end184

if.end184:                                        ; preds = %if.end177, %if.then181
  %and185 = and i64 %flags, 2
  %tobool186 = icmp eq i64 %and185, 0
  br i1 %tobool186, label %if.else188, label %if.then187

if.then187:                                       ; preds = %if.end184
  tail call void @Perl_sv_free(%struct.sv* %44) #2
  br label %return

if.else188:                                       ; preds = %if.end184
  %51 = load %struct.xpvav** %sv_any136, align 8, !tbaa !1
  %xav_flags190 = getelementptr inbounds %struct.xpvav* %51, i64 0, i32 9
  %52 = load i8* %xav_flags190, align 1, !tbaa !7
  %and192 = and i8 %52, 1
  %tobool193 = icmp eq i8 %and192, 0
  br i1 %tobool193, label %return, label %if.then194

if.then194:                                       ; preds = %if.else188
  %call195 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %44) #2
  br label %return

return:                                           ; preds = %if.then187, %if.then194, %if.else188, %if.end135, %cond.end127, %if.then106, %cond.end95, %entry, %if.then110
  %retval.0 = phi %struct.sv* [ %30, %if.then110 ], [ null, %entry ], [ null, %cond.end95 ], [ null, %if.then106 ], [ null, %cond.end127 ], [ null, %if.end135 ], [ null, %if.then187 ], [ %call195, %if.then194 ], [ %44, %if.else188 ]
  ret %struct.sv* %retval.0
}

declare i32 @Perl_sv_unmagic(%struct.sv*, i32) #1

; Function Attrs: nounwind uwtable
define signext i8 @Perl_av_exists(%struct.av* %av, i64 %key) #0 {
entry:
  %tobool = icmp eq %struct.av* %av, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.av* %av, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !41
  %and = and i64 %0, 32768
  %tobool1 = icmp eq i64 %and, 0
  br i1 %tobool1, label %if.end158, label %if.then2

if.then2:                                         ; preds = %if.end
  %1 = bitcast %struct.av* %av to %struct.sv*
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %1, i32 80) #2
  %tobool3 = icmp ne %struct.magic* %call, null
  br i1 %tobool3, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then2
  %call4 = tail call %struct.magic* @Perl_mg_find(%struct.sv* %1, i32 68) #2
  %tobool5 = icmp eq %struct.magic* %call4, null
  br i1 %tobool5, label %if.end158, label %if.then6

if.then6:                                         ; preds = %lor.lhs.false, %if.then2
  %call7 = tail call %struct.sv* @Perl_sv_newmortal() #2
  %cmp = icmp slt i64 %key, 0
  br i1 %cmp, label %if.then8, label %if.end99

if.then8:                                         ; preds = %if.then6
  br i1 %tobool3, label %if.then10, label %if.then83

if.then10:                                        ; preds = %if.then8
  %mg_obj = getelementptr inbounds %struct.magic* %call, i64 0, i32 5
  %2 = load %struct.sv** %mg_obj, align 8, !tbaa !25
  %tobool11 = icmp eq %struct.sv* %2, null
  br i1 %tobool11, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.then10
  %call13 = tail call %struct.sv* @Perl_newRV(%struct.sv* %1) #2
  %call14 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call13) #2
  br label %cond.end

cond.end:                                         ; preds = %if.then10, %cond.false
  %cond = phi %struct.sv* [ %call14, %cond.false ], [ %2, %if.then10 ]
  %sv_any = getelementptr inbounds %struct.sv* %cond, i64 0, i32 0
  %3 = load i8** %sv_any, align 8, !tbaa !42
  %xrv_rv = bitcast i8* %3 to %struct.sv**
  %4 = load %struct.sv** %xrv_rv, align 8, !tbaa !43
  %sv_any15 = getelementptr inbounds %struct.sv* %4, i64 0, i32 0
  %5 = load i8** %sv_any15, align 8, !tbaa !42
  %xmg_stash = getelementptr inbounds i8* %5, i64 48
  %6 = bitcast i8* %xmg_stash to %struct.hv**
  %7 = load %struct.hv** %6, align 8, !tbaa !45
  %call16 = tail call %struct.sv** @Perl_hv_fetch(%struct.hv* %7, i8* getelementptr inbounds ([17 x i8]* @.str2, i64 0, i64 0), i64 16, i64 0) #2
  %tobool17 = icmp eq %struct.sv** %call16, null
  br i1 %tobool17, label %if.then83, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.end
  %8 = load %struct.sv** %call16, align 8, !tbaa !13
  %sv_any18 = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %9 = load i8** %sv_any18, align 8, !tbaa !42
  %xgv_gp = getelementptr inbounds i8* %9, i64 56
  %10 = bitcast i8* %xgv_gp to %struct.gp**
  %11 = load %struct.gp** %10, align 8, !tbaa !31
  %gp_sv = getelementptr inbounds %struct.gp* %11, i64 0, i32 0
  %12 = load %struct.sv** %gp_sv, align 8, !tbaa !47
  %tobool19 = icmp eq %struct.sv* %12, null
  br i1 %tobool19, label %if.then83, label %cond.false21

cond.false21:                                     ; preds = %land.lhs.true
  %sv_flags25 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i64* %sv_flags25, align 8, !tbaa !17
  %and26 = and i64 %13, 262144
  %tobool27 = icmp eq i64 %and26, 0
  br i1 %tobool27, label %cond.false44, label %cond.true28

cond.true28:                                      ; preds = %cond.false21
  %sv_any32 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %14 = load i8** %sv_any32, align 8, !tbaa !42
  %15 = bitcast i8* %14 to %struct.xpv*
  store %struct.xpv* %15, %struct.xpv** @PL_Xpv, align 8, !tbaa !13
  %tobool33 = icmp eq i8* %14, null
  br i1 %tobool33, label %if.then83, label %land.lhs.true34

land.lhs.true34:                                  ; preds = %cond.true28
  %xpv_cur = getelementptr inbounds i8* %14, i64 8
  %16 = bitcast i8* %xpv_cur to i64*
  %17 = load i64* %16, align 8, !tbaa !48
  %cmp35 = icmp ugt i64 %17, 1
  br i1 %cmp35, label %if.end99, label %lor.lhs.false36

lor.lhs.false36:                                  ; preds = %land.lhs.true34
  %tobool38 = icmp eq i64 %17, 0
  br i1 %tobool38, label %if.then83, label %land.lhs.true39

land.lhs.true39:                                  ; preds = %lor.lhs.false36
  %xpv_pv = bitcast i8* %14 to i8**
  %18 = load i8** %xpv_pv, align 8, !tbaa !39
  %19 = load i8* %18, align 1, !tbaa !49
  %cmp40 = icmp eq i8 %19, 48
  br i1 %cmp40, label %if.then83, label %if.end99

cond.false44:                                     ; preds = %cond.false21
  %and49 = and i64 %13, 65536
  %tobool50 = icmp eq i64 %and49, 0
  br i1 %tobool50, label %cond.false58, label %cond.true51

cond.true51:                                      ; preds = %cond.false44
  %sv_any55 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %20 = load i8** %sv_any55, align 8, !tbaa !42
  %xiv_iv = getelementptr inbounds i8* %20, i64 24
  %21 = bitcast i8* %xiv_iv to i64*
  %22 = load i64* %21, align 8, !tbaa !50
  %cmp56 = icmp eq i64 %22, 0
  br i1 %cmp56, label %if.then83, label %if.end99

cond.false58:                                     ; preds = %cond.false44
  %and63 = and i64 %13, 131072
  %tobool64 = icmp eq i64 %and63, 0
  br i1 %tobool64, label %cond.false72, label %cond.true65

cond.true65:                                      ; preds = %cond.false58
  %sv_any69 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %23 = load i8** %sv_any69, align 8, !tbaa !42
  %xnv_nv = getelementptr inbounds i8* %23, i64 32
  %24 = bitcast i8* %xnv_nv to double*
  %25 = load double* %24, align 8, !tbaa !52
  %cmp70 = fcmp une double %25, 0.000000e+00
  br i1 %cmp70, label %if.end99, label %if.then83

cond.false72:                                     ; preds = %cond.false58
  %call76 = tail call signext i8 @Perl_sv_2bool(%struct.sv* %12) #2
  %tobool78 = icmp eq i8 %call76, 0
  br i1 %tobool78, label %if.then83, label %if.end99

if.then83:                                        ; preds = %if.then8, %cond.true65, %cond.end, %land.lhs.true, %cond.false72, %cond.true51, %cond.true28, %lor.lhs.false36, %land.lhs.true39
  %26 = load i64* %sv_flags, align 8, !tbaa !17
  %and85 = and i64 %26, 32768
  %tobool86 = icmp eq i64 %and85, 0
  br i1 %tobool86, label %cond.false89, label %cond.true87

cond.true87:                                      ; preds = %if.then83
  %call88 = tail call i64 @Perl_mg_size(%struct.sv* %1) #2
  br label %cond.end91

cond.false89:                                     ; preds = %if.then83
  %sv_any90 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %27 = load %struct.xpvav** %sv_any90, align 8, !tbaa !1
  %xav_fill = getelementptr inbounds %struct.xpvav* %27, i64 0, i32 1
  %28 = load i64* %xav_fill, align 8, !tbaa !11
  br label %cond.end91

cond.end91:                                       ; preds = %cond.false89, %cond.true87
  %cond92 = phi i64 [ %call88, %cond.true87 ], [ %28, %cond.false89 ]
  %add = add i64 %key, 1
  %add93 = add i64 %add, %cond92
  %cmp94 = icmp slt i64 %add93, 0
  br i1 %cmp94, label %return, label %if.end99

if.end99:                                         ; preds = %cond.true65, %land.lhs.true34, %cond.false72, %cond.true51, %land.lhs.true39, %cond.end91, %if.then6
  %key.addr.0 = phi i64 [ %add93, %cond.end91 ], [ %key, %if.then6 ], [ %key, %land.lhs.true39 ], [ %key, %cond.true51 ], [ %key, %cond.false72 ], [ %key, %land.lhs.true34 ], [ %key, %cond.true65 ]
  %call100 = tail call i32 @Perl_mg_copy(%struct.sv* %1, %struct.sv* %call7, i8* null, i64 %key.addr.0) #2
  %call101 = tail call %struct.magic* @Perl_mg_find(%struct.sv* %call7, i32 112) #2
  %tobool102 = icmp eq %struct.magic* %call101, null
  br i1 %tobool102, label %if.end158, label %if.then103

if.then103:                                       ; preds = %if.end99
  %call104 = tail call i32 (%struct.sv*, %struct.magic*, ...)* bitcast (i32 (...)* @magic_existspack to i32 (%struct.sv*, %struct.magic*, ...)*)(%struct.sv* %call7, %struct.magic* %call101) #2
  %tobool105 = icmp eq %struct.sv* %call7, null
  br i1 %tobool105, label %return, label %cond.false107

cond.false107:                                    ; preds = %if.then103
  %sv_flags108 = getelementptr inbounds %struct.sv* %call7, i64 0, i32 2
  %29 = load i64* %sv_flags108, align 8, !tbaa !17
  %and109 = and i64 %29, 262144
  %tobool110 = icmp eq i64 %and109, 0
  br i1 %tobool110, label %cond.false126, label %cond.true111

cond.true111:                                     ; preds = %cond.false107
  %sv_any112 = getelementptr inbounds %struct.sv* %call7, i64 0, i32 0
  %30 = load i8** %sv_any112, align 8, !tbaa !42
  %31 = bitcast i8* %30 to %struct.xpv*
  store %struct.xpv* %31, %struct.xpv** @PL_Xpv, align 8, !tbaa !13
  %tobool113 = icmp eq i8* %30, null
  br i1 %tobool113, label %land.end124, label %land.rhs

land.rhs:                                         ; preds = %cond.true111
  %xpv_cur114 = getelementptr inbounds i8* %30, i64 8
  %32 = bitcast i8* %xpv_cur114 to i64*
  %33 = load i64* %32, align 8, !tbaa !48
  %cmp115 = icmp ugt i64 %33, 1
  br i1 %cmp115, label %land.end124, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %tobool118 = icmp eq i64 %33, 0
  br i1 %tobool118, label %land.end124, label %land.rhs119

land.rhs119:                                      ; preds = %lor.rhs
  %xpv_pv120 = bitcast i8* %30 to i8**
  %34 = load i8** %xpv_pv120, align 8, !tbaa !39
  %35 = load i8* %34, align 1, !tbaa !49
  %cmp122 = icmp ne i8 %35, 48
  br label %land.end124

land.end124:                                      ; preds = %lor.rhs, %cond.true111, %land.rhs, %land.rhs119
  %36 = phi i1 [ false, %cond.true111 ], [ true, %land.rhs ], [ false, %lor.rhs ], [ %cmp122, %land.rhs119 ]
  %cond125 = zext i1 %36 to i8
  br label %return

cond.false126:                                    ; preds = %cond.false107
  %and128 = and i64 %29, 65536
  %tobool129 = icmp eq i64 %and128, 0
  br i1 %tobool129, label %cond.false135, label %cond.true130

cond.true130:                                     ; preds = %cond.false126
  %sv_any131 = getelementptr inbounds %struct.sv* %call7, i64 0, i32 0
  %37 = load i8** %sv_any131, align 8, !tbaa !42
  %xiv_iv132 = getelementptr inbounds i8* %37, i64 24
  %38 = bitcast i8* %xiv_iv132 to i64*
  %39 = load i64* %38, align 8, !tbaa !50
  %cmp133 = icmp ne i64 %39, 0
  %conv134 = zext i1 %cmp133 to i8
  br label %return

cond.false135:                                    ; preds = %cond.false126
  %and137 = and i64 %29, 131072
  %tobool138 = icmp eq i64 %and137, 0
  br i1 %tobool138, label %cond.false144, label %cond.true139

cond.true139:                                     ; preds = %cond.false135
  %sv_any140 = getelementptr inbounds %struct.sv* %call7, i64 0, i32 0
  %40 = load i8** %sv_any140, align 8, !tbaa !42
  %xnv_nv141 = getelementptr inbounds i8* %40, i64 32
  %41 = bitcast i8* %xnv_nv141 to double*
  %42 = load double* %41, align 8, !tbaa !52
  %cmp142 = fcmp une double %42, 0.000000e+00
  %conv143 = zext i1 %cmp142 to i8
  br label %return

cond.false144:                                    ; preds = %cond.false135
  %call145 = tail call signext i8 @Perl_sv_2bool(%struct.sv* %call7) #2
  br label %return

if.end158:                                        ; preds = %if.end99, %lor.lhs.false, %if.end
  %key.addr.1 = phi i64 [ %key.addr.0, %if.end99 ], [ %key, %lor.lhs.false ], [ %key, %if.end ]
  %cmp159 = icmp slt i64 %key.addr.1, 0
  br i1 %cmp159, label %if.then161, label %if.end178

if.then161:                                       ; preds = %if.end158
  %43 = load i64* %sv_flags, align 8, !tbaa !17
  %and163 = and i64 %43, 32768
  %tobool164 = icmp eq i64 %and163, 0
  br i1 %tobool164, label %cond.false167, label %cond.true165

cond.true165:                                     ; preds = %if.then161
  %44 = bitcast %struct.av* %av to %struct.sv*
  %call166 = tail call i64 @Perl_mg_size(%struct.sv* %44) #2
  br label %cond.end170

cond.false167:                                    ; preds = %if.then161
  %sv_any168 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %45 = load %struct.xpvav** %sv_any168, align 8, !tbaa !1
  %xav_fill169 = getelementptr inbounds %struct.xpvav* %45, i64 0, i32 1
  %46 = load i64* %xav_fill169, align 8, !tbaa !11
  br label %cond.end170

cond.end170:                                      ; preds = %cond.false167, %cond.true165
  %cond171 = phi i64 [ %call166, %cond.true165 ], [ %46, %cond.false167 ]
  %add172 = add i64 %key.addr.1, 1
  %add173 = add i64 %add172, %cond171
  %cmp174 = icmp slt i64 %add173, 0
  br i1 %cmp174, label %return, label %if.end178

if.end178:                                        ; preds = %cond.end170, %if.end158
  %key.addr.2 = phi i64 [ %add173, %cond.end170 ], [ %key.addr.1, %if.end158 ]
  %sv_any179 = getelementptr inbounds %struct.av* %av, i64 0, i32 0
  %47 = load %struct.xpvav** %sv_any179, align 8, !tbaa !1
  %xav_fill180 = getelementptr inbounds %struct.xpvav* %47, i64 0, i32 1
  %48 = load i64* %xav_fill180, align 8, !tbaa !11
  %cmp181 = icmp sgt i64 %key.addr.2, %48
  br i1 %cmp181, label %if.else, label %land.lhs.true183

land.lhs.true183:                                 ; preds = %if.end178
  %xav_array = getelementptr inbounds %struct.xpvav* %47, i64 0, i32 0
  %49 = load i8** %xav_array, align 8, !tbaa !12
  %50 = bitcast i8* %49 to %struct.sv**
  %arrayidx = getelementptr inbounds %struct.sv** %50, i64 %key.addr.2
  %51 = load %struct.sv** %arrayidx, align 8, !tbaa !13
  %cmp185 = icmp eq %struct.sv* %51, @PL_sv_undef
  %tobool191 = icmp eq %struct.sv* %51, null
  %or.cond = or i1 %cmp185, %tobool191
  br i1 %or.cond, label %if.else, label %return

if.else:                                          ; preds = %land.lhs.true183, %if.end178
  br label %return

return:                                           ; preds = %land.lhs.true183, %cond.end170, %cond.true130, %cond.false144, %cond.true139, %land.end124, %if.then103, %cond.end91, %entry, %if.else
  %retval.0 = phi i8 [ 0, %if.else ], [ 0, %entry ], [ 0, %cond.end91 ], [ 0, %if.then103 ], [ %cond125, %land.end124 ], [ %conv134, %cond.true130 ], [ %conv143, %cond.true139 ], [ %call145, %cond.false144 ], [ 0, %cond.end170 ], [ 1, %land.lhs.true183 ]
  ret i8 %retval.0
}

declare i32 @magic_existspack(...) #1

; Function Attrs: nounwind uwtable
define %struct.hv* @Perl_avhv_keys(%struct.av* %av) #0 {
entry:
  %call = tail call %struct.sv** @Perl_av_fetch(%struct.av* %av, i64 0, i64 0)
  %tobool = icmp eq %struct.sv** %call, null
  br i1 %tobool, label %if.end37, label %if.then

if.then:                                          ; preds = %entry
  %0 = load %struct.sv** %call, align 8, !tbaa !13
  %sv_flags = getelementptr inbounds %struct.sv* %0, i64 0, i32 2
  %1 = load i64* %sv_flags, align 8, !tbaa !17
  %and = and i64 %1, 8192
  %tobool1 = icmp eq i64 %and, 0
  br i1 %tobool1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  %call3 = tail call i32 @Perl_mg_get(%struct.sv* %0) #2
  %.pre = load i64* %sv_flags, align 8, !tbaa !17
  br label %if.end

if.end:                                           ; preds = %if.then, %if.then2
  %2 = phi i64 [ %1, %if.then ], [ %.pre, %if.then2 ]
  %and5 = and i64 %2, 524288
  %tobool6 = icmp eq i64 %and5, 0
  br i1 %tobool6, label %if.end37, label %if.then7

if.then7:                                         ; preds = %if.end
  %3 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !13
  %cop_warnings = getelementptr inbounds %struct.cop* %3, i64 0, i32 14
  %4 = load %struct.sv** %cop_warnings, align 8, !tbaa !60
  %cmp = icmp eq %struct.sv* %4, null
  br i1 %cmp, label %lor.lhs.false16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then7
  %5 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !13
  %cop_warnings8 = getelementptr inbounds %struct.cop* %5, i64 0, i32 14
  %6 = load %struct.sv** %cop_warnings8, align 8, !tbaa !60
  %cmp9 = icmp eq %struct.sv* %6, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp9, label %lor.lhs.false16, label %land.lhs.true10

land.lhs.true10:                                  ; preds = %land.lhs.true
  %7 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !13
  %cop_warnings11 = getelementptr inbounds %struct.cop* %7, i64 0, i32 14
  %8 = load %struct.sv** %cop_warnings11, align 8, !tbaa !60
  %cmp12 = icmp eq %struct.sv* %8, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp12, label %land.lhs.true24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true10
  %9 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !13
  %cop_warnings13 = getelementptr inbounds %struct.cop* %9, i64 0, i32 14
  %10 = load %struct.sv** %cop_warnings13, align 8, !tbaa !60
  %sv_any = getelementptr inbounds %struct.sv* %10, i64 0, i32 0
  %11 = load i8** %sv_any, align 8, !tbaa !42
  %xpv_pv = bitcast i8* %11 to i8**
  %12 = load i8** %xpv_pv, align 8, !tbaa !39
  %13 = load i8* %12, align 1, !tbaa !49
  %and14 = and i8 %13, 16
  %tobool15 = icmp eq i8 %and14, 0
  br i1 %tobool15, label %lor.lhs.false16, label %land.lhs.true24

lor.lhs.false16:                                  ; preds = %lor.lhs.false, %land.lhs.true, %if.then7
  %14 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !13
  %cop_warnings17 = getelementptr inbounds %struct.cop* %14, i64 0, i32 14
  %15 = load %struct.sv** %cop_warnings17, align 8, !tbaa !60
  %cmp18 = icmp eq %struct.sv* %15, null
  br i1 %cmp18, label %land.lhs.true20, label %if.end28

land.lhs.true20:                                  ; preds = %lor.lhs.false16
  %16 = load i8* @PL_dowarn, align 1, !tbaa !49
  %and22 = and i8 %16, 1
  %tobool23 = icmp eq i8 %and22, 0
  br i1 %tobool23, label %if.end28, label %land.lhs.true24

land.lhs.true24:                                  ; preds = %lor.lhs.false, %land.lhs.true20, %land.lhs.true10
  %call25 = tail call i32 @Perl_sv_isa(%struct.sv* %0, i8* getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0)) #2
  %tobool26 = icmp eq i32 %call25, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %land.lhs.true24
  tail call void (i64, i8*, ...)* @Perl_warner(i64 2, i8* getelementptr inbounds ([29 x i8]* @.str10, i64 0, i64 0)) #2
  br label %if.end28

if.end28:                                         ; preds = %land.lhs.true24, %land.lhs.true20, %if.then27, %lor.lhs.false16
  %sv_any29 = getelementptr inbounds %struct.sv* %0, i64 0, i32 0
  %17 = load i8** %sv_any29, align 8, !tbaa !42
  %xrv_rv = bitcast i8* %17 to %struct.sv**
  %18 = load %struct.sv** %xrv_rv, align 8, !tbaa !43
  %sv_flags30 = getelementptr inbounds %struct.sv* %18, i64 0, i32 2
  %19 = load i64* %sv_flags30, align 8, !tbaa !17
  %and31 = and i64 %19, 255
  %cmp32 = icmp eq i64 %and31, 11
  br i1 %cmp32, label %if.then34, label %if.end37

if.then34:                                        ; preds = %if.end28
  %20 = bitcast %struct.sv* %18 to %struct.hv*
  br label %return

if.end37:                                         ; preds = %if.end, %entry, %if.end28
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([29 x i8]* @.str11, i64 0, i64 0)) #2
  br label %return

return:                                           ; preds = %if.end37, %if.then34
  %retval.0 = phi %struct.hv* [ %20, %if.then34 ], [ null, %if.end37 ]
  ret %struct.hv* %retval.0
}

declare i32 @Perl_mg_get(%struct.sv*) #1

declare i32 @Perl_sv_isa(%struct.sv*, i8*) #1

declare void @Perl_warner(i64, i8*, ...) #1

; Function Attrs: nounwind uwtable
define %struct.sv** @Perl_avhv_store_ent(%struct.av* %av, %struct.sv* %keysv, %struct.sv* %val, i64 %hash) #0 {
entry:
  %call = tail call i32 (%struct.av*, %struct.sv*, i64, ...)* bitcast (i32 (...)* @avhv_index to i32 (%struct.av*, %struct.sv*, i64, ...)*)(%struct.av* %av, %struct.sv* %keysv, i64 %hash) #2
  %conv = sext i32 %call to i64
  %call1 = tail call %struct.sv** @Perl_av_store(%struct.av* %av, i64 %conv, %struct.sv* %val)
  ret %struct.sv** %call1
}

declare i32 @avhv_index(...) #1

; Function Attrs: nounwind uwtable
define %struct.sv** @Perl_avhv_fetch_ent(%struct.av* %av, %struct.sv* %keysv, i64 %lval, i64 %hash) #0 {
entry:
  %call = tail call i32 (%struct.av*, %struct.sv*, i64, ...)* bitcast (i32 (...)* @avhv_index to i32 (%struct.av*, %struct.sv*, i64, ...)*)(%struct.av* %av, %struct.sv* %keysv, i64 %hash) #2
  %conv = sext i32 %call to i64
  %call1 = tail call %struct.sv** @Perl_av_fetch(%struct.av* %av, i64 %conv, i64 %lval)
  ret %struct.sv** %call1
}

; Function Attrs: nounwind uwtable
define %struct.sv* @Perl_avhv_delete_ent(%struct.av* %av, %struct.sv* %keysv, i64 %flags, i64 %hash) #0 {
entry:
  %call = tail call %struct.hv* @Perl_avhv_keys(%struct.av* %av)
  %call1 = tail call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %call, %struct.sv* %keysv, i64 0, i64 %hash) #2
  %tobool = icmp eq %struct.he* %call1, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %hent_val = getelementptr inbounds %struct.he* %call1, i64 0, i32 2
  %0 = load %struct.sv** %hent_val, align 8, !tbaa !62
  %sv_flags = getelementptr inbounds %struct.sv* %0, i64 0, i32 2
  %1 = load i64* %sv_flags, align 8, !tbaa !17
  %and = and i64 %1, 118423552
  %tobool2 = icmp eq i64 %and, 0
  br i1 %tobool2, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %call4 = tail call i32 (%struct.sv*, ...)* bitcast (i32 (...)* @avhv_index_sv to i32 (%struct.sv*, ...)*)(%struct.sv* %0) #2
  %conv = sext i32 %call4 to i64
  %call5 = tail call %struct.sv* @Perl_av_delete(%struct.av* %av, i64 %conv, i64 %flags)
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi %struct.sv* [ %call5, %if.end ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret %struct.sv* %retval.0
}

declare %struct.he* @Perl_hv_fetch_ent(%struct.hv*, %struct.sv*, i64, i64) #1

declare i32 @avhv_index_sv(...) #1

; Function Attrs: nounwind uwtable
define signext i8 @Perl_avhv_exists_ent(%struct.av* %av, %struct.sv* %keysv, i64 %hash) #0 {
entry:
  %call = tail call %struct.hv* @Perl_avhv_keys(%struct.av* %av)
  %call1 = tail call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %call, %struct.sv* %keysv, i64 0, i64 %hash) #2
  %tobool = icmp eq %struct.he* %call1, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %hent_val = getelementptr inbounds %struct.he* %call1, i64 0, i32 2
  %0 = load %struct.sv** %hent_val, align 8, !tbaa !62
  %sv_flags = getelementptr inbounds %struct.sv* %0, i64 0, i32 2
  %1 = load i64* %sv_flags, align 8, !tbaa !17
  %and = and i64 %1, 118423552
  %tobool2 = icmp eq i64 %and, 0
  br i1 %tobool2, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %call4 = tail call i32 (%struct.sv*, ...)* bitcast (i32 (...)* @avhv_index_sv to i32 (%struct.sv*, ...)*)(%struct.sv* %0) #2
  %conv = sext i32 %call4 to i64
  %call5 = tail call signext i8 @Perl_av_exists(%struct.av* %av, i64 %conv)
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi i8 [ %call5, %if.end ], [ 0, %lor.lhs.false ], [ 0, %entry ]
  ret i8 %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.he* @Perl_avhv_iternext(%struct.av* %av) #0 {
entry:
  %call = tail call %struct.hv* @Perl_avhv_keys(%struct.av* %av)
  %call1 = tail call %struct.he* @Perl_hv_iternext(%struct.hv* %call) #2
  ret %struct.he* %call1
}

declare %struct.he* @Perl_hv_iternext(%struct.hv*) #1

; Function Attrs: nounwind uwtable
define %struct.sv* @Perl_avhv_iterval(%struct.av* %av, %struct.he* %entry1) #0 {
entry:
  %call = tail call %struct.hv* @Perl_avhv_keys(%struct.av* %av)
  %call2 = tail call %struct.sv* @Perl_hv_iterval(%struct.hv* %call, %struct.he* %entry1) #2
  %call3 = tail call i32 (%struct.sv*, ...)* bitcast (i32 (...)* @avhv_index_sv to i32 (%struct.sv*, ...)*)(%struct.sv* %call2) #2
  %conv = sext i32 %call3 to i64
  %call4 = tail call %struct.sv** @Perl_av_fetch(%struct.av* %av, i64 %conv, i64 1)
  %0 = load %struct.sv** %call4, align 8, !tbaa !13
  ret %struct.sv* %0
}

declare %struct.sv* @Perl_hv_iterval(%struct.hv*, %struct.he*) #1

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #2

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5 (trunk)"}
!1 = metadata !{metadata !2, metadata !3, i64 0}
!2 = metadata !{metadata !"av", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!3 = metadata !{metadata !"any pointer", metadata !4, i64 0}
!4 = metadata !{metadata !"omnipotent char", metadata !5, i64 0}
!5 = metadata !{metadata !"Simple C/C++ TBAA"}
!6 = metadata !{metadata !"long", metadata !4, i64 0}
!7 = metadata !{metadata !8, metadata !4, i64 72}
!8 = metadata !{metadata !"xpvav", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !9, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !3, i64 64, metadata !4, i64 72}
!9 = metadata !{metadata !"double", metadata !4, i64 0}
!10 = metadata !{metadata !8, metadata !6, i64 16}
!11 = metadata !{metadata !8, metadata !6, i64 8}
!12 = metadata !{metadata !8, metadata !3, i64 0}
!13 = metadata !{metadata !3, metadata !3, i64 0}
!14 = metadata !{metadata !15, metadata !6, i64 8}
!15 = metadata !{metadata !"sv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!16 = metadata !{metadata !8, metadata !3, i64 56}
!17 = metadata !{metadata !15, metadata !6, i64 16}
!18 = metadata !{metadata !6, metadata !6, i64 0}
!19 = metadata !{metadata !20, metadata !3, i64 48}
!20 = metadata !{metadata !"stackinfo", metadata !3, i64 0, metadata !3, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !6, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !6, i64 56}
!21 = metadata !{metadata !20, metadata !3, i64 40}
!22 = metadata !{metadata !20, metadata !6, i64 32}
!23 = metadata !{metadata !20, metadata !6, i64 16}
!24 = metadata !{metadata !20, metadata !3, i64 0}
!25 = metadata !{metadata !26, metadata !3, i64 24}
!26 = metadata !{metadata !"magic", metadata !3, i64 0, metadata !3, i64 8, metadata !27, i64 16, metadata !4, i64 18, metadata !4, i64 19, metadata !3, i64 24, metadata !3, i64 32, metadata !6, i64 40}
!27 = metadata !{metadata !"short", metadata !4, i64 0}
!28 = metadata !{metadata !29, metadata !6, i64 16}
!29 = metadata !{metadata !"gv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!30 = metadata !{metadata !29, metadata !3, i64 0}
!31 = metadata !{metadata !32, metadata !3, i64 56}
!32 = metadata !{metadata !"xpvgv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !9, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !3, i64 64, metadata !6, i64 72, metadata !3, i64 80, metadata !4, i64 88}
!33 = metadata !{metadata !34, metadata !3, i64 16}
!34 = metadata !{metadata !"gp", metadata !3, i64 0, metadata !6, i64 8, metadata !3, i64 16, metadata !3, i64 24, metadata !3, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !6, i64 64, metadata !6, i64 72, metadata !6, i64 80, metadata !3, i64 88}
!35 = metadata !{metadata !36, metadata !3, i64 0}
!36 = metadata !{metadata !"io", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!37 = metadata !{metadata !38, metadata !3, i64 64}
!38 = metadata !{metadata !"xpvio", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !9, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !3, i64 64, metadata !4, i64 72, metadata !6, i64 80, metadata !6, i64 88, metadata !6, i64 96, metadata !6, i64 104, metadata !3, i64 112, metadata !3, i64 120, metadata !3, i64 128, metadata !3, i64 136, metadata !3, i64 144, metadata !3, i64 152, metadata !27, i64 160, metadata !4, i64 162, metadata !4, i64 163}
!39 = metadata !{metadata !40, metadata !3, i64 0}
!40 = metadata !{metadata !"xpv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!41 = metadata !{metadata !2, metadata !6, i64 16}
!42 = metadata !{metadata !15, metadata !3, i64 0}
!43 = metadata !{metadata !44, metadata !3, i64 0}
!44 = metadata !{metadata !"xrv", metadata !3, i64 0}
!45 = metadata !{metadata !46, metadata !3, i64 48}
!46 = metadata !{metadata !"xpvmg", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !9, i64 32, metadata !3, i64 40, metadata !3, i64 48}
!47 = metadata !{metadata !34, metadata !3, i64 0}
!48 = metadata !{metadata !40, metadata !6, i64 8}
!49 = metadata !{metadata !4, metadata !4, i64 0}
!50 = metadata !{metadata !51, metadata !6, i64 24}
!51 = metadata !{metadata !"xpviv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24}
!52 = metadata !{metadata !53, metadata !9, i64 32}
!53 = metadata !{metadata !"xpvnv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !9, i64 32}
!54 = metadata !{metadata !55, metadata !4, i64 80}
!55 = metadata !{metadata !"xpvlv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !9, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !6, i64 56, metadata !6, i64 64, metadata !3, i64 72, metadata !4, i64 80}
!56 = metadata !{metadata !55, metadata !3, i64 72}
!57 = metadata !{metadata !46, metadata !3, i64 40}
!58 = metadata !{metadata !26, metadata !4, i64 18}
!59 = metadata !{metadata !8, metadata !3, i64 64}
!60 = metadata !{metadata !61, metadata !3, i64 88}
!61 = metadata !{metadata !"cop", metadata !3, i64 0, metadata !3, i64 8, metadata !3, i64 16, metadata !6, i64 24, metadata !27, i64 32, metadata !27, i64 34, metadata !4, i64 36, metadata !4, i64 37, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !6, i64 64, metadata !6, i64 72, metadata !6, i64 80, metadata !3, i64 88, metadata !3, i64 96}
!62 = metadata !{metadata !63, metadata !3, i64 16}
!63 = metadata !{metadata !"he", metadata !3, i64 0, metadata !3, i64 8, metadata !3, i64 16}
