; ModuleID = 'Opcode.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.sv = type { i8*, i64, i64 }
%struct.gv = type { %struct.xpvgv*, i64, i64 }
%struct.xpvgv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.gp*, i8*, i64, %struct.hv*, i8 }
%struct.magic = type { %struct.magic*, %struct.mgvtbl*, i16, i8, i8, %struct.sv*, i8*, i64 }
%struct.mgvtbl = type { i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i64 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)*, i32 (%struct.magic*, %struct.clone_params*)* }
%struct.clone_params = type { %struct.av*, i64, %struct.interpreter* }
%struct.av = type { %struct.xpvav*, i64, i64 }
%struct.xpvav = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.sv**, %struct.sv*, i8 }
%struct.interpreter = type { i8 }
%struct.gp = type { %struct.sv*, i64, %struct.io*, %struct.cv*, %struct.av*, %struct.hv*, %struct.gv*, %struct.cv*, i64, i64, i64, i8* }
%struct.io = type { %struct.xpvio*, i64, i64 }
%struct.xpvio = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct._PerlIO**, %struct._PerlIO**, %union.anon, i64, i64, i64, i64, i8*, %struct.gv*, i8*, %struct.gv*, i8*, %struct.gv*, i16, i8, i8 }
%struct._PerlIO = type opaque
%union.anon = type { %struct.__dirstream* }
%struct.__dirstream = type opaque
%struct.cv = type { %struct.xpvcv*, i64, i64 }
%struct.xpvcv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.hv*, %struct.op*, %struct.op*, {}*, %union.any, %struct.gv*, i8*, i64, %struct.av*, %struct.cv*, i16, i64 }
%struct.op = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8 }
%union.any = type { i8* }
%struct.hv = type { %struct.xpvhv*, i64, i64 }
%struct.xpvhv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, i64, %struct.he*, %struct.pmop*, i8* }
%struct.he = type { %struct.he*, %struct.hek*, %struct.sv* }
%struct.hek = type { i64, i64, [1 x i8] }
%struct.pmop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.pmop*, %struct.regexp*, i64, i64, i8, %struct.hv* }
%struct.regexp = type { i64*, i64*, %struct.regnode*, %struct.reg_substr_data*, i8*, %struct.reg_data*, i8*, i64*, i64, i64, i64, i64, i64, i64, i64, i64, [1 x %struct.regnode] }
%struct.regnode = type { i8, i8, i16 }
%struct.reg_substr_data = type opaque
%struct.reg_data = type opaque

@PL_stack_sp = external global %struct.sv**
@PL_stack_base = external global %struct.sv**
@PL_markstack_ptr = external global i64*
@.str = private unnamed_addr constant [39 x i8] c"Usage: Opcode::_safe_pkg_prep(Package)\00", align 1
@.str1 = private unnamed_addr constant [5 x i8] c"main\00", align 1
@.str2 = private unnamed_addr constant [2 x i8] c"_\00", align 1
@PL_defgv = external global %struct.gv*
@PL_Sv = external global %struct.sv*
@.str3 = private unnamed_addr constant [52 x i8] c"Usage: Opcode::_safe_call_sv(Package, mask, codesv)\00", align 1
@PL_endav = external global %struct.av*
@PL_defstash = external global %struct.hv*
@PL_curstash = external global %struct.hv*
@.str4 = private unnamed_addr constant [7 x i8] c"main::\00", align 1
@PL_incgv = external global %struct.gv*
@.str5 = private unnamed_addr constant [4 x i8] c"INC\00", align 1
@PL_markstack_max = external global i64*
@PL_op = external global %struct.op*
@.str6 = private unnamed_addr constant [46 x i8] c"Usage: Opcode::verify_opset(opset, fatal = 0)\00", align 1
@PL_curpad = external global %struct.sv**
@.str7 = private unnamed_addr constant [35 x i8] c"Usage: Opcode::invert_opset(opset)\00", align 1
@my_cxt.0 = internal unnamed_addr global %struct.hv* null
@my_cxt.1 = internal unnamed_addr global %struct.sv* null
@my_cxt.2 = internal unnamed_addr global i64 0
@PL_maxo = external global i32
@.str8 = private unnamed_addr constant [45 x i8] c"Usage: Opcode::opset_to_ops(opset, desc = 0)\00", align 1
@PL_stack_max = external global %struct.sv**
@.str9 = private unnamed_addr constant [8 x i8] c"(opset)\00", align 1
@.str10 = private unnamed_addr constant [21 x i8] c"Usage: %s(safe, ...)\00", align 1
@.str11 = private unnamed_addr constant [18 x i8] c"Not a Safe object\00", align 1
@.str12 = private unnamed_addr constant [5 x i8] c"Mask\00", align 1
@PL_sv_yes = external global %struct.sv
@.str13 = private unnamed_addr constant [35 x i8] c"panic: opcode %d (%s) out of range\00", align 1
@.str14 = private unnamed_addr constant [42 x i8] c"panic: invalid bitspec for \22%s\22 (type %u)\00", align 1
@.str15 = private unnamed_addr constant [43 x i8] c"Usage: Opcode::define_optag(optagsv, mask)\00", align 1
@.str16 = private unnamed_addr constant [29 x i8] c"Usage: Opcode::empty_opset()\00", align 1
@.str17 = private unnamed_addr constant [28 x i8] c"Usage: Opcode::full_opset()\00", align 1
@.str18 = private unnamed_addr constant [33 x i8] c"Usage: Opcode::opmask_add(opset)\00", align 1
@PL_op_mask = external global i8*
@.str19 = private unnamed_addr constant [25 x i8] c"Usage: Opcode::opcodes()\00", align 1
@.str20 = private unnamed_addr constant [44 x i8] c"opcodes in list context not yet implemented\00", align 1
@.str21 = private unnamed_addr constant [24 x i8] c"Usage: Opcode::opmask()\00", align 1
@.str22 = private unnamed_addr constant [9 x i8] c"Opcode.c\00", align 1
@.str23 = private unnamed_addr constant [23 x i8] c"Opcode::_safe_pkg_prep\00", align 1
@.str24 = private unnamed_addr constant [2 x i8] c"$\00", align 1
@.str25 = private unnamed_addr constant [22 x i8] c"Opcode::_safe_call_sv\00", align 1
@.str26 = private unnamed_addr constant [4 x i8] c"$$$\00", align 1
@.str27 = private unnamed_addr constant [21 x i8] c"Opcode::verify_opset\00", align 1
@.str28 = private unnamed_addr constant [4 x i8] c"$;$\00", align 1
@.str29 = private unnamed_addr constant [21 x i8] c"Opcode::invert_opset\00", align 1
@.str30 = private unnamed_addr constant [21 x i8] c"Opcode::opset_to_ops\00", align 1
@.str31 = private unnamed_addr constant [14 x i8] c"Opcode::opset\00", align 1
@.str32 = private unnamed_addr constant [3 x i8] c";@\00", align 1
@.str33 = private unnamed_addr constant [20 x i8] c"Opcode::permit_only\00", align 1
@.str34 = private unnamed_addr constant [4 x i8] c"$;@\00", align 1
@.str35 = private unnamed_addr constant [13 x i8] c"Opcode::deny\00", align 1
@.str36 = private unnamed_addr constant [18 x i8] c"Opcode::deny_only\00", align 1
@.str37 = private unnamed_addr constant [15 x i8] c"Opcode::permit\00", align 1
@.str38 = private unnamed_addr constant [15 x i8] c"Opcode::opdesc\00", align 1
@.str39 = private unnamed_addr constant [21 x i8] c"Opcode::define_optag\00", align 1
@.str40 = private unnamed_addr constant [3 x i8] c"$$\00", align 1
@.str41 = private unnamed_addr constant [20 x i8] c"Opcode::empty_opset\00", align 1
@.str42 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str43 = private unnamed_addr constant [19 x i8] c"Opcode::full_opset\00", align 1
@.str44 = private unnamed_addr constant [19 x i8] c"Opcode::opmask_add\00", align 1
@.str45 = private unnamed_addr constant [16 x i8] c"Opcode::opcodes\00", align 1
@.str46 = private unnamed_addr constant [15 x i8] c"Opcode::opmask\00", align 1
@.str48 = private unnamed_addr constant [6 x i8] c":none\00", align 1
@.str49 = private unnamed_addr constant [5 x i8] c":all\00", align 1
@.str50 = private unnamed_addr constant [38 x i8] c"Can't add to uninitialised PL_op_mask\00", align 1
@.str51 = private unnamed_addr constant [32 x i8] c"Opcode tag \22%s\22 already defined\00", align 1
@.str52 = private unnamed_addr constant [39 x i8] c"panic: opcode \22%s\22 value %d is invalid\00", align 1
@.str57 = private unnamed_addr constant [26 x i8] c"Unknown operator tag \22%s\22\00", align 1
@.str58 = private unnamed_addr constant [35 x i8] c"Can't negate operators here (\22%s\22)\00", align 1
@.str59 = private unnamed_addr constant [27 x i8] c"Unknown operator name \22%s\22\00", align 1
@.str60 = private unnamed_addr constant [29 x i8] c"Unknown operator prefix \22%s\22\00", align 1
@.str61 = private unnamed_addr constant [10 x i8] c"undefined\00", align 1
@.str62 = private unnamed_addr constant [11 x i8] c"wrong type\00", align 1
@.str63 = private unnamed_addr constant [11 x i8] c"wrong size\00", align 1
@.str64 = private unnamed_addr constant [18 x i8] c"Invalid opset: %s\00", align 1

; Function Attrs: nounwind uwtable
define void @XS_Opcode__safe_pkg_prep(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %sub.ptr.div4 = ashr exact i64 %sub.ptr.sub3, 3
  %cmp = icmp eq i64 %sub.ptr.div4, 1
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([39 x i8]* @.str, i64 0, i64 0)) #3
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %idx.neg = sub i64 0, %sub.ptr.div4
  %add.ptr5 = getelementptr inbounds %struct.sv** %0, i64 %idx.neg
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i64* %sv_flags, align 8, !tbaa !7
  %and = and i64 %6, 262144
  %cmp7 = icmp eq i64 %and, 0
  br i1 %cmp7, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %7 = load i8** %sv_any, align 8, !tbaa !9
  %xpv_pv = bitcast i8* %7 to i8**
  %8 = load i8** %xpv_pv, align 8, !tbaa !10
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %5) #3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %8, %cond.true ], [ %call, %cond.false ]
  tail call void @Perl_push_scope() #3
  %call12 = tail call %struct.hv* @Perl_gv_stashpv(i8* %cond, i64 4) #3
  %sv_any13 = getelementptr inbounds %struct.hv* %call12, i64 0, i32 0
  %9 = load %struct.xpvhv** %sv_any13, align 8, !tbaa !12
  %xhv_name = getelementptr inbounds %struct.xpvhv* %9, i64 0, i32 10
  %10 = load i8** %xhv_name, align 8, !tbaa !14
  %call14 = tail call i32 @strcmp(i8* %10, i8* getelementptr inbounds ([5 x i8]* @.str1, i64 0, i64 0)) #3
  %tobool = icmp eq i32 %call14, 0
  br i1 %tobool, label %if.end24, label %if.then15

if.then15:                                        ; preds = %cond.end
  tail call void @Perl_safesysfree(i8* %10) #3
  %call18 = tail call i8* @Perl_savepv(i8* getelementptr inbounds ([5 x i8]* @.str1, i64 0, i64 0)) #3
  %11 = load %struct.xpvhv** %sv_any13, align 8, !tbaa !12
  %xhv_name20 = getelementptr inbounds %struct.xpvhv* %11, i64 0, i32 10
  store i8* %call18, i8** %xhv_name20, align 8, !tbaa !14
  %12 = load %struct.gv** @PL_defgv, align 8, !tbaa !1
  %13 = bitcast %struct.gv* %12 to %struct.sv*
  %call21 = tail call %struct.sv** @Perl_hv_store(%struct.hv* %call12, i8* getelementptr inbounds ([2 x i8]* @.str2, i64 0, i64 0), i64 1, %struct.sv* %13, i64 0) #3
  %14 = load %struct.gv** @PL_defgv, align 8, !tbaa !1
  %15 = bitcast %struct.gv* %14 to %struct.sv*
  store %struct.sv* %15, %struct.sv** @PL_Sv, align 8, !tbaa !1
  %tobool22 = icmp eq %struct.gv* %14, null
  br i1 %tobool22, label %if.end24, label %land.rhs

land.rhs:                                         ; preds = %if.then15
  %16 = getelementptr inbounds %struct.gv* %14, i64 0, i32 1
  %17 = load i64* %16, align 8, !tbaa !17
  %inc = add i64 %17, 1
  store i64 %inc, i64* %16, align 8, !tbaa !17
  br label %if.end24

if.end24:                                         ; preds = %land.rhs, %if.then15, %cond.end
  tail call void @Perl_pop_scope() #3
  store %struct.sv** %add.ptr5, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare void @Perl_croak(i8*, ...) #1

declare i8* @Perl_sv_2pv_nolen(%struct.sv*) #1

declare void @Perl_push_scope() #1

declare %struct.hv* @Perl_gv_stashpv(i8*, i64) #1

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8* nocapture, i8* nocapture) #2

declare void @Perl_safesysfree(i8*) #1

declare i8* @Perl_savepv(i8*) #1

declare %struct.sv** @Perl_hv_store(%struct.hv*, i8*, i64, %struct.sv*, i64) #1

declare void @Perl_pop_scope() #1

; Function Attrs: nounwind uwtable
define void @XS_Opcode__safe_call_sv(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %op_mask_buf = alloca [452 x i8], align 16
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %sub.ptr.div4 = ashr exact i64 %sub.ptr.sub3, 3
  %cmp = icmp eq i64 %sub.ptr.div4, 3
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([52 x i8]* @.str3, i64 0, i64 0)) #3
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %idx.neg = sub i64 0, %sub.ptr.div4
  %add.ptr5 = getelementptr inbounds %struct.sv** %0, i64 %idx.neg
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i64* %sv_flags, align 8, !tbaa !7
  %and = and i64 %6, 262144
  %cmp7 = icmp eq i64 %and, 0
  br i1 %cmp7, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %7 = load i8** %sv_any, align 8, !tbaa !9
  %xpv_pv = bitcast i8* %7 to i8**
  %8 = load i8** %xpv_pv, align 8, !tbaa !10
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = call i8* @Perl_sv_2pv_nolen(%struct.sv* %5) #3
  %.pre74 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %9 = phi %struct.sv** [ %4, %cond.true ], [ %.pre74, %cond.false ]
  %cond = phi i8* [ %8, %cond.true ], [ %call, %cond.false ]
  %add12 = add nsw i64 %sub.ptr.div, 2
  %arrayidx13 = getelementptr inbounds %struct.sv** %9, i64 %add12
  %10 = load %struct.sv** %arrayidx13, align 8, !tbaa !1
  %add14 = add nsw i64 %sub.ptr.div, 3
  %arrayidx15 = getelementptr inbounds %struct.sv** %9, i64 %add14
  %11 = load %struct.sv** %arrayidx15, align 8, !tbaa !1
  %12 = getelementptr inbounds [452 x i8]* %op_mask_buf, i64 0, i64 0
  call void @llvm.lifetime.start(i64 452, i8* %12) #3
  call void @Perl_push_scope() #3
  %13 = load i8** @PL_op_mask, align 8, !tbaa !1
  call void @Perl_save_vptr(i8* bitcast (i8** @PL_op_mask to i8*)) #3
  store i8* %12, i8** @PL_op_mask, align 8, !tbaa !1
  %tobool.i = icmp eq i8* %13, null
  %14 = load i32* @PL_maxo, align 4, !tbaa !18
  %conv2.i = sext i32 %14 to i64
  br i1 %tobool.i, label %if.else.i, label %if.then1.i

if.then1.i:                                       ; preds = %cond.end
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 %conv2.i, i32 1, i1 false) #3
  br label %opmask_addlocal.exit

if.else.i:                                        ; preds = %cond.end
  call void @llvm.memset.p0i8.i64(i8* %12, i8 0, i64 %conv2.i, i32 16, i1 false) #3
  br label %opmask_addlocal.exit

opmask_addlocal.exit:                             ; preds = %if.then1.i, %if.else.i
  call fastcc void @opmask_add(%struct.sv* %10) #3
  call void @Perl_save_aptr(%struct.av** @PL_endav) #3
  %call16 = call %struct.av* @Perl_newAV() #3
  %15 = bitcast %struct.av* %call16 to %struct.sv*
  %call17 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %15) #3
  %16 = bitcast %struct.sv* %call17 to %struct.av*
  store %struct.av* %16, %struct.av** @PL_endav, align 8, !tbaa !1
  call void @Perl_save_hptr(%struct.hv** @PL_defstash) #3
  %call18 = call %struct.hv* @Perl_gv_stashpv(i8* %cond, i64 4) #3
  store %struct.hv* %call18, %struct.hv** @PL_defstash, align 8, !tbaa !1
  call void @Perl_save_hptr(%struct.hv** @PL_curstash) #3
  %17 = load %struct.hv** @PL_defstash, align 8, !tbaa !1
  store %struct.hv* %17, %struct.hv** @PL_curstash, align 8, !tbaa !1
  %call19 = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([7 x i8]* @.str4, i64 0, i64 0), i64 4, i64 11) #3
  %sv_any20 = getelementptr inbounds %struct.gv* %call19, i64 0, i32 0
  %18 = load %struct.xpvgv** %sv_any20, align 8, !tbaa !20
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %18, i64 0, i32 7
  %19 = load %struct.gp** %xgv_gp, align 8, !tbaa !22
  %gp_hv = getelementptr inbounds %struct.gp* %19, i64 0, i32 5
  %20 = load %struct.hv** %gp_hv, align 8, !tbaa !24
  %21 = bitcast %struct.hv* %20 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %21) #3
  %22 = load %struct.hv** @PL_defstash, align 8, !tbaa !1
  %23 = bitcast %struct.hv* %22 to %struct.sv*
  store %struct.sv* %23, %struct.sv** @PL_Sv, align 8, !tbaa !1
  %tobool = icmp eq %struct.hv* %22, null
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %opmask_addlocal.exit
  %24 = getelementptr inbounds %struct.hv* %22, i64 0, i32 1
  %25 = load i64* %24, align 8, !tbaa !17
  %inc = add i64 %25, 1
  store i64 %inc, i64* %24, align 8, !tbaa !17
  br label %land.end

land.end:                                         ; preds = %opmask_addlocal.exit, %land.rhs
  %26 = load %struct.xpvgv** %sv_any20, align 8, !tbaa !20
  %xgv_gp23 = getelementptr inbounds %struct.xpvgv* %26, i64 0, i32 7
  %27 = load %struct.gp** %xgv_gp23, align 8, !tbaa !22
  %gp_hv24 = getelementptr inbounds %struct.gp* %27, i64 0, i32 5
  store %struct.hv* %22, %struct.hv** %gp_hv24, align 8, !tbaa !24
  %28 = load %struct.gv** @PL_incgv, align 8, !tbaa !1
  %call25 = call %struct.hv* @Perl_save_hash(%struct.gv* %28) #3
  %call26 = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([4 x i8]* @.str5, i64 0, i64 0), i64 1, i64 11) #3
  %call27 = call %struct.gv* @Perl_gv_HVadd(%struct.gv* %call26) #3
  %sv_any28 = getelementptr inbounds %struct.gv* %call27, i64 0, i32 0
  %29 = load %struct.xpvgv** %sv_any28, align 8, !tbaa !20
  %xgv_gp29 = getelementptr inbounds %struct.xpvgv* %29, i64 0, i32 7
  %30 = load %struct.gp** %xgv_gp29, align 8, !tbaa !22
  %gp_hv30 = getelementptr inbounds %struct.gp* %30, i64 0, i32 5
  %31 = load %struct.hv** %gp_hv30, align 8, !tbaa !24
  %32 = bitcast %struct.hv* %31 to %struct.sv*
  store %struct.sv* %32, %struct.sv** @PL_Sv, align 8, !tbaa !1
  %tobool31 = icmp eq %struct.hv* %31, null
  br i1 %tobool31, label %land.end36, label %land.rhs32

land.rhs32:                                       ; preds = %land.end
  %33 = getelementptr inbounds %struct.hv* %31, i64 0, i32 1
  %34 = load i64* %33, align 8, !tbaa !17
  %inc34 = add i64 %34, 1
  store i64 %inc34, i64* %33, align 8, !tbaa !17
  br label %land.end36

land.end36:                                       ; preds = %land.end, %land.rhs32
  %35 = load %struct.gv** @PL_incgv, align 8, !tbaa !1
  %sv_any38 = getelementptr inbounds %struct.gv* %35, i64 0, i32 0
  %36 = load %struct.xpvgv** %sv_any38, align 8, !tbaa !20
  %xgv_gp39 = getelementptr inbounds %struct.xpvgv* %36, i64 0, i32 7
  %37 = load %struct.gp** %xgv_gp39, align 8, !tbaa !22
  %gp_hv40 = getelementptr inbounds %struct.gp* %37, i64 0, i32 5
  store %struct.hv* %31, %struct.hv** %gp_hv40, align 8, !tbaa !24
  %38 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr41 = getelementptr inbounds i64* %38, i64 1
  store i64* %incdec.ptr41, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %39 = load i64** @PL_markstack_max, align 8, !tbaa !1
  %cmp42 = icmp eq i64* %incdec.ptr41, %39
  br i1 %cmp42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %land.end36
  call void @Perl_markstack_grow() #3
  %.pre75 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  br label %if.end44

if.end44:                                         ; preds = %if.then43, %land.end36
  %40 = phi i64* [ %.pre75, %if.then43 ], [ %incdec.ptr41, %land.end36 ]
  %41 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %sub.ptr.lhs.cast45 = ptrtoint %struct.sv** %add.ptr5 to i64
  %sub.ptr.rhs.cast46 = ptrtoint %struct.sv** %41 to i64
  %sub.ptr.sub47 = sub i64 %sub.ptr.lhs.cast45, %sub.ptr.rhs.cast46
  %sub.ptr.div48 = ashr exact i64 %sub.ptr.sub47, 3
  store i64 %sub.ptr.div48, i64* %40, align 8, !tbaa !5
  %42 = load %struct.op** @PL_op, align 8, !tbaa !1
  %op_flags = getelementptr inbounds %struct.op* %42, i64 0, i32 6
  %43 = load i8* %op_flags, align 1, !tbaa !26
  %conv = zext i8 %43 to i32
  %and49 = and i32 %conv, 3
  %tobool50 = icmp eq i32 %and49, 0
  br i1 %tobool50, label %cond.false59, label %cond.true51

cond.true51:                                      ; preds = %if.end44
  %cmp55 = icmp eq i32 %and49, 3
  %conv58 = zext i1 %cmp55 to i64
  br label %cond.end61

cond.false59:                                     ; preds = %if.end44
  %call60 = call i64 @Perl_dowantarray() #3
  br label %cond.end61

cond.end61:                                       ; preds = %cond.false59, %cond.true51
  %cond62 = phi i64 [ %conv58, %cond.true51 ], [ %call60, %cond.false59 ]
  %or63 = or i64 %cond62, 20
  %call64 = call i64 @Perl_call_sv(%struct.sv* %11, i64 %or63) #3
  %44 = bitcast %struct.hv* %call25 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %44) #3
  %45 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  call void @Perl_pop_scope() #3
  store %struct.sv** %45, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  call void @llvm.lifetime.end(i64 452, i8* %12) #3
  ret void
}

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #3

declare void @Perl_save_aptr(%struct.av**) #1

declare %struct.sv* @Perl_sv_2mortal(%struct.sv*) #1

declare %struct.av* @Perl_newAV() #1

declare void @Perl_save_hptr(%struct.hv**) #1

declare %struct.gv* @Perl_gv_fetchpv(i8*, i64, i64) #1

declare void @Perl_sv_free(%struct.sv*) #1

declare %struct.hv* @Perl_save_hash(%struct.gv*) #1

declare %struct.gv* @Perl_gv_HVadd(%struct.gv*) #1

declare void @Perl_markstack_grow() #1

declare i64 @Perl_call_sv(%struct.sv*, i64) #1

declare i64 @Perl_dowantarray() #1

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #3

; Function Attrs: nounwind uwtable
define void @XS_Opcode_verify_opset(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %sub.ptr.sub3.off = add i64 %sub.ptr.sub3, -8
  %4 = icmp ugt i64 %sub.ptr.sub3.off, 8
  br i1 %4, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([46 x i8]* @.str6, i64 0, i64 0)) #3
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %5 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %5, i64 %add
  %6 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %7 = load %struct.op** @PL_op, align 8, !tbaa !1
  %op_private = getelementptr inbounds %struct.op* %7, i64 0, i32 7
  %8 = load i8* %op_private, align 1, !tbaa !29
  %and = and i8 %8, 32
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %op_targ = getelementptr inbounds %struct.op* %7, i64 0, i32 3
  %9 = load i64* %op_targ, align 8, !tbaa !30
  %10 = load %struct.sv*** @PL_curpad, align 8, !tbaa !1
  %arrayidx7 = getelementptr inbounds %struct.sv** %10, i64 %9
  %11 = load %struct.sv** %arrayidx7, align 8, !tbaa !1
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = tail call %struct.sv* @Perl_sv_newmortal() #3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %11, %cond.true ], [ %call, %cond.false ]
  %cmp8 = icmp slt i64 %sub.ptr.sub3, 16
  br i1 %cmp8, label %if.end25, label %if.else

if.else:                                          ; preds = %cond.end
  %add11 = add nsw i64 %sub.ptr.div, 2
  %12 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx12 = getelementptr inbounds %struct.sv** %12, i64 %add11
  %13 = load %struct.sv** %arrayidx12, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %14 = load i64* %sv_flags, align 8, !tbaa !7
  %and13 = and i64 %14, 65536
  %tobool14 = icmp eq i64 %and13, 0
  br i1 %tobool14, label %cond.false18, label %cond.true15

cond.true15:                                      ; preds = %if.else
  %sv_any = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %15 = load i8** %sv_any, align 8, !tbaa !9
  %xiv_iv = getelementptr inbounds i8* %15, i64 24
  %16 = bitcast i8* %xiv_iv to i64*
  %17 = load i64* %16, align 8, !tbaa !31
  br label %cond.end22

cond.false18:                                     ; preds = %if.else
  %call21 = tail call i64 @Perl_sv_2iv(%struct.sv* %13) #3
  br label %cond.end22

cond.end22:                                       ; preds = %cond.false18, %cond.true15
  %cond23 = phi i64 [ %17, %cond.true15 ], [ %call21, %cond.false18 ]
  %conv24 = trunc i64 %cond23 to i32
  br label %if.end25

if.end25:                                         ; preds = %cond.end, %cond.end22
  %fatal.0 = phi i32 [ %conv24, %cond.end22 ], [ 0, %cond.end ]
  %sv_flags.i = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %18 = load i64* %sv_flags.i, align 8, !tbaa !7
  %and.i = and i64 %18, 118423552
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end8.i, label %if.else.i

if.else.i:                                        ; preds = %if.end25
  %and2.i = and i64 %18, 262144
  %tobool3.i = icmp eq i64 %and2.i, 0
  br i1 %tobool3.i, label %if.end8.i, label %if.else5.i

if.else5.i:                                       ; preds = %if.else.i
  %sv_any.i = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %19 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_cur.i = getelementptr inbounds i8* %19, i64 8
  %20 = bitcast i8* %xpv_cur.i to i64*
  %21 = load i64* %20, align 8, !tbaa !33
  %22 = load i64* @my_cxt.2, align 8, !tbaa !34
  %cmp.i = icmp eq i64 %21, %22
  %..i = select i1 %cmp.i, i8* null, i8* getelementptr inbounds ([11 x i8]* @.str63, i64 0, i64 0)
  br label %if.end8.i

if.end8.i:                                        ; preds = %if.else5.i, %if.else.i, %if.end25
  %err.0.i = phi i8* [ getelementptr inbounds ([10 x i8]* @.str61, i64 0, i64 0), %if.end25 ], [ getelementptr inbounds ([11 x i8]* @.str62, i64 0, i64 0), %if.else.i ], [ %..i, %if.else5.i ]
  %tobool9.i = icmp ne i8* %err.0.i, null
  %tobool10.i = icmp ne i32 %fatal.0, 0
  %or.cond.i = and i1 %tobool9.i, %tobool10.i
  br i1 %or.cond.i, label %if.then11.i, label %verify_opset.exit

if.then11.i:                                      ; preds = %if.end8.i
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([18 x i8]* @.str64, i64 0, i64 0), i8* %err.0.i) #3
  br label %verify_opset.exit

verify_opset.exit:                                ; preds = %if.end8.i, %if.then11.i
  %23 = zext i1 %tobool9.i to i64
  %lnot.ext.i = xor i64 %23, 1
  %24 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %lnot.ext.i) #3
  %sv_flags30 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %25 = load i64* %sv_flags30, align 8, !tbaa !7
  %and31 = and i64 %25, 16384
  %tobool32 = icmp eq i64 %and31, 0
  br i1 %tobool32, label %if.end35, label %if.then33

if.then33:                                        ; preds = %verify_opset.exit
  %call34 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #3
  br label %if.end35

if.end35:                                         ; preds = %verify_opset.exit, %if.then33
  %incdec.ptr36 = getelementptr inbounds %struct.sv** %24, i64 %add
  store %struct.sv* %cond, %struct.sv** %incdec.ptr36, align 8, !tbaa !1
  %26 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr38 = getelementptr inbounds %struct.sv** %26, i64 %add
  store %struct.sv** %add.ptr38, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare %struct.sv* @Perl_sv_newmortal() #1

declare i64 @Perl_sv_2iv(%struct.sv*) #1

declare void @Perl_sv_setiv(%struct.sv*, i64) #1

declare i32 @Perl_mg_set(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define void @XS_Opcode_invert_opset(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp eq i64 %sub.ptr.sub3, 8
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([35 x i8]* @.str7, i64 0, i64 0)) #3
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %6 = load i64* @my_cxt.2, align 8, !tbaa !34
  %tobool.i = icmp eq %struct.sv* %5, null
  br i1 %tobool.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.end
  %sv_flags.i.i = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %7 = load i64* %sv_flags.i.i, align 8, !tbaa !7
  %and.i.i = and i64 %7, 118423552
  %tobool.i.i = icmp eq i64 %and.i.i, 0
  br i1 %tobool.i.i, label %if.then11.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i
  %and2.i.i = and i64 %7, 262144
  %tobool3.i.i = icmp eq i64 %and2.i.i, 0
  br i1 %tobool3.i.i, label %if.then11.i.i, label %if.else5.i.i

if.else5.i.i:                                     ; preds = %if.else.i.i
  %sv_any.i.i = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %8 = load i8** %sv_any.i.i, align 8, !tbaa !9
  %xpv_cur.i.i = getelementptr inbounds i8* %8, i64 8
  %9 = bitcast i8* %xpv_cur.i.i to i64*
  %10 = load i64* %9, align 8, !tbaa !33
  %cmp.i.i = icmp eq i64 %10, %6
  br i1 %cmp.i.i, label %verify_opset.exit.i, label %if.then11.i.i

if.then11.i.i:                                    ; preds = %if.else5.i.i, %if.else.i.i, %if.then.i
  %err.0.i.ph.i = phi i8* [ getelementptr inbounds ([10 x i8]* @.str61, i64 0, i64 0), %if.then.i ], [ getelementptr inbounds ([11 x i8]* @.str62, i64 0, i64 0), %if.else.i.i ], [ getelementptr inbounds ([11 x i8]* @.str63, i64 0, i64 0), %if.else5.i.i ]
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([18 x i8]* @.str64, i64 0, i64 0), i8* %err.0.i.ph.i) #3
  br label %verify_opset.exit.i

verify_opset.exit.i:                              ; preds = %if.then11.i.i, %if.else5.i.i
  %call1.i = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %5) #3
  br label %new_opset.exit

if.else.i:                                        ; preds = %if.end
  %call2.i = tail call %struct.sv* @Perl_newSV(i64 %6) #3
  %sv_any.i = getelementptr inbounds %struct.sv* %call2.i, i64 0, i32 0
  %11 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_pv.i = bitcast i8* %11 to i8**
  %12 = load i8** %xpv_pv.i, align 8, !tbaa !10
  %13 = load i64* @my_cxt.2, align 8, !tbaa !34
  %add.i = add nsw i64 %13, 1
  tail call void @llvm.memset.p0i8.i64(i8* %12, i8 0, i64 %add.i, i32 1, i1 false) #3
  %14 = load i64* @my_cxt.2, align 8, !tbaa !34
  %15 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_cur.i = getelementptr inbounds i8* %15, i64 8
  %16 = bitcast i8* %xpv_cur.i to i64*
  store i64 %14, i64* %16, align 8, !tbaa !33
  %sv_flags.i = getelementptr inbounds %struct.sv* %call2.i, i64 0, i32 2
  %17 = load i64* %sv_flags.i, align 8, !tbaa !7
  %and.i = and i64 %17, 1223753727
  %or.i = or i64 %and.i, 67371008
  store i64 %or.i, i64* %sv_flags.i, align 8, !tbaa !7
  br label %new_opset.exit

new_opset.exit:                                   ; preds = %verify_opset.exit.i, %if.else.i
  %opset.0.i = phi %struct.sv* [ %call1.i, %verify_opset.exit.i ], [ %call2.i, %if.else.i ]
  %call6 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %opset.0.i) #3
  %sv_any = getelementptr inbounds %struct.sv* %call6, i64 0, i32 0
  %18 = load i8** %sv_any, align 8, !tbaa !9
  %xpv_pv = bitcast i8* %18 to i8**
  %19 = load i8** %xpv_pv, align 8, !tbaa !10
  %cmp736 = icmp eq i64 %6, 0
  br i1 %cmp736, label %while.end, label %while.body.preheader

while.body.preheader:                             ; preds = %new_opset.exit
  %n.vec = and i64 %6, -4
  %cmp.zero = icmp eq i64 %n.vec, 0
  %rev.ind.end = sub i64 %6, %n.vec
  br i1 %cmp.zero, label %middle.block, label %vector.body

vector.body:                                      ; preds = %while.body.preheader, %vector.body
  %index = phi i64 [ %index.next, %vector.body ], [ 0, %while.body.preheader ]
  %reverse.idx = sub i64 %6, %index
  %.sum = add i64 %reverse.idx, -4
  %20 = getelementptr i8* %19, i64 %.sum
  %21 = bitcast i8* %20 to <4 x i8>*
  %wide.load = load <4 x i8>* %21, align 1
  %reverse = shufflevector <4 x i8> %wide.load, <4 x i8> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %22 = xor <4 x i8> %reverse, <i8 -1, i8 -1, i8 -1, i8 -1>
  %reverse38 = shufflevector <4 x i8> %22, <4 x i8> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %23 = bitcast i8* %20 to <4 x i8>*
  store <4 x i8> %reverse38, <4 x i8>* %23, align 1
  %index.next = add i64 %index, 4
  %24 = icmp eq i64 %index.next, %n.vec
  br i1 %24, label %middle.block, label %vector.body, !llvm.loop !36

middle.block:                                     ; preds = %vector.body, %while.body.preheader
  %resume.val = phi i64 [ %6, %while.body.preheader ], [ %rev.ind.end, %vector.body ]
  %new.indc.resume.val = phi i64 [ 0, %while.body.preheader ], [ %n.vec, %vector.body ]
  %cmp.n = icmp eq i64 %6, %new.indc.resume.val
  br i1 %cmp.n, label %while.end, label %while.body

while.body:                                       ; preds = %middle.block, %while.body
  %dec37.in = phi i64 [ %dec37, %while.body ], [ %resume.val, %middle.block ]
  %dec37 = add i64 %dec37.in, -1
  %arrayidx8 = getelementptr inbounds i8* %19, i64 %dec37
  %25 = load i8* %arrayidx8, align 1, !tbaa !39
  %neg = xor i8 %25, -1
  store i8 %neg, i8* %arrayidx8, align 1, !tbaa !39
  %cmp7 = icmp eq i64 %dec37, 0
  br i1 %cmp7, label %while.end, label %while.body, !llvm.loop !40

while.end:                                        ; preds = %while.body, %middle.block, %new_opset.exit
  %26 = load i32* @PL_maxo, align 4, !tbaa !18
  %and = and i32 %26, 7
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end18, label %if.then11

if.then11:                                        ; preds = %while.end
  %shl = shl i32 255, %and
  %neg13 = xor i32 %shl, 255
  %27 = load i64* @my_cxt.2, align 8, !tbaa !34
  %sub = add nsw i64 %27, -1
  %arrayidx14 = getelementptr inbounds i8* %19, i64 %sub
  %28 = load i8* %arrayidx14, align 1, !tbaa !39
  %conv1533 = zext i8 %28 to i32
  %and16 = and i32 %conv1533, %neg13
  %conv17 = trunc i32 %and16 to i8
  store i8 %conv17, i8* %arrayidx14, align 1, !tbaa !39
  br label %if.end18

if.end18:                                         ; preds = %while.end, %if.then11
  %29 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx20 = getelementptr inbounds %struct.sv** %29, i64 %add
  store %struct.sv* %call6, %struct.sv** %arrayidx20, align 8, !tbaa !1
  %30 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr21 = getelementptr inbounds %struct.sv** %30, i64 %add
  store %struct.sv** %add.ptr21, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

; Function Attrs: nounwind uwtable
define void @XS_Opcode_opset_to_ops(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %sub.ptr.div4 = ashr exact i64 %sub.ptr.sub3, 3
  %sub.ptr.sub3.off = add i64 %sub.ptr.sub3, -8
  %4 = icmp ugt i64 %sub.ptr.sub3.off, 8
  br i1 %4, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([45 x i8]* @.str8, i64 0, i64 0)) #3
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %5 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %idx.neg = sub i64 0, %sub.ptr.div4
  %add.ptr6 = getelementptr inbounds %struct.sv** %0, i64 %idx.neg
  %arrayidx = getelementptr inbounds %struct.sv** %5, i64 %add
  %6 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %cmp8 = icmp slt i64 %sub.ptr.sub3, 16
  br i1 %cmp8, label %if.end16, label %if.else

if.else:                                          ; preds = %if.end
  %add10 = add nsw i64 %sub.ptr.div, 2
  %arrayidx11 = getelementptr inbounds %struct.sv** %5, i64 %add10
  %7 = load %struct.sv** %arrayidx11, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i64* %sv_flags, align 8, !tbaa !7
  %and = and i64 %8, 65536
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !9
  %xiv_iv = getelementptr inbounds i8* %9, i64 24
  %10 = bitcast i8* %xiv_iv to i64*
  %11 = load i64* %10, align 8, !tbaa !31
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %call = call i64 @Perl_sv_2iv(%struct.sv* %7) #3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %11, %cond.true ], [ %call, %cond.false ]
  %conv = trunc i64 %cond to i32
  br label %if.end16

if.end16:                                         ; preds = %if.end, %cond.end
  %desc.0 = phi i32 [ %conv, %cond.end ], [ 0, %if.end ]
  %sv_flags17 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %12 = load i64* %sv_flags17, align 8, !tbaa !7
  %and18 = and i64 %12, 262144
  %cmp19 = icmp eq i64 %and18, 0
  br i1 %cmp19, label %cond.false24, label %cond.true21

cond.true21:                                      ; preds = %if.end16
  %sv_any22 = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %13 = load i8** %sv_any22, align 8, !tbaa !9
  %xpv_cur = getelementptr inbounds i8* %13, i64 8
  %14 = bitcast i8* %xpv_cur to i64*
  %15 = load i64* %14, align 8, !tbaa !33
  store i64 %15, i64* %len, align 8, !tbaa !5
  %xpv_pv = bitcast i8* %13 to i8**
  %16 = load i8** %xpv_pv, align 8, !tbaa !10
  br label %cond.end26

cond.false24:                                     ; preds = %if.end16
  %call25 = call i8* @Perl_sv_2pv_flags(%struct.sv* %6, i64* %len, i64 2) #3
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false24, %cond.true21
  %cond27 = phi i8* [ %16, %cond.true21 ], [ %call25, %cond.false24 ]
  %tobool28 = icmp eq i32 %desc.0, 0
  br i1 %tobool28, label %cond.false31, label %cond.true29

cond.true29:                                      ; preds = %cond.end26
  %call30 = call i8** @Perl_get_op_descs() #3
  br label %cond.end33

cond.false31:                                     ; preds = %cond.end26
  %call32 = call i8** @Perl_get_op_names() #3
  br label %cond.end33

cond.end33:                                       ; preds = %cond.false31, %cond.true29
  %cond34 = phi i8** [ %call30, %cond.true29 ], [ %call32, %cond.false31 ]
  %17 = load i64* %sv_flags17, align 8, !tbaa !7
  %and.i = and i64 %17, 118423552
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.then11.i, label %if.else.i

if.else.i:                                        ; preds = %cond.end33
  %and2.i = and i64 %17, 262144
  %tobool3.i = icmp eq i64 %and2.i, 0
  br i1 %tobool3.i, label %if.then11.i, label %if.else5.i

if.else5.i:                                       ; preds = %if.else.i
  %sv_any.i = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %18 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_cur.i = getelementptr inbounds i8* %18, i64 8
  %19 = bitcast i8* %xpv_cur.i to i64*
  %20 = load i64* %19, align 8, !tbaa !33
  %21 = load i64* @my_cxt.2, align 8, !tbaa !34
  %cmp.i = icmp eq i64 %20, %21
  br i1 %cmp.i, label %for.cond.preheader, label %if.then11.i

if.then11.i:                                      ; preds = %cond.end33, %if.else.i, %if.else5.i
  %err.0.i.ph = phi i8* [ getelementptr inbounds ([10 x i8]* @.str61, i64 0, i64 0), %cond.end33 ], [ getelementptr inbounds ([11 x i8]* @.str62, i64 0, i64 0), %if.else.i ], [ getelementptr inbounds ([11 x i8]* @.str63, i64 0, i64 0), %if.else5.i ]
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([18 x i8]* @.str64, i64 0, i64 0), i8* %err.0.i.ph) #3
  %.pre109 = load i64* @my_cxt.2, align 8, !tbaa !34
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.else5.i, %if.then11.i
  %22 = phi i64 [ %20, %if.else5.i ], [ %.pre109, %if.then11.i ]
  %cmp37101 = icmp sgt i64 %22, 0
  br i1 %cmp37101, label %for.body.lr.ph, label %for.end69

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %.pre110 = load i32* @PL_maxo, align 4
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc67
  %23 = phi i32 [ %.pre110, %for.body.lr.ph ], [ %31, %for.inc67 ]
  %indvars.iv107 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next108, %for.inc67 ]
  %sp.0104 = phi %struct.sv** [ %add.ptr6, %for.body.lr.ph ], [ %sp.1.lcssa, %for.inc67 ]
  %myopcode.0102 = phi i32 [ 0, %for.body.lr.ph ], [ %myopcode.1.lcssa, %for.inc67 ]
  %cmp4495 = icmp slt i32 %myopcode.0102, %23
  br i1 %cmp4495, label %for.body46.lr.ph, label %for.inc67

for.body46.lr.ph:                                 ; preds = %for.body
  %arrayidx39 = getelementptr inbounds i8* %cond27, i64 %indvars.iv107
  %24 = load i8* %arrayidx39, align 1, !tbaa !39
  %conv40 = sext i8 %24 to i32
  %conv47 = and i32 %conv40, 65535
  %25 = sext i32 %myopcode.0102 to i64
  br label %for.body46

for.body46:                                       ; preds = %for.body46.lr.ph, %for.inc
  %26 = phi i32 [ %23, %for.body46.lr.ph ], [ %29, %for.inc ]
  %indvars.iv = phi i64 [ %25, %for.body46.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %sp.199 = phi %struct.sv** [ %sp.0104, %for.body46.lr.ph ], [ %sp.3, %for.inc ]
  %j.098 = phi i32 [ 0, %for.body46.lr.ph ], [ %inc, %for.inc ]
  %shl = shl i32 1, %j.098
  %and48 = and i32 %conv47, %shl
  %tobool49 = icmp eq i32 %and48, 0
  br i1 %tobool49, label %for.inc, label %if.then50

if.then50:                                        ; preds = %for.body46
  %27 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !1
  %sub.ptr.lhs.cast51 = ptrtoint %struct.sv** %27 to i64
  %sub.ptr.rhs.cast52 = ptrtoint %struct.sv** %sp.199 to i64
  %sub.ptr.sub53 = sub i64 %sub.ptr.lhs.cast51, %sub.ptr.rhs.cast52
  %cmp55 = icmp slt i64 %sub.ptr.sub53, 8
  br i1 %cmp55, label %if.then57, label %if.end59

if.then57:                                        ; preds = %if.then50
  %call58 = call %struct.sv** @Perl_stack_grow(%struct.sv** %sp.199, %struct.sv** %sp.199, i32 1) #3
  br label %if.end59

if.end59:                                         ; preds = %if.then57, %if.then50
  %sp.2 = phi %struct.sv** [ %call58, %if.then57 ], [ %sp.199, %if.then50 ]
  %arrayidx61 = getelementptr inbounds i8** %cond34, i64 %indvars.iv
  %28 = load i8** %arrayidx61, align 8, !tbaa !1
  %call62 = call %struct.sv* @Perl_newSVpv(i8* %28, i64 0) #3
  %call63 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call62) #3
  %incdec.ptr64 = getelementptr inbounds %struct.sv** %sp.2, i64 1
  store %struct.sv* %call63, %struct.sv** %incdec.ptr64, align 8, !tbaa !1
  %.pre111 = load i32* @PL_maxo, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body46, %if.end59
  %29 = phi i32 [ %.pre111, %if.end59 ], [ %26, %for.body46 ]
  %sp.3 = phi %struct.sv** [ %incdec.ptr64, %if.end59 ], [ %sp.199, %for.body46 ]
  %inc = add nsw i32 %j.098, 1
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %cmp42 = icmp slt i32 %inc, 8
  %30 = trunc i64 %indvars.iv.next to i32
  %cmp44 = icmp slt i32 %30, %29
  %or.cond = and i1 %cmp42, %cmp44
  br i1 %or.cond, label %for.body46, label %for.inc67

for.inc67:                                        ; preds = %for.inc, %for.body
  %31 = phi i32 [ %23, %for.body ], [ %29, %for.inc ]
  %sp.1.lcssa = phi %struct.sv** [ %sp.0104, %for.body ], [ %sp.3, %for.inc ]
  %myopcode.1.lcssa = phi i32 [ %myopcode.0102, %for.body ], [ %30, %for.inc ]
  %indvars.iv.next108 = add nuw nsw i64 %indvars.iv107, 1
  %32 = load i64* @my_cxt.2, align 8, !tbaa !34
  %cmp37 = icmp slt i64 %indvars.iv.next108, %32
  br i1 %cmp37, label %for.body, label %for.end69

for.end69:                                        ; preds = %for.inc67, %for.cond.preheader
  %sp.0.lcssa = phi %struct.sv** [ %add.ptr6, %for.cond.preheader ], [ %sp.1.lcssa, %for.inc67 ]
  store %struct.sv** %sp.0.lcssa, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare i8* @Perl_sv_2pv_flags(%struct.sv*, i64*, i64) #1

declare i8** @Perl_get_op_descs() #1

declare i8** @Perl_get_op_names() #1

declare %struct.sv** @Perl_stack_grow(%struct.sv**, %struct.sv**, i32) #1

declare %struct.sv* @Perl_newSVpv(i8*, i64) #1

; Function Attrs: nounwind uwtable
define void @XS_Opcode_opset(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %sub.ptr.div4 = ashr exact i64 %sub.ptr.sub3, 3
  %4 = load i64* @my_cxt.2, align 8, !tbaa !34
  %call2.i = call %struct.sv* @Perl_newSV(i64 %4) #3
  %sv_any.i = getelementptr inbounds %struct.sv* %call2.i, i64 0, i32 0
  %5 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_pv.i = bitcast i8* %5 to i8**
  %6 = load i8** %xpv_pv.i, align 8, !tbaa !10
  %7 = load i64* @my_cxt.2, align 8, !tbaa !34
  %add.i = add nsw i64 %7, 1
  call void @llvm.memset.p0i8.i64(i8* %6, i8 0, i64 %add.i, i32 1, i1 false) #3
  %8 = load i64* @my_cxt.2, align 8, !tbaa !34
  %9 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_cur.i = getelementptr inbounds i8* %9, i64 8
  %10 = bitcast i8* %xpv_cur.i to i64*
  store i64 %8, i64* %10, align 8, !tbaa !33
  %sv_flags.i = getelementptr inbounds %struct.sv* %call2.i, i64 0, i32 2
  %11 = load i64* %sv_flags.i, align 8, !tbaa !7
  %and.i = and i64 %11, 1223753727
  %or.i = or i64 %and.i, 67371008
  store i64 %or.i, i64* %sv_flags.i, align 8, !tbaa !7
  %call5 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call2.i) #3
  %sv_any = getelementptr inbounds %struct.sv* %call5, i64 0, i32 0
  %12 = load i8** %sv_any, align 8, !tbaa !9
  %xpv_pv = bitcast i8* %12 to i8**
  %13 = load i8** %xpv_pv, align 8, !tbaa !10
  %cmp64 = icmp sgt i64 %sub.ptr.sub3, 0
  br i1 %cmp64, label %for.body, label %for.end

for.body:                                         ; preds = %entry, %if.end37
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end37 ], [ 0, %entry ]
  %add8 = add nsw i64 %indvars.iv, %add
  %14 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.sv** %14, i64 %add8
  %15 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %sv_flags.i60 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %16 = load i64* %sv_flags.i60, align 8, !tbaa !7
  %and2.i = and i64 %16, 262144
  %tobool3.i = icmp eq i64 %and2.i, 0
  br i1 %tobool3.i, label %if.else, label %if.else5.i

if.else5.i:                                       ; preds = %for.body
  %sv_any.i62 = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %17 = load i8** %sv_any.i62, align 8, !tbaa !9
  %xpv_cur.i63 = getelementptr inbounds i8* %17, i64 8
  %18 = bitcast i8* %xpv_cur.i63 to i64*
  %19 = load i64* %18, align 8, !tbaa !33
  %20 = load i64* @my_cxt.2, align 8, !tbaa !34
  %cmp.i = icmp eq i64 %19, %20
  br i1 %cmp.i, label %if.end37, label %if.else

if.else:                                          ; preds = %for.body, %if.else5.i
  %and = and i64 %16, 262144
  %cmp16 = icmp eq i64 %and, 0
  br i1 %cmp16, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %sv_any21 = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %21 = load i8** %sv_any21, align 8, !tbaa !9
  %xpv_cur = getelementptr inbounds i8* %21, i64 8
  %22 = bitcast i8* %xpv_cur to i64*
  %23 = load i64* %22, align 8, !tbaa !33
  store i64 %23, i64* %len, align 8, !tbaa !5
  %xpv_pv26 = bitcast i8* %21 to i8**
  %24 = load i8** %xpv_pv26, align 8, !tbaa !10
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %call30 = call i8* @Perl_sv_2pv_flags(%struct.sv* %15, i64* %len, i64 2) #3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %24, %cond.true ], [ %call30, %cond.false ]
  %25 = load i8* %cond, align 1, !tbaa !39
  %cmp32 = icmp eq i8 %25, 33
  br i1 %cmp32, label %if.then34, label %cond.end.if.end_crit_edge

cond.end.if.end_crit_edge:                        ; preds = %cond.end
  %.pre = load i64* %len, align 8, !tbaa !5
  br label %if.end

if.then34:                                        ; preds = %cond.end
  %incdec.ptr35 = getelementptr inbounds i8* %cond, i64 1
  %26 = load i64* %len, align 8, !tbaa !5
  %dec = add i64 %26, -1
  store i64 %dec, i64* %len, align 8, !tbaa !5
  br label %if.end

if.end:                                           ; preds = %cond.end.if.end_crit_edge, %if.then34
  %27 = phi i64 [ %dec, %if.then34 ], [ %.pre, %cond.end.if.end_crit_edge ]
  %on.0 = phi i32 [ 0, %if.then34 ], [ 1, %cond.end.if.end_crit_edge ]
  %opname.0 = phi i8* [ %incdec.ptr35, %if.then34 ], [ %cond, %cond.end.if.end_crit_edge ]
  %call36 = call fastcc %struct.sv* @get_op_bitspec(i8* %opname.0, i64 %27)
  br label %if.end37

if.end37:                                         ; preds = %if.else5.i, %if.end
  %bitspec.0 = phi %struct.sv* [ %call36, %if.end ], [ %15, %if.else5.i ]
  %on.1 = phi i32 [ %on.0, %if.end ], [ 1, %if.else5.i ]
  %opname.1 = phi i8* [ %opname.0, %if.end ], [ getelementptr inbounds ([8 x i8]* @.str9, i64 0, i64 0), %if.else5.i ]
  call fastcc void @set_opset_bits(i8* %13, %struct.sv* %bitspec.0, i32 %on.1, i8* %opname.1)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cmp = icmp slt i64 %indvars.iv.next, %sub.ptr.div4
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %if.end37, %entry
  %28 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx40 = getelementptr inbounds %struct.sv** %28, i64 %add
  store %struct.sv* %call5, %struct.sv** %arrayidx40, align 8, !tbaa !1
  %29 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr41 = getelementptr inbounds %struct.sv** %29, i64 %add
  store %struct.sv** %add.ptr41, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.sv* @get_op_bitspec(i8* %opname, i64 %len) #0 {
entry:
  %tobool = icmp eq i64 %len, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call i64 @strlen(i8* %opname) #3
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %len.addr.0 = phi i64 [ %len, %entry ], [ %call, %if.then ]
  %0 = load %struct.hv** @my_cxt.0, align 8, !tbaa !41
  %call1 = tail call %struct.sv** @Perl_hv_fetch(%struct.hv* %0, i8* %opname, i64 %len.addr.0, i64 0) #3
  %tobool2 = icmp eq %struct.sv** %call1, null
  br i1 %tobool2, label %if.end7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %1 = load %struct.sv** %call1, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i64* %sv_flags, align 8, !tbaa !7
  %and = and i64 %2, 118423552
  %tobool3 = icmp eq i64 %and, 0
  br i1 %tobool3, label %if.end7, label %return

if.end7:                                          ; preds = %if.end, %lor.lhs.false
  %3 = load i8* %opname, align 1, !tbaa !39
  %cmp = icmp eq i8 %3, 58
  br i1 %cmp, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([26 x i8]* @.str57, i64 0, i64 0), i8* %opname) #3
  %.pr = load i8* %opname, align 1, !tbaa !39
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end7
  %4 = phi i8 [ %.pr, %if.then9 ], [ %3, %if.end7 ]
  %cmp12 = icmp eq i8 %4, 33
  br i1 %cmp12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end10
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([35 x i8]* @.str58, i64 0, i64 0), i8* %opname) #3
  %.pre = load i8* %opname, align 1, !tbaa !39
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end10
  %5 = phi i8 [ %.pre, %if.then14 ], [ %4, %if.end10 ]
  %.off = add i8 %5, -65
  %6 = icmp ult i8 %.off, 26
  %.off2 = add i8 %5, -97
  %7 = icmp ult i8 %.off2, 26
  %or.cond = or i1 %6, %7
  br i1 %or.cond, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end15
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([27 x i8]* @.str59, i64 0, i64 0), i8* %opname) #3
  br label %if.end31

if.end31:                                         ; preds = %if.end15, %if.then30
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([29 x i8]* @.str60, i64 0, i64 0), i8* %opname) #3
  %.pre4 = load %struct.sv** %call1, align 8, !tbaa !1
  br label %return

return:                                           ; preds = %if.end31, %lor.lhs.false
  %8 = phi %struct.sv* [ %.pre4, %if.end31 ], [ %1, %lor.lhs.false ]
  ret %struct.sv* %8
}

; Function Attrs: nounwind uwtable
define internal fastcc void @set_opset_bits(i8* nocapture %bitmap, %struct.sv* %bitspec, i32 %on, i8* %opname) #0 {
entry:
  %sv_flags = getelementptr inbounds %struct.sv* %bitspec, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !7
  %and = and i64 %0, 65536
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.else26, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %bitspec, i64 0, i32 0
  %1 = load i8** %sv_any, align 8, !tbaa !9
  %xiv_iv = getelementptr inbounds i8* %1, i64 24
  %2 = bitcast i8* %xiv_iv to i64*
  %3 = load i64* %2, align 8, !tbaa !31
  %conv = trunc i64 %3 to i32
  %shr = ashr i32 %conv, 3
  %and4 = and i32 %conv, 7
  %4 = load i32* @PL_maxo, align 4, !tbaa !18
  %cmp = icmp sge i32 %conv, %4
  %cmp6 = icmp slt i32 %conv, 0
  %or.cond = or i1 %cmp, %cmp6
  br i1 %or.cond, label %if.then8, label %if.end14

if.then8:                                         ; preds = %cond.true
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([39 x i8]* @.str52, i64 0, i64 0), i8* %opname, i32 %conv) #3
  br label %if.end14

if.end14:                                         ; preds = %if.then8, %cond.true
  %tobool15 = icmp eq i32 %on, 0
  %shl = shl i32 1, %and4
  br i1 %tobool15, label %if.else, label %if.then16

if.then16:                                        ; preds = %if.end14
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds i8* %bitmap, i64 %idxprom
  %5 = load i8* %arrayidx, align 1, !tbaa !39
  %conv17112 = zext i8 %5 to i32
  %or = or i32 %conv17112, %shl
  %conv18 = trunc i32 %or to i8
  store i8 %conv18, i8* %arrayidx, align 1, !tbaa !39
  br label %if.end82

if.else:                                          ; preds = %if.end14
  %neg = xor i32 %shl, 255
  %idxprom20 = sext i32 %shr to i64
  %arrayidx21 = getelementptr inbounds i8* %bitmap, i64 %idxprom20
  %6 = load i8* %arrayidx21, align 1, !tbaa !39
  %conv22111 = zext i8 %6 to i32
  %and23 = and i32 %conv22111, %neg
  %conv24 = trunc i32 %and23 to i8
  store i8 %conv24, i8* %arrayidx21, align 1, !tbaa !39
  br label %if.end82

if.else26:                                        ; preds = %entry
  %and28 = and i64 %0, 262144
  %tobool29 = icmp eq i64 %and28, 0
  br i1 %tobool29, label %if.else77, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else26
  %sv_any30 = getelementptr inbounds %struct.sv* %bitspec, i64 0, i32 0
  %7 = load i8** %sv_any30, align 8, !tbaa !9
  %xpv_cur = getelementptr inbounds i8* %7, i64 8
  %8 = bitcast i8* %xpv_cur to i64*
  %9 = load i64* %8, align 8, !tbaa !33
  %10 = load i64* @my_cxt.2, align 8, !tbaa !34
  %cmp31 = icmp eq i64 %9, %10
  br i1 %cmp31, label %if.end51, label %if.else77

if.end51:                                         ; preds = %land.lhs.true
  %xpv_pv = bitcast i8* %7 to i8**
  %11 = load i8** %xpv_pv, align 8, !tbaa !10
  %tobool52 = icmp eq i32 %on, 0
  %dec64115 = add i64 %9, -1
  %cmp65116 = icmp eq i64 %9, 0
  br i1 %tobool52, label %while.cond63.preheader, label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.end51
  br i1 %cmp65116, label %if.end82, label %while.body.preheader

while.body.preheader:                             ; preds = %while.cond.preheader
  %n.vec = and i64 %9, -4
  %cmp.zero = icmp eq i64 %n.vec, 0
  %12 = add i64 %9, -1
  br i1 %cmp.zero, label %middle.block, label %vector.memcheck

vector.memcheck:                                  ; preds = %while.body.preheader
  %scevgep125 = getelementptr i8* %11, i64 %12
  %scevgep = getelementptr i8* %bitmap, i64 %12
  %bound1 = icmp ule i8* %scevgep125, %bitmap
  %bound0 = icmp ule i8* %scevgep, %11
  %memcheck.conflict = and i1 %bound0, %bound1
  %rev.ind.end = sub i64 %dec64115, %n.vec
  br i1 %memcheck.conflict, label %middle.block, label %vector.body

vector.body:                                      ; preds = %vector.memcheck, %vector.body
  %index = phi i64 [ %index.next, %vector.body ], [ 0, %vector.memcheck ]
  %reverse.idx = sub i64 %dec64115, %index
  %.sum = add i64 %reverse.idx, -3
  %13 = getelementptr i8* %11, i64 %.sum
  %14 = bitcast i8* %13 to <4 x i8>*
  %wide.load = load <4 x i8>* %14, align 1
  %reverse = shufflevector <4 x i8> %wide.load, <4 x i8> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %.sum161 = add i64 %reverse.idx, -3
  %15 = getelementptr i8* %bitmap, i64 %.sum161
  %16 = bitcast i8* %15 to <4 x i8>*
  %wide.load126 = load <4 x i8>* %16, align 1
  %reverse127 = shufflevector <4 x i8> %wide.load126, <4 x i8> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %17 = or <4 x i8> %reverse127, %reverse
  %reverse128 = shufflevector <4 x i8> %17, <4 x i8> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %18 = bitcast i8* %15 to <4 x i8>*
  store <4 x i8> %reverse128, <4 x i8>* %18, align 1
  %index.next = add i64 %index, 4
  %19 = icmp eq i64 %index.next, %n.vec
  br i1 %19, label %middle.block, label %vector.body, !llvm.loop !42

middle.block:                                     ; preds = %vector.body, %vector.memcheck, %while.body.preheader
  %resume.val = phi i64 [ %dec64115, %while.body.preheader ], [ %dec64115, %vector.memcheck ], [ %rev.ind.end, %vector.body ]
  %new.indc.resume.val = phi i64 [ 0, %while.body.preheader ], [ 0, %vector.memcheck ], [ %n.vec, %vector.body ]
  %cmp.n = icmp eq i64 %9, %new.indc.resume.val
  br i1 %cmp.n, label %if.end82, label %while.body

while.cond63.preheader:                           ; preds = %if.end51
  br i1 %cmp65116, label %if.end82, label %while.body67.preheader

while.body67.preheader:                           ; preds = %while.cond63.preheader
  %n.vec136 = and i64 %9, -4
  %cmp.zero138 = icmp eq i64 %n.vec136, 0
  %20 = add i64 %9, -1
  br i1 %cmp.zero138, label %middle.block131, label %vector.memcheck145

vector.memcheck145:                               ; preds = %while.body67.preheader
  %scevgep140 = getelementptr i8* %11, i64 %20
  %scevgep139 = getelementptr i8* %bitmap, i64 %20
  %bound1142 = icmp ule i8* %scevgep140, %bitmap
  %bound0141 = icmp ule i8* %scevgep139, %11
  %memcheck.conflict144 = and i1 %bound0141, %bound1142
  %rev.ind.end147 = sub i64 %dec64115, %n.vec136
  br i1 %memcheck.conflict144, label %middle.block131, label %vector.body130

vector.body130:                                   ; preds = %vector.memcheck145, %vector.body130
  %index133 = phi i64 [ %index.next150, %vector.body130 ], [ 0, %vector.memcheck145 ]
  %reverse.idx152 = sub i64 %dec64115, %index133
  %.sum162 = add i64 %reverse.idx152, -3
  %21 = getelementptr i8* %11, i64 %.sum162
  %22 = bitcast i8* %21 to <4 x i8>*
  %wide.load156 = load <4 x i8>* %22, align 1
  %reverse157 = shufflevector <4 x i8> %wide.load156, <4 x i8> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %23 = xor <4 x i8> %reverse157, <i8 -1, i8 -1, i8 -1, i8 -1>
  %.sum163 = add i64 %reverse.idx152, -3
  %24 = getelementptr i8* %bitmap, i64 %.sum163
  %25 = bitcast i8* %24 to <4 x i8>*
  %wide.load158 = load <4 x i8>* %25, align 1
  %reverse159 = shufflevector <4 x i8> %wide.load158, <4 x i8> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %26 = and <4 x i8> %reverse159, %23
  %reverse160 = shufflevector <4 x i8> %26, <4 x i8> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %27 = bitcast i8* %24 to <4 x i8>*
  store <4 x i8> %reverse160, <4 x i8>* %27, align 1
  %index.next150 = add i64 %index133, 4
  %28 = icmp eq i64 %index.next150, %n.vec136
  br i1 %28, label %middle.block131, label %vector.body130, !llvm.loop !43

middle.block131:                                  ; preds = %vector.body130, %vector.memcheck145, %while.body67.preheader
  %resume.val146 = phi i64 [ %dec64115, %while.body67.preheader ], [ %dec64115, %vector.memcheck145 ], [ %rev.ind.end147, %vector.body130 ]
  %new.indc.resume.val148 = phi i64 [ 0, %while.body67.preheader ], [ 0, %vector.memcheck145 ], [ %n.vec136, %vector.body130 ]
  %cmp.n149 = icmp eq i64 %9, %new.indc.resume.val148
  br i1 %cmp.n149, label %if.end82, label %while.body67

while.body:                                       ; preds = %middle.block, %while.body
  %.pr123 = phi i64 [ %dec, %while.body ], [ %resume.val, %middle.block ]
  %arrayidx56 = getelementptr inbounds i8* %11, i64 %.pr123
  %29 = load i8* %arrayidx56, align 1, !tbaa !39
  %arrayidx58 = getelementptr inbounds i8* %bitmap, i64 %.pr123
  %30 = load i8* %arrayidx58, align 1, !tbaa !39
  %or60110 = or i8 %30, %29
  store i8 %or60110, i8* %arrayidx58, align 1, !tbaa !39
  %dec = add i64 %.pr123, -1
  %cmp54 = icmp eq i64 %.pr123, 0
  br i1 %cmp54, label %if.end82, label %while.body, !llvm.loop !44

while.body67:                                     ; preds = %middle.block131, %while.body67
  %.pr113118 = phi i64 [ %dec64, %while.body67 ], [ %resume.val146, %middle.block131 ]
  %arrayidx68 = getelementptr inbounds i8* %11, i64 %.pr113118
  %31 = load i8* %arrayidx68, align 1, !tbaa !39
  %neg70 = xor i8 %31, -1
  %arrayidx71 = getelementptr inbounds i8* %bitmap, i64 %.pr113118
  %32 = load i8* %arrayidx71, align 1, !tbaa !39
  %and73 = and i8 %32, %neg70
  store i8 %and73, i8* %arrayidx71, align 1, !tbaa !39
  %dec64 = add i64 %.pr113118, -1
  %cmp65 = icmp eq i64 %.pr113118, 0
  br i1 %cmp65, label %if.end82, label %while.body67, !llvm.loop !45

if.else77:                                        ; preds = %if.else26, %land.lhs.true
  %.tr = trunc i64 %0 to i32
  %conv80 = and i32 %.tr, 255
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([42 x i8]* @.str14, i64 0, i64 0), i8* %opname, i32 %conv80) #3
  br label %if.end82

if.end82:                                         ; preds = %while.body, %middle.block, %while.body67, %middle.block131, %while.cond.preheader, %while.cond63.preheader, %if.else77, %if.then16, %if.else
  ret void
}

; Function Attrs: nounwind uwtable
define void @XS_Opcode_permit_only(%struct.cv* nocapture readonly %cv) #0 {
entry:
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %sub.ptr.div4 = ashr exact i64 %sub.ptr.sub3, 3
  %sv_any = getelementptr inbounds %struct.cv* %cv, i64 0, i32 0
  %4 = load %struct.xpvcv** %sv_any, align 8, !tbaa !46
  %xcv_xsubany = getelementptr inbounds %struct.xpvcv* %4, i64 0, i32 11
  %any_i32 = bitcast %union.any* %xcv_xsubany to i64*
  %5 = load i64* %any_i32, align 8, !tbaa !5
  %cmp = icmp slt i64 %sub.ptr.sub3, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %4, i64 0, i32 12
  %6 = load %struct.gv** %xcv_gv, align 8, !tbaa !48
  %sv_any6 = getelementptr inbounds %struct.gv* %6, i64 0, i32 0
  %7 = load %struct.xpvgv** %sv_any6, align 8, !tbaa !20
  %xgv_name = getelementptr inbounds %struct.xpvgv* %7, i64 0, i32 8
  %8 = load i8** %xgv_name, align 8, !tbaa !50
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([21 x i8]* @.str10, i64 0, i64 0), i8* %8) #3
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = phi %struct.sv** [ %.pre, %if.then ], [ %1, %entry ]
  %arrayidx = getelementptr inbounds %struct.sv** %9, i64 %add
  %10 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %10, i64 0, i32 2
  %11 = load i64* %sv_flags, align 8, !tbaa !7
  %and = and i64 %11, 524288
  %tobool = icmp eq i64 %and, 0
  %sv_any20.phi.trans.insert.pre = getelementptr inbounds %struct.sv* %10, i64 0, i32 0
  br i1 %tobool, label %if.then18, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %12 = load i8** %sv_any20.phi.trans.insert.pre, align 8, !tbaa !9
  %xrv_rv = bitcast i8* %12 to %struct.sv**
  %13 = load %struct.sv** %xrv_rv, align 8, !tbaa !51
  %sv_flags9 = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %14 = load i64* %sv_flags9, align 8, !tbaa !7
  %15 = and i64 %14, 4351
  %16 = icmp eq i64 %15, 4107
  br i1 %16, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end, %lor.lhs.false
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([18 x i8]* @.str11, i64 0, i64 0)) #3
  %.pre147 = load i8** %sv_any20.phi.trans.insert.pre, align 8, !tbaa !9
  %xrv_rv21.phi.trans.insert = bitcast i8* %.pre147 to %struct.sv**
  %.pre148 = load %struct.sv** %xrv_rv21.phi.trans.insert, align 8, !tbaa !51
  br label %if.end19

if.end19:                                         ; preds = %lor.lhs.false, %if.then18
  %17 = phi %struct.sv* [ %13, %lor.lhs.false ], [ %.pre148, %if.then18 ]
  %18 = bitcast %struct.sv* %17 to %struct.hv*
  %call = call %struct.sv** @Perl_hv_fetch(%struct.hv* %18, i8* getelementptr inbounds ([5 x i8]* @.str12, i64 0, i64 0), i64 4, i64 1) #3
  %19 = load %struct.sv** %call, align 8, !tbaa !1
  %20 = and i64 %5, -3
  %21 = icmp eq i64 %20, 0
  br i1 %21, label %if.then25, label %if.else

if.then25:                                        ; preds = %if.end19
  %22 = icmp ult i64 %5, 2
  %23 = load %struct.sv** @my_cxt.1, align 8, !tbaa !53
  %cond = select i1 %22, %struct.sv* %23, %struct.sv* null
  %tobool.i = icmp eq %struct.sv* %cond, null
  br i1 %tobool.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.then25
  %sv_flags.i.i = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %24 = load i64* %sv_flags.i.i, align 8, !tbaa !7
  %and.i.i = and i64 %24, 118423552
  %tobool.i.i = icmp eq i64 %and.i.i, 0
  br i1 %tobool.i.i, label %if.then11.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i
  %and2.i.i = and i64 %24, 262144
  %tobool3.i.i = icmp eq i64 %and2.i.i, 0
  br i1 %tobool3.i.i, label %if.then11.i.i, label %if.else5.i.i

if.else5.i.i:                                     ; preds = %if.else.i.i
  %sv_any.i.i = getelementptr inbounds %struct.sv* %cond, i64 0, i32 0
  %25 = load i8** %sv_any.i.i, align 8, !tbaa !9
  %xpv_cur.i.i = getelementptr inbounds i8* %25, i64 8
  %26 = bitcast i8* %xpv_cur.i.i to i64*
  %27 = load i64* %26, align 8, !tbaa !33
  %28 = load i64* @my_cxt.2, align 8, !tbaa !34
  %cmp.i.i = icmp eq i64 %27, %28
  br i1 %cmp.i.i, label %verify_opset.exit.i, label %if.then11.i.i

if.then11.i.i:                                    ; preds = %if.else5.i.i, %if.else.i.i, %if.then.i
  %err.0.i.ph.i = phi i8* [ getelementptr inbounds ([10 x i8]* @.str61, i64 0, i64 0), %if.then.i ], [ getelementptr inbounds ([11 x i8]* @.str62, i64 0, i64 0), %if.else.i.i ], [ getelementptr inbounds ([11 x i8]* @.str63, i64 0, i64 0), %if.else5.i.i ]
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([18 x i8]* @.str64, i64 0, i64 0), i8* %err.0.i.ph.i) #3
  br label %verify_opset.exit.i

verify_opset.exit.i:                              ; preds = %if.then11.i.i, %if.else5.i.i
  %call1.i = call %struct.sv* @Perl_newSVsv(%struct.sv* %cond) #3
  br label %new_opset.exit

if.else.i:                                        ; preds = %if.then25
  %29 = load i64* @my_cxt.2, align 8, !tbaa !34
  %call2.i = call %struct.sv* @Perl_newSV(i64 %29) #3
  %sv_any.i = getelementptr inbounds %struct.sv* %call2.i, i64 0, i32 0
  %30 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_pv.i = bitcast i8* %30 to i8**
  %31 = load i8** %xpv_pv.i, align 8, !tbaa !10
  %32 = load i64* @my_cxt.2, align 8, !tbaa !34
  %add.i = add nsw i64 %32, 1
  call void @llvm.memset.p0i8.i64(i8* %31, i8 0, i64 %add.i, i32 1, i1 false) #3
  %33 = load i64* @my_cxt.2, align 8, !tbaa !34
  %34 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_cur.i = getelementptr inbounds i8* %34, i64 8
  %35 = bitcast i8* %xpv_cur.i to i64*
  store i64 %33, i64* %35, align 8, !tbaa !33
  %sv_flags.i = getelementptr inbounds %struct.sv* %call2.i, i64 0, i32 2
  %36 = load i64* %sv_flags.i, align 8, !tbaa !7
  %and.i = and i64 %36, 1223753727
  %or.i = or i64 %and.i, 67371008
  store i64 %or.i, i64* %sv_flags.i, align 8, !tbaa !7
  br label %new_opset.exit

new_opset.exit:                                   ; preds = %verify_opset.exit.i, %if.else.i
  %opset.0.i = phi %struct.sv* [ %call1.i, %verify_opset.exit.i ], [ %call2.i, %if.else.i ]
  %call30 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %opset.0.i) #3
  call void @Perl_sv_setsv_flags(%struct.sv* %19, %struct.sv* %call30, i64 2) #3
  br label %if.end32

if.else:                                          ; preds = %if.end19
  %sv_flags.i118 = getelementptr inbounds %struct.sv* %19, i64 0, i32 2
  %37 = load i64* %sv_flags.i118, align 8, !tbaa !7
  %and.i119 = and i64 %37, 118423552
  %tobool.i120 = icmp eq i64 %and.i119, 0
  br i1 %tobool.i120, label %if.then11.i, label %if.else.i121

if.else.i121:                                     ; preds = %if.else
  %and2.i = and i64 %37, 262144
  %tobool3.i = icmp eq i64 %and2.i, 0
  br i1 %tobool3.i, label %if.then11.i, label %if.else5.i

if.else5.i:                                       ; preds = %if.else.i121
  %sv_any.i122 = getelementptr inbounds %struct.sv* %19, i64 0, i32 0
  %38 = load i8** %sv_any.i122, align 8, !tbaa !9
  %xpv_cur.i123 = getelementptr inbounds i8* %38, i64 8
  %39 = bitcast i8* %xpv_cur.i123 to i64*
  %40 = load i64* %39, align 8, !tbaa !33
  %41 = load i64* @my_cxt.2, align 8, !tbaa !34
  %cmp.i = icmp eq i64 %40, %41
  br i1 %cmp.i, label %if.end32, label %if.then11.i

if.then11.i:                                      ; preds = %if.else, %if.else.i121, %if.else5.i
  %err.0.i.ph = phi i8* [ getelementptr inbounds ([10 x i8]* @.str61, i64 0, i64 0), %if.else ], [ getelementptr inbounds ([11 x i8]* @.str62, i64 0, i64 0), %if.else.i121 ], [ getelementptr inbounds ([11 x i8]* @.str63, i64 0, i64 0), %if.else5.i ]
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([18 x i8]* @.str64, i64 0, i64 0), i8* %err.0.i.ph) #3
  br label %if.end32

if.end32:                                         ; preds = %if.then11.i, %if.else5.i, %new_opset.exit
  %sv_any33 = getelementptr inbounds %struct.sv* %19, i64 0, i32 0
  %42 = load i8** %sv_any33, align 8, !tbaa !9
  %xpv_pv = bitcast i8* %42 to i8**
  %43 = load i8** %xpv_pv, align 8, !tbaa !10
  %cmp34144 = icmp sgt i64 %sub.ptr.sub3, 8
  br i1 %cmp34144, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %if.end32
  %44 = icmp ult i64 %5, 2
  %45 = zext i1 %44 to i32
  %cond40 = xor i32 %45, 1
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %if.end83
  %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %if.end83 ]
  %add42 = add nsw i64 %indvars.iv, %add
  %46 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx43 = getelementptr inbounds %struct.sv** %46, i64 %add42
  %47 = load %struct.sv** %arrayidx43, align 8, !tbaa !1
  %sv_flags.i124 = getelementptr inbounds %struct.sv* %47, i64 0, i32 2
  %48 = load i64* %sv_flags.i124, align 8, !tbaa !7
  %and2.i127 = and i64 %48, 262144
  %tobool3.i128 = icmp eq i64 %and2.i127, 0
  br i1 %tobool3.i128, label %if.else50, label %if.else5.i134

if.else5.i134:                                    ; preds = %for.body
  %sv_any.i130 = getelementptr inbounds %struct.sv* %47, i64 0, i32 0
  %49 = load i8** %sv_any.i130, align 8, !tbaa !9
  %xpv_cur.i131 = getelementptr inbounds i8* %49, i64 8
  %50 = bitcast i8* %xpv_cur.i131 to i64*
  %51 = load i64* %50, align 8, !tbaa !33
  %52 = load i64* @my_cxt.2, align 8, !tbaa !34
  %cmp.i132 = icmp eq i64 %51, %52
  br i1 %cmp.i132, label %if.end83, label %if.else50

if.else50:                                        ; preds = %for.body, %if.else5.i134
  %and55 = and i64 %48, 262144
  %cmp56 = icmp eq i64 %and55, 0
  br i1 %cmp56, label %cond.false68, label %cond.true58

cond.true58:                                      ; preds = %if.else50
  %sv_any62 = getelementptr inbounds %struct.sv* %47, i64 0, i32 0
  %53 = load i8** %sv_any62, align 8, !tbaa !9
  %xpv_cur = getelementptr inbounds i8* %53, i64 8
  %54 = bitcast i8* %xpv_cur to i64*
  %55 = load i64* %54, align 8, !tbaa !33
  store i64 %55, i64* %len, align 8, !tbaa !5
  %xpv_pv67 = bitcast i8* %53 to i8**
  %56 = load i8** %xpv_pv67, align 8, !tbaa !10
  br label %cond.end73

cond.false68:                                     ; preds = %if.else50
  %call72 = call i8* @Perl_sv_2pv_flags(%struct.sv* %47, i64* %len, i64 2) #3
  br label %cond.end73

cond.end73:                                       ; preds = %cond.false68, %cond.true58
  %cond74 = phi i8* [ %56, %cond.true58 ], [ %call72, %cond.false68 ]
  %57 = load i8* %cond74, align 1, !tbaa !39
  %cmp76 = icmp eq i8 %57, 33
  br i1 %cmp76, label %if.then78, label %cond.end73.if.end81_crit_edge

cond.end73.if.end81_crit_edge:                    ; preds = %cond.end73
  %.pre149 = load i64* %len, align 8, !tbaa !5
  br label %if.end81

if.then78:                                        ; preds = %cond.end73
  %incdec.ptr80 = getelementptr inbounds i8* %cond74, i64 1
  %58 = load i64* %len, align 8, !tbaa !5
  %dec = add i64 %58, -1
  store i64 %dec, i64* %len, align 8, !tbaa !5
  br label %if.end81

if.end81:                                         ; preds = %cond.end73.if.end81_crit_edge, %if.then78
  %59 = phi i64 [ %dec, %if.then78 ], [ %.pre149, %cond.end73.if.end81_crit_edge ]
  %on.0 = phi i32 [ %45, %if.then78 ], [ %cond40, %cond.end73.if.end81_crit_edge ]
  %opname.0 = phi i8* [ %incdec.ptr80, %if.then78 ], [ %cond74, %cond.end73.if.end81_crit_edge ]
  %call82 = call fastcc %struct.sv* @get_op_bitspec(i8* %opname.0, i64 %59)
  br label %if.end83

if.end83:                                         ; preds = %if.else5.i134, %if.end81
  %bitspec.0 = phi %struct.sv* [ %call82, %if.end81 ], [ %47, %if.else5.i134 ]
  %on.1 = phi i32 [ %on.0, %if.end81 ], [ %cond40, %if.else5.i134 ]
  %opname.1 = phi i8* [ %opname.0, %if.end81 ], [ getelementptr inbounds ([8 x i8]* @.str9, i64 0, i64 0), %if.else5.i134 ]
  call fastcc void @set_opset_bits(i8* %43, %struct.sv* %bitspec.0, i32 %on.1, i8* %opname.1)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cmp34 = icmp slt i64 %indvars.iv.next, %sub.ptr.div4
  br i1 %cmp34, label %for.body, label %for.end

for.end:                                          ; preds = %if.end83, %if.end32
  %60 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx85 = getelementptr inbounds %struct.sv** %60, i64 %add
  store %struct.sv* @PL_sv_yes, %struct.sv** %arrayidx85, align 8, !tbaa !1
  %61 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr86 = getelementptr inbounds %struct.sv** %61, i64 %add
  store %struct.sv** %add.ptr86, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare %struct.sv** @Perl_hv_fetch(%struct.hv*, i8*, i64, i64) #1

declare void @Perl_sv_setsv_flags(%struct.sv*, %struct.sv*, i64) #1

; Function Attrs: nounwind uwtable
define void @XS_Opcode_opdesc(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %sub.ptr.div4 = ashr exact i64 %sub.ptr.sub3, 3
  %idx.neg = sub i64 0, %sub.ptr.div4
  %add.ptr5 = getelementptr inbounds %struct.sv** %0, i64 %idx.neg
  %call = call i8** @Perl_get_op_descs() #3
  %4 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = bitcast %struct.sv** %arrayidx to i8*
  %call7 = call %struct.sv* @Perl_newSVpvn(i8* %5, i64 %sub.ptr.sub3) #3
  %call8 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call7) #3
  %sv_any = getelementptr inbounds %struct.sv* %call8, i64 0, i32 0
  %6 = load i8** %sv_any, align 8, !tbaa !9
  %xpv_pv = bitcast i8* %6 to i8**
  %7 = load i8** %xpv_pv, align 8, !tbaa !10
  %8 = bitcast i8* %7 to %struct.sv**
  %cmp180 = icmp sgt i64 %sub.ptr.sub3, 0
  br i1 %cmp180, label %for.body, label %for.end127

for.body:                                         ; preds = %entry, %for.inc125
  %indvars.iv187 = phi i64 [ %indvars.iv.next188, %for.inc125 ], [ 0, %entry ]
  %sp.0182 = phi %struct.sv** [ %sp.6, %for.inc125 ], [ %add.ptr5, %entry ]
  %arrayidx10 = getelementptr inbounds %struct.sv** %8, i64 %indvars.iv187
  %9 = load %struct.sv** %arrayidx10, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %9, i64 0, i32 2
  %10 = load i64* %sv_flags, align 8, !tbaa !7
  %and = and i64 %10, 262144
  %cmp11 = icmp eq i64 %and, 0
  br i1 %cmp11, label %cond.false, label %cond.true

cond.true:                                        ; preds = %for.body
  %sv_any15 = getelementptr inbounds %struct.sv* %9, i64 0, i32 0
  %11 = load i8** %sv_any15, align 8, !tbaa !9
  %xpv_cur = getelementptr inbounds i8* %11, i64 8
  %12 = bitcast i8* %xpv_cur to i64*
  %13 = load i64* %12, align 8, !tbaa !33
  store i64 %13, i64* %len, align 8, !tbaa !5
  %xpv_pv19 = bitcast i8* %11 to i8**
  %14 = load i8** %xpv_pv19, align 8, !tbaa !10
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %call22 = call i8* @Perl_sv_2pv_flags(%struct.sv* %9, i64* %len, i64 2) #3
  %.pre = load i64* %len, align 8, !tbaa !5
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %15 = phi i64 [ %13, %cond.true ], [ %.pre, %cond.false ]
  %cond = phi i8* [ %14, %cond.true ], [ %call22, %cond.false ]
  %call23 = call fastcc %struct.sv* @get_op_bitspec(i8* %cond, i64 %15)
  %sv_flags24 = getelementptr inbounds %struct.sv* %call23, i64 0, i32 2
  %16 = load i64* %sv_flags24, align 8, !tbaa !7
  %and25 = and i64 %16, 65536
  %tobool = icmp eq i64 %and25, 0
  br i1 %tobool, label %if.else, label %cond.true29

cond.true29:                                      ; preds = %cond.end
  %sv_any30 = getelementptr inbounds %struct.sv* %call23, i64 0, i32 0
  %17 = load i8** %sv_any30, align 8, !tbaa !9
  %xiv_iv = getelementptr inbounds i8* %17, i64 24
  %18 = bitcast i8* %xiv_iv to i64*
  %19 = load i64* %18, align 8, !tbaa !31
  %conv35 = trunc i64 %19 to i32
  %cmp36 = icmp sgt i32 %conv35, -1
  %20 = load i32* @PL_maxo, align 4
  %cmp38 = icmp slt i32 %conv35, %20
  %or.cond = and i1 %cmp36, %cmp38
  br i1 %or.cond, label %if.end, label %if.then40

if.then40:                                        ; preds = %cond.true29
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([35 x i8]* @.str13, i64 0, i64 0), i32 %conv35, i8* %cond) #3
  br label %if.end

if.end:                                           ; preds = %cond.true29, %if.then40
  %21 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !1
  %sub.ptr.lhs.cast41 = ptrtoint %struct.sv** %21 to i64
  %sub.ptr.rhs.cast42 = ptrtoint %struct.sv** %sp.0182 to i64
  %sub.ptr.sub43 = sub i64 %sub.ptr.lhs.cast41, %sub.ptr.rhs.cast42
  %cmp45 = icmp slt i64 %sub.ptr.sub43, 8
  br i1 %cmp45, label %if.then47, label %if.end49

if.then47:                                        ; preds = %if.end
  %call48 = call %struct.sv** @Perl_stack_grow(%struct.sv** %sp.0182, %struct.sv** %sp.0182, i32 1) #3
  br label %if.end49

if.end49:                                         ; preds = %if.then47, %if.end
  %sp.1 = phi %struct.sv** [ %call48, %if.then47 ], [ %sp.0182, %if.end ]
  %sext = shl i64 %19, 32
  %idxprom50 = ashr exact i64 %sext, 32
  %arrayidx51 = getelementptr inbounds i8** %call, i64 %idxprom50
  %22 = load i8** %arrayidx51, align 8, !tbaa !1
  %call52 = call %struct.sv* @Perl_newSVpv(i8* %22, i64 0) #3
  %call53 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call52) #3
  %incdec.ptr54 = getelementptr inbounds %struct.sv** %sp.1, i64 1
  store %struct.sv* %call53, %struct.sv** %incdec.ptr54, align 8, !tbaa !1
  br label %for.inc125

if.else:                                          ; preds = %cond.end
  %and56 = and i64 %16, 262144
  %tobool57 = icmp eq i64 %and56, 0
  br i1 %tobool57, label %if.else119, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %sv_any58 = getelementptr inbounds %struct.sv* %call23, i64 0, i32 0
  %23 = load i8** %sv_any58, align 8, !tbaa !9
  %xpv_cur59 = getelementptr inbounds i8* %23, i64 8
  %24 = bitcast i8* %xpv_cur59 to i64*
  %25 = load i64* %24, align 8, !tbaa !33
  %26 = load i64* @my_cxt.2, align 8, !tbaa !34
  %cmp60 = icmp eq i64 %25, %26
  br i1 %cmp60, label %cond.end78, label %if.else119

cond.end78:                                       ; preds = %land.lhs.true
  %xpv_pv75 = bitcast i8* %23 to i8**
  %27 = load i8** %xpv_pv75, align 8, !tbaa !10
  %cmp82174 = icmp sgt i64 %25, 0
  br i1 %cmp82174, label %for.body84.lr.ph, label %for.inc125

for.body84.lr.ph:                                 ; preds = %cond.end78
  %.pre189 = load i32* @PL_maxo, align 4
  br label %for.body84

for.body84:                                       ; preds = %for.body84.lr.ph, %for.inc116
  %28 = phi i32 [ %.pre189, %for.body84.lr.ph ], [ %36, %for.inc116 ]
  %indvars.iv185 = phi i64 [ 0, %for.body84.lr.ph ], [ %indvars.iv.next186, %for.inc116 ]
  %sp.2177 = phi %struct.sv** [ %sp.0182, %for.body84.lr.ph ], [ %sp.3.lcssa, %for.inc116 ]
  %myopcode.0176 = phi i32 [ 0, %for.body84.lr.ph ], [ %myopcode.1.lcssa, %for.inc116 ]
  %cmp92168 = icmp slt i32 %myopcode.0176, %28
  br i1 %cmp92168, label %for.body94.lr.ph, label %for.inc116

for.body94.lr.ph:                                 ; preds = %for.body84
  %arrayidx87 = getelementptr inbounds i8* %27, i64 %indvars.iv185
  %29 = load i8* %arrayidx87, align 1, !tbaa !39
  %conv88 = sext i8 %29 to i32
  %conv95 = and i32 %conv88, 65535
  %30 = sext i32 %myopcode.0176 to i64
  br label %for.body94

for.body94:                                       ; preds = %for.body94.lr.ph, %for.inc
  %31 = phi i32 [ %28, %for.body94.lr.ph ], [ %34, %for.inc ]
  %indvars.iv = phi i64 [ %30, %for.body94.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %sp.3172 = phi %struct.sv** [ %sp.2177, %for.body94.lr.ph ], [ %sp.5, %for.inc ]
  %j.0170 = phi i32 [ 0, %for.body94.lr.ph ], [ %inc, %for.inc ]
  %shl = shl i32 1, %j.0170
  %and96 = and i32 %conv95, %shl
  %tobool97 = icmp eq i32 %and96, 0
  br i1 %tobool97, label %for.inc, label %if.then98

if.then98:                                        ; preds = %for.body94
  %32 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !1
  %sub.ptr.lhs.cast99 = ptrtoint %struct.sv** %32 to i64
  %sub.ptr.rhs.cast100 = ptrtoint %struct.sv** %sp.3172 to i64
  %sub.ptr.sub101 = sub i64 %sub.ptr.lhs.cast99, %sub.ptr.rhs.cast100
  %cmp103 = icmp slt i64 %sub.ptr.sub101, 8
  br i1 %cmp103, label %if.then105, label %if.end107

if.then105:                                       ; preds = %if.then98
  %call106 = call %struct.sv** @Perl_stack_grow(%struct.sv** %sp.3172, %struct.sv** %sp.3172, i32 1) #3
  br label %if.end107

if.end107:                                        ; preds = %if.then105, %if.then98
  %sp.4 = phi %struct.sv** [ %call106, %if.then105 ], [ %sp.3172, %if.then98 ]
  %arrayidx110 = getelementptr inbounds i8** %call, i64 %indvars.iv
  %33 = load i8** %arrayidx110, align 8, !tbaa !1
  %call111 = call %struct.sv* @Perl_newSVpv(i8* %33, i64 0) #3
  %call112 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call111) #3
  %incdec.ptr113 = getelementptr inbounds %struct.sv** %sp.4, i64 1
  store %struct.sv* %call112, %struct.sv** %incdec.ptr113, align 8, !tbaa !1
  %.pre190 = load i32* @PL_maxo, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body94, %if.end107
  %34 = phi i32 [ %.pre190, %if.end107 ], [ %31, %for.body94 ]
  %sp.5 = phi %struct.sv** [ %incdec.ptr113, %if.end107 ], [ %sp.3172, %for.body94 ]
  %inc = add nsw i32 %j.0170, 1
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %cmp90 = icmp slt i32 %inc, 8
  %35 = trunc i64 %indvars.iv.next to i32
  %cmp92 = icmp slt i32 %35, %34
  %or.cond167 = and i1 %cmp90, %cmp92
  br i1 %or.cond167, label %for.body94, label %for.inc116

for.inc116:                                       ; preds = %for.inc, %for.body84
  %36 = phi i32 [ %28, %for.body84 ], [ %34, %for.inc ]
  %sp.3.lcssa = phi %struct.sv** [ %sp.2177, %for.body84 ], [ %sp.5, %for.inc ]
  %myopcode.1.lcssa = phi i32 [ %myopcode.0176, %for.body84 ], [ %35, %for.inc ]
  %indvars.iv.next186 = add nuw nsw i64 %indvars.iv185, 1
  %37 = load i64* @my_cxt.2, align 8, !tbaa !34
  %cmp82 = icmp slt i64 %indvars.iv.next186, %37
  br i1 %cmp82, label %for.body84, label %for.inc125

if.else119:                                       ; preds = %if.else, %land.lhs.true
  %.tr = trunc i64 %16 to i32
  %conv122 = and i32 %.tr, 255
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([42 x i8]* @.str14, i64 0, i64 0), i8* %cond, i32 %conv122) #3
  br label %for.inc125

for.inc125:                                       ; preds = %for.inc116, %cond.end78, %if.end49, %if.else119
  %sp.6 = phi %struct.sv** [ %incdec.ptr54, %if.end49 ], [ %sp.0182, %if.else119 ], [ %sp.0182, %cond.end78 ], [ %sp.3.lcssa, %for.inc116 ]
  %indvars.iv.next188 = add nuw nsw i64 %indvars.iv187, 1
  %cmp = icmp slt i64 %indvars.iv.next188, %sub.ptr.div4
  br i1 %cmp, label %for.body, label %for.end127

for.end127:                                       ; preds = %for.inc125, %entry
  %sp.0.lcssa = phi %struct.sv** [ %add.ptr5, %entry ], [ %sp.6, %for.inc125 ]
  store %struct.sv** %sp.0.lcssa, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare %struct.sv* @Perl_newSVpvn(i8*, i64) #1

; Function Attrs: nounwind uwtable
define void @XS_Opcode_define_optag(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp eq i64 %sub.ptr.sub3, 16
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([43 x i8]* @.str15, i64 0, i64 0)) #3
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %add6 = add nsw i64 %sub.ptr.div, 2
  %arrayidx7 = getelementptr inbounds %struct.sv** %4, i64 %add6
  %6 = load %struct.sv** %arrayidx7, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %7 = load i64* %sv_flags, align 8, !tbaa !7
  %and = and i64 %7, 262144
  %cmp8 = icmp eq i64 %and, 0
  br i1 %cmp8, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !9
  %xpv_cur = getelementptr inbounds i8* %8, i64 8
  %9 = bitcast i8* %xpv_cur to i64*
  %10 = load i64* %9, align 8, !tbaa !33
  store i64 %10, i64* %len, align 8, !tbaa !5
  %xpv_pv = bitcast i8* %8 to i8**
  %11 = load i8** %xpv_pv, align 8, !tbaa !10
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %5, i64* %len, i64 2) #3
  %.pre20 = load i64* %len, align 8, !tbaa !5
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %12 = phi i64 [ %10, %cond.true ], [ %.pre20, %cond.false ]
  %cond = phi i8* [ %11, %cond.true ], [ %call, %cond.false ]
  call fastcc void @put_op_bitspec(i8* %cond, i64 %12, %struct.sv* %6)
  %13 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx11 = getelementptr inbounds %struct.sv** %13, i64 %add
  store %struct.sv* @PL_sv_yes, %struct.sv** %arrayidx11, align 8, !tbaa !1
  %14 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr12 = getelementptr inbounds %struct.sv** %14, i64 %add
  store %struct.sv** %add.ptr12, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @put_op_bitspec(i8* %optag, i64 %len, %struct.sv* %mask) #0 {
entry:
  %sv_flags.i = getelementptr inbounds %struct.sv* %mask, i64 0, i32 2
  %0 = load i64* %sv_flags.i, align 8, !tbaa !7
  %and.i = and i64 %0, 118423552
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.then11.i, label %if.else.i

if.else.i:                                        ; preds = %entry
  %and2.i = and i64 %0, 262144
  %tobool3.i = icmp eq i64 %and2.i, 0
  br i1 %tobool3.i, label %if.then11.i, label %if.else5.i

if.else5.i:                                       ; preds = %if.else.i
  %sv_any.i = getelementptr inbounds %struct.sv* %mask, i64 0, i32 0
  %1 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_cur.i = getelementptr inbounds i8* %1, i64 8
  %2 = bitcast i8* %xpv_cur.i to i64*
  %3 = load i64* %2, align 8, !tbaa !33
  %4 = load i64* @my_cxt.2, align 8, !tbaa !34
  %cmp.i = icmp eq i64 %3, %4
  br i1 %cmp.i, label %verify_opset.exit, label %if.then11.i

if.then11.i:                                      ; preds = %entry, %if.else.i, %if.else5.i
  %err.0.i.ph = phi i8* [ getelementptr inbounds ([10 x i8]* @.str61, i64 0, i64 0), %entry ], [ getelementptr inbounds ([11 x i8]* @.str62, i64 0, i64 0), %if.else.i ], [ getelementptr inbounds ([11 x i8]* @.str63, i64 0, i64 0), %if.else5.i ]
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([18 x i8]* @.str64, i64 0, i64 0), i8* %err.0.i.ph) #3
  br label %verify_opset.exit

verify_opset.exit:                                ; preds = %if.else5.i, %if.then11.i
  %tobool = icmp eq i64 %len, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %verify_opset.exit
  %call1 = tail call i64 @strlen(i8* %optag) #3
  br label %if.end

if.end:                                           ; preds = %verify_opset.exit, %if.then
  %len.addr.0 = phi i64 [ %len, %verify_opset.exit ], [ %call1, %if.then ]
  %5 = load %struct.hv** @my_cxt.0, align 8, !tbaa !41
  %call2 = tail call %struct.sv** @Perl_hv_fetch(%struct.hv* %5, i8* %optag, i64 %len.addr.0, i64 1) #3
  %6 = load %struct.sv** %call2, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i64* %sv_flags, align 8, !tbaa !7
  %and = and i64 %7, 118423552
  %tobool3 = icmp eq i64 %and, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([32 x i8]* @.str51, i64 0, i64 0), i8* %optag) #3
  %.pre = load %struct.sv** %call2, align 8, !tbaa !1
  br label %if.end5

if.end5:                                          ; preds = %if.end, %if.then4
  %8 = phi %struct.sv* [ %6, %if.end ], [ %.pre, %if.then4 ]
  tail call void @Perl_sv_setsv_flags(%struct.sv* %8, %struct.sv* %mask, i64 2) #3
  %9 = load %struct.sv** %call2, align 8, !tbaa !1
  %sv_flags6 = getelementptr inbounds %struct.sv* %9, i64 0, i32 2
  %10 = load i64* %sv_flags6, align 8, !tbaa !7
  %or = or i64 %10, 8388608
  store i64 %or, i64* %sv_flags6, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind uwtable
define void @XS_Opcode_empty_opset(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %cmp = icmp eq %struct.sv** %0, %add.ptr
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([29 x i8]* @.str16, i64 0, i64 0)) #3
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = load i64* @my_cxt.2, align 8, !tbaa !34
  %call2.i = tail call %struct.sv* @Perl_newSV(i64 %4) #3
  %sv_any.i = getelementptr inbounds %struct.sv* %call2.i, i64 0, i32 0
  %5 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_pv.i = bitcast i8* %5 to i8**
  %6 = load i8** %xpv_pv.i, align 8, !tbaa !10
  %7 = load i64* @my_cxt.2, align 8, !tbaa !34
  %add.i = add nsw i64 %7, 1
  tail call void @llvm.memset.p0i8.i64(i8* %6, i8 0, i64 %add.i, i32 1, i1 false) #3
  %8 = load i64* @my_cxt.2, align 8, !tbaa !34
  %9 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_cur.i = getelementptr inbounds i8* %9, i64 8
  %10 = bitcast i8* %xpv_cur.i to i64*
  store i64 %8, i64* %10, align 8, !tbaa !33
  %sv_flags.i = getelementptr inbounds %struct.sv* %call2.i, i64 0, i32 2
  %11 = load i64* %sv_flags.i, align 8, !tbaa !7
  %and.i = and i64 %11, 1223753727
  %or.i = or i64 %and.i, 67371008
  store i64 %or.i, i64* %sv_flags.i, align 8, !tbaa !7
  %call5 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call2.i) #3
  %12 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.sv** %12, i64 %add
  store %struct.sv* %call5, %struct.sv** %arrayidx, align 8, !tbaa !1
  %13 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr7 = getelementptr inbounds %struct.sv** %13, i64 %add
  store %struct.sv** %add.ptr7, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

; Function Attrs: nounwind uwtable
define void @XS_Opcode_full_opset(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %cmp = icmp eq %struct.sv** %0, %add.ptr
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([28 x i8]* @.str17, i64 0, i64 0)) #3
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = load %struct.sv** @my_cxt.1, align 8, !tbaa !53
  %tobool.i = icmp eq %struct.sv* %4, null
  br i1 %tobool.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.end
  %sv_flags.i.i = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %5 = load i64* %sv_flags.i.i, align 8, !tbaa !7
  %and.i.i = and i64 %5, 118423552
  %tobool.i.i = icmp eq i64 %and.i.i, 0
  br i1 %tobool.i.i, label %if.then11.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i
  %and2.i.i = and i64 %5, 262144
  %tobool3.i.i = icmp eq i64 %and2.i.i, 0
  br i1 %tobool3.i.i, label %if.then11.i.i, label %if.else5.i.i

if.else5.i.i:                                     ; preds = %if.else.i.i
  %sv_any.i.i = getelementptr inbounds %struct.sv* %4, i64 0, i32 0
  %6 = load i8** %sv_any.i.i, align 8, !tbaa !9
  %xpv_cur.i.i = getelementptr inbounds i8* %6, i64 8
  %7 = bitcast i8* %xpv_cur.i.i to i64*
  %8 = load i64* %7, align 8, !tbaa !33
  %9 = load i64* @my_cxt.2, align 8, !tbaa !34
  %cmp.i.i = icmp eq i64 %8, %9
  br i1 %cmp.i.i, label %verify_opset.exit.i, label %if.then11.i.i

if.then11.i.i:                                    ; preds = %if.else5.i.i, %if.else.i.i, %if.then.i
  %err.0.i.ph.i = phi i8* [ getelementptr inbounds ([10 x i8]* @.str61, i64 0, i64 0), %if.then.i ], [ getelementptr inbounds ([11 x i8]* @.str62, i64 0, i64 0), %if.else.i.i ], [ getelementptr inbounds ([11 x i8]* @.str63, i64 0, i64 0), %if.else5.i.i ]
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([18 x i8]* @.str64, i64 0, i64 0), i8* %err.0.i.ph.i) #3
  br label %verify_opset.exit.i

verify_opset.exit.i:                              ; preds = %if.then11.i.i, %if.else5.i.i
  %call1.i = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %4) #3
  br label %new_opset.exit

if.else.i:                                        ; preds = %if.end
  %10 = load i64* @my_cxt.2, align 8, !tbaa !34
  %call2.i = tail call %struct.sv* @Perl_newSV(i64 %10) #3
  %sv_any.i = getelementptr inbounds %struct.sv* %call2.i, i64 0, i32 0
  %11 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_pv.i = bitcast i8* %11 to i8**
  %12 = load i8** %xpv_pv.i, align 8, !tbaa !10
  %13 = load i64* @my_cxt.2, align 8, !tbaa !34
  %add.i = add nsw i64 %13, 1
  tail call void @llvm.memset.p0i8.i64(i8* %12, i8 0, i64 %add.i, i32 1, i1 false) #3
  %14 = load i64* @my_cxt.2, align 8, !tbaa !34
  %15 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_cur.i = getelementptr inbounds i8* %15, i64 8
  %16 = bitcast i8* %xpv_cur.i to i64*
  store i64 %14, i64* %16, align 8, !tbaa !33
  %sv_flags.i = getelementptr inbounds %struct.sv* %call2.i, i64 0, i32 2
  %17 = load i64* %sv_flags.i, align 8, !tbaa !7
  %and.i = and i64 %17, 1223753727
  %or.i = or i64 %and.i, 67371008
  store i64 %or.i, i64* %sv_flags.i, align 8, !tbaa !7
  br label %new_opset.exit

new_opset.exit:                                   ; preds = %verify_opset.exit.i, %if.else.i
  %opset.0.i = phi %struct.sv* [ %call1.i, %verify_opset.exit.i ], [ %call2.i, %if.else.i ]
  %call5 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %opset.0.i) #3
  %18 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.sv** %18, i64 %add
  store %struct.sv* %call5, %struct.sv** %arrayidx, align 8, !tbaa !1
  %19 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr7 = getelementptr inbounds %struct.sv** %19, i64 %add
  store %struct.sv** %add.ptr7, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

; Function Attrs: nounwind uwtable
define void @XS_Opcode_opmask_add(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp eq i64 %sub.ptr.sub3, 8
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([33 x i8]* @.str18, i64 0, i64 0)) #3
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %6 = load i8** @PL_op_mask, align 8, !tbaa !1
  %tobool = icmp eq i8* %6, null
  br i1 %tobool, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end
  %7 = load i32* @PL_maxo, align 4, !tbaa !18
  %conv = sext i32 %7 to i64
  %call = tail call i8* @Perl_safesysmalloc(i64 %conv) #3
  store i8* %call, i8** @PL_op_mask, align 8, !tbaa !1
  %8 = load i32* @PL_maxo, align 4, !tbaa !18
  %conv7 = sext i32 %8 to i64
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 %conv7, i32 1, i1 false)
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then6
  tail call fastcc void @opmask_add(%struct.sv* %5)
  %9 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr11 = getelementptr inbounds %struct.sv** %9, i64 %sub.ptr.div
  store %struct.sv** %add.ptr11, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare i8* @Perl_safesysmalloc(i64) #1

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #3

; Function Attrs: nounwind uwtable
define internal fastcc void @opmask_add(%struct.sv* %opset) #0 {
entry:
  %len = alloca i64, align 8
  %sv_flags.i = getelementptr inbounds %struct.sv* %opset, i64 0, i32 2
  %0 = load i64* %sv_flags.i, align 8, !tbaa !7
  %and.i = and i64 %0, 118423552
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.then11.i, label %if.else.i

if.else.i:                                        ; preds = %entry
  %and2.i = and i64 %0, 262144
  %tobool3.i = icmp eq i64 %and2.i, 0
  br i1 %tobool3.i, label %if.then11.i, label %if.else5.i

if.else5.i:                                       ; preds = %if.else.i
  %sv_any.i = getelementptr inbounds %struct.sv* %opset, i64 0, i32 0
  %1 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_cur.i = getelementptr inbounds i8* %1, i64 8
  %2 = bitcast i8* %xpv_cur.i to i64*
  %3 = load i64* %2, align 8, !tbaa !33
  %4 = load i64* @my_cxt.2, align 8, !tbaa !34
  %cmp.i = icmp eq i64 %3, %4
  br i1 %cmp.i, label %verify_opset.exit, label %if.then11.i

if.then11.i:                                      ; preds = %entry, %if.else.i, %if.else5.i
  %err.0.i.ph = phi i8* [ getelementptr inbounds ([10 x i8]* @.str61, i64 0, i64 0), %entry ], [ getelementptr inbounds ([11 x i8]* @.str62, i64 0, i64 0), %if.else.i ], [ getelementptr inbounds ([11 x i8]* @.str63, i64 0, i64 0), %if.else5.i ]
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([18 x i8]* @.str64, i64 0, i64 0), i8* %err.0.i.ph) #3
  br label %verify_opset.exit

verify_opset.exit:                                ; preds = %if.else5.i, %if.then11.i
  %5 = load i8** @PL_op_mask, align 8, !tbaa !1
  %tobool = icmp eq i8* %5, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %verify_opset.exit
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([38 x i8]* @.str50, i64 0, i64 0)) #3
  br label %if.end

if.end:                                           ; preds = %verify_opset.exit, %if.then
  %6 = load i64* %sv_flags.i, align 8, !tbaa !7
  %and = and i64 %6, 262144
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.sv* %opset, i64 0, i32 0
  %7 = load i8** %sv_any, align 8, !tbaa !9
  %xpv_cur = getelementptr inbounds i8* %7, i64 8
  %8 = bitcast i8* %xpv_cur to i64*
  %9 = load i64* %8, align 8, !tbaa !33
  store i64 %9, i64* %len, align 8, !tbaa !5
  %xpv_pv = bitcast i8* %7 to i8**
  %10 = load i8** %xpv_pv, align 8, !tbaa !10
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call2 = call i8* @Perl_sv_2pv_flags(%struct.sv* %opset, i64* %len, i64 2) #3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %10, %cond.true ], [ %call2, %cond.false ]
  %11 = load i64* @my_cxt.2, align 8, !tbaa !34
  %cmp343 = icmp sgt i64 %11, 0
  br i1 %cmp343, label %for.body, label %for.end23

for.body:                                         ; preds = %cond.end, %for.inc
  %12 = phi i64 [ %20, %for.inc ], [ %11, %cond.end ]
  %indvars.iv47 = phi i64 [ %indvars.iv.next48, %for.inc ], [ 0, %cond.end ]
  %myopcode.044 = phi i32 [ %myopcode.2, %for.inc ], [ 0, %cond.end ]
  %arrayidx = getelementptr inbounds i8* %cond, i64 %indvars.iv47
  %13 = load i8* %arrayidx, align 1, !tbaa !39
  %conv533 = zext i8 %13 to i32
  %tobool6 = icmp eq i8 %13, 0
  br i1 %tobool6, label %if.then7, label %for.cond9.preheader

for.cond9.preheader:                              ; preds = %for.body
  %14 = load i32* @PL_maxo, align 4
  %cmp1239 = icmp slt i32 %myopcode.044, %14
  br i1 %cmp1239, label %for.body14.lr.ph, label %for.inc

for.body14.lr.ph:                                 ; preds = %for.cond9.preheader
  %15 = sext i32 %myopcode.044 to i64
  br label %for.body14

if.then7:                                         ; preds = %for.body
  %add = add nsw i32 %myopcode.044, 8
  br label %for.inc

for.body14:                                       ; preds = %for.body14.lr.ph, %for.body14
  %indvars.iv = phi i64 [ %15, %for.body14.lr.ph ], [ %indvars.iv.next, %for.body14 ]
  %j.041 = phi i32 [ 0, %for.body14.lr.ph ], [ %inc, %for.body14 ]
  %inc = add nsw i32 %j.041, 1
  %shl = shl i32 1, %j.041
  %and16 = and i32 %shl, %conv533
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %16 = load i8** @PL_op_mask, align 8, !tbaa !1
  %arrayidx19 = getelementptr inbounds i8* %16, i64 %indvars.iv
  %17 = load i8* %arrayidx19, align 1, !tbaa !39
  %conv2034 = zext i8 %17 to i32
  %or = or i32 %conv2034, %and16
  %conv21 = trunc i32 %or to i8
  store i8 %conv21, i8* %arrayidx19, align 1, !tbaa !39
  %cmp10 = icmp slt i32 %inc, 8
  %18 = load i32* @PL_maxo, align 4
  %19 = trunc i64 %indvars.iv.next to i32
  %cmp12 = icmp slt i32 %19, %18
  %or.cond = and i1 %cmp10, %cmp12
  br i1 %or.cond, label %for.body14, label %for.cond9.for.inc.loopexit_crit_edge

for.cond9.for.inc.loopexit_crit_edge:             ; preds = %for.body14
  %.pre.pre = load i64* @my_cxt.2, align 8, !tbaa !34
  br label %for.inc

for.inc:                                          ; preds = %for.cond9.preheader, %for.cond9.for.inc.loopexit_crit_edge, %if.then7
  %20 = phi i64 [ %12, %if.then7 ], [ %.pre.pre, %for.cond9.for.inc.loopexit_crit_edge ], [ %12, %for.cond9.preheader ]
  %myopcode.2 = phi i32 [ %add, %if.then7 ], [ %19, %for.cond9.for.inc.loopexit_crit_edge ], [ %myopcode.044, %for.cond9.preheader ]
  %indvars.iv.next48 = add nuw nsw i64 %indvars.iv47, 1
  %cmp3 = icmp slt i64 %indvars.iv.next48, %20
  br i1 %cmp3, label %for.body, label %for.end23

for.end23:                                        ; preds = %for.inc, %cond.end
  ret void
}

; Function Attrs: nounwind uwtable
define void @XS_Opcode_opcodes(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %sub.ptr.div4 = ashr exact i64 %sub.ptr.sub3, 3
  %cmp = icmp eq i64 %sub.ptr.div4, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([25 x i8]* @.str19, i64 0, i64 0)) #3
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %idx.neg = sub i64 0, %sub.ptr.div4
  %add.ptr5 = getelementptr inbounds %struct.sv** %0, i64 %idx.neg
  %4 = load %struct.op** @PL_op, align 8, !tbaa !1
  %op_flags = getelementptr inbounds %struct.op* %4, i64 0, i32 6
  %5 = load i8* %op_flags, align 1, !tbaa !26
  %conv = zext i8 %5 to i32
  %and = and i32 %conv, 3
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %cmp9 = icmp eq i32 %and, 3
  %conv11 = zext i1 %cmp9 to i64
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = tail call i64 @Perl_dowantarray() #3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond12 = phi i64 [ %conv11, %cond.true ], [ %call, %cond.false ]
  %cmp13 = icmp eq i64 %cond12, 1
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %cond.end
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([44 x i8]* @.str20, i64 0, i64 0)) #3
  br label %if.end29

if.else:                                          ; preds = %cond.end
  %6 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !1
  %sub.ptr.lhs.cast16 = ptrtoint %struct.sv** %6 to i64
  %sub.ptr.rhs.cast17 = ptrtoint %struct.sv** %add.ptr5 to i64
  %sub.ptr.sub18 = sub i64 %sub.ptr.lhs.cast16, %sub.ptr.rhs.cast17
  %cmp20 = icmp slt i64 %sub.ptr.sub18, 8
  br i1 %cmp20, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.else
  %call23 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr5, %struct.sv** %add.ptr5, i32 1) #3
  br label %if.end24

if.end24:                                         ; preds = %if.then22, %if.else
  %sp.0 = phi %struct.sv** [ %call23, %if.then22 ], [ %add.ptr5, %if.else ]
  %7 = load i32* @PL_maxo, align 4, !tbaa !18
  %conv25 = sext i32 %7 to i64
  %call26 = tail call %struct.sv* @Perl_newSViv(i64 %conv25) #3
  %call27 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call26) #3
  %incdec.ptr28 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %call27, %struct.sv** %incdec.ptr28, align 8, !tbaa !1
  br label %if.end29

if.end29:                                         ; preds = %if.end24, %if.then15
  %sp.1 = phi %struct.sv** [ %add.ptr5, %if.then15 ], [ %incdec.ptr28, %if.end24 ]
  store %struct.sv** %sp.1, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare %struct.sv* @Perl_newSViv(i64) #1

; Function Attrs: nounwind uwtable
define void @XS_Opcode_opmask(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %cmp = icmp eq %struct.sv** %0, %add.ptr
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([24 x i8]* @.str21, i64 0, i64 0)) #3
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = load i64* @my_cxt.2, align 8, !tbaa !34
  %call2.i = tail call %struct.sv* @Perl_newSV(i64 %4) #3
  %sv_any.i = getelementptr inbounds %struct.sv* %call2.i, i64 0, i32 0
  %5 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_pv.i = bitcast i8* %5 to i8**
  %6 = load i8** %xpv_pv.i, align 8, !tbaa !10
  %7 = load i64* @my_cxt.2, align 8, !tbaa !34
  %add.i = add nsw i64 %7, 1
  tail call void @llvm.memset.p0i8.i64(i8* %6, i8 0, i64 %add.i, i32 1, i1 false) #3
  %8 = load i64* @my_cxt.2, align 8, !tbaa !34
  %9 = load i8** %sv_any.i, align 8, !tbaa !9
  %xpv_cur.i = getelementptr inbounds i8* %9, i64 8
  %10 = bitcast i8* %xpv_cur.i to i64*
  store i64 %8, i64* %10, align 8, !tbaa !33
  %sv_flags.i = getelementptr inbounds %struct.sv* %call2.i, i64 0, i32 2
  %11 = load i64* %sv_flags.i, align 8, !tbaa !7
  %and.i = and i64 %11, 1223753727
  %or.i = or i64 %and.i, 67371008
  store i64 %or.i, i64* %sv_flags.i, align 8, !tbaa !7
  %call5 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call2.i) #3
  %12 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.sv** %12, i64 %add
  store %struct.sv* %call5, %struct.sv** %arrayidx, align 8, !tbaa !1
  %13 = load i8** @PL_op_mask, align 8, !tbaa !1
  %tobool = icmp eq i8* %13, null
  br i1 %tobool, label %if.end18, label %if.then7

if.then7:                                         ; preds = %if.end
  %14 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx9 = getelementptr inbounds %struct.sv** %14, i64 %add
  %15 = load %struct.sv** %arrayidx9, align 8, !tbaa !1
  %sv_any = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %16 = load i8** %sv_any, align 8, !tbaa !9
  %xpv_pv = bitcast i8* %16 to i8**
  %17 = load i8** %xpv_pv, align 8, !tbaa !10
  %18 = load i32* @PL_maxo, align 4, !tbaa !18
  %cmp1029 = icmp sgt i32 %18, 0
  br i1 %cmp1029, label %for.body, label %if.end18

for.body:                                         ; preds = %if.then7, %for.inc.for.body_crit_edge
  %19 = phi i32 [ %24, %for.inc.for.body_crit_edge ], [ %18, %if.then7 ]
  %20 = phi i8* [ %.pre, %for.inc.for.body_crit_edge ], [ %13, %if.then7 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc.for.body_crit_edge ], [ 0, %if.then7 ]
  %arrayidx11 = getelementptr inbounds i8* %20, i64 %indvars.iv
  %21 = load i8* %arrayidx11, align 1, !tbaa !39
  %tobool12 = icmp eq i8 %21, 0
  br i1 %tobool12, label %for.inc, label %if.then13

if.then13:                                        ; preds = %for.body
  %22 = trunc i64 %indvars.iv to i32
  %and = and i32 %22, 7
  %shl = shl i32 1, %and
  %shr = ashr i32 %22, 3
  %idxprom14 = sext i32 %shr to i64
  %arrayidx15 = getelementptr inbounds i8* %17, i64 %idxprom14
  %23 = load i8* %arrayidx15, align 1, !tbaa !39
  %conv28 = zext i8 %23 to i32
  %or = or i32 %conv28, %shl
  %conv16 = trunc i32 %or to i8
  store i8 %conv16, i8* %arrayidx15, align 1, !tbaa !39
  %.pre31 = load i32* @PL_maxo, align 4, !tbaa !18
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then13
  %24 = phi i32 [ %19, %for.body ], [ %.pre31, %if.then13 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %25 = trunc i64 %indvars.iv.next to i32
  %cmp10 = icmp slt i32 %25, %24
  br i1 %cmp10, label %for.inc.for.body_crit_edge, label %if.end18

for.inc.for.body_crit_edge:                       ; preds = %for.inc
  %.pre = load i8** @PL_op_mask, align 8, !tbaa !1
  br label %for.body

if.end18:                                         ; preds = %for.inc, %if.then7, %if.end
  %26 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr19 = getelementptr inbounds %struct.sv** %26, i64 %add
  store %struct.sv** %add.ptr19, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

; Function Attrs: nounwind uwtable
define void @boot_Opcode(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %0, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %1 = load i64* %0, align 8, !tbaa !5
  %add.ptr.idx = shl nuw i64 %1, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %call = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([23 x i8]* @.str23, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode__safe_pkg_prep, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %2 = bitcast %struct.cv* %call to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %2, i8* getelementptr inbounds ([2 x i8]* @.str24, i64 0, i64 0)) #3
  %call6 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([22 x i8]* @.str25, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode__safe_call_sv, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %3 = bitcast %struct.cv* %call6 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %3, i8* getelementptr inbounds ([4 x i8]* @.str26, i64 0, i64 0)) #3
  %call7 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([21 x i8]* @.str27, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_verify_opset, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %4 = bitcast %struct.cv* %call7 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %4, i8* getelementptr inbounds ([4 x i8]* @.str28, i64 0, i64 0)) #3
  %call8 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([21 x i8]* @.str29, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_invert_opset, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %5 = bitcast %struct.cv* %call8 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %5, i8* getelementptr inbounds ([2 x i8]* @.str24, i64 0, i64 0)) #3
  %call9 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([21 x i8]* @.str30, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_opset_to_ops, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %6 = bitcast %struct.cv* %call9 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %6, i8* getelementptr inbounds ([4 x i8]* @.str28, i64 0, i64 0)) #3
  %call10 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([14 x i8]* @.str31, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_opset, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %7 = bitcast %struct.cv* %call10 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %7, i8* getelementptr inbounds ([3 x i8]* @.str32, i64 0, i64 0)) #3
  %call11 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([20 x i8]* @.str33, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_permit_only, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %sv_any = getelementptr inbounds %struct.cv* %call11, i64 0, i32 0
  %8 = load %struct.xpvcv** %sv_any, align 8, !tbaa !46
  %9 = getelementptr inbounds %struct.xpvcv* %8, i64 0, i32 11, i32 0
  store i8* null, i8** %9, align 8, !tbaa !5
  %10 = bitcast %struct.cv* %call11 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %10, i8* getelementptr inbounds ([4 x i8]* @.str34, i64 0, i64 0)) #3
  %call12 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([13 x i8]* @.str35, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_permit_only, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %sv_any13 = getelementptr inbounds %struct.cv* %call12, i64 0, i32 0
  %11 = load %struct.xpvcv** %sv_any13, align 8, !tbaa !46
  %12 = getelementptr inbounds %struct.xpvcv* %11, i64 0, i32 11, i32 0
  store i8* inttoptr (i64 3 to i8*), i8** %12, align 8, !tbaa !5
  %13 = bitcast %struct.cv* %call12 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %13, i8* getelementptr inbounds ([4 x i8]* @.str34, i64 0, i64 0)) #3
  %call16 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([18 x i8]* @.str36, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_permit_only, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %sv_any17 = getelementptr inbounds %struct.cv* %call16, i64 0, i32 0
  %14 = load %struct.xpvcv** %sv_any17, align 8, !tbaa !46
  %15 = getelementptr inbounds %struct.xpvcv* %14, i64 0, i32 11, i32 0
  store i8* inttoptr (i64 2 to i8*), i8** %15, align 8, !tbaa !5
  %16 = bitcast %struct.cv* %call16 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %16, i8* getelementptr inbounds ([4 x i8]* @.str34, i64 0, i64 0)) #3
  %call20 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([15 x i8]* @.str37, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_permit_only, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %sv_any21 = getelementptr inbounds %struct.cv* %call20, i64 0, i32 0
  %17 = load %struct.xpvcv** %sv_any21, align 8, !tbaa !46
  %18 = getelementptr inbounds %struct.xpvcv* %17, i64 0, i32 11, i32 0
  store i8* inttoptr (i64 1 to i8*), i8** %18, align 8, !tbaa !5
  %19 = bitcast %struct.cv* %call20 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %19, i8* getelementptr inbounds ([4 x i8]* @.str34, i64 0, i64 0)) #3
  %call24 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([15 x i8]* @.str38, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_opdesc, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %20 = bitcast %struct.cv* %call24 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %20, i8* getelementptr inbounds ([3 x i8]* @.str32, i64 0, i64 0)) #3
  %call25 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([21 x i8]* @.str39, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_define_optag, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %21 = bitcast %struct.cv* %call25 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %21, i8* getelementptr inbounds ([3 x i8]* @.str40, i64 0, i64 0)) #3
  %call26 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([20 x i8]* @.str41, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_empty_opset, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %22 = bitcast %struct.cv* %call26 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %22, i8* getelementptr inbounds ([1 x i8]* @.str42, i64 0, i64 0)) #3
  %call27 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([19 x i8]* @.str43, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_full_opset, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %23 = bitcast %struct.cv* %call27 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %23, i8* getelementptr inbounds ([1 x i8]* @.str42, i64 0, i64 0)) #3
  %call28 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([19 x i8]* @.str44, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_opmask_add, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %24 = bitcast %struct.cv* %call28 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %24, i8* getelementptr inbounds ([2 x i8]* @.str24, i64 0, i64 0)) #3
  %call29 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([16 x i8]* @.str45, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_opcodes, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %25 = bitcast %struct.cv* %call29 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %25, i8* getelementptr inbounds ([1 x i8]* @.str42, i64 0, i64 0)) #3
  %call30 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([15 x i8]* @.str46, i64 0, i64 0), void (%struct.cv*)* @XS_Opcode_opmask, i8* getelementptr inbounds ([9 x i8]* @.str22, i64 0, i64 0)) #3
  %26 = bitcast %struct.cv* %call30 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %26, i8* getelementptr inbounds ([1 x i8]* @.str42, i64 0, i64 0)) #3
  %27 = load i32* @PL_maxo, align 4, !tbaa !18
  %add31 = add nsw i32 %27, 7
  %div = sdiv i32 %add31, 8
  %conv = sext i32 %div to i64
  store i64 %conv, i64* @my_cxt.2, align 8, !tbaa !34
  %call.i = tail call %struct.hv* @Perl_newHV() #3
  store %struct.hv* %call.i, %struct.hv** @my_cxt.0, align 8, !tbaa !41
  %call1.i = tail call i8** @Perl_get_op_names() #3
  %28 = load i32* @PL_maxo, align 4, !tbaa !18
  %cmp49.i = icmp sgt i32 %28, 0
  br i1 %cmp49.i, label %for.body.i, label %cond.end.i

for.body.i:                                       ; preds = %entry, %for.body.i
  %indvars.iv51.i = phi i64 [ %indvars.iv.next52.i, %for.body.i ], [ 0, %entry ]
  %call2.i = tail call %struct.sv* @Perl_newSViv(i64 %indvars.iv51.i) #3
  %sv_flags.i = getelementptr inbounds %struct.sv* %call2.i, i64 0, i32 2
  %29 = load i64* %sv_flags.i, align 8, !tbaa !7
  %or.i = or i64 %29, 8388608
  store i64 %or.i, i64* %sv_flags.i, align 8, !tbaa !7
  %30 = load %struct.hv** @my_cxt.0, align 8, !tbaa !41
  %arrayidx.i = getelementptr inbounds i8** %call1.i, i64 %indvars.iv51.i
  %31 = load i8** %arrayidx.i, align 8, !tbaa !1
  %call5.i = tail call i64 @strlen(i8* %31) #3
  %call6.i = tail call %struct.sv** @Perl_hv_store(%struct.hv* %30, i8* %31, i64 %call5.i, %struct.sv* %call2.i, i64 0) #3
  %indvars.iv.next52.i = add nuw nsw i64 %indvars.iv51.i, 1
  %32 = load i32* @PL_maxo, align 4, !tbaa !18
  %33 = trunc i64 %indvars.iv.next52.i to i32
  %cmp.i = icmp slt i32 %33, %32
  br i1 %cmp.i, label %for.body.i, label %cond.end.i

cond.end.i:                                       ; preds = %for.body.i, %entry
  %34 = load i64* @my_cxt.2, align 8, !tbaa !34
  %call2.i.i = tail call %struct.sv* @Perl_newSV(i64 %34) #3
  %sv_any.i.i = getelementptr inbounds %struct.sv* %call2.i.i, i64 0, i32 0
  %35 = load i8** %sv_any.i.i, align 8, !tbaa !9
  %xpv_pv.i.i = bitcast i8* %35 to i8**
  %36 = load i8** %xpv_pv.i.i, align 8, !tbaa !10
  %37 = load i64* @my_cxt.2, align 8, !tbaa !34
  %add.i.i = add nsw i64 %37, 1
  tail call void @llvm.memset.p0i8.i64(i8* %36, i8 0, i64 %add.i.i, i32 1, i1 false) #3
  %38 = load i64* @my_cxt.2, align 8, !tbaa !34
  %39 = load i8** %sv_any.i.i, align 8, !tbaa !9
  %xpv_cur.i.i = getelementptr inbounds i8* %39, i64 8
  %40 = bitcast i8* %xpv_cur.i.i to i64*
  store i64 %38, i64* %40, align 8, !tbaa !33
  %sv_flags.i.i = getelementptr inbounds %struct.sv* %call2.i.i, i64 0, i32 2
  %41 = load i64* %sv_flags.i.i, align 8, !tbaa !7
  %and.i.i = and i64 %41, 1223753727
  %or.i.i = or i64 %and.i.i, 67371008
  store i64 %or.i.i, i64* %sv_flags.i.i, align 8, !tbaa !7
  %call8.i = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call2.i.i) #3
  tail call fastcc void @put_op_bitspec(i8* getelementptr inbounds ([6 x i8]* @.str48, i64 0, i64 0), i64 0, %struct.sv* %call8.i) #3
  %42 = load i64* @my_cxt.2, align 8, !tbaa !34
  %call2.i38.i = tail call %struct.sv* @Perl_newSV(i64 %42) #3
  %sv_any.i39.i = getelementptr inbounds %struct.sv* %call2.i38.i, i64 0, i32 0
  %43 = load i8** %sv_any.i39.i, align 8, !tbaa !9
  %xpv_pv.i40.i = bitcast i8* %43 to i8**
  %44 = load i8** %xpv_pv.i40.i, align 8, !tbaa !10
  %45 = load i64* @my_cxt.2, align 8, !tbaa !34
  %add.i41.i = add nsw i64 %45, 1
  tail call void @llvm.memset.p0i8.i64(i8* %44, i8 0, i64 %add.i41.i, i32 1, i1 false) #3
  %46 = load i64* @my_cxt.2, align 8, !tbaa !34
  %47 = load i8** %sv_any.i39.i, align 8, !tbaa !9
  %xpv_cur.i42.i = getelementptr inbounds i8* %47, i64 8
  %48 = bitcast i8* %xpv_cur.i42.i to i64*
  store i64 %46, i64* %48, align 8, !tbaa !33
  %sv_flags.i43.i = getelementptr inbounds %struct.sv* %call2.i38.i, i64 0, i32 2
  %49 = load i64* %sv_flags.i43.i, align 8, !tbaa !7
  %and.i44.i = and i64 %49, 1223753727
  %or.i45.i = or i64 %and.i44.i, 67371008
  store i64 %or.i45.i, i64* %sv_flags.i43.i, align 8, !tbaa !7
  store %struct.sv* %call2.i38.i, %struct.sv** @my_cxt.1, align 8, !tbaa !53
  %xpv_pv.i = bitcast i8* %47 to i8**
  %50 = load i8** %xpv_pv.i, align 8, !tbaa !10
  %sub.i = add i64 %46, 4294967295
  %conv15.i = trunc i64 %sub.i to i32
  %cmp1647.i = icmp sgt i32 %conv15.i, 0
  br i1 %cmp1647.i, label %while.body.lr.ph.i, label %while.end.i

while.body.lr.ph.i:                               ; preds = %cond.end.i
  %sext.i = shl i64 %sub.i, 32
  %51 = ashr exact i64 %sext.i, 32
  %52 = shl i64 %46, 32
  %sext = add i64 %52, -4294967296
  %53 = lshr exact i64 %sext, 32
  %54 = add i64 %53, 4294967295
  %55 = trunc i64 %54 to i32
  %56 = xor i32 %55, -1
  %57 = icmp sgt i32 %56, -1
  %smax = select i1 %57, i32 %56, i32 -1
  %58 = add i32 %smax, %55
  %59 = add i32 %58, 1
  %60 = zext i32 %59 to i64
  %61 = add i64 %60, 1
  %end.idx = add i64 %60, 1
  %n.vec = and i64 %61, 8589934588
  %cmp.zero = icmp eq i64 %n.vec, 0
  %rev.ind.end = sub i64 %51, %n.vec
  br i1 %cmp.zero, label %middle.block, label %vector.body

vector.body:                                      ; preds = %while.body.lr.ph.i, %vector.body
  %index = phi i64 [ %index.next, %vector.body ], [ 0, %while.body.lr.ph.i ]
  %reverse.idx = sub i64 %51, %index
  %.sum = add i64 %reverse.idx, -4
  %62 = getelementptr i8* %50, i64 %.sum
  %63 = bitcast i8* %62 to <4 x i8>*
  store <4 x i8> <i8 -1, i8 -1, i8 -1, i8 -1>, <4 x i8>* %63, align 1
  %index.next = add i64 %index, 4
  %64 = icmp eq i64 %index.next, %n.vec
  br i1 %64, label %middle.block, label %vector.body, !llvm.loop !54

middle.block:                                     ; preds = %vector.body, %while.body.lr.ph.i
  %resume.val = phi i64 [ %51, %while.body.lr.ph.i ], [ %rev.ind.end, %vector.body ]
  %new.indc.resume.val = phi i64 [ 0, %while.body.lr.ph.i ], [ %n.vec, %vector.body ]
  %cmp.n = icmp eq i64 %end.idx, %new.indc.resume.val
  br i1 %cmp.n, label %while.end.i, label %while.body.i

while.body.i:                                     ; preds = %middle.block, %while.body.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %while.body.i ], [ %resume.val, %middle.block ]
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, -1
  %arrayidx19.i = getelementptr inbounds i8* %50, i64 %indvars.iv.next.i
  store i8 -1, i8* %arrayidx19.i, align 1, !tbaa !39
  %65 = trunc i64 %indvars.iv.next.i to i32
  %cmp16.i = icmp sgt i32 %65, 0
  br i1 %cmp16.i, label %while.body.i, label %while.end.i, !llvm.loop !55

while.end.i:                                      ; preds = %while.body.i, %middle.block, %cond.end.i
  %66 = load i32* @PL_maxo, align 4, !tbaa !18
  %and20.i = and i32 %66, 7
  %tobool.i = icmp eq i32 %and20.i, 0
  br i1 %tobool.i, label %op_names_init.exit, label %cond.true21.i

cond.true21.i:                                    ; preds = %while.end.i
  %shl.i = shl i32 255, %and20.i
  %neg.i = xor i32 %shl.i, 255
  %phitmp.i = trunc i32 %neg.i to i8
  br label %op_names_init.exit

op_names_init.exit:                               ; preds = %while.end.i, %cond.true21.i
  %cond25.i = phi i8 [ %phitmp.i, %cond.true21.i ], [ -1, %while.end.i ]
  %sub27.i = add i64 %46, -1
  %arrayidx28.i = getelementptr inbounds i8* %50, i64 %sub27.i
  store i8 %cond25.i, i8* %arrayidx28.i, align 1, !tbaa !39
  %67 = load %struct.sv** @my_cxt.1, align 8, !tbaa !53
  tail call fastcc void @put_op_bitspec(i8* getelementptr inbounds ([5 x i8]* @.str49, i64 0, i64 0), i64 0, %struct.sv* %67) #3
  %68 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.sv** %68, i64 %add
  store %struct.sv* @PL_sv_yes, %struct.sv** %arrayidx, align 8, !tbaa !1
  %69 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr34 = getelementptr inbounds %struct.sv** %69, i64 %add
  store %struct.sv** %add.ptr34, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare void @Perl_sv_setpv(%struct.sv*, i8*) #1

declare %struct.cv* @Perl_newXS(i8*, void (%struct.cv*)*, i8*) #1

declare %struct.hv* @Perl_newHV() #1

; Function Attrs: nounwind readonly
declare i64 @strlen(i8* nocapture) #2

declare %struct.sv* @Perl_newSVsv(%struct.sv*) #1

declare %struct.sv* @Perl_newSV(i64) #1

declare void @Perl_save_vptr(i8*) #1

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #3

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5 (trunk)"}
!1 = metadata !{metadata !2, metadata !2, i64 0}
!2 = metadata !{metadata !"any pointer", metadata !3, i64 0}
!3 = metadata !{metadata !"omnipotent char", metadata !4, i64 0}
!4 = metadata !{metadata !"Simple C/C++ TBAA"}
!5 = metadata !{metadata !6, metadata !6, i64 0}
!6 = metadata !{metadata !"long", metadata !3, i64 0}
!7 = metadata !{metadata !8, metadata !6, i64 16}
!8 = metadata !{metadata !"sv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!9 = metadata !{metadata !8, metadata !2, i64 0}
!10 = metadata !{metadata !11, metadata !2, i64 0}
!11 = metadata !{metadata !"xpv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!12 = metadata !{metadata !13, metadata !2, i64 0}
!13 = metadata !{metadata !"hv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!14 = metadata !{metadata !15, metadata !2, i64 80}
!15 = metadata !{metadata !"xpvhv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !16, i64 32, metadata !2, i64 40, metadata !2, i64 48, metadata !6, i64 56, metadata !2, i64 64, metadata !2, i64 72, metadata !2, i64 80}
!16 = metadata !{metadata !"double", metadata !3, i64 0}
!17 = metadata !{metadata !8, metadata !6, i64 8}
!18 = metadata !{metadata !19, metadata !19, i64 0}
!19 = metadata !{metadata !"int", metadata !3, i64 0}
!20 = metadata !{metadata !21, metadata !2, i64 0}
!21 = metadata !{metadata !"gv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!22 = metadata !{metadata !23, metadata !2, i64 56}
!23 = metadata !{metadata !"xpvgv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !16, i64 32, metadata !2, i64 40, metadata !2, i64 48, metadata !2, i64 56, metadata !2, i64 64, metadata !6, i64 72, metadata !2, i64 80, metadata !3, i64 88}
!24 = metadata !{metadata !25, metadata !2, i64 40}
!25 = metadata !{metadata !"gp", metadata !2, i64 0, metadata !6, i64 8, metadata !2, i64 16, metadata !2, i64 24, metadata !2, i64 32, metadata !2, i64 40, metadata !2, i64 48, metadata !2, i64 56, metadata !6, i64 64, metadata !6, i64 72, metadata !6, i64 80, metadata !2, i64 88}
!26 = metadata !{metadata !27, metadata !3, i64 36}
!27 = metadata !{metadata !"op", metadata !2, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !6, i64 24, metadata !28, i64 32, metadata !28, i64 34, metadata !3, i64 36, metadata !3, i64 37}
!28 = metadata !{metadata !"short", metadata !3, i64 0}
!29 = metadata !{metadata !27, metadata !3, i64 37}
!30 = metadata !{metadata !27, metadata !6, i64 24}
!31 = metadata !{metadata !32, metadata !6, i64 24}
!32 = metadata !{metadata !"xpviv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24}
!33 = metadata !{metadata !11, metadata !6, i64 8}
!34 = metadata !{metadata !35, metadata !6, i64 16}
!35 = metadata !{metadata !"", metadata !2, i64 0, metadata !2, i64 8, metadata !6, i64 16, metadata !19, i64 24}
!36 = metadata !{metadata !36, metadata !37, metadata !38}
!37 = metadata !{metadata !"llvm.vectorizer.width", i32 1}
!38 = metadata !{metadata !"llvm.vectorizer.unroll", i32 1}
!39 = metadata !{metadata !3, metadata !3, i64 0}
!40 = metadata !{metadata !40, metadata !37, metadata !38}
!41 = metadata !{metadata !35, metadata !2, i64 0}
!42 = metadata !{metadata !42, metadata !37, metadata !38}
!43 = metadata !{metadata !43, metadata !37, metadata !38}
!44 = metadata !{metadata !44, metadata !37, metadata !38}
!45 = metadata !{metadata !45, metadata !37, metadata !38}
!46 = metadata !{metadata !47, metadata !2, i64 0}
!47 = metadata !{metadata !"cv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!48 = metadata !{metadata !49, metadata !2, i64 96}
!49 = metadata !{metadata !"xpvcv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !16, i64 32, metadata !2, i64 40, metadata !2, i64 48, metadata !2, i64 56, metadata !2, i64 64, metadata !2, i64 72, metadata !2, i64 80, metadata !3, i64 88, metadata !2, i64 96, metadata !2, i64 104, metadata !6, i64 112, metadata !2, i64 120, metadata !2, i64 128, metadata !28, i64 136, metadata !6, i64 144}
!50 = metadata !{metadata !23, metadata !2, i64 64}
!51 = metadata !{metadata !52, metadata !2, i64 0}
!52 = metadata !{metadata !"xrv", metadata !2, i64 0}
!53 = metadata !{metadata !35, metadata !2, i64 8}
!54 = metadata !{metadata !54, metadata !37, metadata !38}
!55 = metadata !{metadata !55, metadata !37, metadata !38}
