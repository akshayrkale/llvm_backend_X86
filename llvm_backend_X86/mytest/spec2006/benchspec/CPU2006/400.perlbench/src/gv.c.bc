; ModuleID = 'gv.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.hv = type { %struct.xpvhv*, i64, i64 }
%struct.xpvhv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, i64, %struct.he*, %struct.pmop*, i8* }
%struct.magic = type { %struct.magic*, %struct.mgvtbl*, i16, i8, i8, %struct.sv*, i8*, i64 }
%struct.mgvtbl = type { i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i64 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)*, i32 (%struct.magic*, %struct.clone_params*)* }
%struct.clone_params = type { %struct.av*, i64, %struct.interpreter* }
%struct.av = type { %struct.xpvav*, i64, i64 }
%struct.xpvav = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.sv**, %struct.sv*, i8 }
%struct.interpreter = type { i8 }
%struct.sv = type { i8*, i64, i64 }
%struct.he = type { %struct.he*, %struct.hek*, %struct.sv* }
%struct.hek = type { i64, i64, [1 x i8] }
%struct.pmop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.pmop*, %struct.regexp*, i64, i64, i8, %struct.hv* }
%struct.op = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8 }
%struct.regexp = type { i64*, i64*, %struct.regnode*, %struct.reg_substr_data*, i8*, %struct.reg_data*, i8*, i64*, i64, i64, i64, i64, i64, i64, i64, i64, [1 x %struct.regnode] }
%struct.regnode = type { i8, i8, i16 }
%struct.reg_substr_data = type opaque
%struct.reg_data = type opaque
%struct.cop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, i8*, %struct.hv*, %struct.gv*, i64, i64, i64, %struct.sv*, %struct.sv* }
%struct.gv = type { %struct.xpvgv*, i64, i64 }
%struct.xpvgv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.gp*, i8*, i64, %struct.hv*, i8 }
%struct.gp = type { %struct.sv*, i64, %struct.io*, %struct.cv*, %struct.av*, %struct.hv*, %struct.gv*, %struct.cv*, i64, i64, i64, i8* }
%struct.io = type { %struct.xpvio*, i64, i64 }
%struct.xpvio = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct._PerlIO**, %struct._PerlIO**, %union.anon, i64, i64, i64, i64, i8*, %struct.gv*, i8*, %struct.gv*, i8*, %struct.gv*, i16, i8, i8 }
%struct._PerlIO = type opaque
%union.anon = type { %struct.__dirstream* }
%struct.__dirstream = type opaque
%struct.cv = type { %struct.xpvcv*, i64, i64 }
%struct.xpvcv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.hv*, %struct.op*, %struct.op*, void (%struct.cv*)*, %union.any, %struct.gv*, i8*, i64, %struct.av*, %struct.cv*, i16, i64 }
%union.any = type { i8* }
%struct.xpv = type { i8*, i64, i64 }
%struct.jmpenv = type { [1 x %struct.__jmp_buf_tag], %struct.jmpenv*, i32, i8 }
%struct.__jmp_buf_tag = type { [8 x i64], i64, [16 x i64] }
%struct.stackinfo = type { %struct.av*, %struct.context*, i64, i64, i64, %struct.stackinfo*, %struct.stackinfo*, i64 }
%struct.context = type { i64, %union.anon.0 }
%union.anon.0 = type { %struct.block }
%struct.block = type { i64, %struct.cop*, i64, i64, i64, %struct.pmop*, i8, %union.anon.1 }
%union.anon.1 = type { %struct.block_loop }
%struct.block_loop = type { i8*, i64, %struct.op*, %struct.op*, %struct.op*, %struct.sv**, %struct.sv*, %struct.sv*, %struct.av*, i64, i64 }
%struct.am_table = type { i64, i64, i64, [66 x %struct.cv*], i64 }
%struct.binop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op* }

@.str = private unnamed_addr constant [21 x i8] c"Bad symbol for array\00", align 1
@.str1 = private unnamed_addr constant [20 x i8] c"Bad symbol for hash\00", align 1
@.str2 = private unnamed_addr constant [26 x i8] c"Bad symbol for filehandle\00", align 1
@PL_defstash = external global %struct.hv*
@PL_perldb = external global i64
@PL_curcop = external global %struct.cop*
@.str3 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@PL_Sv = external global %struct.sv*
@PL_compcv = external global %struct.cv*
@PL_sub_generation = external global i64
@PL_curstash = external global %struct.hv*
@.str4 = private unnamed_addr constant [10 x i8] c"UNIVERSAL\00", align 1
@.str5 = private unnamed_addr constant [51 x i8] c"Can't use anonymous symbol table for method lookup\00", align 1
@.str6 = private unnamed_addr constant [77 x i8] c"Recursive inheritance detected while looking for method '%s' in package '%s'\00", align 1
@.str7 = private unnamed_addr constant [4 x i8] c"ISA\00", align 1
@PL_sv_undef = external global %struct.sv
@.str8 = private unnamed_addr constant [8 x i8] c"::SUPER\00", align 1
@.str9 = private unnamed_addr constant [22 x i8] c"Cannot create %s::ISA\00", align 1
@PL_dowarn = external global i8
@.str10 = private unnamed_addr constant [37 x i8] c"Can't locate package %_ for @%s::ISA\00", align 1
@.str11 = private unnamed_addr constant [6 x i8] c"SUPER\00", align 1
@.str12 = private unnamed_addr constant [10 x i8] c"%s::SUPER\00", align 1
@.str13 = private unnamed_addr constant [7 x i8] c"import\00", align 1
@.str14 = private unnamed_addr constant [9 x i8] c"unimport\00", align 1
@PL_sv_yes = external global %struct.sv
@Perl_gv_autoload4.autoload = private unnamed_addr constant [9 x i8] c"AUTOLOAD\00", align 1
@.str15 = private unnamed_addr constant [66 x i8] c"Use of inherited AUTOLOAD for non-method %s::%.*s() is deprecated\00", align 1
@.str16 = private unnamed_addr constant [3 x i8] c"::\00", align 1
@PL_tainting = external global i8
@.str17 = private unnamed_addr constant [7 x i8] c"main::\00", align 1
@.str18 = private unnamed_addr constant [4 x i8] c"INC\00", align 1
@.str19 = private unnamed_addr constant [4 x i8] c"ENV\00", align 1
@.str20 = private unnamed_addr constant [4 x i8] c"SIG\00", align 1
@.str21 = private unnamed_addr constant [6 x i8] c"STDIN\00", align 1
@.str22 = private unnamed_addr constant [7 x i8] c"STDOUT\00", align 1
@.str23 = private unnamed_addr constant [7 x i8] c"STDERR\00", align 1
@.str24 = private unnamed_addr constant [5 x i8] c"ARGV\00", align 1
@.str25 = private unnamed_addr constant [8 x i8] c"ARGVOUT\00", align 1
@PL_compiling = external global %struct.cop
@PL_hints = external global i64
@.str26 = private unnamed_addr constant [32 x i8] c"Variable \22%c%s\22 is not imported\00", align 1
@.str27 = private unnamed_addr constant [30 x i8] c"\09(Did you mean &%s instead?)\0A\00", align 1
@.str28 = private unnamed_addr constant [52 x i8] c"Global symbol \22%s%s\22 requires explicit package name\00", align 1
@.str29 = private unnamed_addr constant [2 x i8] c"$\00", align 1
@.str30 = private unnamed_addr constant [2 x i8] c"@\00", align 1
@.str31 = private unnamed_addr constant [2 x i8] c"%\00", align 1
@PL_nullstash = external global %struct.hv*
@.str32 = private unnamed_addr constant [30 x i8] c"Had to create %s unexpectedly\00", align 1
@.str33 = private unnamed_addr constant [4 x i8] c"RGV\00", align 1
@.str34 = private unnamed_addr constant [6 x i8] c"XPORT\00", align 1
@.str35 = private unnamed_addr constant [3 x i8] c"SA\00", align 1
@.str36 = private unnamed_addr constant [17 x i8] c"AnyDBM_File::ISA\00", align 1
@.str37 = private unnamed_addr constant [10 x i8] c"NDBM_File\00", align 1
@.str38 = private unnamed_addr constant [8 x i8] c"DB_File\00", align 1
@.str39 = private unnamed_addr constant [10 x i8] c"GDBM_File\00", align 1
@.str40 = private unnamed_addr constant [10 x i8] c"SDBM_File\00", align 1
@.str41 = private unnamed_addr constant [10 x i8] c"ODBM_File\00", align 1
@.str42 = private unnamed_addr constant [8 x i8] c"VERLOAD\00", align 1
@.str43 = private unnamed_addr constant [3 x i8] c"IG\00", align 1
@PL_psig_ptr = external global %struct.sv**
@PL_psig_name = external global %struct.sv**
@PL_psig_pend = external global i32*
@PL_sig_name = external global [0 x i8*]
@.str44 = private unnamed_addr constant [7 x i8] c"ERSION\00", align 1
@.str45 = private unnamed_addr constant [8 x i8] c"NCODING\00", align 1
@.str46 = private unnamed_addr constant [4 x i8] c"PEN\00", align 1
@.str47 = private unnamed_addr constant [5 x i8] c"AINT\00", align 1
@.str48 = private unnamed_addr constant [7 x i8] c"NICODE\00", align 1
@.str49 = private unnamed_addr constant [10 x i8] c"TF8LOCALE\00", align 1
@.str50 = private unnamed_addr constant [12 x i8] c"ARNING_BITS\00", align 1
@PL_sawampersand = external global i8
@PL_chopset = external global i8*
@.str51 = private unnamed_addr constant [25 x i8] c"Use of $%s is deprecated\00", align 1
@PL_defoutgv = external global %struct.gv*
@.str52 = private unnamed_addr constant [2 x i8] c"\0C\00", align 1
@PL_formfeed = external global %struct.sv*
@.str53 = private unnamed_addr constant [2 x i8] c"\1C\00", align 1
@.str54 = private unnamed_addr constant [6 x i8] c"%8.6f\00", align 1
@PL_patchlevel = external global %struct.sv*
@.str55 = private unnamed_addr constant [9 x i8] c"__ANON__\00", align 1
@.str56 = private unnamed_addr constant [5 x i8] c"main\00", align 1
@.str57 = private unnamed_addr constant [2 x i8] c"*\00", align 1
@PL_stashcache = external global %struct.hv*
@.str58 = private unnamed_addr constant [13 x i8] c"FileHandle::\00", align 1
@.str59 = private unnamed_addr constant [13 x i8] c"IO::Handle::\00", align 1
@.str60 = private unnamed_addr constant [6 x i8] c"/lib/\00", align 1
@.str61 = private unnamed_addr constant [4 x i8] c".pm\00", align 1
@.str62 = private unnamed_addr constant [44 x i8] c"Name \22%s::%s\22 used only once: possible typo\00", align 1
@.str63 = private unnamed_addr constant [13 x i8] c"%s::_GEN_%ld\00", align 1
@PL_gensym = external global i64
@.str64 = private unnamed_addr constant [43 x i8] c"Attempt to free unreferenced glob pointers\00", align 1
@PL_amagic_generation = external global i64
@PL_AMG_names = external global [66 x i8*]
@PL_Xpv = external global %struct.xpv*
@.str65 = private unnamed_addr constant [4 x i8] c"nil\00", align 1
@.str66 = private unnamed_addr constant [9 x i8] c"overload\00", align 1
@.str67 = private unnamed_addr constant [4 x i8] c"???\00", align 1
@.str68 = private unnamed_addr constant [56 x i8] c"%s method `%.256s' overloading `%s' in package `%.256s'\00", align 1
@.str69 = private unnamed_addr constant [27 x i8] c"Stub found while resolving\00", align 1
@.str70 = private unnamed_addr constant [14 x i8] c"Can't resolve\00", align 1
@.str71 = private unnamed_addr constant [52 x i8] c"Operation `%s': no method found,%sargument %s%s%s%s\00", align 1
@.str72 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str73 = private unnamed_addr constant [8 x i8] c"\0A\09left \00", align 1
@.str74 = private unnamed_addr constant [23 x i8] c"in overloaded package \00", align 1
@.str75 = private unnamed_addr constant [24 x i8] c"has no overloaded magic\00", align 1
@.str76 = private unnamed_addr constant [41 x i8] c",\0A\09right argument in overloaded package \00", align 1
@.str77 = private unnamed_addr constant [42 x i8] c",\0A\09right argument has no overloaded magic\00", align 1
@.str78 = private unnamed_addr constant [3 x i8] c"%_\00", align 1
@PL_stack_sp = external global %struct.sv**
@PL_top_env = external global %struct.jmpenv*
@PL_curstackinfo = external global %struct.stackinfo*
@PL_stack_base = external global %struct.sv**
@PL_curstack = external global %struct.av*
@PL_stack_max = external global %struct.sv**
@PL_op = external global %struct.op*
@PL_debstash = external global %struct.hv*
@PL_sv_no = external global %struct.sv
@PL_runops = external global i32 ()*
@PL_stderrgv = external global %struct.gv*
@.str79 = private unnamed_addr constant [17 x i8] c"panic: POPSTACK\0A\00", align 1
@.str80 = private unnamed_addr constant [39 x i8] c"Copy method did not return a reference\00", align 1

; Function Attrs: nounwind uwtable
define %struct.gv* @Perl_gv_AVadd(%struct.gv* readonly %gv) #0 {
entry:
  %tobool = icmp eq %struct.gv* %gv, null
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = getelementptr inbounds %struct.gv* %gv, i64 0, i32 2
  %1 = load i64* %0, align 8, !tbaa !1
  %and = and i64 %1, 255
  %cmp = icmp eq i64 %and, 13
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([21 x i8]* @.str, i64 0, i64 0)) #2
  br label %if.end

if.end:                                           ; preds = %lor.lhs.false, %if.then
  %sv_any = getelementptr inbounds %struct.gv* %gv, i64 0, i32 0
  %2 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %2, i64 0, i32 7
  %3 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_av = getelementptr inbounds %struct.gp* %3, i64 0, i32 4
  %4 = load %struct.av** %gp_av, align 8, !tbaa !12
  %tobool1 = icmp eq %struct.av* %4, null
  br i1 %tobool1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  %call = tail call %struct.av* @Perl_newAV() #2
  %5 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp4 = getelementptr inbounds %struct.xpvgv* %5, i64 0, i32 7
  %6 = load %struct.gp** %xgv_gp4, align 8, !tbaa !9
  %gp_av5 = getelementptr inbounds %struct.gp* %6, i64 0, i32 4
  store %struct.av* %call, %struct.av** %gp_av5, align 8, !tbaa !12
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then2
  ret %struct.gv* %gv
}

declare void @Perl_croak(i8*, ...) #1

declare %struct.av* @Perl_newAV() #1

; Function Attrs: nounwind uwtable
define %struct.gv* @Perl_gv_HVadd(%struct.gv* readonly %gv) #0 {
entry:
  %tobool = icmp eq %struct.gv* %gv, null
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = getelementptr inbounds %struct.gv* %gv, i64 0, i32 2
  %1 = load i64* %0, align 8, !tbaa !1
  %and = and i64 %1, 255
  %cmp = icmp eq i64 %and, 13
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([20 x i8]* @.str1, i64 0, i64 0)) #2
  br label %if.end

if.end:                                           ; preds = %lor.lhs.false, %if.then
  %sv_any = getelementptr inbounds %struct.gv* %gv, i64 0, i32 0
  %2 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %2, i64 0, i32 7
  %3 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_hv = getelementptr inbounds %struct.gp* %3, i64 0, i32 5
  %4 = load %struct.hv** %gp_hv, align 8, !tbaa !14
  %tobool1 = icmp eq %struct.hv* %4, null
  br i1 %tobool1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  %call = tail call %struct.hv* @Perl_newHV() #2
  %5 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp4 = getelementptr inbounds %struct.xpvgv* %5, i64 0, i32 7
  %6 = load %struct.gp** %xgv_gp4, align 8, !tbaa !9
  %gp_hv5 = getelementptr inbounds %struct.gp* %6, i64 0, i32 5
  store %struct.hv* %call, %struct.hv** %gp_hv5, align 8, !tbaa !14
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then2
  ret %struct.gv* %gv
}

declare %struct.hv* @Perl_newHV() #1

; Function Attrs: nounwind uwtable
define %struct.gv* @Perl_gv_IOadd(%struct.gv* readonly %gv) #0 {
entry:
  %tobool = icmp eq %struct.gv* %gv, null
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = getelementptr inbounds %struct.gv* %gv, i64 0, i32 2
  %1 = load i64* %0, align 8, !tbaa !1
  %and = and i64 %1, 255
  %cmp = icmp eq i64 %and, 13
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([26 x i8]* @.str2, i64 0, i64 0)) #2
  br label %if.end

if.end:                                           ; preds = %lor.lhs.false, %if.then
  %sv_any = getelementptr inbounds %struct.gv* %gv, i64 0, i32 0
  %2 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %2, i64 0, i32 7
  %3 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_io = getelementptr inbounds %struct.gp* %3, i64 0, i32 2
  %4 = load %struct.io** %gp_io, align 8, !tbaa !15
  %tobool1 = icmp eq %struct.io* %4, null
  br i1 %tobool1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  %call = tail call %struct.io* @Perl_newIO()
  %5 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp4 = getelementptr inbounds %struct.xpvgv* %5, i64 0, i32 7
  %6 = load %struct.gp** %xgv_gp4, align 8, !tbaa !9
  %gp_io5 = getelementptr inbounds %struct.gp* %6, i64 0, i32 2
  store %struct.io* %call, %struct.io** %gp_io5, align 8, !tbaa !15
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then2
  ret %struct.gv* %gv
}

; Function Attrs: nounwind uwtable
define %struct.io* @Perl_newIO() #0 {
entry:
  %call = tail call %struct.sv* @Perl_newSV(i64 0) #2
  %0 = bitcast %struct.sv* %call to %struct.io*
  %call1 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %call, i64 15) #2
  %1 = getelementptr inbounds %struct.sv* %call, i64 0, i32 1
  store i64 1, i64* %1, align 8, !tbaa !16
  %2 = getelementptr inbounds %struct.sv* %call, i64 0, i32 2
  %3 = load i64* %2, align 8, !tbaa !18
  %or = or i64 %3, 4096
  store i64 %or, i64* %2, align 8, !tbaa !18
  %4 = load %struct.hv** @PL_stashcache, align 8, !tbaa !19
  tail call void @Perl_hv_clear(%struct.hv* %4) #2
  %call2 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([13 x i8]* @.str58, i64 0, i64 0), i64 0, i64 11)
  %tobool = icmp eq %struct.gv* %call2, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %sv_any = getelementptr inbounds %struct.gv* %call2, i64 0, i32 0
  %5 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %5, i64 0, i32 7
  %6 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_hv = getelementptr inbounds %struct.gp* %6, i64 0, i32 5
  %7 = load %struct.hv** %gp_hv, align 8, !tbaa !14
  %tobool3 = icmp eq %struct.hv* %7, null
  br i1 %tobool3, label %if.end, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %sv_any8 = getelementptr inbounds %struct.hv* %7, i64 0, i32 0
  %8 = load %struct.xpvhv** %sv_any8, align 8, !tbaa !20
  %9 = bitcast %struct.xpvhv* %8 to %struct.he***
  %10 = load %struct.he*** %9, align 8, !tbaa !19
  %tobool9 = icmp eq %struct.he** %10, null
  br i1 %tobool9, label %if.end, label %if.end.thread

if.end.thread:                                    ; preds = %land.lhs.true4
  %11 = bitcast %struct.hv* %7 to %struct.sv*
  store %struct.sv* %11, %struct.sv** @PL_Sv, align 8, !tbaa !19
  br label %land.rhs

if.end:                                           ; preds = %entry, %land.lhs.true, %land.lhs.true4
  %call10 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([13 x i8]* @.str59, i64 0, i64 0), i64 1, i64 11)
  %sv_any11.phi.trans.insert = getelementptr inbounds %struct.gv* %call10, i64 0, i32 0
  %.pre = load %struct.xpvgv** %sv_any11.phi.trans.insert, align 8, !tbaa !7
  %xgv_gp12.phi.trans.insert = getelementptr inbounds %struct.xpvgv* %.pre, i64 0, i32 7
  %.pre25 = load %struct.gp** %xgv_gp12.phi.trans.insert, align 8, !tbaa !9
  %gp_hv13.phi.trans.insert = getelementptr inbounds %struct.gp* %.pre25, i64 0, i32 5
  %.pre26 = load %struct.hv** %gp_hv13.phi.trans.insert, align 8, !tbaa !14
  %12 = bitcast %struct.hv* %.pre26 to %struct.sv*
  store %struct.sv* %12, %struct.sv** @PL_Sv, align 8, !tbaa !19
  %tobool14 = icmp eq %struct.hv* %.pre26, null
  br i1 %tobool14, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end.thread, %if.end
  %13 = phi %struct.hv* [ %7, %if.end.thread ], [ %.pre26, %if.end ]
  %14 = getelementptr inbounds %struct.hv* %13, i64 0, i32 1
  %15 = load i64* %14, align 8, !tbaa !22
  %inc = add i64 %15, 1
  store i64 %inc, i64* %14, align 8, !tbaa !22
  br label %land.end

land.end:                                         ; preds = %if.end, %land.rhs
  %16 = phi %struct.hv* [ null, %if.end ], [ %13, %land.rhs ]
  %sv_any17 = bitcast %struct.sv* %call to %struct.xpvio**
  %17 = load %struct.xpvio** %sv_any17, align 8, !tbaa !23
  %18 = getelementptr inbounds %struct.xpvio* %17, i64 0, i32 6
  store %struct.hv* %16, %struct.hv** %18, align 8, !tbaa !24
  ret %struct.io* %0
}

; Function Attrs: nounwind uwtable
define %struct.gv* @Perl_gv_fetchfile(i8* %name) #0 {
entry:
  %smallbuf = alloca [256 x i8], align 16
  %0 = getelementptr inbounds [256 x i8]* %smallbuf, i64 0, i64 0
  call void @llvm.lifetime.start(i64 256, i8* %0) #2
  %1 = load %struct.hv** @PL_defstash, align 8, !tbaa !19
  %tobool = icmp eq %struct.hv* %1, null
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i64 @strlen(i8* %name) #2
  %add = add i64 %call, 2
  %cmp = icmp ult i64 %add, 256
  br i1 %cmp, label %if.end4, label %if.else

if.else:                                          ; preds = %if.end
  %add2 = add i64 %call, 3
  %call3 = call i8* @Perl_safesysmalloc(i64 %add2) #2
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.else
  %tmpbuf.0 = phi i8* [ %call3, %if.else ], [ %0, %if.end ]
  store i8 95, i8* %tmpbuf.0, align 1, !tbaa !26
  %arrayidx5 = getelementptr inbounds i8* %tmpbuf.0, i64 1
  store i8 60, i8* %arrayidx5, align 1, !tbaa !26
  %add.ptr = getelementptr inbounds i8* %tmpbuf.0, i64 2
  %call6 = call i8* @strcpy(i8* %add.ptr, i8* %name) #2
  %2 = load %struct.hv** @PL_defstash, align 8, !tbaa !19
  %call7 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %2, i8* %tmpbuf.0, i64 %add, i64 1) #2
  %3 = load %struct.sv** %call7, align 8
  %4 = bitcast %struct.sv* %3 to %struct.gv*
  %5 = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %6 = load i64* %5, align 8, !tbaa !27
  %and = and i64 %6, 255
  %cmp8 = icmp eq i64 %and, 13
  br i1 %cmp8, label %if.end28, label %if.then9

if.then9:                                         ; preds = %if.end4
  %7 = load %struct.hv** @PL_defstash, align 8, !tbaa !19
  call void @Perl_gv_init(%struct.gv* %4, %struct.hv* %7, i8* %tmpbuf.0, i64 %add, i32 0)
  %sv_any = bitcast %struct.sv* %3 to %struct.xpvgv**
  %8 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %8, i64 0, i32 7
  %9 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_sv = getelementptr inbounds %struct.gp* %9, i64 0, i32 0
  %10 = load %struct.sv** %gp_sv, align 8, !tbaa !28
  call void @Perl_sv_setpv(%struct.sv* %10, i8* %name) #2
  %11 = load i64* @PL_perldb, align 8, !tbaa !29
  %and11 = and i64 %11, 2
  %tobool12 = icmp eq i64 %and11, 0
  br i1 %tobool12, label %if.end28, label %if.then13

if.then13:                                        ; preds = %if.then9
  %tobool.i = icmp eq %struct.sv* %3, null
  br i1 %tobool.i, label %if.then.i, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.then13
  %12 = load i64* %5, align 8, !tbaa !1
  %and.i = and i64 %12, 255
  %cmp.i = icmp eq i64 %and.i, 13
  br i1 %cmp.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %lor.lhs.false.i, %if.then13
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([21 x i8]* @.str, i64 0, i64 0)) #2
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %lor.lhs.false.i
  %13 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp.i = getelementptr inbounds %struct.xpvgv* %13, i64 0, i32 7
  %14 = load %struct.gp** %xgv_gp.i, align 8, !tbaa !9
  %gp_av.i = getelementptr inbounds %struct.gp* %14, i64 0, i32 4
  %15 = load %struct.av** %gp_av.i, align 8, !tbaa !12
  %tobool1.i = icmp eq %struct.av* %15, null
  br i1 %tobool1.i, label %if.then2.i, label %Perl_gv_AVadd.exit

if.then2.i:                                       ; preds = %if.end.i
  %call.i = call %struct.av* @Perl_newAV() #2
  %16 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp4.i = getelementptr inbounds %struct.xpvgv* %16, i64 0, i32 7
  %17 = load %struct.gp** %xgv_gp4.i, align 8, !tbaa !9
  %gp_av5.i = getelementptr inbounds %struct.gp* %17, i64 0, i32 4
  store %struct.av* %call.i, %struct.av** %gp_av5.i, align 8, !tbaa !12
  br label %Perl_gv_AVadd.exit

Perl_gv_AVadd.exit:                               ; preds = %if.end.i, %if.then2.i
  %18 = phi %struct.gp* [ %14, %if.end.i ], [ %17, %if.then2.i ]
  %19 = phi %struct.xpvgv* [ %13, %if.end.i ], [ %16, %if.then2.i ]
  %gp_hv = getelementptr inbounds %struct.gp* %18, i64 0, i32 5
  %20 = load %struct.hv** %gp_hv, align 8, !tbaa !14
  %tobool17 = icmp eq %struct.hv* %20, null
  br i1 %tobool.i, label %if.then.i54, label %lor.lhs.false.i53

lor.lhs.false.i53:                                ; preds = %Perl_gv_AVadd.exit
  %21 = load i64* %5, align 8, !tbaa !1
  %and.i51 = and i64 %21, 255
  %cmp.i52 = icmp eq i64 %and.i51, 13
  br i1 %cmp.i52, label %if.end.i59, label %if.then.i54

if.then.i54:                                      ; preds = %lor.lhs.false.i53, %Perl_gv_AVadd.exit
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([21 x i8]* @.str, i64 0, i64 0)) #2
  %.pre = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp.i56.phi.trans.insert = getelementptr inbounds %struct.xpvgv* %.pre, i64 0, i32 7
  %.pre77 = load %struct.gp** %xgv_gp.i56.phi.trans.insert, align 8, !tbaa !9
  br label %if.end.i59

if.end.i59:                                       ; preds = %if.then.i54, %lor.lhs.false.i53
  %22 = phi %struct.gp* [ %.pre77, %if.then.i54 ], [ %18, %lor.lhs.false.i53 ]
  %23 = phi %struct.xpvgv* [ %.pre, %if.then.i54 ], [ %19, %lor.lhs.false.i53 ]
  %gp_av.i57 = getelementptr inbounds %struct.gp* %22, i64 0, i32 4
  %24 = load %struct.av** %gp_av.i57, align 8, !tbaa !12
  %tobool1.i58 = icmp eq %struct.av* %24, null
  br i1 %tobool1.i58, label %if.then2.i63, label %Perl_gv_AVadd.exit64

if.then2.i63:                                     ; preds = %if.end.i59
  %call.i60 = call %struct.av* @Perl_newAV() #2
  %25 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp4.i61 = getelementptr inbounds %struct.xpvgv* %25, i64 0, i32 7
  %26 = load %struct.gp** %xgv_gp4.i61, align 8, !tbaa !9
  %gp_av5.i62 = getelementptr inbounds %struct.gp* %26, i64 0, i32 4
  store %struct.av* %call.i60, %struct.av** %gp_av5.i62, align 8, !tbaa !12
  br label %Perl_gv_AVadd.exit64

Perl_gv_AVadd.exit64:                             ; preds = %if.end.i59, %if.then2.i63
  %27 = phi %struct.xpvgv* [ %23, %if.end.i59 ], [ %25, %if.then2.i63 ]
  br i1 %tobool17, label %cond.false, label %cond.end

cond.false:                                       ; preds = %Perl_gv_AVadd.exit64
  br i1 %tobool.i, label %if.then.i69, label %lor.lhs.false.i68

lor.lhs.false.i68:                                ; preds = %cond.false
  %28 = load i64* %5, align 8, !tbaa !1
  %and.i66 = and i64 %28, 255
  %cmp.i67 = icmp eq i64 %and.i66, 13
  br i1 %cmp.i67, label %if.end.i73, label %if.then.i69

if.then.i69:                                      ; preds = %lor.lhs.false.i68, %cond.false
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([20 x i8]* @.str1, i64 0, i64 0)) #2
  %.pre78 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  br label %if.end.i73

if.end.i73:                                       ; preds = %if.then.i69, %lor.lhs.false.i68
  %29 = phi %struct.xpvgv* [ %.pre78, %if.then.i69 ], [ %27, %lor.lhs.false.i68 ]
  %xgv_gp.i71 = getelementptr inbounds %struct.xpvgv* %29, i64 0, i32 7
  %30 = load %struct.gp** %xgv_gp.i71, align 8, !tbaa !9
  %gp_hv.i = getelementptr inbounds %struct.gp* %30, i64 0, i32 5
  %31 = load %struct.hv** %gp_hv.i, align 8, !tbaa !14
  %tobool1.i72 = icmp eq %struct.hv* %31, null
  br i1 %tobool1.i72, label %if.then2.i76, label %cond.end

if.then2.i76:                                     ; preds = %if.end.i73
  %call.i74 = call %struct.hv* @Perl_newHV() #2
  %32 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp4.i75 = getelementptr inbounds %struct.xpvgv* %32, i64 0, i32 7
  %33 = load %struct.gp** %xgv_gp4.i75, align 8, !tbaa !9
  %gp_hv5.i = getelementptr inbounds %struct.gp* %33, i64 0, i32 5
  store %struct.hv* %call.i74, %struct.hv** %gp_hv5.i, align 8, !tbaa !14
  br label %cond.end

cond.end:                                         ; preds = %if.then2.i76, %if.end.i73, %Perl_gv_AVadd.exit64
  %.pn49 = load %struct.xpvgv** %sv_any, align 8
  %.pn.in = getelementptr inbounds %struct.xpvgv* %.pn49, i64 0, i32 7
  %.pn = load %struct.gp** %.pn.in, align 8
  %cond.in = getelementptr inbounds %struct.gp* %.pn, i64 0, i32 5
  %cond = load %struct.hv** %cond.in, align 8
  call void @Perl_hv_magic(%struct.hv* %cond, %struct.gv* null, i32 76) #2
  br label %if.end28

if.end28:                                         ; preds = %if.then9, %cond.end, %if.end4
  %cmp30 = icmp eq i8* %tmpbuf.0, %0
  br i1 %cmp30, label %cleanup, label %if.then31

if.then31:                                        ; preds = %if.end28
  call void @Perl_safesysfree(i8* %tmpbuf.0) #2
  br label %cleanup

cleanup:                                          ; preds = %if.then31, %if.end28, %entry
  %retval.0 = phi %struct.gv* [ null, %entry ], [ %4, %if.end28 ], [ %4, %if.then31 ]
  call void @llvm.lifetime.end(i64 256, i8* %0) #2
  ret %struct.gv* %retval.0
}

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #2

; Function Attrs: nounwind readonly
declare i64 @strlen(i8* nocapture) #3

declare i8* @Perl_safesysmalloc(i64) #1

; Function Attrs: nounwind
declare i8* @strcpy(i8*, i8* nocapture readonly) #4

declare %struct.sv** @Perl_hv_fetch(%struct.hv*, i8*, i64, i64) #1

; Function Attrs: nounwind uwtable
define void @Perl_gv_init(%struct.gv* %gv, %struct.hv* %stash, i8* %name, i64 %len, i32 %multi) #0 {
entry:
  %sv_flags = getelementptr inbounds %struct.gv* %gv, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !27
  %and = and i64 %0, 255
  %cmp = icmp ne i64 %and, 0
  %cmp.not = xor i1 %cmp, true
  %and4 = and i64 %0, 262144
  %tobool5 = icmp eq i64 %and4, 0
  %or.cond = or i1 %tobool5, %cmp.not
  %sv_any6.pre = getelementptr inbounds %struct.gv* %gv, i64 0, i32 0
  br i1 %or.cond, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %1 = load %struct.xpvgv** %sv_any6.pre, align 8, !tbaa !7
  %xpv_pv = getelementptr inbounds %struct.xpvgv* %1, i64 0, i32 0
  %2 = load i8** %xpv_pv, align 8, !tbaa !30
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.true
  %cond = phi i8* [ %2, %cond.true ], [ null, %entry ]
  %3 = bitcast %struct.gv* %gv to %struct.sv*
  %call = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %3, i64 13) #2
  %4 = load %struct.xpvgv** %sv_any6.pre, align 8, !tbaa !7
  %5 = getelementptr inbounds %struct.xpvgv* %4, i64 0, i32 2
  %6 = load i64* %5, align 8, !tbaa !32
  %tobool7 = icmp eq i64 %6, 0
  br i1 %tobool7, label %if.end18, label %if.then

if.then:                                          ; preds = %cond.end
  %tobool8 = icmp eq i8* %cond, null
  %xpv_pv11 = getelementptr inbounds %struct.xpvgv* %4, i64 0, i32 0
  br i1 %tobool8, label %if.else, label %if.then9

if.then9:                                         ; preds = %if.then
  store i8* null, i8** %xpv_pv11, align 8, !tbaa !30
  store i64 0, i64* %5, align 8, !tbaa !32
  %7 = load i64* %sv_flags, align 8, !tbaa !27
  %and15 = and i64 %7, -67371009
  store i64 %and15, i64* %sv_flags, align 8, !tbaa !27
  br label %if.end18

if.else:                                          ; preds = %if.then
  %8 = load i8** %xpv_pv11, align 8, !tbaa !30
  tail call void @Perl_safesysfree(i8* %8) #2
  br label %if.end18

if.end18:                                         ; preds = %cond.end, %if.then9, %if.else
  %call19 = tail call i8* @Perl_safesysmalloc(i64 96) #2
  tail call void @llvm.memset.p0i8.i64(i8* %call19, i8 0, i64 96, i32 1, i1 false)
  %tobool.i = icmp eq i8* %call19, null
  br i1 %tobool.i, label %Perl_gp_ref.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end18
  %9 = bitcast i8* %call19 to %struct.gp*
  %gp_refcnt.i = getelementptr inbounds i8* %call19, i64 8
  %10 = bitcast i8* %gp_refcnt.i to i64*
  store i64 1, i64* %10, align 8, !tbaa !33
  br label %Perl_gp_ref.exit

Perl_gp_ref.exit:                                 ; preds = %if.end.i, %if.end18
  %retval.0.i = phi %struct.gp* [ null, %if.end18 ], [ %9, %if.end.i ]
  %11 = load %struct.xpvgv** %sv_any6.pre, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %11, i64 0, i32 7
  store %struct.gp* %retval.0.i, %struct.gp** %xgv_gp, align 8, !tbaa !9
  %call22 = tail call %struct.sv* @Perl_newSV(i64 0) #2
  %12 = load %struct.xpvgv** %sv_any6.pre, align 8, !tbaa !7
  %xgv_gp24 = getelementptr inbounds %struct.xpvgv* %12, i64 0, i32 7
  %13 = load %struct.gp** %xgv_gp24, align 8, !tbaa !9
  %gp_sv = getelementptr inbounds %struct.gp* %13, i64 0, i32 0
  store %struct.sv* %call22, %struct.sv** %gp_sv, align 8, !tbaa !28
  %14 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_line = getelementptr inbounds %struct.cop* %14, i64 0, i32 13
  %15 = load i64* %cop_line, align 8, !tbaa !34
  %16 = load %struct.xpvgv** %sv_any6.pre, align 8, !tbaa !7
  %xgv_gp26 = getelementptr inbounds %struct.xpvgv* %16, i64 0, i32 7
  %17 = load %struct.gp** %xgv_gp26, align 8, !tbaa !9
  %gp_line = getelementptr inbounds %struct.gp* %17, i64 0, i32 10
  store i64 %15, i64* %gp_line, align 8, !tbaa !37
  %18 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_filegv = getelementptr inbounds %struct.cop* %18, i64 0, i32 10
  %19 = load %struct.gv** %cop_filegv, align 8, !tbaa !38
  %tobool27 = icmp eq %struct.gv* %19, null
  br i1 %tobool27, label %cond.end77, label %cond.true28

cond.true28:                                      ; preds = %Perl_gp_ref.exit
  %20 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_filegv29 = getelementptr inbounds %struct.cop* %20, i64 0, i32 10
  %21 = load %struct.gv** %cop_filegv29, align 8, !tbaa !38
  %sv_any30 = getelementptr inbounds %struct.gv* %21, i64 0, i32 0
  %22 = load %struct.xpvgv** %sv_any30, align 8, !tbaa !7
  %xgv_gp31 = getelementptr inbounds %struct.xpvgv* %22, i64 0, i32 7
  %23 = load %struct.gp** %xgv_gp31, align 8, !tbaa !9
  %gp_sv32 = getelementptr inbounds %struct.gp* %23, i64 0, i32 0
  %24 = load %struct.sv** %gp_sv32, align 8, !tbaa !28
  %tobool33 = icmp eq %struct.sv* %24, null
  br i1 %tobool33, label %cond.end77, label %cond.true35

cond.true35:                                      ; preds = %cond.true28
  %25 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %26 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_filegv39 = getelementptr inbounds %struct.cop* %26, i64 0, i32 10
  %27 = load %struct.gv** %cop_filegv39, align 8, !tbaa !38
  %sv_any40 = getelementptr inbounds %struct.gv* %27, i64 0, i32 0
  %28 = load %struct.xpvgv** %sv_any40, align 8, !tbaa !7
  %xgv_gp41 = getelementptr inbounds %struct.xpvgv* %28, i64 0, i32 7
  %29 = load %struct.gp** %xgv_gp41, align 8, !tbaa !9
  %gp_sv42 = getelementptr inbounds %struct.gp* %29, i64 0, i32 0
  %30 = load %struct.sv** %gp_sv42, align 8, !tbaa !28
  %sv_any46 = getelementptr inbounds %struct.sv* %30, i64 0, i32 0
  %31 = load i8** %sv_any46, align 8, !tbaa !39
  %xpv_pv47 = bitcast i8* %31 to i8**
  %32 = load i8** %xpv_pv47, align 8, !tbaa !30
  %tobool48 = icmp eq i8* %32, null
  br i1 %tobool48, label %cond.end77, label %cond.true50

cond.true50:                                      ; preds = %cond.true35
  %33 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_filegv51 = getelementptr inbounds %struct.cop* %33, i64 0, i32 10
  %34 = load %struct.gv** %cop_filegv51, align 8, !tbaa !38
  %tobool52 = icmp eq %struct.gv* %34, null
  br i1 %tobool52, label %cond.end77, label %cond.true53

cond.true53:                                      ; preds = %cond.true50
  %35 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_filegv54 = getelementptr inbounds %struct.cop* %35, i64 0, i32 10
  %36 = load %struct.gv** %cop_filegv54, align 8, !tbaa !38
  %sv_any55 = getelementptr inbounds %struct.gv* %36, i64 0, i32 0
  %37 = load %struct.xpvgv** %sv_any55, align 8, !tbaa !7
  %xgv_gp56 = getelementptr inbounds %struct.xpvgv* %37, i64 0, i32 7
  %38 = load %struct.gp** %xgv_gp56, align 8, !tbaa !9
  %gp_sv57 = getelementptr inbounds %struct.gp* %38, i64 0, i32 0
  %39 = load %struct.sv** %gp_sv57, align 8, !tbaa !28
  %tobool58 = icmp eq %struct.sv* %39, null
  br i1 %tobool58, label %cond.end77, label %cond.true60

cond.true60:                                      ; preds = %cond.true53
  %40 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %41 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_filegv64 = getelementptr inbounds %struct.cop* %41, i64 0, i32 10
  %42 = load %struct.gv** %cop_filegv64, align 8, !tbaa !38
  %sv_any65 = getelementptr inbounds %struct.gv* %42, i64 0, i32 0
  %43 = load %struct.xpvgv** %sv_any65, align 8, !tbaa !7
  %xgv_gp66 = getelementptr inbounds %struct.xpvgv* %43, i64 0, i32 7
  %44 = load %struct.gp** %xgv_gp66, align 8, !tbaa !9
  %gp_sv67 = getelementptr inbounds %struct.gp* %44, i64 0, i32 0
  %45 = load %struct.sv** %gp_sv67, align 8, !tbaa !28
  %sv_any71 = getelementptr inbounds %struct.sv* %45, i64 0, i32 0
  %46 = load i8** %sv_any71, align 8, !tbaa !39
  %xpv_pv72 = bitcast i8* %46 to i8**
  %47 = load i8** %xpv_pv72, align 8, !tbaa !30
  br label %cond.end77

cond.end77:                                       ; preds = %cond.true53, %cond.true50, %cond.true35, %cond.true28, %Perl_gp_ref.exit, %cond.true60
  %cond78 = phi i8* [ %47, %cond.true60 ], [ null, %cond.true50 ], [ null, %cond.true53 ], [ getelementptr inbounds ([1 x i8]* @.str3, i64 0, i64 0), %cond.true28 ], [ getelementptr inbounds ([1 x i8]* @.str3, i64 0, i64 0), %Perl_gp_ref.exit ], [ getelementptr inbounds ([1 x i8]* @.str3, i64 0, i64 0), %cond.true35 ]
  %48 = load %struct.xpvgv** %sv_any6.pre, align 8, !tbaa !7
  %xgv_gp80 = getelementptr inbounds %struct.xpvgv* %48, i64 0, i32 7
  %49 = load %struct.gp** %xgv_gp80, align 8, !tbaa !9
  %gp_file = getelementptr inbounds %struct.gp* %49, i64 0, i32 11
  store i8* %cond78, i8** %gp_file, align 8, !tbaa !40
  %gp_cvgen = getelementptr inbounds %struct.gp* %49, i64 0, i32 8
  store i64 0, i64* %gp_cvgen, align 8, !tbaa !41
  %gp_egv = getelementptr inbounds %struct.gp* %49, i64 0, i32 6
  store %struct.gv* %gv, %struct.gv** %gp_egv, align 8, !tbaa !42
  tail call void @Perl_sv_magic(%struct.sv* %3, %struct.sv* %3, i32 42, i8* null, i64 0) #2
  %50 = bitcast %struct.hv* %stash to %struct.sv*
  store %struct.sv* %50, %struct.sv** @PL_Sv, align 8, !tbaa !19
  %tobool85 = icmp eq %struct.hv* %stash, null
  br i1 %tobool85, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %cond.end77
  %51 = getelementptr inbounds %struct.hv* %stash, i64 0, i32 1
  %52 = load i64* %51, align 8, !tbaa !22
  %inc = add i64 %52, 1
  store i64 %inc, i64* %51, align 8, !tbaa !22
  br label %land.end

land.end:                                         ; preds = %cond.end77, %land.rhs
  %53 = load %struct.xpvgv** %sv_any6.pre, align 8, !tbaa !7
  %xgv_stash = getelementptr inbounds %struct.xpvgv* %53, i64 0, i32 10
  store %struct.hv* %stash, %struct.hv** %xgv_stash, align 8, !tbaa !43
  %call88 = tail call i8* @Perl_savepvn(i8* %name, i64 %len) #2
  %54 = load %struct.xpvgv** %sv_any6.pre, align 8, !tbaa !7
  %xgv_name = getelementptr inbounds %struct.xpvgv* %54, i64 0, i32 8
  store i8* %call88, i8** %xgv_name, align 8, !tbaa !44
  %xgv_namelen = getelementptr inbounds %struct.xpvgv* %54, i64 0, i32 9
  store i64 %len, i64* %xgv_namelen, align 8, !tbaa !45
  %tobool91.not = icmp ne i32 %multi, 0
  %brmerge = or i1 %tobool91.not, %cmp
  br i1 %brmerge, label %if.then94, label %if.end98

if.then94:                                        ; preds = %land.end
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %54, i64 0, i32 11
  %55 = load i8* %xgv_flags, align 1, !tbaa !46
  %or = or i8 %55, 2
  store i8 %or, i8* %xgv_flags, align 1, !tbaa !46
  br label %if.end98

if.end98:                                         ; preds = %land.end, %if.then94
  br i1 %cmp, label %if.then100, label %if.end150

if.then100:                                       ; preds = %if.end98
  %56 = load i64* %sv_flags, align 8, !tbaa !27
  %and102 = and i64 %56, 2130640895
  store i64 %and102, i64* %sv_flags, align 8, !tbaa !27
  tail call void @Perl_push_scope() #2
  %call103 = tail call i64 @Perl_start_subparse(i64 0, i64 0) #2
  %57 = load %struct.cv** @PL_compcv, align 8, !tbaa !19
  %58 = load %struct.xpvgv** %sv_any6.pre, align 8, !tbaa !7
  %xgv_gp105 = getelementptr inbounds %struct.xpvgv* %58, i64 0, i32 7
  %59 = load %struct.gp** %xgv_gp105, align 8, !tbaa !9
  %gp_cv = getelementptr inbounds %struct.gp* %59, i64 0, i32 7
  store %struct.cv* %57, %struct.cv** %gp_cv, align 8, !tbaa !47
  tail call void @Perl_pop_scope() #2
  %60 = load i64* @PL_sub_generation, align 8, !tbaa !29
  %inc106 = add i64 %60, 1
  store i64 %inc106, i64* @PL_sub_generation, align 8, !tbaa !29
  %61 = load %struct.xpvgv** %sv_any6.pre, align 8, !tbaa !7
  %xgv_gp108 = getelementptr inbounds %struct.xpvgv* %61, i64 0, i32 7
  %62 = load %struct.gp** %xgv_gp108, align 8, !tbaa !9
  %gp_cv109 = getelementptr inbounds %struct.gp* %62, i64 0, i32 7
  %63 = load %struct.cv** %gp_cv109, align 8, !tbaa !47
  %sv_any110 = getelementptr inbounds %struct.cv* %63, i64 0, i32 0
  %64 = load %struct.xpvcv** %sv_any110, align 8, !tbaa !48
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %64, i64 0, i32 12
  store %struct.gv* %gv, %struct.gv** %xcv_gv, align 8, !tbaa !50
  %65 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_filegv111 = getelementptr inbounds %struct.cop* %65, i64 0, i32 10
  %66 = load %struct.gv** %cop_filegv111, align 8, !tbaa !38
  %tobool112 = icmp eq %struct.gv* %66, null
  br i1 %tobool112, label %cond.end134, label %cond.true113

cond.true113:                                     ; preds = %if.then100
  %67 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_filegv114 = getelementptr inbounds %struct.cop* %67, i64 0, i32 10
  %68 = load %struct.gv** %cop_filegv114, align 8, !tbaa !38
  %sv_any115 = getelementptr inbounds %struct.gv* %68, i64 0, i32 0
  %69 = load %struct.xpvgv** %sv_any115, align 8, !tbaa !7
  %xgv_gp116 = getelementptr inbounds %struct.xpvgv* %69, i64 0, i32 7
  %70 = load %struct.gp** %xgv_gp116, align 8, !tbaa !9
  %gp_sv117 = getelementptr inbounds %struct.gp* %70, i64 0, i32 0
  %71 = load %struct.sv** %gp_sv117, align 8, !tbaa !28
  %tobool118 = icmp eq %struct.sv* %71, null
  br i1 %tobool118, label %cond.end134, label %cond.true120

cond.true120:                                     ; preds = %cond.true113
  %72 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %73 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_filegv124 = getelementptr inbounds %struct.cop* %73, i64 0, i32 10
  %74 = load %struct.gv** %cop_filegv124, align 8, !tbaa !38
  %sv_any125 = getelementptr inbounds %struct.gv* %74, i64 0, i32 0
  %75 = load %struct.xpvgv** %sv_any125, align 8, !tbaa !7
  %xgv_gp126 = getelementptr inbounds %struct.xpvgv* %75, i64 0, i32 7
  %76 = load %struct.gp** %xgv_gp126, align 8, !tbaa !9
  %gp_sv127 = getelementptr inbounds %struct.gp* %76, i64 0, i32 0
  %77 = load %struct.sv** %gp_sv127, align 8, !tbaa !28
  %sv_any131 = getelementptr inbounds %struct.sv* %77, i64 0, i32 0
  %78 = load i8** %sv_any131, align 8, !tbaa !39
  %xpv_pv132 = bitcast i8* %78 to i8**
  %79 = load i8** %xpv_pv132, align 8, !tbaa !30
  br label %cond.end134

cond.end134:                                      ; preds = %cond.true113, %if.then100, %cond.true120
  %cond135 = phi i8* [ %79, %cond.true120 ], [ null, %if.then100 ], [ null, %cond.true113 ]
  %80 = load %struct.xpvgv** %sv_any6.pre, align 8, !tbaa !7
  %xgv_gp137 = getelementptr inbounds %struct.xpvgv* %80, i64 0, i32 7
  %81 = load %struct.gp** %xgv_gp137, align 8, !tbaa !9
  %gp_cv138 = getelementptr inbounds %struct.gp* %81, i64 0, i32 7
  %82 = load %struct.cv** %gp_cv138, align 8, !tbaa !47
  %sv_any139 = getelementptr inbounds %struct.cv* %82, i64 0, i32 0
  %83 = load %struct.xpvcv** %sv_any139, align 8, !tbaa !48
  %xcv_file = getelementptr inbounds %struct.xpvcv* %83, i64 0, i32 13
  store i8* %cond135, i8** %xcv_file, align 8, !tbaa !52
  %84 = load %struct.hv** @PL_curstash, align 8, !tbaa !19
  %xcv_stash = getelementptr inbounds %struct.xpvcv* %83, i64 0, i32 7
  store %struct.hv* %84, %struct.hv** %xcv_stash, align 8, !tbaa !53
  %tobool144 = icmp eq i8* %cond, null
  br i1 %tobool144, label %if.end150, label %if.then145

if.then145:                                       ; preds = %cond.end134
  %85 = bitcast %struct.cv* %82 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %85, i8* %cond) #2
  tail call void @Perl_safesysfree(i8* %cond) #2
  br label %if.end150

if.end150:                                        ; preds = %cond.end134, %if.then145, %if.end98
  ret void
}

declare void @Perl_sv_setpv(%struct.sv*, i8*) #1

declare void @Perl_hv_magic(%struct.hv*, %struct.gv*, i32) #1

declare void @Perl_safesysfree(i8*) #1

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #2

declare signext i8 @Perl_sv_upgrade(%struct.sv*, i64) #1

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #2

; Function Attrs: nounwind uwtable
define %struct.gp* @Perl_gp_ref(%struct.gp* %gp) #0 {
entry:
  %tobool = icmp eq %struct.gp* %gp, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %gp_refcnt = getelementptr inbounds %struct.gp* %gp, i64 0, i32 1
  %0 = load i64* %gp_refcnt, align 8, !tbaa !33
  %inc = add i64 %0, 1
  store i64 %inc, i64* %gp_refcnt, align 8, !tbaa !33
  %gp_cv = getelementptr inbounds %struct.gp* %gp, i64 0, i32 7
  %1 = load %struct.cv** %gp_cv, align 8, !tbaa !47
  %tobool1 = icmp eq %struct.cv* %1, null
  br i1 %tobool1, label %return, label %if.then2

if.then2:                                         ; preds = %if.end
  %gp_cvgen = getelementptr inbounds %struct.gp* %gp, i64 0, i32 8
  %2 = load i64* %gp_cvgen, align 8, !tbaa !41
  %tobool3 = icmp eq i64 %2, 0
  br i1 %tobool3, label %if.else, label %if.then4

if.then4:                                         ; preds = %if.then2
  %3 = bitcast %struct.cv* %1 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %3) #2
  %4 = bitcast %struct.cv** %gp_cv to i8*
  call void @llvm.memset.p0i8.i64(i8* %4, i8 0, i64 16, i32 8, i1 false)
  br label %return

if.else:                                          ; preds = %if.then2
  %5 = load i64* @PL_sub_generation, align 8, !tbaa !29
  %inc8 = add i64 %5, 1
  store i64 %inc8, i64* @PL_sub_generation, align 8, !tbaa !29
  br label %return

return:                                           ; preds = %if.else, %if.then4, %if.end, %entry
  %retval.0 = phi %struct.gp* [ null, %entry ], [ %gp, %if.end ], [ %gp, %if.then4 ], [ %gp, %if.else ]
  ret %struct.gp* %retval.0
}

declare %struct.sv* @Perl_newSV(i64) #1

declare void @Perl_sv_magic(%struct.sv*, %struct.sv*, i32, i8*, i64) #1

declare i8* @Perl_savepvn(i8*, i64) #1

declare void @Perl_push_scope() #1

declare i64 @Perl_start_subparse(i64, i64) #1

declare void @Perl_pop_scope() #1

; Function Attrs: nounwind uwtable
define %struct.gv* @Perl_gv_fetchmeth(%struct.hv* %stash, i8* %name, i64 %len, i64 %level) #0 {
entry:
  %len.i = alloca i64, align 8
  %smallbuf.i = alloca [256 x i8], align 16
  %tobool = icmp eq %struct.hv* %stash, null
  br i1 %tobool, label %if.end10.i, label %if.end3

if.end10.i:                                       ; preds = %entry
  %0 = getelementptr inbounds [256 x i8]* %smallbuf.i, i64 0, i64 0
  call void @llvm.lifetime.start(i64 256, i8* %0) #2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* getelementptr inbounds ([10 x i8]* @.str4, i64 0, i64 0), i64 9, i32 1, i1 false) #2
  %arrayidx.i = getelementptr inbounds [256 x i8]* %smallbuf.i, i64 0, i64 9
  store i8 58, i8* %arrayidx.i, align 1, !tbaa !26
  %arrayidx4.i = getelementptr inbounds [256 x i8]* %smallbuf.i, i64 0, i64 10
  store i8 58, i8* %arrayidx4.i, align 2, !tbaa !26
  %arrayidx5.i = getelementptr inbounds [256 x i8]* %smallbuf.i, i64 0, i64 11
  store i8 0, i8* %arrayidx5.i, align 1, !tbaa !26
  %call6.i = call %struct.gv* @Perl_gv_fetchpv(i8* %0, i64 0, i64 11) #2
  %tobool.i = icmp eq %struct.gv* %call6.i, null
  br i1 %tobool.i, label %return, label %if.end12.i

if.end12.i:                                       ; preds = %if.end10.i
  %sv_any.i = getelementptr inbounds %struct.gv* %call6.i, i64 0, i32 0
  %1 = load %struct.xpvgv** %sv_any.i, align 8, !tbaa !7
  %xgv_gp.i = getelementptr inbounds %struct.xpvgv* %1, i64 0, i32 7
  %2 = load %struct.gp** %xgv_gp.i, align 8, !tbaa !9
  %gp_hv.i = getelementptr inbounds %struct.gp* %2, i64 0, i32 5
  %3 = load %struct.hv** %gp_hv.i, align 8, !tbaa !14
  %tobool13.i = icmp eq %struct.hv* %3, null
  br i1 %tobool13.i, label %if.then14.i, label %if.end19.i

if.then14.i:                                      ; preds = %if.end12.i
  %call15.i = call %struct.hv* @Perl_newHV() #2
  %4 = load %struct.xpvgv** %sv_any.i, align 8, !tbaa !7
  %xgv_gp17.i = getelementptr inbounds %struct.xpvgv* %4, i64 0, i32 7
  %5 = load %struct.gp** %xgv_gp17.i, align 8, !tbaa !9
  %gp_hv18.i = getelementptr inbounds %struct.gp* %5, i64 0, i32 5
  store %struct.hv* %call15.i, %struct.hv** %gp_hv18.i, align 8, !tbaa !14
  br label %if.end19.i

if.end19.i:                                       ; preds = %if.then14.i, %if.end12.i
  %6 = phi %struct.hv* [ %3, %if.end12.i ], [ %call15.i, %if.then14.i ]
  %sv_any23.i = getelementptr inbounds %struct.hv* %6, i64 0, i32 0
  %7 = load %struct.xpvhv** %sv_any23.i, align 8, !tbaa !20
  %xhv_name.i = getelementptr inbounds %struct.xpvhv* %7, i64 0, i32 10
  %8 = load i8** %xhv_name.i, align 8, !tbaa !54
  %tobool24.i = icmp eq i8* %8, null
  br i1 %tobool24.i, label %Perl_gv_stashpvn.exit.thread342, label %Perl_gv_stashpvn.exit

Perl_gv_stashpvn.exit.thread342:                  ; preds = %if.end19.i
  %call26.i = call i8* @Perl_savepv(i8* getelementptr inbounds ([10 x i8]* @.str4, i64 0, i64 0)) #2
  %9 = load %struct.xpvhv** %sv_any23.i, align 8, !tbaa !20
  %xhv_name28.i = getelementptr inbounds %struct.xpvhv* %9, i64 0, i32 10
  store i8* %call26.i, i8** %xhv_name28.i, align 8, !tbaa !54
  call void @llvm.lifetime.end(i64 256, i8* %0) #2
  br label %if.end3

Perl_gv_stashpvn.exit:                            ; preds = %if.end19.i
  call void @llvm.lifetime.end(i64 256, i8* %0) #2
  %tobool1 = icmp eq %struct.hv* %6, null
  br i1 %tobool1, label %return, label %if.end3

if.end3:                                          ; preds = %Perl_gv_stashpvn.exit.thread342, %Perl_gv_stashpvn.exit, %entry
  %level.addr.0 = phi i64 [ %level, %entry ], [ -1, %Perl_gv_stashpvn.exit ], [ -1, %Perl_gv_stashpvn.exit.thread342 ]
  %stash.addr.0 = phi %struct.hv* [ %stash, %entry ], [ %6, %Perl_gv_stashpvn.exit ], [ %6, %Perl_gv_stashpvn.exit.thread342 ]
  %sv_any = getelementptr inbounds %struct.hv* %stash.addr.0, i64 0, i32 0
  %10 = load %struct.xpvhv** %sv_any, align 8, !tbaa !20
  %xhv_name = getelementptr inbounds %struct.xpvhv* %10, i64 0, i32 10
  %11 = load i8** %xhv_name, align 8, !tbaa !54
  %tobool4 = icmp eq i8* %11, null
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([51 x i8]* @.str5, i64 0, i64 0)) #2
  br label %if.end6

if.end6:                                          ; preds = %if.end3, %if.then5
  %level.addr.0.off = add i64 %level.addr.0, 100
  %12 = icmp ugt i64 %level.addr.0.off, 200
  br i1 %12, label %if.then8, label %if.end11

if.then8:                                         ; preds = %if.end6
  %13 = load %struct.xpvhv** %sv_any, align 8, !tbaa !20
  %xhv_name10 = getelementptr inbounds %struct.xpvhv* %13, i64 0, i32 10
  %14 = load i8** %xhv_name10, align 8, !tbaa !54
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([77 x i8]* @.str6, i64 0, i64 0), i8* %name, i8* %14) #2
  br label %if.end11

if.end11:                                         ; preds = %if.end6, %if.then8
  %level.addr.0.lobit = lshr i64 %level.addr.0, 63
  %.not = xor i64 %level.addr.0.lobit, 1
  %call14 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %stash.addr.0, i8* %name, i64 %len, i64 %.not) #2
  %tobool15 = icmp eq %struct.sv** %call14, null
  br i1 %tobool15, label %if.end50, label %if.else

if.else:                                          ; preds = %if.end11
  %15 = load %struct.sv** %call14, align 8
  %16 = bitcast %struct.sv* %15 to %struct.gv*
  %17 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %18 = load i64* %17, align 8, !tbaa !27
  %and = and i64 %18, 255
  %cmp17 = icmp eq i64 %and, 13
  br i1 %cmp17, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.else
  call void @Perl_gv_init(%struct.gv* %16, %struct.hv* %stash.addr.0, i8* %name, i64 %len, i32 1)
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then19
  %sv_any21 = bitcast %struct.sv* %15 to %struct.xpvgv**
  %19 = load %struct.xpvgv** %sv_any21, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %19, i64 0, i32 7
  %20 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_cv = getelementptr inbounds %struct.gp* %20, i64 0, i32 7
  %21 = load %struct.cv** %gp_cv, align 8, !tbaa !47
  %tobool22 = icmp eq %struct.cv* %21, null
  %gp_cvgen = getelementptr inbounds %struct.gp* %20, i64 0, i32 8
  %22 = load i64* %gp_cvgen, align 8, !tbaa !41
  br i1 %tobool22, label %if.else41, label %if.then23

if.then23:                                        ; preds = %if.end20
  %tobool26 = icmp eq i64 %22, 0
  %23 = load i64* @PL_sub_generation, align 8
  %cmp31 = icmp eq i64 %22, %23
  %or.cond = or i1 %tobool26, %cmp31
  br i1 %or.cond, label %return, label %if.end34

if.end34:                                         ; preds = %if.then23
  %24 = bitcast %struct.cv* %21 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %24) #2
  %25 = load %struct.xpvgv** %sv_any21, align 8, !tbaa !7
  %xgv_gp36 = getelementptr inbounds %struct.xpvgv* %25, i64 0, i32 7
  %26 = load %struct.gp** %xgv_gp36, align 8, !tbaa !9
  %gp_cv37 = getelementptr inbounds %struct.gp* %26, i64 0, i32 7
  %27 = bitcast %struct.cv** %gp_cv37 to i8*
  call void @llvm.memset.p0i8.i64(i8* %27, i8 0, i64 16, i32 8, i1 false)
  br label %if.end50

if.else41:                                        ; preds = %if.end20
  %28 = load i64* @PL_sub_generation, align 8, !tbaa !29
  %cmp45 = icmp eq i64 %22, %28
  br i1 %cmp45, label %return, label %if.end50

if.end50:                                         ; preds = %if.end11, %if.end34, %if.else41
  %topgv.0 = phi %struct.gv* [ %16, %if.end34 ], [ %16, %if.else41 ], [ null, %if.end11 ]
  %call51 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %stash.addr.0, i8* getelementptr inbounds ([4 x i8]* @.str7, i64 0, i64 0), i64 3, i64 0) #2
  %tobool52 = icmp eq %struct.sv** %call51, null
  br i1 %tobool52, label %if.then63, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end50
  %29 = load %struct.sv** %call51, align 8
  %tobool53 = icmp ne %struct.sv* %29, null
  %cmp55 = icmp ne %struct.sv* %29, @PL_sv_undef
  %or.cond239 = and i1 %tobool53, %cmp55
  br i1 %or.cond239, label %cond.end, label %if.then63

cond.end:                                         ; preds = %land.lhs.true
  %sv_any57 = bitcast %struct.sv* %29 to %struct.xpvgv**
  %30 = load %struct.xpvgv** %sv_any57, align 8, !tbaa !7
  %xgv_gp58 = getelementptr inbounds %struct.xpvgv* %30, i64 0, i32 7
  %31 = load %struct.gp** %xgv_gp58, align 8, !tbaa !9
  %gp_av = getelementptr inbounds %struct.gp* %31, i64 0, i32 4
  %32 = load %struct.av** %gp_av, align 8, !tbaa !12
  %tobool59 = icmp eq %struct.av* %32, null
  br i1 %tobool59, label %if.then63, label %lor.lhs.false60

lor.lhs.false60:                                  ; preds = %cond.end
  %sv_any61 = getelementptr inbounds %struct.av* %32, i64 0, i32 0
  %33 = load %struct.xpvav** %sv_any61, align 8, !tbaa !56
  %34 = getelementptr inbounds %struct.xpvav* %33, i64 0, i32 5
  %35 = load %struct.magic** %34, align 8, !tbaa !58
  %tobool62 = icmp eq %struct.magic* %35, null
  br i1 %tobool62, label %if.then63, label %if.then112

if.then63:                                        ; preds = %if.end50, %land.lhs.true, %lor.lhs.false60, %cond.end
  %cond345 = phi %struct.av* [ %32, %lor.lhs.false60 ], [ null, %cond.end ], [ null, %land.lhs.true ], [ null, %if.end50 ]
  %36 = load %struct.xpvhv** %sv_any, align 8, !tbaa !20
  %xhv_name65 = getelementptr inbounds %struct.xpvhv* %36, i64 0, i32 10
  %37 = load i8** %xhv_name65, align 8, !tbaa !54
  %call66 = call i64 @strlen(i8* %37) #2
  %cmp67 = icmp ugt i64 %call66, 6
  br i1 %cmp67, label %land.lhs.true69, label %if.end110

land.lhs.true69:                                  ; preds = %if.then63
  %add.ptr.sum = add i64 %call66, -7
  %add.ptr70 = getelementptr inbounds i8* %37, i64 %add.ptr.sum
  %call71 = call i32 @strcmp(i8* %add.ptr70, i8* getelementptr inbounds ([8 x i8]* @.str8, i64 0, i64 0)) #2
  %tobool72 = icmp eq i32 %call71, 0
  br i1 %tobool72, label %if.then73, label %if.end110

if.then73:                                        ; preds = %land.lhs.true69
  %call74 = call %struct.hv* @Perl_gv_stashpvn(i8* %37, i64 %add.ptr.sum, i64 1)
  %call75 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %call74, i8* getelementptr inbounds ([4 x i8]* @.str7, i64 0, i64 0), i64 3, i64 0) #2
  %tobool76 = icmp eq %struct.sv** %call75, null
  br i1 %tobool76, label %if.end110, label %land.lhs.true77

land.lhs.true77:                                  ; preds = %if.then73
  %38 = load %struct.sv** %call75, align 8
  %39 = bitcast %struct.sv* %38 to %struct.gv*
  %cmp78 = icmp eq %struct.sv* %38, @PL_sv_undef
  br i1 %cmp78, label %if.end110, label %land.lhs.true80

land.lhs.true80:                                  ; preds = %land.lhs.true77
  %sv_any81 = bitcast %struct.sv* %38 to %struct.xpvgv**
  %40 = load %struct.xpvgv** %sv_any81, align 8, !tbaa !7
  %xgv_gp82 = getelementptr inbounds %struct.xpvgv* %40, i64 0, i32 7
  %41 = load %struct.gp** %xgv_gp82, align 8, !tbaa !9
  %gp_av83 = getelementptr inbounds %struct.gp* %41, i64 0, i32 4
  %42 = load %struct.av** %gp_av83, align 8, !tbaa !12
  %tobool84 = icmp eq %struct.av* %42, null
  br i1 %tobool84, label %if.end161, label %if.then85

if.then85:                                        ; preds = %land.lhs.true80
  %call86 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %stash.addr.0, i8* getelementptr inbounds ([4 x i8]* @.str7, i64 0, i64 0), i64 3, i64 1) #2
  %tobool87 = icmp eq %struct.sv** %call86, null
  br i1 %tobool87, label %if.then90, label %lor.lhs.false88

lor.lhs.false88:                                  ; preds = %if.then85
  %43 = load %struct.sv** %call86, align 8
  %44 = bitcast %struct.sv* %43 to %struct.gv*
  %tobool89 = icmp eq %struct.sv* %43, null
  br i1 %tobool89, label %if.then90, label %if.end93

if.then90:                                        ; preds = %lor.lhs.false88, %if.then85
  %gv.0 = phi %struct.gv* [ %44, %lor.lhs.false88 ], [ %39, %if.then85 ]
  %45 = load %struct.xpvhv** %sv_any, align 8, !tbaa !20
  %xhv_name92 = getelementptr inbounds %struct.xpvhv* %45, i64 0, i32 10
  %46 = load i8** %xhv_name92, align 8, !tbaa !54
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([22 x i8]* @.str9, i64 0, i64 0), i8* %46) #2
  br label %if.end93

if.end93:                                         ; preds = %lor.lhs.false88, %if.then90
  %gv.1 = phi %struct.gv* [ %44, %lor.lhs.false88 ], [ %gv.0, %if.then90 ]
  %sv_flags94 = getelementptr inbounds %struct.gv* %gv.1, i64 0, i32 2
  %47 = load i64* %sv_flags94, align 8, !tbaa !27
  %and95 = and i64 %47, 255
  %cmp96 = icmp eq i64 %and95, 13
  br i1 %cmp96, label %land.end, label %if.then98

if.then98:                                        ; preds = %if.end93
  call void @Perl_gv_init(%struct.gv* %gv.1, %struct.hv* %stash.addr.0, i8* getelementptr inbounds ([4 x i8]* @.str7, i64 0, i64 0), i64 3, i32 1)
  br label %land.end

land.end:                                         ; preds = %if.end93, %if.then98
  %sv_any100 = getelementptr inbounds %struct.gv* %gv.1, i64 0, i32 0
  %48 = load %struct.xpvgv** %sv_any100, align 8, !tbaa !7
  %xgv_gp101 = getelementptr inbounds %struct.xpvgv* %48, i64 0, i32 7
  %49 = load %struct.gp** %xgv_gp101, align 8, !tbaa !9
  %gp_av102 = getelementptr inbounds %struct.gp* %49, i64 0, i32 4
  %50 = load %struct.av** %gp_av102, align 8, !tbaa !12
  %51 = bitcast %struct.av* %50 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %51) #2
  %52 = bitcast %struct.av* %42 to %struct.sv*
  store %struct.sv* %52, %struct.sv** @PL_Sv, align 8, !tbaa !19
  %53 = getelementptr inbounds %struct.av* %42, i64 0, i32 1
  %54 = load i64* %53, align 8, !tbaa !22
  %inc = add i64 %54, 1
  store i64 %inc, i64* %53, align 8, !tbaa !22
  %55 = load %struct.xpvgv** %sv_any100, align 8, !tbaa !7
  %xgv_gp106 = getelementptr inbounds %struct.xpvgv* %55, i64 0, i32 7
  %56 = load %struct.gp** %xgv_gp106, align 8, !tbaa !9
  %gp_av107 = getelementptr inbounds %struct.gp* %56, i64 0, i32 4
  store %struct.av* %42, %struct.av** %gp_av107, align 8, !tbaa !12
  br label %if.end110

if.end110:                                        ; preds = %land.lhs.true77, %if.then73, %land.lhs.true69, %if.then63, %land.end
  %av.0 = phi %struct.av* [ %cond345, %land.lhs.true69 ], [ %42, %land.end ], [ %cond345, %land.lhs.true77 ], [ %cond345, %if.then73 ], [ %cond345, %if.then63 ]
  %tobool111 = icmp eq %struct.av* %av.0, null
  br i1 %tobool111, label %if.end161, label %if.end110.if.then112_crit_edge

if.end110.if.then112_crit_edge:                   ; preds = %if.end110
  %sv_any113.phi.trans.insert = getelementptr inbounds %struct.av* %av.0, i64 0, i32 0
  %.pre359 = load %struct.xpvav** %sv_any113.phi.trans.insert, align 8, !tbaa !56
  br label %if.then112

if.then112:                                       ; preds = %if.end110.if.then112_crit_edge, %lor.lhs.false60
  %57 = phi %struct.xpvav* [ %.pre359, %if.end110.if.then112_crit_edge ], [ %33, %lor.lhs.false60 ]
  %xav_fill = getelementptr inbounds %struct.xpvav* %57, i64 0, i32 1
  %58 = load i64* %xav_fill, align 8, !tbaa !59
  %tobool115354 = icmp eq i64 %58, -1
  br i1 %tobool115354, label %if.end161, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %if.then112
  %xav_array = getelementptr inbounds %struct.xpvav* %57, i64 0, i32 0
  %59 = load i8** %xav_array, align 8, !tbaa !61
  %60 = bitcast i8* %59 to %struct.sv**
  %61 = bitcast i64* %len.i to i8*
  %62 = ashr i64 %level.addr.0, 63
  %63 = or i64 %62, 1
  %cond156 = add i64 %63, %level.addr.0
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.cond.backedge
  %dec356 = phi i64 [ %58, %while.body.lr.ph ], [ %dec, %while.cond.backedge ]
  %svp.0355 = phi %struct.sv** [ %60, %while.body.lr.ph ], [ %incdec.ptr, %while.cond.backedge ]
  %incdec.ptr = getelementptr inbounds %struct.sv** %svp.0355, i64 1
  %64 = load %struct.sv** %svp.0355, align 8, !tbaa !19
  call void @llvm.lifetime.start(i64 8, i8* %61) #2
  %sv_flags.i = getelementptr inbounds %struct.sv* %64, i64 0, i32 2
  %65 = load i64* %sv_flags.i, align 8, !tbaa !1
  %and.i = and i64 %65, 262144
  %cmp.i = icmp eq i64 %and.i, 0
  br i1 %cmp.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %while.body
  %sv_any.i315 = getelementptr inbounds %struct.sv* %64, i64 0, i32 0
  %66 = load i8** %sv_any.i315, align 8, !tbaa !39
  %xpv_cur.i = getelementptr inbounds i8* %66, i64 8
  %67 = bitcast i8* %xpv_cur.i to i64*
  %68 = load i64* %67, align 8, !tbaa !62
  store i64 %68, i64* %len.i, align 8, !tbaa !29
  %xpv_pv.i = bitcast i8* %66 to i8**
  %69 = load i8** %xpv_pv.i, align 8, !tbaa !30
  br label %Perl_gv_stashsv.exit

cond.false.i:                                     ; preds = %while.body
  %call.i = call i8* @Perl_sv_2pv_flags(%struct.sv* %64, i64* %len.i, i64 2) #2
  %.pre.i = load i64* %len.i, align 8, !tbaa !29
  br label %Perl_gv_stashsv.exit

Perl_gv_stashsv.exit:                             ; preds = %cond.true.i, %cond.false.i
  %70 = phi i64 [ %68, %cond.true.i ], [ %.pre.i, %cond.false.i ]
  %cond.i = phi i8* [ %69, %cond.true.i ], [ %call.i, %cond.false.i ]
  %call2.i = call %struct.hv* @Perl_gv_stashpvn(i8* %cond.i, i64 %70, i64 0) #2
  call void @llvm.lifetime.end(i64 8, i8* %61) #2
  %tobool118 = icmp eq %struct.hv* %call2.i, null
  br i1 %tobool118, label %if.then119, label %if.end148

if.then119:                                       ; preds = %Perl_gv_stashsv.exit
  %71 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings = getelementptr inbounds %struct.cop* %71, i64 0, i32 14
  %72 = load %struct.sv** %cop_warnings, align 8, !tbaa !63
  %cmp120 = icmp eq %struct.sv* %72, null
  br i1 %cmp120, label %lor.lhs.false136, label %land.lhs.true122

land.lhs.true122:                                 ; preds = %if.then119
  %73 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings123 = getelementptr inbounds %struct.cop* %73, i64 0, i32 14
  %74 = load %struct.sv** %cop_warnings123, align 8, !tbaa !63
  %cmp124 = icmp eq %struct.sv* %74, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp124, label %lor.lhs.false136, label %land.lhs.true126

land.lhs.true126:                                 ; preds = %land.lhs.true122
  %75 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings127 = getelementptr inbounds %struct.cop* %75, i64 0, i32 14
  %76 = load %struct.sv** %cop_warnings127, align 8, !tbaa !63
  %cmp128 = icmp eq %struct.sv* %76, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp128, label %if.then144, label %lor.lhs.false130

lor.lhs.false130:                                 ; preds = %land.lhs.true126
  %77 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings131 = getelementptr inbounds %struct.cop* %77, i64 0, i32 14
  %78 = load %struct.sv** %cop_warnings131, align 8, !tbaa !63
  %sv_any132 = getelementptr inbounds %struct.sv* %78, i64 0, i32 0
  %79 = load i8** %sv_any132, align 8, !tbaa !39
  %xpv_pv = bitcast i8* %79 to i8**
  %80 = load i8** %xpv_pv, align 8, !tbaa !30
  %arrayidx = getelementptr inbounds i8* %80, i64 3
  %81 = load i8* %arrayidx, align 1, !tbaa !26
  %and134 = and i8 %81, 1
  %tobool135 = icmp eq i8 %and134, 0
  br i1 %tobool135, label %lor.lhs.false136, label %if.then144

lor.lhs.false136:                                 ; preds = %lor.lhs.false130, %land.lhs.true122, %if.then119
  %82 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings137 = getelementptr inbounds %struct.cop* %82, i64 0, i32 14
  %83 = load %struct.sv** %cop_warnings137, align 8, !tbaa !63
  %cmp138 = icmp eq %struct.sv* %83, null
  br i1 %cmp138, label %land.lhs.true140, label %while.cond.backedge

land.lhs.true140:                                 ; preds = %lor.lhs.false136
  %84 = load i8* @PL_dowarn, align 1, !tbaa !26
  %and142 = and i8 %84, 1
  %tobool143 = icmp eq i8 %and142, 0
  br i1 %tobool143, label %while.cond.backedge, label %if.then144

if.then144:                                       ; preds = %lor.lhs.false130, %land.lhs.true140, %land.lhs.true126
  %85 = load %struct.xpvhv** %sv_any, align 8, !tbaa !20
  %xhv_name146 = getelementptr inbounds %struct.xpvhv* %85, i64 0, i32 10
  %86 = load i8** %xhv_name146, align 8, !tbaa !54
  call void (i64, i8*, ...)* @Perl_warner(i64 12, i8* getelementptr inbounds ([37 x i8]* @.str10, i64 0, i64 0), %struct.sv* %64, i8* %86) #2
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.then144, %lor.lhs.false136, %land.lhs.true140, %if.end148
  %dec = add nsw i64 %dec356, -1
  %tobool115 = icmp eq i64 %dec356, 0
  br i1 %tobool115, label %if.end161, label %while.body

if.end148:                                        ; preds = %Perl_gv_stashsv.exit
  %call157 = call %struct.gv* @Perl_gv_fetchmeth(%struct.hv* %call2.i, i8* %name, i64 %len, i64 %cond156)
  %tobool158 = icmp eq %struct.gv* %call157, null
  br i1 %tobool158, label %while.cond.backedge, label %gotcha

if.end161:                                        ; preds = %while.cond.backedge, %if.then112, %land.lhs.true80, %if.end110
  switch i64 %level.addr.0, label %return [
    i64 -1, label %if.end10.i322
    i64 0, label %if.end10.i322
  ]

if.end10.i322:                                    ; preds = %if.end161, %if.end161
  %87 = getelementptr inbounds [256 x i8]* %smallbuf.i, i64 0, i64 0
  call void @llvm.lifetime.start(i64 256, i8* %87) #2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %87, i8* getelementptr inbounds ([10 x i8]* @.str4, i64 0, i64 0), i64 9, i32 1, i1 false) #2
  %arrayidx.i317 = getelementptr inbounds [256 x i8]* %smallbuf.i, i64 0, i64 9
  store i8 58, i8* %arrayidx.i317, align 1, !tbaa !26
  %arrayidx4.i318 = getelementptr inbounds [256 x i8]* %smallbuf.i, i64 0, i64 10
  store i8 58, i8* %arrayidx4.i318, align 2, !tbaa !26
  %arrayidx5.i319 = getelementptr inbounds [256 x i8]* %smallbuf.i, i64 0, i64 11
  store i8 0, i8* %arrayidx5.i319, align 1, !tbaa !26
  %call6.i320 = call %struct.gv* @Perl_gv_fetchpv(i8* %87, i64 0, i64 11) #2
  %tobool.i321 = icmp eq %struct.gv* %call6.i320, null
  br i1 %tobool.i321, label %return, label %if.end12.i327

if.end12.i327:                                    ; preds = %if.end10.i322
  %sv_any.i323 = getelementptr inbounds %struct.gv* %call6.i320, i64 0, i32 0
  %88 = load %struct.xpvgv** %sv_any.i323, align 8, !tbaa !7
  %xgv_gp.i324 = getelementptr inbounds %struct.xpvgv* %88, i64 0, i32 7
  %89 = load %struct.gp** %xgv_gp.i324, align 8, !tbaa !9
  %gp_hv.i325 = getelementptr inbounds %struct.gp* %89, i64 0, i32 5
  %90 = load %struct.hv** %gp_hv.i325, align 8, !tbaa !14
  %tobool13.i326 = icmp eq %struct.hv* %90, null
  br i1 %tobool13.i326, label %if.then14.i331, label %if.end19.i335

if.then14.i331:                                   ; preds = %if.end12.i327
  %call15.i328 = call %struct.hv* @Perl_newHV() #2
  %91 = load %struct.xpvgv** %sv_any.i323, align 8, !tbaa !7
  %xgv_gp17.i329 = getelementptr inbounds %struct.xpvgv* %91, i64 0, i32 7
  %92 = load %struct.gp** %xgv_gp17.i329, align 8, !tbaa !9
  %gp_hv18.i330 = getelementptr inbounds %struct.gp* %92, i64 0, i32 5
  store %struct.hv* %call15.i328, %struct.hv** %gp_hv18.i330, align 8, !tbaa !14
  br label %if.end19.i335

if.end19.i335:                                    ; preds = %if.then14.i331, %if.end12.i327
  %93 = phi %struct.hv* [ %90, %if.end12.i327 ], [ %call15.i328, %if.then14.i331 ]
  %sv_any23.i332 = getelementptr inbounds %struct.hv* %93, i64 0, i32 0
  %94 = load %struct.xpvhv** %sv_any23.i332, align 8, !tbaa !20
  %xhv_name.i333 = getelementptr inbounds %struct.xpvhv* %94, i64 0, i32 10
  %95 = load i8** %xhv_name.i333, align 8, !tbaa !54
  %tobool24.i334 = icmp eq i8* %95, null
  br i1 %tobool24.i334, label %Perl_gv_stashpvn.exit340.thread351, label %Perl_gv_stashpvn.exit340

Perl_gv_stashpvn.exit340.thread351:               ; preds = %if.end19.i335
  %call26.i336 = call i8* @Perl_savepv(i8* getelementptr inbounds ([10 x i8]* @.str4, i64 0, i64 0)) #2
  %96 = load %struct.xpvhv** %sv_any23.i332, align 8, !tbaa !20
  %xhv_name28.i337 = getelementptr inbounds %struct.xpvhv* %96, i64 0, i32 10
  store i8* %call26.i336, i8** %xhv_name28.i337, align 8, !tbaa !54
  call void @llvm.lifetime.end(i64 256, i8* %87) #2
  br label %if.then170

Perl_gv_stashpvn.exit340:                         ; preds = %if.end19.i335
  call void @llvm.lifetime.end(i64 256, i8* %87) #2
  %tobool169 = icmp eq %struct.hv* %93, null
  br i1 %tobool169, label %return, label %if.then170

if.then170:                                       ; preds = %Perl_gv_stashpvn.exit340.thread351, %Perl_gv_stashpvn.exit340
  %97 = ashr i64 %level.addr.0, 63
  %98 = or i64 %97, 1
  %cond178 = add i64 %98, %level.addr.0
  %call179 = call %struct.gv* @Perl_gv_fetchmeth(%struct.hv* %93, i8* %name, i64 %len, i64 %cond178)
  %tobool180 = icmp eq %struct.gv* %call179, null
  br i1 %tobool180, label %if.else223, label %gotcha

gotcha:                                           ; preds = %if.end148, %if.then170
  %gv.2 = phi %struct.gv* [ %call179, %if.then170 ], [ %call157, %if.end148 ]
  %tobool182 = icmp eq %struct.gv* %topgv.0, null
  br i1 %tobool182, label %return, label %land.lhs.true183

land.lhs.true183:                                 ; preds = %gotcha
  %sv_any184 = getelementptr inbounds %struct.gv* %topgv.0, i64 0, i32 0
  %99 = load %struct.xpvgv** %sv_any184, align 8, !tbaa !7
  %xgv_gp185 = getelementptr inbounds %struct.xpvgv* %99, i64 0, i32 7
  %100 = load %struct.gp** %xgv_gp185, align 8, !tbaa !9
  %gp_refcnt = getelementptr inbounds %struct.gp* %100, i64 0, i32 1
  %101 = load i64* %gp_refcnt, align 8, !tbaa !33
  %cmp186 = icmp eq i64 %101, 1
  br i1 %cmp186, label %land.lhs.true188, label %return

land.lhs.true188:                                 ; preds = %land.lhs.true183
  %sv_any189 = getelementptr inbounds %struct.gv* %gv.2, i64 0, i32 0
  %102 = load %struct.xpvgv** %sv_any189, align 8, !tbaa !7
  %xgv_gp190 = getelementptr inbounds %struct.xpvgv* %102, i64 0, i32 7
  %103 = load %struct.gp** %xgv_gp190, align 8, !tbaa !9
  %gp_cv191 = getelementptr inbounds %struct.gp* %103, i64 0, i32 7
  %104 = load %struct.cv** %gp_cv191, align 8, !tbaa !47
  %tobool192 = icmp eq %struct.cv* %104, null
  br i1 %tobool192, label %return, label %land.lhs.true193

land.lhs.true193:                                 ; preds = %land.lhs.true188
  %sv_any194 = getelementptr inbounds %struct.cv* %104, i64 0, i32 0
  %105 = load %struct.xpvcv** %sv_any194, align 8, !tbaa !48
  %xcv_root = getelementptr inbounds %struct.xpvcv* %105, i64 0, i32 9
  %106 = load %struct.op** %xcv_root, align 8, !tbaa !64
  %tobool195 = icmp eq %struct.op* %106, null
  br i1 %tobool195, label %lor.lhs.false196, label %if.then199

lor.lhs.false196:                                 ; preds = %land.lhs.true193
  %xcv_xsub = getelementptr inbounds %struct.xpvcv* %105, i64 0, i32 10
  %107 = load void (%struct.cv*)** %xcv_xsub, align 8, !tbaa !65
  %tobool198 = icmp eq void (%struct.cv*)* %107, null
  br i1 %tobool198, label %return, label %if.then199

if.then199:                                       ; preds = %lor.lhs.false196, %land.lhs.true193
  %gp_cv202 = getelementptr inbounds %struct.gp* %100, i64 0, i32 7
  %108 = load %struct.cv** %gp_cv202, align 8, !tbaa !47
  %tobool203 = icmp eq %struct.cv* %108, null
  br i1 %tobool203, label %if.end205, label %if.then204

if.then204:                                       ; preds = %if.then199
  %109 = bitcast %struct.cv* %108 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %109) #2
  %.pre = load %struct.xpvgv** %sv_any189, align 8, !tbaa !7
  %xgv_gp207.phi.trans.insert = getelementptr inbounds %struct.xpvgv* %.pre, i64 0, i32 7
  %.pre357 = load %struct.gp** %xgv_gp207.phi.trans.insert, align 8, !tbaa !9
  %gp_cv208.phi.trans.insert = getelementptr inbounds %struct.gp* %.pre357, i64 0, i32 7
  %.pre358 = load %struct.cv** %gp_cv208.phi.trans.insert, align 8, !tbaa !47
  br label %if.end205

if.end205:                                        ; preds = %if.then199, %if.then204
  %110 = phi %struct.cv* [ %104, %if.then199 ], [ %.pre358, %if.then204 ]
  %111 = bitcast %struct.cv* %110 to %struct.sv*
  store %struct.sv* %111, %struct.sv** @PL_Sv, align 8, !tbaa !19
  %tobool209 = icmp eq %struct.cv* %110, null
  br i1 %tobool209, label %land.end214, label %land.rhs210

land.rhs210:                                      ; preds = %if.end205
  %112 = getelementptr inbounds %struct.cv* %110, i64 0, i32 1
  %113 = load i64* %112, align 8, !tbaa !22
  %inc212 = add i64 %113, 1
  store i64 %inc212, i64* %112, align 8, !tbaa !22
  br label %land.end214

land.end214:                                      ; preds = %if.end205, %land.rhs210
  %114 = load %struct.xpvgv** %sv_any184, align 8, !tbaa !7
  %xgv_gp217 = getelementptr inbounds %struct.xpvgv* %114, i64 0, i32 7
  %115 = load %struct.gp** %xgv_gp217, align 8, !tbaa !9
  %gp_cv218 = getelementptr inbounds %struct.gp* %115, i64 0, i32 7
  store %struct.cv* %110, %struct.cv** %gp_cv218, align 8, !tbaa !47
  %116 = load i64* @PL_sub_generation, align 8, !tbaa !29
  %gp_cvgen221 = getelementptr inbounds %struct.gp* %115, i64 0, i32 8
  store i64 %116, i64* %gp_cvgen221, align 8, !tbaa !41
  br label %return

if.else223:                                       ; preds = %if.then170
  %tobool224 = icmp eq %struct.gv* %topgv.0, null
  br i1 %tobool224, label %return, label %land.lhs.true225

land.lhs.true225:                                 ; preds = %if.else223
  %sv_any226 = getelementptr inbounds %struct.gv* %topgv.0, i64 0, i32 0
  %117 = load %struct.xpvgv** %sv_any226, align 8, !tbaa !7
  %xgv_gp227 = getelementptr inbounds %struct.xpvgv* %117, i64 0, i32 7
  %118 = load %struct.gp** %xgv_gp227, align 8, !tbaa !9
  %gp_refcnt228 = getelementptr inbounds %struct.gp* %118, i64 0, i32 1
  %119 = load i64* %gp_refcnt228, align 8, !tbaa !33
  %cmp229 = icmp eq i64 %119, 1
  br i1 %cmp229, label %if.then231, label %return

if.then231:                                       ; preds = %land.lhs.true225
  %120 = load i64* @PL_sub_generation, align 8, !tbaa !29
  %gp_cvgen234 = getelementptr inbounds %struct.gp* %118, i64 0, i32 8
  store i64 %120, i64* %gp_cvgen234, align 8, !tbaa !41
  br label %return

return:                                           ; preds = %if.end10.i322, %if.end10.i, %if.then231, %land.lhs.true225, %Perl_gv_stashpvn.exit340, %if.else223, %if.end161, %land.lhs.true183, %land.end214, %gotcha, %land.lhs.true188, %lor.lhs.false196, %if.else41, %if.then23, %Perl_gv_stashpvn.exit
  %retval.0 = phi %struct.gv* [ null, %Perl_gv_stashpvn.exit ], [ %16, %if.then23 ], [ null, %if.else41 ], [ %gv.2, %lor.lhs.false196 ], [ %gv.2, %land.lhs.true188 ], [ %gv.2, %gotcha ], [ %gv.2, %land.end214 ], [ %gv.2, %land.lhs.true183 ], [ null, %if.end161 ], [ null, %if.else223 ], [ null, %Perl_gv_stashpvn.exit340 ], [ null, %land.lhs.true225 ], [ null, %if.then231 ], [ null, %if.end10.i ], [ null, %if.end10.i322 ]
  ret %struct.gv* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.hv* @Perl_gv_stashpvn(i8* %name, i64 %namelen, i64 %create) #0 {
entry:
  %smallbuf = alloca [256 x i8], align 16
  %0 = getelementptr inbounds [256 x i8]* %smallbuf, i64 0, i64 0
  call void @llvm.lifetime.start(i64 256, i8* %0) #2
  %add = add i64 %namelen, 3
  %cmp = icmp ult i64 %add, 256
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  %call = call i8* @Perl_safesysmalloc(i64 %add) #2
  br label %if.end

if.end:                                           ; preds = %entry, %if.else
  %tmpbuf.0 = phi i8* [ %call, %if.else ], [ %0, %entry ]
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %tmpbuf.0, i8* %name, i64 %namelen, i32 1, i1 false)
  %inc = add i64 %namelen, 1
  %arrayidx = getelementptr inbounds i8* %tmpbuf.0, i64 %namelen
  store i8 58, i8* %arrayidx, align 1, !tbaa !26
  %inc3 = add i64 %namelen, 2
  %arrayidx4 = getelementptr inbounds i8* %tmpbuf.0, i64 %inc
  store i8 58, i8* %arrayidx4, align 1, !tbaa !26
  %arrayidx5 = getelementptr inbounds i8* %tmpbuf.0, i64 %inc3
  store i8 0, i8* %arrayidx5, align 1, !tbaa !26
  %call6 = call %struct.gv* @Perl_gv_fetchpv(i8* %tmpbuf.0, i64 %create, i64 11)
  %cmp8 = icmp eq i8* %tmpbuf.0, %0
  br i1 %cmp8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end
  call void @Perl_safesysfree(i8* %tmpbuf.0) #2
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then9
  %tobool = icmp eq %struct.gv* %call6, null
  br i1 %tobool, label %cleanup, label %if.end12

if.end12:                                         ; preds = %if.end10
  %sv_any = getelementptr inbounds %struct.gv* %call6, i64 0, i32 0
  %1 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %1, i64 0, i32 7
  %2 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_hv = getelementptr inbounds %struct.gp* %2, i64 0, i32 5
  %3 = load %struct.hv** %gp_hv, align 8, !tbaa !14
  %tobool13 = icmp eq %struct.hv* %3, null
  br i1 %tobool13, label %if.then14, label %if.end19

if.then14:                                        ; preds = %if.end12
  %call15 = call %struct.hv* @Perl_newHV() #2
  %4 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp17 = getelementptr inbounds %struct.xpvgv* %4, i64 0, i32 7
  %5 = load %struct.gp** %xgv_gp17, align 8, !tbaa !9
  %gp_hv18 = getelementptr inbounds %struct.gp* %5, i64 0, i32 5
  store %struct.hv* %call15, %struct.hv** %gp_hv18, align 8, !tbaa !14
  br label %if.end19

if.end19:                                         ; preds = %if.end12, %if.then14
  %6 = phi %struct.hv* [ %3, %if.end12 ], [ %call15, %if.then14 ]
  %sv_any23 = getelementptr inbounds %struct.hv* %6, i64 0, i32 0
  %7 = load %struct.xpvhv** %sv_any23, align 8, !tbaa !20
  %xhv_name = getelementptr inbounds %struct.xpvhv* %7, i64 0, i32 10
  %8 = load i8** %xhv_name, align 8, !tbaa !54
  %tobool24 = icmp eq i8* %8, null
  br i1 %tobool24, label %if.then25, label %cleanup

if.then25:                                        ; preds = %if.end19
  %call26 = call i8* @Perl_savepv(i8* %name) #2
  %9 = load %struct.xpvhv** %sv_any23, align 8, !tbaa !20
  %xhv_name28 = getelementptr inbounds %struct.xpvhv* %9, i64 0, i32 10
  store i8* %call26, i8** %xhv_name28, align 8, !tbaa !54
  br label %cleanup

cleanup:                                          ; preds = %if.then25, %if.end19, %if.end10
  %retval.0 = phi %struct.hv* [ null, %if.end10 ], [ %6, %if.end19 ], [ %6, %if.then25 ]
  call void @llvm.lifetime.end(i64 256, i8* %0) #2
  ret %struct.hv* %retval.0
}

declare void @Perl_sv_free(%struct.sv*) #1

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8* nocapture, i8* nocapture) #3

; Function Attrs: nounwind uwtable
define %struct.hv* @Perl_gv_stashsv(%struct.sv* %sv, i64 %create) #0 {
entry:
  %len = alloca i64, align 8
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !1
  %and = and i64 %0, 262144
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %1 = load i8** %sv_any, align 8, !tbaa !39
  %xpv_cur = getelementptr inbounds i8* %1, i64 8
  %2 = bitcast i8* %xpv_cur to i64*
  %3 = load i64* %2, align 8, !tbaa !62
  store i64 %3, i64* %len, align 8, !tbaa !29
  %xpv_pv = bitcast i8* %1 to i8**
  %4 = load i8** %xpv_pv, align 8, !tbaa !30
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %sv, i64* %len, i64 2) #2
  %.pre = load i64* %len, align 8, !tbaa !29
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %5 = phi i64 [ %3, %cond.true ], [ %.pre, %cond.false ]
  %cond = phi i8* [ %4, %cond.true ], [ %call, %cond.false ]
  %call2 = call %struct.hv* @Perl_gv_stashpvn(i8* %cond, i64 %5, i64 %create)
  ret %struct.hv* %call2
}

declare void @Perl_warner(i64, i8*, ...) #1

; Function Attrs: nounwind uwtable
define %struct.gv* @Perl_gv_fetchmeth_autoload(%struct.hv* %stash, i8* %name, i64 %len, i64 %level) #0 {
entry:
  %autoload = alloca [9 x i8], align 1
  %call = call %struct.gv* @Perl_gv_fetchmeth(%struct.hv* %stash, i8* %name, i64 %len, i64 %level)
  %tobool = icmp eq %struct.gv* %call, null
  br i1 %tobool, label %if.then, label %return

if.then:                                          ; preds = %entry
  %0 = getelementptr inbounds [9 x i8]* %autoload, i64 0, i64 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* getelementptr inbounds ([9 x i8]* @Perl_gv_autoload4.autoload, i64 0, i64 0), i64 9, i32 1, i1 false)
  %tobool1 = icmp eq %struct.hv* %stash, null
  br i1 %tobool1, label %return, label %if.end

if.end:                                           ; preds = %if.then
  %cmp = icmp eq i64 %len, 8
  br i1 %cmp, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %call3 = call i32 @strncmp(i8* %name, i8* %0, i64 8) #2
  %tobool4 = icmp eq i32 %call3, 0
  br i1 %tobool4, label %return, label %if.end6

if.end6:                                          ; preds = %land.lhs.true, %if.end
  %call8 = call %struct.gv* @Perl_gv_fetchmeth(%struct.hv* %stash, i8* %0, i64 8, i64 0)
  %tobool9 = icmp eq %struct.gv* %call8, null
  br i1 %tobool9, label %return, label %if.end11

if.end11:                                         ; preds = %if.end6
  %sv_any = getelementptr inbounds %struct.gv* %call8, i64 0, i32 0
  %1 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %1, i64 0, i32 7
  %2 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_cv = getelementptr inbounds %struct.gp* %2, i64 0, i32 7
  %3 = load %struct.cv** %gp_cv, align 8, !tbaa !47
  %sv_any12 = getelementptr inbounds %struct.cv* %3, i64 0, i32 0
  %4 = load %struct.xpvcv** %sv_any12, align 8, !tbaa !48
  %xcv_root = getelementptr inbounds %struct.xpvcv* %4, i64 0, i32 9
  %5 = load %struct.op** %xcv_root, align 8, !tbaa !64
  %tobool13 = icmp eq %struct.op* %5, null
  br i1 %tobool13, label %lor.lhs.false, label %if.end17

lor.lhs.false:                                    ; preds = %if.end11
  %xcv_xsub = getelementptr inbounds %struct.xpvcv* %4, i64 0, i32 10
  %6 = load void (%struct.cv*)** %xcv_xsub, align 8, !tbaa !65
  %tobool15 = icmp eq void (%struct.cv*)* %6, null
  br i1 %tobool15, label %return, label %if.end17

if.end17:                                         ; preds = %lor.lhs.false, %if.end11
  %cmp18 = icmp slt i64 %level, 0
  br i1 %cmp18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.end17
  %call20 = call %struct.gv* @Perl_gv_fetchmeth(%struct.hv* %stash, i8* %name, i64 %len, i64 0)
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.end17
  %level.lobit = lshr i64 %level, 63
  %.not = xor i64 %level.lobit, 1
  %call24 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %stash, i8* %name, i64 %len, i64 %.not) #2
  %tobool25 = icmp eq %struct.sv** %call24, null
  br i1 %tobool25, label %return, label %if.end27

if.end27:                                         ; preds = %if.end21
  %7 = load %struct.sv** %call24, align 8
  %8 = bitcast %struct.sv* %7 to %struct.gv*
  br label %return

return:                                           ; preds = %entry, %if.end21, %lor.lhs.false, %if.end6, %land.lhs.true, %if.then, %if.end27
  %retval.0 = phi %struct.gv* [ %8, %if.end27 ], [ null, %if.then ], [ null, %land.lhs.true ], [ null, %if.end6 ], [ null, %lor.lhs.false ], [ null, %if.end21 ], [ %call, %entry ]
  ret %struct.gv* %retval.0
}

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: nounwind readonly
declare i32 @strncmp(i8* nocapture, i8* nocapture, i64) #3

; Function Attrs: nounwind uwtable
define %struct.gv* @Perl_gv_fetchmethod(%struct.hv* %stash, i8* %name) #0 {
entry:
  %call = tail call %struct.gv* @Perl_gv_fetchmethod_autoload(%struct.hv* %stash, i8* %name, i64 1)
  ret %struct.gv* %call
}

; Function Attrs: nounwind uwtable
define %struct.gv* @Perl_gv_fetchmethod_autoload(%struct.hv* %stash, i8* %name, i64 %autoload) #0 {
entry:
  %tobool = icmp eq %struct.hv* %stash, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.hv* %stash, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !66
  %and = and i64 %0, 255
  %cmp = icmp ult i64 %and, 11
  %.stash = select i1 %cmp, %struct.hv* null, %struct.hv* %stash
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %stash.addr.0 = phi %struct.hv* [ null, %entry ], [ %.stash, %land.lhs.true ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %nsplit.0 = phi i8* [ null, %if.end ], [ %nsplit.1, %for.inc ]
  %nend.0 = phi i8* [ %name, %if.end ], [ %incdec.ptr15, %for.inc ]
  %1 = load i8* %nend.0, align 1, !tbaa !26
  switch i8 %1, label %if.else [
    i8 0, label %for.end
    i8 39, label %for.inc
  ]

if.else:                                          ; preds = %for.cond
  %cmp6 = icmp eq i8 %1, 58
  br i1 %cmp6, label %land.lhs.true8, label %for.inc

land.lhs.true8:                                   ; preds = %if.else
  %add.ptr = getelementptr inbounds i8* %nend.0, i64 1
  %2 = load i8* %add.ptr, align 1, !tbaa !26
  %cmp10 = icmp eq i8 %2, 58
  %incdec.ptr.nsplit.0 = select i1 %cmp10, i8* %add.ptr, i8* %nsplit.0
  %incdec.ptr.nend.0 = select i1 %cmp10, i8* %add.ptr, i8* %nend.0
  br label %for.inc

for.inc:                                          ; preds = %land.lhs.true8, %for.cond, %if.else
  %nsplit.1 = phi i8* [ %nsplit.0, %if.else ], [ %nend.0, %for.cond ], [ %incdec.ptr.nsplit.0, %land.lhs.true8 ]
  %nend.1 = phi i8* [ %nend.0, %if.else ], [ %nend.0, %for.cond ], [ %incdec.ptr.nend.0, %land.lhs.true8 ]
  %incdec.ptr15 = getelementptr inbounds i8* %nend.1, i64 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool16 = icmp eq i8* %nsplit.0, null
  br i1 %tobool16, label %if.end66, label %if.then17

if.then17:                                        ; preds = %for.end
  %add.ptr18 = getelementptr inbounds i8* %nsplit.0, i64 1
  %3 = load i8* %nsplit.0, align 1, !tbaa !26
  %cmp20 = icmp eq i8 %3, 58
  %incdec.ptr23 = getelementptr inbounds i8* %nsplit.0, i64 -1
  %incdec.ptr23.nsplit.0 = select i1 %cmp20, i8* %incdec.ptr23, i8* %nsplit.0
  %sub.ptr.lhs.cast = ptrtoint i8* %incdec.ptr23.nsplit.0 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %name to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp25 = icmp eq i64 %sub.ptr.sub, 5
  br i1 %cmp25, label %land.lhs.true27, label %if.else37

land.lhs.true27:                                  ; preds = %if.then17
  %call = tail call i32 @strncmp(i8* %name, i8* getelementptr inbounds ([6 x i8]* @.str11, i64 0, i64 0), i64 5) #2
  %tobool28 = icmp eq i32 %call, 0
  br i1 %tobool28, label %if.then29, label %if.else37

if.then29:                                        ; preds = %land.lhs.true27
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_stash = getelementptr inbounds %struct.cop* %4, i64 0, i32 9
  %5 = load %struct.hv** %cop_stash, align 8, !tbaa !67
  %tobool30 = icmp eq %struct.hv* %5, null
  br i1 %tobool30, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.then29
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_stash31 = getelementptr inbounds %struct.cop* %6, i64 0, i32 9
  %7 = load %struct.hv** %cop_stash31, align 8, !tbaa !67
  %sv_any = getelementptr inbounds %struct.hv* %7, i64 0, i32 0
  %8 = load %struct.xpvhv** %sv_any, align 8, !tbaa !20
  %xhv_name = getelementptr inbounds %struct.xpvhv* %8, i64 0, i32 10
  %9 = load i8** %xhv_name, align 8, !tbaa !54
  br label %cond.end

cond.end:                                         ; preds = %if.then29, %cond.true
  %cond = phi i8* [ %9, %cond.true ], [ null, %if.then29 ]
  %call32 = tail call %struct.sv* (i8*, ...)* @Perl_newSVpvf(i8* getelementptr inbounds ([10 x i8]* @.str12, i64 0, i64 0), i8* %cond) #2
  %call33 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call32) #2
  %sv_any34 = getelementptr inbounds %struct.sv* %call33, i64 0, i32 0
  %10 = load i8** %sv_any34, align 8, !tbaa !39
  %xpv_pv = bitcast i8* %10 to i8**
  %11 = load i8** %xpv_pv, align 8, !tbaa !30
  %xpv_cur = getelementptr inbounds i8* %10, i64 8
  %12 = bitcast i8* %xpv_cur to i64*
  %13 = load i64* %12, align 8, !tbaa !62
  %call36 = tail call %struct.hv* @Perl_gv_stashpvn(i8* %11, i64 %13, i64 1)
  br label %if.end66

if.else37:                                        ; preds = %land.lhs.true27, %if.then17
  %call41 = tail call %struct.hv* @Perl_gv_stashpvn(i8* %name, i64 %sub.ptr.sub, i64 0)
  %tobool42 = icmp eq %struct.hv* %call41, null
  %cmp47 = icmp sgt i64 %sub.ptr.sub, 6
  %or.cond = and i1 %tobool42, %cmp47
  br i1 %or.cond, label %land.lhs.true49, label %if.end66

land.lhs.true49:                                  ; preds = %if.else37
  %add.ptr50 = getelementptr inbounds i8* %incdec.ptr23.nsplit.0, i64 -7
  %call51 = tail call i32 @strncmp(i8* %add.ptr50, i8* getelementptr inbounds ([8 x i8]* @.str8, i64 0, i64 0), i64 7) #2
  %tobool52 = icmp eq i32 %call51, 0
  br i1 %tobool52, label %land.lhs.true53, label %if.end66

land.lhs.true53:                                  ; preds = %land.lhs.true49
  %sub = add nsw i64 %sub.ptr.sub, -7
  %call57 = tail call %struct.hv* @Perl_gv_stashpvn(i8* %name, i64 %sub, i64 0)
  %tobool58 = icmp eq %struct.hv* %call57, null
  br i1 %tobool58, label %if.end66, label %if.then59

if.then59:                                        ; preds = %land.lhs.true53
  %call63 = tail call %struct.hv* @Perl_gv_stashpvn(i8* %name, i64 %sub.ptr.sub, i64 1)
  br label %if.end66

if.end66:                                         ; preds = %cond.end, %if.then59, %if.else37, %land.lhs.true49, %land.lhs.true53, %for.end
  %ostash.0 = phi %struct.hv* [ %stash, %for.end ], [ %call41, %if.else37 ], [ null, %land.lhs.true49 ], [ %call63, %if.then59 ], [ null, %land.lhs.true53 ], [ %call36, %cond.end ]
  %name.addr.0 = phi i8* [ %name, %for.end ], [ %add.ptr18, %if.else37 ], [ %add.ptr18, %land.lhs.true49 ], [ %add.ptr18, %if.then59 ], [ %add.ptr18, %land.lhs.true53 ], [ %add.ptr18, %cond.end ]
  %stash.addr.2 = phi %struct.hv* [ %stash.addr.0, %for.end ], [ %call41, %if.else37 ], [ null, %land.lhs.true49 ], [ %call63, %if.then59 ], [ null, %land.lhs.true53 ], [ %call36, %cond.end ]
  %sub.ptr.lhs.cast67 = ptrtoint i8* %nend.0 to i64
  %sub.ptr.rhs.cast68 = ptrtoint i8* %name.addr.0 to i64
  %sub.ptr.sub69 = sub i64 %sub.ptr.lhs.cast67, %sub.ptr.rhs.cast68
  %call70 = tail call %struct.gv* @Perl_gv_fetchmeth(%struct.hv* %stash.addr.2, i8* %name.addr.0, i64 %sub.ptr.sub69, i64 0)
  %tobool71 = icmp eq %struct.gv* %call70, null
  br i1 %tobool71, label %if.then72, label %if.else87

if.then72:                                        ; preds = %if.end66
  %call73 = tail call i32 @strcmp(i8* %name.addr.0, i8* getelementptr inbounds ([7 x i8]* @.str13, i64 0, i64 0)) #2
  %tobool74 = icmp eq i32 %call73, 0
  br i1 %tobool74, label %if.end121, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then72
  %call75 = tail call i32 @strcmp(i8* %name.addr.0, i8* getelementptr inbounds ([9 x i8]* @.str14, i64 0, i64 0)) #2
  %tobool76 = icmp eq i32 %call75, 0
  br i1 %tobool76, label %if.end121, label %if.else78

if.else78:                                        ; preds = %lor.lhs.false
  %tobool79 = icmp eq i64 %autoload, 0
  br i1 %tobool79, label %if.end121, label %if.then80

if.then80:                                        ; preds = %if.else78
  %call84 = tail call %struct.gv* @Perl_gv_autoload4(%struct.hv* %ostash.0, i8* %name.addr.0, i64 %sub.ptr.sub69, i64 1)
  br label %if.end121

if.else87:                                        ; preds = %if.end66
  %tobool88 = icmp eq i64 %autoload, 0
  br i1 %tobool88, label %if.end121, label %if.then89

if.then89:                                        ; preds = %if.else87
  %sv_any90 = getelementptr inbounds %struct.gv* %call70, i64 0, i32 0
  %14 = load %struct.xpvgv** %sv_any90, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %14, i64 0, i32 7
  %15 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_cv = getelementptr inbounds %struct.gp* %15, i64 0, i32 7
  %16 = load %struct.cv** %gp_cv, align 8, !tbaa !47
  %sv_any91 = getelementptr inbounds %struct.cv* %16, i64 0, i32 0
  %17 = load %struct.xpvcv** %sv_any91, align 8, !tbaa !48
  %xcv_root = getelementptr inbounds %struct.xpvcv* %17, i64 0, i32 9
  %18 = load %struct.op** %xcv_root, align 8, !tbaa !64
  %tobool92 = icmp eq %struct.op* %18, null
  br i1 %tobool92, label %land.lhs.true93, label %if.end121

land.lhs.true93:                                  ; preds = %if.then89
  %xcv_xsub = getelementptr inbounds %struct.xpvcv* %17, i64 0, i32 10
  %19 = load void (%struct.cv*)** %xcv_xsub, align 8, !tbaa !65
  %tobool95 = icmp eq void (%struct.cv*)* %19, null
  br i1 %tobool95, label %if.then96, label %if.end121

if.then96:                                        ; preds = %land.lhs.true93
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %17, i64 0, i32 17
  %20 = load i16* %xcv_flags, align 2, !tbaa !68
  %and99 = and i16 %20, 4
  %tobool100 = icmp eq i16 %and99, 0
  br i1 %tobool100, label %if.else102, label %if.end111

if.else102:                                       ; preds = %if.then96
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %17, i64 0, i32 12
  %21 = load %struct.gv** %xcv_gv, align 8, !tbaa !50
  %sv_any104 = getelementptr inbounds %struct.gv* %21, i64 0, i32 0
  %22 = load %struct.xpvgv** %sv_any104, align 8, !tbaa !7
  %xgv_gp105 = getelementptr inbounds %struct.xpvgv* %22, i64 0, i32 7
  %23 = load %struct.gp** %xgv_gp105, align 8, !tbaa !9
  %gp_cv106 = getelementptr inbounds %struct.gp* %23, i64 0, i32 7
  %24 = load %struct.cv** %gp_cv106, align 8, !tbaa !47
  %cmp107 = icmp eq %struct.cv* %24, %16
  %.call70 = select i1 %cmp107, %struct.gv* %21, %struct.gv* %call70
  %sv_any112.phi.trans.insert = getelementptr inbounds %struct.gv* %.call70, i64 0, i32 0
  %.pre = load %struct.xpvgv** %sv_any112.phi.trans.insert, align 8, !tbaa !7
  br label %if.end111

if.end111:                                        ; preds = %if.else102, %if.then96
  %25 = phi %struct.xpvgv* [ %14, %if.then96 ], [ %.pre, %if.else102 ]
  %xgv_stash = getelementptr inbounds %struct.xpvgv* %25, i64 0, i32 10
  %26 = load %struct.hv** %xgv_stash, align 8, !tbaa !43
  %xgv_name = getelementptr inbounds %struct.xpvgv* %25, i64 0, i32 8
  %27 = load i8** %xgv_name, align 8, !tbaa !44
  %xgv_namelen = getelementptr inbounds %struct.xpvgv* %25, i64 0, i32 9
  %28 = load i64* %xgv_namelen, align 8, !tbaa !45
  %call115 = tail call %struct.gv* @Perl_gv_autoload4(%struct.hv* %26, i8* %27, i64 %28, i64 1)
  %tobool116 = icmp eq %struct.gv* %call115, null
  %call70.call115 = select i1 %tobool116, %struct.gv* %call70, %struct.gv* %call115
  ret %struct.gv* %call70.call115

if.end121:                                        ; preds = %if.then72, %lor.lhs.false, %land.lhs.true93, %if.then89, %if.else87, %if.else78, %if.then80
  %gv.0 = phi %struct.gv* [ %call70, %if.then89 ], [ %call70, %land.lhs.true93 ], [ %call70, %if.else87 ], [ %call84, %if.then80 ], [ null, %if.else78 ], [ bitcast (%struct.sv* @PL_sv_yes to %struct.gv*), %lor.lhs.false ], [ bitcast (%struct.sv* @PL_sv_yes to %struct.gv*), %if.then72 ]
  ret %struct.gv* %gv.0
}

declare %struct.sv* @Perl_sv_2mortal(%struct.sv*) #1

declare %struct.sv* @Perl_newSVpvf(i8*, ...) #1

; Function Attrs: nounwind uwtable
define %struct.gv* @Perl_gv_autoload4(%struct.hv* %stash, i8* %name, i64 %len, i64 %method) #0 {
entry:
  %autoload = alloca [9 x i8], align 1
  %0 = getelementptr inbounds [9 x i8]* %autoload, i64 0, i64 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* getelementptr inbounds ([9 x i8]* @Perl_gv_autoload4.autoload, i64 0, i64 0), i64 9, i32 1, i1 false)
  %cmp = icmp eq i64 %len, 8
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call = call i32 @strncmp(i8* %name, i8* %0, i64 8) #2
  %tobool = icmp eq i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %tobool1 = icmp eq %struct.hv* %stash, null
  br i1 %tobool1, label %if.end11, label %if.then2

if.then2:                                         ; preds = %if.end
  %sv_flags = getelementptr inbounds %struct.hv* %stash, i64 0, i32 2
  %1 = load i64* %sv_flags, align 8, !tbaa !66
  %and = and i64 %1, 255
  %cmp3 = icmp ult i64 %and, 11
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then2
  %and6 = and i64 %1, 262144
  %cmp7 = icmp eq i64 %and6, 0
  br i1 %cmp7, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then4
  %sv_any = bitcast %struct.hv* %stash to i8**
  %2 = load i8** %sv_any, align 8, !tbaa !39
  %xpv_pv = bitcast i8* %2 to i8**
  %3 = load i8** %xpv_pv, align 8, !tbaa !30
  br label %if.end11

cond.false:                                       ; preds = %if.then4
  %4 = bitcast %struct.hv* %stash to %struct.sv*
  %call8 = call i8* @Perl_sv_2pv_nolen(%struct.sv* %4) #2
  br label %if.end11

if.else:                                          ; preds = %if.then2
  %sv_any9 = getelementptr inbounds %struct.hv* %stash, i64 0, i32 0
  %5 = load %struct.xpvhv** %sv_any9, align 8, !tbaa !20
  %xhv_name = getelementptr inbounds %struct.xpvhv* %5, i64 0, i32 10
  %6 = load i8** %xhv_name, align 8, !tbaa !54
  br label %if.end11

if.end11:                                         ; preds = %cond.true, %cond.false, %if.end, %if.else
  %stash.addr.0 = phi %struct.hv* [ %stash, %if.else ], [ null, %if.end ], [ null, %cond.false ], [ null, %cond.true ]
  %packname.0 = phi i8* [ %6, %if.else ], [ getelementptr inbounds ([1 x i8]* @.str3, i64 0, i64 0), %if.end ], [ %call8, %cond.false ], [ %3, %cond.true ]
  %call13 = call %struct.gv* @Perl_gv_fetchmeth(%struct.hv* %stash.addr.0, i8* %0, i64 8, i64 0)
  %tobool14 = icmp eq %struct.gv* %call13, null
  br i1 %tobool14, label %return, label %if.end16

if.end16:                                         ; preds = %if.end11
  %sv_any17 = getelementptr inbounds %struct.gv* %call13, i64 0, i32 0
  %7 = load %struct.xpvgv** %sv_any17, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %7, i64 0, i32 7
  %8 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_cv = getelementptr inbounds %struct.gp* %8, i64 0, i32 7
  %9 = load %struct.cv** %gp_cv, align 8, !tbaa !47
  %sv_any18 = getelementptr inbounds %struct.cv* %9, i64 0, i32 0
  %10 = load %struct.xpvcv** %sv_any18, align 8, !tbaa !48
  %xcv_root = getelementptr inbounds %struct.xpvcv* %10, i64 0, i32 9
  %11 = load %struct.op** %xcv_root, align 8, !tbaa !64
  %tobool19 = icmp eq %struct.op* %11, null
  br i1 %tobool19, label %lor.lhs.false, label %if.end23

lor.lhs.false:                                    ; preds = %if.end16
  %xcv_xsub = getelementptr inbounds %struct.xpvcv* %10, i64 0, i32 10
  %12 = load void (%struct.cv*)** %xcv_xsub, align 8, !tbaa !65
  %tobool21 = icmp eq void (%struct.cv*)* %12, null
  br i1 %tobool21, label %return, label %if.end23

if.end23:                                         ; preds = %lor.lhs.false, %if.end16
  %13 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings = getelementptr inbounds %struct.cop* %13, i64 0, i32 14
  %14 = load %struct.sv** %cop_warnings, align 8, !tbaa !63
  %cmp24 = icmp eq %struct.sv* %14, null
  br i1 %cmp24, label %lor.lhs.false45, label %land.lhs.true25

land.lhs.true25:                                  ; preds = %if.end23
  %15 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings26 = getelementptr inbounds %struct.cop* %15, i64 0, i32 14
  %16 = load %struct.sv** %cop_warnings26, align 8, !tbaa !63
  %cmp27 = icmp eq %struct.sv* %16, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp27, label %lor.lhs.false45, label %land.lhs.true28

land.lhs.true28:                                  ; preds = %land.lhs.true25
  %17 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings29 = getelementptr inbounds %struct.cop* %17, i64 0, i32 14
  %18 = load %struct.sv** %cop_warnings29, align 8, !tbaa !63
  %cmp30 = icmp eq %struct.sv* %18, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp30, label %land.lhs.true53, label %lor.lhs.false31

lor.lhs.false31:                                  ; preds = %land.lhs.true28
  %19 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings32 = getelementptr inbounds %struct.cop* %19, i64 0, i32 14
  %20 = load %struct.sv** %cop_warnings32, align 8, !tbaa !63
  %sv_any33 = getelementptr inbounds %struct.sv* %20, i64 0, i32 0
  %21 = load i8** %sv_any33, align 8, !tbaa !39
  %xpv_pv34 = bitcast i8* %21 to i8**
  %22 = load i8** %xpv_pv34, align 8, !tbaa !30
  %23 = load i8* %22, align 1, !tbaa !26
  %and35 = and i8 %23, 16
  %tobool36 = icmp eq i8 %and35, 0
  br i1 %tobool36, label %lor.lhs.false37, label %land.lhs.true53

lor.lhs.false37:                                  ; preds = %lor.lhs.false31
  %24 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings38 = getelementptr inbounds %struct.cop* %24, i64 0, i32 14
  %25 = load %struct.sv** %cop_warnings38, align 8, !tbaa !63
  %sv_any39 = getelementptr inbounds %struct.sv* %25, i64 0, i32 0
  %26 = load i8** %sv_any39, align 8, !tbaa !39
  %xpv_pv40 = bitcast i8* %26 to i8**
  %27 = load i8** %xpv_pv40, align 8, !tbaa !30
  %arrayidx41 = getelementptr inbounds i8* %27, i64 7
  %28 = load i8* %arrayidx41, align 1, !tbaa !26
  %and43 = and i8 %28, 1
  %tobool44 = icmp eq i8 %and43, 0
  br i1 %tobool44, label %lor.lhs.false45, label %land.lhs.true53

lor.lhs.false45:                                  ; preds = %lor.lhs.false37, %land.lhs.true25, %if.end23
  %29 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings46 = getelementptr inbounds %struct.cop* %29, i64 0, i32 14
  %30 = load %struct.sv** %cop_warnings46, align 8, !tbaa !63
  %cmp47 = icmp eq %struct.sv* %30, null
  br i1 %cmp47, label %land.lhs.true49, label %if.end65

land.lhs.true49:                                  ; preds = %lor.lhs.false45
  %31 = load i8* @PL_dowarn, align 1, !tbaa !26
  %and51 = and i8 %31, 1
  %tobool52 = icmp eq i8 %and51, 0
  %tobool54 = icmp ne i64 %method, 0
  %or.cond = or i1 %tobool52, %tobool54
  br i1 %or.cond, label %if.end65, label %land.lhs.true55

land.lhs.true53:                                  ; preds = %lor.lhs.false37, %lor.lhs.false31, %land.lhs.true28
  %tobool54.old = icmp eq i64 %method, 0
  br i1 %tobool54.old, label %land.lhs.true55, label %if.end65

land.lhs.true55:                                  ; preds = %land.lhs.true53, %land.lhs.true49
  %32 = load %struct.xpvgv** %sv_any17, align 8, !tbaa !7
  %xgv_gp57 = getelementptr inbounds %struct.xpvgv* %32, i64 0, i32 7
  %33 = load %struct.gp** %xgv_gp57, align 8, !tbaa !9
  %gp_cvgen = getelementptr inbounds %struct.gp* %33, i64 0, i32 8
  %34 = load i64* %gp_cvgen, align 8, !tbaa !41
  %tobool58 = icmp eq i64 %34, 0
  br i1 %tobool58, label %lor.lhs.false59, label %if.then63

lor.lhs.false59:                                  ; preds = %land.lhs.true55
  %xgv_stash = getelementptr inbounds %struct.xpvgv* %32, i64 0, i32 10
  %35 = load %struct.hv** %xgv_stash, align 8, !tbaa !43
  %cmp61 = icmp eq %struct.hv* %35, %stash.addr.0
  br i1 %cmp61, label %if.end65, label %if.then63

if.then63:                                        ; preds = %lor.lhs.false59, %land.lhs.true55
  %conv64 = trunc i64 %len to i32
  call void (i64, i8*, ...)* @Perl_warner(i64 7170, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i8* %packname.0, i32 %conv64, i8* %name) #2
  br label %if.end65

if.end65:                                         ; preds = %land.lhs.true53, %lor.lhs.false59, %land.lhs.true49, %if.then63, %lor.lhs.false45
  %36 = load %struct.xpvcv** %sv_any18, align 8, !tbaa !48
  %xcv_xsub67 = getelementptr inbounds %struct.xpvcv* %36, i64 0, i32 10
  %37 = load void (%struct.cv*)** %xcv_xsub67, align 8, !tbaa !65
  %tobool68 = icmp eq void (%struct.cv*)* %37, null
  br i1 %tobool68, label %if.end74, label %if.then69

if.then69:                                        ; preds = %if.end65
  %xcv_stash = getelementptr inbounds %struct.xpvcv* %36, i64 0, i32 7
  store %struct.hv* %stash.addr.0, %struct.hv** %xcv_stash, align 8, !tbaa !53
  %xpv_pv72 = getelementptr inbounds %struct.xpvcv* %36, i64 0, i32 0
  store i8* %name, i8** %xpv_pv72, align 8, !tbaa !30
  %38 = getelementptr inbounds %struct.xpvcv* %36, i64 0, i32 1
  store i64 %len, i64* %38, align 8, !tbaa !62
  br label %return

if.end74:                                         ; preds = %if.end65
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %36, i64 0, i32 12
  %39 = load %struct.gv** %xcv_gv, align 8, !tbaa !50
  %sv_any76 = getelementptr inbounds %struct.gv* %39, i64 0, i32 0
  %40 = load %struct.xpvgv** %sv_any76, align 8, !tbaa !7
  %xgv_stash77 = getelementptr inbounds %struct.xpvgv* %40, i64 0, i32 10
  %41 = load %struct.hv** %xgv_stash77, align 8, !tbaa !43
  %call79 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %41, i8* %0, i64 8, i64 1) #2
  %42 = load %struct.sv** %call79, align 8
  call void @Perl_push_scope() #2
  %43 = getelementptr inbounds %struct.sv* %42, i64 0, i32 2
  %44 = load i64* %43, align 8, !tbaa !27
  %and81 = and i64 %44, 255
  %cmp82 = icmp eq i64 %and81, 13
  br i1 %cmp82, label %if.end86, label %if.then84

if.then84:                                        ; preds = %if.end74
  %45 = bitcast %struct.sv* %42 to %struct.gv*
  call void @Perl_gv_init(%struct.gv* %45, %struct.hv* %41, i8* %0, i64 8, i32 0)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %if.end74
  call void @Perl_pop_scope() #2
  %sv_any87 = bitcast %struct.sv* %42 to %struct.xpvgv**
  %46 = load %struct.xpvgv** %sv_any87, align 8, !tbaa !7
  %xgv_gp88 = getelementptr inbounds %struct.xpvgv* %46, i64 0, i32 7
  %47 = load %struct.gp** %xgv_gp88, align 8, !tbaa !9
  %gp_sv = getelementptr inbounds %struct.gp* %47, i64 0, i32 0
  %48 = load %struct.sv** %gp_sv, align 8, !tbaa !28
  call void @Perl_sv_setpv(%struct.sv* %48, i8* %packname.0) #2
  call void @Perl_sv_catpvn_flags(%struct.sv* %48, i8* getelementptr inbounds ([3 x i8]* @.str16, i64 0, i64 0), i64 2, i64 2) #2
  call void @Perl_sv_catpvn_flags(%struct.sv* %48, i8* %name, i64 %len, i64 2) #2
  %49 = load i8* @PL_tainting, align 1, !tbaa !26
  %tobool89 = icmp eq i8 %49, 0
  br i1 %tobool89, label %return, label %if.then90

if.then90:                                        ; preds = %if.end86
  call void @Perl_sv_untaint(%struct.sv* %48) #2
  br label %return

return:                                           ; preds = %if.then90, %if.end86, %lor.lhs.false, %if.end11, %land.lhs.true, %if.then69
  %retval.0 = phi %struct.gv* [ %call13, %if.then69 ], [ null, %land.lhs.true ], [ null, %if.end11 ], [ null, %lor.lhs.false ], [ %call13, %if.end86 ], [ %call13, %if.then90 ]
  ret %struct.gv* %retval.0
}

declare i8* @Perl_sv_2pv_nolen(%struct.sv*) #1

declare void @Perl_sv_catpvn_flags(%struct.sv*, i8*, i64, i64) #1

declare void @Perl_sv_untaint(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.hv* @Perl_gv_stashpv(i8* %name, i64 %create) #0 {
entry:
  %call = tail call i64 @strlen(i8* %name) #2
  %call1 = tail call %struct.hv* @Perl_gv_stashpvn(i8* %name, i64 %call, i64 %create)
  ret %struct.hv* %call1
}

; Function Attrs: nounwind uwtable
define %struct.gv* @Perl_gv_fetchpv(i8* %nambeg, i64 %add, i64 %sv_type) #0 {
entry:
  %smallbuf.i = alloca [256 x i8], align 16
  %smallbuf = alloca [256 x i8], align 16
  %0 = load i8* %nambeg, align 1, !tbaa !26
  %cmp = icmp eq i8 %0, 42
  br i1 %cmp, label %land.lhs.true, label %for.cond.preheader

land.lhs.true:                                    ; preds = %entry
  %arrayidx = getelementptr inbounds i8* %nambeg, i64 1
  %1 = load i8* %arrayidx, align 1, !tbaa !26
  %.off1361 = add i8 %1, -65
  %2 = icmp ult i8 %.off1361, 26
  %.off1362 = add i8 %1, -97
  %3 = icmp ult i8 %.off1362, 26
  %or.cond1364 = or i1 %2, %3
  %arrayidx.nambeg = select i1 %or.cond1364, i8* %arrayidx, i8* %nambeg
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %entry, %land.lhs.true
  %namend.0.ph = phi i8* [ %arrayidx.nambeg, %land.lhs.true ], [ %nambeg, %entry ]
  %4 = getelementptr inbounds [256 x i8]* %smallbuf, i64 0, i64 0
  %sub.ptr.rhs.cast98 = ptrtoint i8* %nambeg to i64
  %add.tr = trunc i64 %add to i32
  %conv69 = and i32 %add.tr, 2
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %stash.0 = phi %struct.hv* [ %stash.5, %for.inc ], [ null, %for.cond.preheader ]
  %namend.0 = phi i8* [ %incdec.ptr122, %for.inc ], [ %namend.0.ph, %for.cond.preheader ]
  %gv.0 = phi %struct.gv* [ %gv.2, %for.inc ], [ null, %for.cond.preheader ]
  %name.1 = phi i8* [ %name.2, %for.inc ], [ %namend.0.ph, %for.cond.preheader ]
  %5 = load i8* %namend.0, align 1, !tbaa !26
  switch i8 %5, label %for.inc [
    i8 0, label %for.end
    i8 58, label %land.lhs.true22
    i8 39, label %land.lhs.true31
  ]

land.lhs.true22:                                  ; preds = %for.cond
  %arrayidx23 = getelementptr inbounds i8* %namend.0, i64 1
  %6 = load i8* %arrayidx23, align 1, !tbaa !26
  %cmp25 = icmp eq i8 %6, 58
  br i1 %cmp25, label %if.then35, label %for.inc

land.lhs.true31:                                  ; preds = %for.cond
  %arrayidx32 = getelementptr inbounds i8* %namend.0, i64 1
  %7 = load i8* %arrayidx32, align 1, !tbaa !26
  %tobool34 = icmp eq i8 %7, 0
  br i1 %tobool34, label %for.inc, label %if.then35

if.then35:                                        ; preds = %land.lhs.true31, %land.lhs.true22
  %tobool36 = icmp eq %struct.hv* %stash.0, null
  %8 = load %struct.hv** @PL_defstash, align 8, !tbaa !19
  %.stash.0 = select i1 %tobool36, %struct.hv* %8, %struct.hv* %stash.0
  %tobool39 = icmp eq %struct.hv* %.stash.0, null
  br i1 %tobool39, label %return, label %lor.lhs.false40

lor.lhs.false40:                                  ; preds = %if.then35
  %sv_refcnt = getelementptr inbounds %struct.hv* %.stash.0, i64 0, i32 1
  %9 = load i64* %sv_refcnt, align 8, !tbaa !69
  %tobool41 = icmp eq i64 %9, 0
  br i1 %tobool41, label %return, label %if.end43

if.end43:                                         ; preds = %lor.lhs.false40
  %sub.ptr.lhs.cast = ptrtoint i8* %namend.0 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %name.1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp44 = icmp sgt i64 %sub.ptr.sub, 0
  br i1 %cmp44, label %if.then46, label %if.end104

if.then46:                                        ; preds = %if.end43
  call void @llvm.lifetime.start(i64 256, i8* %4) #2
  %add47 = add nsw i64 %sub.ptr.sub, 3
  %cmp48 = icmp ult i64 %add47, 256
  br i1 %cmp48, label %if.end52, label %if.else

if.else:                                          ; preds = %if.then46
  %call = call i8* @Perl_safesysmalloc(i64 %add47) #2
  br label %if.end52

if.end52:                                         ; preds = %if.then46, %if.else
  %tmpbuf.0 = phi i8* [ %call, %if.else ], [ %4, %if.then46 ]
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %tmpbuf.0, i8* %name.1, i64 %sub.ptr.sub, i32 1, i1 false)
  %inc = add nsw i64 %sub.ptr.sub, 1
  %arrayidx54 = getelementptr inbounds i8* %tmpbuf.0, i64 %sub.ptr.sub
  store i8 58, i8* %arrayidx54, align 1, !tbaa !26
  %inc55 = add nsw i64 %sub.ptr.sub, 2
  %arrayidx56 = getelementptr inbounds i8* %tmpbuf.0, i64 %inc
  store i8 58, i8* %arrayidx56, align 1, !tbaa !26
  %arrayidx57 = getelementptr inbounds i8* %tmpbuf.0, i64 %inc55
  store i8 0, i8* %arrayidx57, align 1, !tbaa !26
  %call58 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %.stash.0, i8* %tmpbuf.0, i64 %inc55, i64 %add) #2
  %tobool59 = icmp eq %struct.sv** %call58, null
  br i1 %tobool59, label %if.end74, label %cond.end

cond.end:                                         ; preds = %if.end52
  %10 = load %struct.sv** %call58, align 8
  %11 = bitcast %struct.sv* %10 to %struct.gv*
  %tobool60 = icmp ne %struct.sv* %10, null
  %cmp62 = icmp ne %struct.sv* %10, @PL_sv_undef
  %or.cond = and i1 %tobool60, %cmp62
  br i1 %or.cond, label %if.then64, label %if.end74

if.then64:                                        ; preds = %cond.end
  %12 = getelementptr inbounds %struct.sv* %10, i64 0, i32 2
  %13 = load i64* %12, align 8, !tbaa !27
  %and = and i64 %13, 255
  %cmp65 = icmp eq i64 %and, 13
  br i1 %cmp65, label %if.else70, label %if.then67

if.then67:                                        ; preds = %if.then64
  call void @Perl_gv_init(%struct.gv* %11, %struct.hv* %.stash.0, i8* %tmpbuf.0, i64 %inc55, i32 %conv69)
  br label %if.end74

if.else70:                                        ; preds = %if.then64
  %sv_any = bitcast %struct.sv* %10 to %struct.xpvgv**
  %14 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %14, i64 0, i32 11
  %15 = load i8* %xgv_flags, align 1, !tbaa !46
  %or = or i8 %15, 2
  store i8 %or, i8* %xgv_flags, align 1, !tbaa !46
  br label %if.end74

if.end74:                                         ; preds = %if.end52, %if.then67, %if.else70, %cond.end
  %cond1348 = phi %struct.gv* [ %11, %if.then67 ], [ %11, %if.else70 ], [ %11, %cond.end ], [ null, %if.end52 ]
  %cmp76 = icmp eq i8* %tmpbuf.0, %4
  br i1 %cmp76, label %if.end79, label %if.then78

if.then78:                                        ; preds = %if.end74
  call void @Perl_safesysfree(i8* %tmpbuf.0) #2
  br label %if.end79

if.end79:                                         ; preds = %if.end74, %if.then78
  %tobool80 = icmp eq %struct.gv* %cond1348, null
  %cmp82 = icmp eq %struct.gv* %cond1348, bitcast (%struct.sv* @PL_sv_undef to %struct.gv*)
  %or.cond875 = or i1 %tobool80, %cmp82
  br i1 %or.cond875, label %return, label %if.end85

if.end85:                                         ; preds = %if.end79
  %sv_any86 = getelementptr inbounds %struct.gv* %cond1348, i64 0, i32 0
  %16 = load %struct.xpvgv** %sv_any86, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %16, i64 0, i32 7
  %17 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_hv = getelementptr inbounds %struct.gp* %17, i64 0, i32 5
  %18 = load %struct.hv** %gp_hv, align 8, !tbaa !14
  %tobool87 = icmp eq %struct.hv* %18, null
  br i1 %tobool87, label %if.then88, label %if.end93

if.then88:                                        ; preds = %if.end85
  %call89 = call %struct.hv* @Perl_newHV() #2
  %19 = load %struct.xpvgv** %sv_any86, align 8, !tbaa !7
  %xgv_gp91 = getelementptr inbounds %struct.xpvgv* %19, i64 0, i32 7
  %20 = load %struct.gp** %xgv_gp91, align 8, !tbaa !9
  %gp_hv92 = getelementptr inbounds %struct.gp* %20, i64 0, i32 5
  store %struct.hv* %call89, %struct.hv** %gp_hv92, align 8, !tbaa !14
  br label %if.end93

if.end93:                                         ; preds = %if.end85, %if.then88
  %stash.2 = phi %struct.hv* [ %18, %if.end85 ], [ %call89, %if.then88 ]
  %sv_any94 = getelementptr inbounds %struct.hv* %stash.2, i64 0, i32 0
  %21 = load %struct.xpvhv** %sv_any94, align 8, !tbaa !20
  %xhv_name = getelementptr inbounds %struct.xpvhv* %21, i64 0, i32 10
  %22 = load i8** %xhv_name, align 8, !tbaa !54
  %tobool95 = icmp eq i8* %22, null
  br i1 %tobool95, label %if.then96, label %if.end104

if.then96:                                        ; preds = %if.end93
  %sub.ptr.sub99 = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast98
  %call100 = call i8* @Perl_savepvn(i8* %nambeg, i64 %sub.ptr.sub99) #2
  %23 = load %struct.xpvhv** %sv_any94, align 8, !tbaa !20
  %xhv_name102 = getelementptr inbounds %struct.xpvhv* %23, i64 0, i32 10
  store i8* %call100, i8** %xhv_name102, align 8, !tbaa !54
  br label %if.end104

if.end104:                                        ; preds = %if.then96, %if.end93, %if.end43
  %stash.4 = phi %struct.hv* [ %.stash.0, %if.end43 ], [ %stash.2, %if.end93 ], [ %stash.2, %if.then96 ]
  %gv.1 = phi %struct.gv* [ %gv.0, %if.end43 ], [ %cond1348, %if.end93 ], [ %cond1348, %if.then96 ]
  %24 = load i8* %namend.0, align 1, !tbaa !26
  %cmp106 = icmp eq i8 %24, 58
  %incdec.ptr109 = getelementptr inbounds i8* %namend.0, i64 1
  %incdec.ptr109.namend.0 = select i1 %cmp106, i8* %incdec.ptr109, i8* %namend.0
  %incdec.ptr111 = getelementptr inbounds i8* %incdec.ptr109.namend.0, i64 1
  %25 = load i8* %incdec.ptr111, align 1, !tbaa !26
  %tobool112 = icmp eq i8 %25, 0
  br i1 %tobool112, label %if.then113, label %for.inc

if.then113:                                       ; preds = %if.end104
  %tobool114 = icmp eq %struct.gv* %gv.1, null
  br i1 %tobool114, label %cond.false116, label %return

cond.false116:                                    ; preds = %if.then113
  %26 = load %struct.hv** @PL_defstash, align 8, !tbaa !19
  %call117 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %26, i8* getelementptr inbounds ([7 x i8]* @.str17, i64 0, i64 0), i64 6, i64 1) #2
  %27 = load %struct.sv** %call117, align 8, !tbaa !19
  %28 = bitcast %struct.sv* %27 to %struct.gv*
  br label %return

for.inc:                                          ; preds = %for.cond, %land.lhs.true22, %if.end104, %land.lhs.true31
  %stash.5 = phi %struct.hv* [ %stash.4, %if.end104 ], [ %stash.0, %land.lhs.true31 ], [ %stash.0, %land.lhs.true22 ], [ %stash.0, %for.cond ]
  %namend.2 = phi i8* [ %incdec.ptr111, %if.end104 ], [ %namend.0, %land.lhs.true31 ], [ %namend.0, %land.lhs.true22 ], [ %namend.0, %for.cond ]
  %gv.2 = phi %struct.gv* [ %gv.1, %if.end104 ], [ %gv.0, %land.lhs.true31 ], [ %gv.0, %land.lhs.true22 ], [ %gv.0, %for.cond ]
  %name.2 = phi i8* [ %incdec.ptr111, %if.end104 ], [ %name.1, %land.lhs.true31 ], [ %name.1, %land.lhs.true22 ], [ %name.1, %for.cond ]
  %incdec.ptr122 = getelementptr inbounds i8* %namend.2, i64 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %sub.ptr.lhs.cast123 = ptrtoint i8* %namend.0 to i64
  %sub.ptr.rhs.cast124 = ptrtoint i8* %name.1 to i64
  %sub.ptr.sub125 = sub i64 %sub.ptr.lhs.cast123, %sub.ptr.rhs.cast124
  %tobool126 = icmp eq %struct.hv* %stash.0, null
  br i1 %tobool126, label %if.then127, label %if.end335

if.then127:                                       ; preds = %for.end
  %29 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %op_private = getelementptr inbounds %struct.cop* %29, i64 0, i32 7
  %30 = load i8* %op_private, align 1, !tbaa !70
  %and129 = and i8 %30, 8
  %tobool130 = icmp ne i8 %and129, 0
  %31 = load i8* %name.1, align 1, !tbaa !26
  %cmp133 = icmp ult i8 %31, -64
  %or.cond1355 = or i1 %tobool130, %cmp133
  br i1 %or.cond1355, label %cond.true135, label %cond.false155

cond.true135:                                     ; preds = %if.then127
  %.off1359 = add i8 %31, -65
  %32 = icmp ult i8 %.off1359, 26
  br i1 %32, label %if.then162, label %lor.lhs.false143

lor.lhs.false143:                                 ; preds = %cond.true135
  %.off1360 = add i8 %31, -97
  %33 = icmp ult i8 %.off1360, 26
  %cmp153 = icmp eq i8 %31, 95
  %or.cond1354 = or i1 %33, %cmp153
  br i1 %or.cond1354, label %if.then162, label %if.else303

cond.false155:                                    ; preds = %if.then127
  %call156 = call signext i8 @Perl_is_utf8_idcont(i8* %name.1) #2
  %tobool158 = icmp eq i8 %call156, 0
  br i1 %tobool158, label %if.else303, label %land.lhs.true159

land.lhs.true159:                                 ; preds = %cond.false155
  %call160 = call signext i8 @Perl_is_utf8_digit(i8* %name.1) #2
  %tobool161 = icmp eq i8 %call160, 0
  br i1 %tobool161, label %if.then162, label %if.else303

if.then162:                                       ; preds = %lor.lhs.false143, %cond.true135, %land.lhs.true159
  %arrayidx163 = getelementptr inbounds i8* %name.1, i64 1
  %34 = load i8* %arrayidx163, align 1, !tbaa !26
  %conv164 = sext i8 %34 to i32
  switch i32 %conv164, label %if.else204 [
    i32 0, label %sw.epilog
    i32 78, label %sw.bb170
    i32 73, label %sw.bb178
    i32 84, label %sw.bb183
    i32 82, label %sw.bb194
  ]

sw.bb170:                                         ; preds = %if.then162
  %call171 = call i32 @strcmp(i8* %name.1, i8* getelementptr inbounds ([4 x i8]* @.str18, i64 0, i64 0)) #2
  %tobool172 = icmp eq i32 %call171, 0
  br i1 %tobool172, label %if.then203, label %lor.lhs.false173

lor.lhs.false173:                                 ; preds = %sw.bb170
  %call174 = call i32 @strcmp(i8* %name.1, i8* getelementptr inbounds ([4 x i8]* @.str19, i64 0, i64 0)) #2
  %tobool175 = icmp eq i32 %call174, 0
  br i1 %tobool175, label %if.then203, label %if.else204

sw.bb178:                                         ; preds = %if.then162
  %call179 = call i32 @strcmp(i8* %name.1, i8* getelementptr inbounds ([4 x i8]* @.str20, i64 0, i64 0)) #2
  %tobool180 = icmp eq i32 %call179, 0
  br i1 %tobool180, label %if.then203, label %if.else204

sw.bb183:                                         ; preds = %if.then162
  %call184 = call i32 @strcmp(i8* %name.1, i8* getelementptr inbounds ([6 x i8]* @.str21, i64 0, i64 0)) #2
  %tobool185 = icmp eq i32 %call184, 0
  br i1 %tobool185, label %if.then203, label %lor.lhs.false186

lor.lhs.false186:                                 ; preds = %sw.bb183
  %call187 = call i32 @strcmp(i8* %name.1, i8* getelementptr inbounds ([7 x i8]* @.str22, i64 0, i64 0)) #2
  %tobool188 = icmp eq i32 %call187, 0
  br i1 %tobool188, label %if.then203, label %lor.lhs.false189

lor.lhs.false189:                                 ; preds = %lor.lhs.false186
  %call190 = call i32 @strcmp(i8* %name.1, i8* getelementptr inbounds ([7 x i8]* @.str23, i64 0, i64 0)) #2
  %tobool191 = icmp eq i32 %call190, 0
  br i1 %tobool191, label %if.then203, label %if.else204

sw.bb194:                                         ; preds = %if.then162
  %call195 = call i32 @strcmp(i8* %name.1, i8* getelementptr inbounds ([5 x i8]* @.str24, i64 0, i64 0)) #2
  %tobool196 = icmp eq i32 %call195, 0
  br i1 %tobool196, label %if.then203, label %lor.lhs.false197

lor.lhs.false197:                                 ; preds = %sw.bb194
  %call198 = call i32 @strcmp(i8* %name.1, i8* getelementptr inbounds ([8 x i8]* @.str25, i64 0, i64 0)) #2
  %tobool199 = icmp eq i32 %call198, 0
  br i1 %tobool199, label %if.then203, label %if.else204

sw.epilog:                                        ; preds = %if.then162
  %35 = load i8* %name.1, align 1, !tbaa !26
  %cmp166 = icmp eq i8 %35, 95
  br i1 %cmp166, label %if.then203, label %if.else204

if.then203:                                       ; preds = %sw.bb178, %lor.lhs.false173, %sw.bb170, %lor.lhs.false189, %lor.lhs.false186, %sw.bb183, %lor.lhs.false197, %sw.bb194, %sw.epilog
  %36 = load %struct.hv** @PL_defstash, align 8, !tbaa !19
  br label %if.end305

if.else204:                                       ; preds = %sw.bb178, %lor.lhs.false173, %lor.lhs.false189, %lor.lhs.false197, %if.then162, %sw.epilog
  %37 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cmp205 = icmp eq %struct.cop* %37, @PL_compiling
  br i1 %cmp205, label %if.then207, label %if.else300

if.then207:                                       ; preds = %if.else204
  %38 = load %struct.hv** @PL_curstash, align 8, !tbaa !19
  %tobool208 = icmp eq i64 %add, 0
  br i1 %tobool208, label %if.end305, label %land.lhs.true209

land.lhs.true209:                                 ; preds = %if.then207
  %39 = load i64* @PL_hints, align 8, !tbaa !29
  %and210 = and i64 %39, 1024
  %tobool211 = icmp ne i64 %and210, 0
  %cmp213 = icmp ne i64 %sv_type, 12
  %or.cond876 = and i1 %tobool211, %cmp213
  %cmp216 = icmp ne i64 %sv_type, 13
  %or.cond877 = and i1 %or.cond876, %cmp216
  %cmp219 = icmp ne i64 %sv_type, 14
  %or.cond878 = and i1 %or.cond877, %cmp219
  %cmp222 = icmp ne i64 %sv_type, 15
  %or.cond879 = and i1 %or.cond878, %cmp222
  br i1 %or.cond879, label %land.lhs.true224, label %if.end305

land.lhs.true224:                                 ; preds = %land.lhs.true209
  %cmp225 = icmp eq i64 %sub.ptr.sub125, 1
  %cmp228 = icmp eq i64 %sv_type, 4
  %or.cond880 = and i1 %cmp225, %cmp228
  br i1 %or.cond880, label %land.lhs.true230, label %if.then238

land.lhs.true230:                                 ; preds = %land.lhs.true224
  %40 = load i8* %name.1, align 1, !tbaa !26
  %.off = add i8 %40, -97
  %switch = icmp ult i8 %.off, 2
  br i1 %switch, label %if.end305, label %if.then238

if.then238:                                       ; preds = %land.lhs.true230, %land.lhs.true224
  %call239 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %38, i8* %name.1, i64 %sub.ptr.sub125, i64 0) #2
  %tobool240 = icmp eq %struct.sv** %call239, null
  br i1 %tobool240, label %if.then307, label %lor.lhs.false241

lor.lhs.false241:                                 ; preds = %if.then238
  %41 = load %struct.sv** %call239, align 8
  %cmp242 = icmp eq %struct.sv* %41, @PL_sv_undef
  br i1 %cmp242, label %if.then307, label %lor.lhs.false244

lor.lhs.false244:                                 ; preds = %lor.lhs.false241
  %42 = getelementptr inbounds %struct.sv* %41, i64 0, i32 2
  %43 = load i64* %42, align 8, !tbaa !27
  %and246 = and i64 %43, 255
  %cmp247 = icmp eq i64 %and246, 13
  br i1 %cmp247, label %if.else250, label %if.then307

if.else250:                                       ; preds = %lor.lhs.false244
  br i1 %cmp228, label %land.lhs.true253, label %lor.lhs.false259

land.lhs.true253:                                 ; preds = %if.else250
  %sv_any254 = bitcast %struct.sv* %41 to %struct.xpvgv**
  %44 = load %struct.xpvgv** %sv_any254, align 8, !tbaa !7
  %xgv_flags255 = getelementptr inbounds %struct.xpvgv* %44, i64 0, i32 11
  %45 = load i8* %xgv_flags255, align 1, !tbaa !46
  %and257 = and i8 %45, 16
  %tobool258 = icmp eq i8 %and257, 0
  br i1 %tobool258, label %cond.false281, label %if.end305

lor.lhs.false259:                                 ; preds = %if.else250
  switch i64 %sv_type, label %if.end305 [
    i64 10, label %land.lhs.true262
    i64 11, label %land.lhs.true271
  ]

land.lhs.true262:                                 ; preds = %lor.lhs.false259
  %sv_any263 = bitcast %struct.sv* %41 to %struct.xpvgv**
  %46 = load %struct.xpvgv** %sv_any263, align 8, !tbaa !7
  %xgv_flags264 = getelementptr inbounds %struct.xpvgv* %46, i64 0, i32 11
  %47 = load i8* %xgv_flags264, align 1, !tbaa !46
  %and266 = and i8 %47, 32
  %tobool267 = icmp eq i8 %and266, 0
  br i1 %tobool267, label %cond.end285, label %if.end305

land.lhs.true271:                                 ; preds = %lor.lhs.false259
  %sv_any272 = bitcast %struct.sv* %41 to %struct.xpvgv**
  %48 = load %struct.xpvgv** %sv_any272, align 8, !tbaa !7
  %xgv_flags273 = getelementptr inbounds %struct.xpvgv* %48, i64 0, i32 11
  %49 = load i8* %xgv_flags273, align 1, !tbaa !46
  %and275 = and i8 %49, 64
  %tobool276 = icmp eq i8 %and275, 0
  br i1 %tobool276, label %cond.false281, label %if.end305

cond.false281:                                    ; preds = %land.lhs.true253, %land.lhs.true271
  %cmp282 = icmp eq i64 %sv_type, 11
  %cond284 = select i1 %cmp282, i32 37, i32 36
  br label %cond.end285

cond.end285:                                      ; preds = %land.lhs.true262, %cond.false281
  %cond286 = phi i32 [ %cond284, %cond.false281 ], [ 64, %land.lhs.true262 ]
  call void (i8*, ...)* @Perl_warn(i8* getelementptr inbounds ([32 x i8]* @.str26, i64 0, i64 0), i32 %cond286, i8* %name.1) #2
  %50 = load %struct.sv** %call239, align 8
  %sv_any287 = bitcast %struct.sv* %50 to %struct.xpvgv**
  %51 = load %struct.xpvgv** %sv_any287, align 8, !tbaa !7
  %xgv_gp288 = getelementptr inbounds %struct.xpvgv* %51, i64 0, i32 7
  %52 = load %struct.gp** %xgv_gp288, align 8, !tbaa !9
  %gp_cvgen = getelementptr inbounds %struct.gp* %52, i64 0, i32 8
  %53 = load i64* %gp_cvgen, align 8, !tbaa !41
  %tobool289 = icmp eq i64 %53, 0
  br i1 %tobool289, label %cond.false291, label %if.then307

cond.false291:                                    ; preds = %cond.end285
  %gp_cv = getelementptr inbounds %struct.gp* %52, i64 0, i32 7
  %54 = load %struct.cv** %gp_cv, align 8, !tbaa !47
  %tobool294 = icmp eq %struct.cv* %54, null
  br i1 %tobool294, label %if.then307, label %if.then295

if.then295:                                       ; preds = %cond.false291
  call void (i8*, ...)* @Perl_warn(i8* getelementptr inbounds ([30 x i8]* @.str27, i64 0, i64 0), i8* %name.1) #2
  br label %if.then307

if.else300:                                       ; preds = %if.else204
  %55 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_stash = getelementptr inbounds %struct.cop* %55, i64 0, i32 9
  %56 = load %struct.hv** %cop_stash, align 8, !tbaa !67
  br label %if.end305

if.else303:                                       ; preds = %lor.lhs.false143, %land.lhs.true159, %cond.false155
  %57 = load %struct.hv** @PL_defstash, align 8, !tbaa !19
  br label %if.end305

if.end305:                                        ; preds = %land.lhs.true262, %land.lhs.true253, %land.lhs.true230, %lor.lhs.false259, %land.lhs.true271, %if.then207, %if.else303, %if.else300, %land.lhs.true209, %if.then203
  %stash.6 = phi %struct.hv* [ %36, %if.then203 ], [ %38, %land.lhs.true271 ], [ %38, %land.lhs.true209 ], [ %38, %if.then207 ], [ %56, %if.else300 ], [ %57, %if.else303 ], [ %38, %land.lhs.true230 ], [ %38, %lor.lhs.false259 ], [ %38, %land.lhs.true253 ], [ %38, %land.lhs.true262 ]
  %tobool306 = icmp eq %struct.hv* %stash.6, null
  br i1 %tobool306, label %if.then307, label %if.end335

if.then307:                                       ; preds = %if.then295, %cond.end285, %cond.false291, %lor.lhs.false241, %if.then238, %lor.lhs.false244, %if.end305
  %tobool308 = icmp eq i64 %add, 0
  br i1 %tobool308, label %return, label %if.then309

if.then309:                                       ; preds = %if.then307
  %cmp310 = icmp eq i64 %sv_type, 4
  br i1 %cmp310, label %cond.end323, label %cond.false313

cond.false313:                                    ; preds = %if.then309
  %cmp314 = icmp eq i64 %sv_type, 10
  br i1 %cmp314, label %cond.end323, label %cond.false317

cond.false317:                                    ; preds = %cond.false313
  %cmp318 = icmp eq i64 %sv_type, 11
  %cond320 = select i1 %cmp318, i8* getelementptr inbounds ([2 x i8]* @.str31, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8]* @.str3, i64 0, i64 0)
  br label %cond.end323

cond.end323:                                      ; preds = %cond.false317, %cond.false313, %if.then309
  %cond324 = phi i8* [ getelementptr inbounds ([2 x i8]* @.str29, i64 0, i64 0), %if.then309 ], [ %cond320, %cond.false317 ], [ getelementptr inbounds ([2 x i8]* @.str30, i64 0, i64 0), %cond.false313 ]
  %call325 = call %struct.sv* (i8*, ...)* @Perl_mess(i8* getelementptr inbounds ([52 x i8]* @.str28, i64 0, i64 0), i8* %cond324, i8* %name.1) #2
  %58 = load i64* @PL_hints, align 8, !tbaa !29
  %and326 = and i64 %58, 8388608
  %tobool327 = icmp eq i64 %and326, 0
  br i1 %tobool327, label %if.end331, label %if.then328

if.then328:                                       ; preds = %cond.end323
  %sv_flags329 = getelementptr inbounds %struct.sv* %call325, i64 0, i32 2
  %59 = load i64* %sv_flags329, align 8, !tbaa !1
  %or330 = or i64 %59, 536870912
  store i64 %or330, i64* %sv_flags329, align 8, !tbaa !1
  br label %if.end331

if.end331:                                        ; preds = %cond.end323, %if.then328
  %call332 = call i32 (%struct.sv*, ...)* bitcast (i32 (...)* @qerror to i32 (%struct.sv*, ...)*)(%struct.sv* %call325) #2
  %60 = load %struct.hv** @PL_nullstash, align 8, !tbaa !19
  br label %if.end335

if.end335:                                        ; preds = %for.end, %if.end305, %if.end331
  %stash.7 = phi %struct.hv* [ %stash.6, %if.end305 ], [ %60, %if.end331 ], [ %stash.0, %for.end ]
  %sv_refcnt336 = getelementptr inbounds %struct.hv* %stash.7, i64 0, i32 1
  %61 = load i64* %sv_refcnt336, align 8, !tbaa !69
  %tobool337 = icmp eq i64 %61, 0
  br i1 %tobool337, label %return, label %if.end339

if.end339:                                        ; preds = %if.end335
  %call340 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %stash.7, i8* %name.1, i64 %sub.ptr.sub125, i64 %add) #2
  %tobool341 = icmp eq %struct.sv** %call340, null
  br i1 %tobool341, label %return, label %lor.lhs.false342

lor.lhs.false342:                                 ; preds = %if.end339
  %62 = load %struct.sv** %call340, align 8
  %63 = bitcast %struct.sv* %62 to %struct.gv*
  %cmp343 = icmp eq %struct.sv* %62, @PL_sv_undef
  br i1 %cmp343, label %return, label %if.end346

if.end346:                                        ; preds = %lor.lhs.false342
  %64 = getelementptr inbounds %struct.sv* %62, i64 0, i32 2
  %65 = load i64* %64, align 8, !tbaa !27
  %and348 = and i64 %65, 255
  %cmp349 = icmp eq i64 %and348, 13
  br i1 %cmp349, label %if.then351, label %if.else373

if.then351:                                       ; preds = %if.end346
  %tobool352 = icmp eq i64 %add, 0
  br i1 %tobool352, label %return, label %if.then353

if.then353:                                       ; preds = %if.then351
  %sv_any354 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %66 = load %struct.xpvgv** %sv_any354, align 8, !tbaa !7
  %xgv_flags355 = getelementptr inbounds %struct.xpvgv* %66, i64 0, i32 11
  %67 = load i8* %xgv_flags355, align 1, !tbaa !46
  %or357 = or i8 %67, 2
  store i8 %or357, i8* %xgv_flags355, align 1, !tbaa !46
  %call359 = call i32 (%struct.gv*, i64, ...)* bitcast (i32 (...)* @gv_init_sv to i32 (%struct.gv*, i64, ...)*)(%struct.gv* %63, i64 %sv_type) #2
  %68 = load i8* %name.1, align 1, !tbaa !26
  %cmp361 = icmp eq i8 %68, 33
  %cmp364 = icmp eq i64 %sv_type, 11
  %or.cond881 = and i1 %cmp361, %cmp364
  %cmp367 = icmp eq i64 %sub.ptr.sub125, 1
  %or.cond882 = and i1 %or.cond881, %cmp367
  br i1 %or.cond882, label %if.then369, label %return

if.then369:                                       ; preds = %if.then353
  %call370 = call i32 (%struct.gv*, ...)* bitcast (i32 (...)* @require_errno to i32 (%struct.gv*, ...)*)(%struct.gv* %63) #2
  br label %return

if.else373:                                       ; preds = %if.end346
  %and374 = and i64 %add, 16
  %tobool375 = icmp eq i64 %and374, 0
  br i1 %tobool375, label %if.end378, label %return

if.end378:                                        ; preds = %if.else373
  %and379 = and i64 %add, 4
  %tobool380 = icmp eq i64 %and379, 0
  br i1 %tobool380, label %if.end400, label %land.lhs.true381

land.lhs.true381:                                 ; preds = %if.end378
  %69 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings = getelementptr inbounds %struct.cop* %69, i64 0, i32 14
  %70 = load %struct.sv** %cop_warnings, align 8, !tbaa !63
  %cmp382 = icmp eq %struct.sv* %70, null
  br i1 %cmp382, label %if.then399, label %lor.lhs.false384

lor.lhs.false384:                                 ; preds = %land.lhs.true381
  %71 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings385 = getelementptr inbounds %struct.cop* %71, i64 0, i32 14
  %72 = load %struct.sv** %cop_warnings385, align 8, !tbaa !63
  %cmp386 = icmp eq %struct.sv* %72, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp386, label %if.then399, label %lor.lhs.false388

lor.lhs.false388:                                 ; preds = %lor.lhs.false384
  %73 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings389 = getelementptr inbounds %struct.cop* %73, i64 0, i32 14
  %74 = load %struct.sv** %cop_warnings389, align 8, !tbaa !63
  %cmp390 = icmp eq %struct.sv* %74, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp390, label %if.end400, label %land.lhs.true392

land.lhs.true392:                                 ; preds = %lor.lhs.false388
  %75 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings393 = getelementptr inbounds %struct.cop* %75, i64 0, i32 14
  %76 = load %struct.sv** %cop_warnings393, align 8, !tbaa !63
  %sv_any394 = getelementptr inbounds %struct.sv* %76, i64 0, i32 0
  %77 = load i8** %sv_any394, align 8, !tbaa !39
  %xpv_pv = bitcast i8* %77 to i8**
  %78 = load i8** %xpv_pv, align 8, !tbaa !30
  %arrayidx395 = getelementptr inbounds i8* %78, i64 6
  %79 = load i8* %arrayidx395, align 1, !tbaa !26
  %and397 = and i8 %79, 1
  %tobool398 = icmp eq i8 %and397, 0
  br i1 %tobool398, label %if.end400, label %if.then399

if.then399:                                       ; preds = %land.lhs.true392, %lor.lhs.false384, %land.lhs.true381
  call void (i64, i8*, ...)* @Perl_warner(i64 24, i8* getelementptr inbounds ([30 x i8]* @.str32, i64 0, i64 0), i8* %nambeg) #2
  br label %if.end400

if.end400:                                        ; preds = %land.lhs.true392, %lor.lhs.false388, %if.end378, %if.then399
  %and401 = and i64 %add, 2
  %conv402 = trunc i64 %and401 to i32
  call void @Perl_gv_init(%struct.gv* %63, %struct.hv* %stash.7, i8* %name.1, i64 %sub.ptr.sub125, i32 %conv402)
  %call403 = call i32 (%struct.gv*, i64, ...)* bitcast (i32 (...)* @gv_init_sv to i32 (%struct.gv*, i64, ...)*)(%struct.gv* %63, i64 %sv_type) #2
  %80 = load i8* %name.1, align 1, !tbaa !26
  %.off1356 = add i8 %80, -65
  %81 = icmp ult i8 %.off1356, 26
  %.off1357 = add i8 %80, -97
  %82 = icmp ult i8 %.off1357, 26
  %or.cond1366 = or i1 %81, %82
  br i1 %or.cond1366, label %land.lhs.true423, label %if.end465

land.lhs.true423:                                 ; preds = %if.end400
  %83 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings424 = getelementptr inbounds %struct.cop* %83, i64 0, i32 14
  %84 = load %struct.sv** %cop_warnings424, align 8, !tbaa !63
  %cmp425 = icmp eq %struct.sv* %84, null
  br i1 %cmp425, label %cond.false455, label %cond.true427

cond.true427:                                     ; preds = %land.lhs.true423
  %85 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings428 = getelementptr inbounds %struct.cop* %85, i64 0, i32 14
  %86 = load %struct.sv** %cop_warnings428, align 8, !tbaa !63
  %cmp429 = icmp eq %struct.sv* %86, null
  br i1 %cmp429, label %lor.lhs.false447, label %land.lhs.true431

land.lhs.true431:                                 ; preds = %cond.true427
  %87 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings432 = getelementptr inbounds %struct.cop* %87, i64 0, i32 14
  %88 = load %struct.sv** %cop_warnings432, align 8, !tbaa !63
  %cmp433 = icmp eq %struct.sv* %88, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp433, label %lor.lhs.false447, label %land.lhs.true435

land.lhs.true435:                                 ; preds = %land.lhs.true431
  %89 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings436 = getelementptr inbounds %struct.cop* %89, i64 0, i32 14
  %90 = load %struct.sv** %cop_warnings436, align 8, !tbaa !63
  %cmp437 = icmp eq %struct.sv* %90, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp437, label %if.end465, label %lor.lhs.false439

lor.lhs.false439:                                 ; preds = %land.lhs.true435
  %91 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings440 = getelementptr inbounds %struct.cop* %91, i64 0, i32 14
  %92 = load %struct.sv** %cop_warnings440, align 8, !tbaa !63
  %sv_any441 = getelementptr inbounds %struct.sv* %92, i64 0, i32 0
  %93 = load i8** %sv_any441, align 8, !tbaa !39
  %xpv_pv442 = bitcast i8* %93 to i8**
  %94 = load i8** %xpv_pv442, align 8, !tbaa !30
  %arrayidx443 = getelementptr inbounds i8* %94, i64 3
  %95 = load i8* %arrayidx443, align 1, !tbaa !26
  %and445 = and i8 %95, 16
  %tobool446 = icmp eq i8 %and445, 0
  br i1 %tobool446, label %lor.lhs.false447, label %if.end465

lor.lhs.false447:                                 ; preds = %lor.lhs.false439, %land.lhs.true431, %cond.true427
  %96 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings448 = getelementptr inbounds %struct.cop* %96, i64 0, i32 14
  %97 = load %struct.sv** %cop_warnings448, align 8, !tbaa !63
  %cmp449 = icmp eq %struct.sv* %97, null
  br i1 %cmp449, label %land.lhs.true451, label %if.then459

land.lhs.true451:                                 ; preds = %lor.lhs.false447
  %98 = load i8* @PL_dowarn, align 1, !tbaa !26
  %and453 = and i8 %98, 1
  %tobool454 = icmp eq i8 %and453, 0
  br i1 %tobool454, label %if.then459, label %if.end465

cond.false455:                                    ; preds = %land.lhs.true423
  %99 = load i8* @PL_dowarn, align 1, !tbaa !26
  %and457 = and i8 %99, 1
  %tobool458 = icmp eq i8 %and457, 0
  br i1 %tobool458, label %if.then459, label %if.end465

if.then459:                                       ; preds = %land.lhs.true451, %cond.false455, %lor.lhs.false447
  %sv_any460 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %100 = load %struct.xpvgv** %sv_any460, align 8, !tbaa !7
  %xgv_flags461 = getelementptr inbounds %struct.xpvgv* %100, i64 0, i32 11
  %101 = load i8* %xgv_flags461, align 1, !tbaa !46
  %or463 = or i8 %101, 2
  store i8 %or463, i8* %xgv_flags461, align 1, !tbaa !46
  br label %if.end465

if.end465:                                        ; preds = %if.end400, %lor.lhs.false439, %land.lhs.true451, %cond.false455, %if.then459, %land.lhs.true435
  %cmp466 = icmp sgt i64 %sub.ptr.sub125, 1
  %102 = load i8* %name.1, align 1, !tbaa !26
  %conv469 = sext i8 %102 to i32
  br i1 %cmp466, label %if.then468, label %if.else694

if.then468:                                       ; preds = %if.end465
  %cmp470 = icmp sgt i8 %102, 86
  br i1 %cmp470, label %return, label %if.else473

if.else473:                                       ; preds = %if.then468
  %add.ptr = getelementptr inbounds i8* %name.1, i64 1
  switch i32 %conv469, label %return [
    i32 65, label %sw.bb475
    i32 69, label %sw.bb510
    i32 73, label %sw.bb520
    i32 79, label %sw.bb565
    i32 83, label %sw.bb590
    i32 86, label %sw.bb639
    i32 5, label %sw.bb649
    i32 15, label %sw.bb654
    i32 20, label %sw.bb659
    i32 21, label %sw.bb664
    i32 23, label %sw.bb673
    i32 49, label %sw.bb678
    i32 50, label %sw.bb678
    i32 51, label %sw.bb678
    i32 52, label %sw.bb678
    i32 53, label %sw.bb678
    i32 54, label %sw.bb678
    i32 55, label %sw.bb678
    i32 56, label %sw.bb678
    i32 57, label %sw.bb678
  ]

sw.bb475:                                         ; preds = %if.else473
  %call476 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([4 x i8]* @.str33, i64 0, i64 0)) #2
  %tobool477 = icmp eq i32 %call476, 0
  br i1 %tobool477, label %if.then478, label %return

if.then478:                                       ; preds = %sw.bb475
  %cond = icmp eq %struct.sv* %62, null
  br i1 %cond, label %if.then.i1337, label %land.lhs.true480

land.lhs.true480:                                 ; preds = %if.then478
  %103 = load i64* %64, align 8, !tbaa !1
  %and482 = and i64 %103, 255
  %cmp483 = icmp eq i64 %and482, 13
  br i1 %cmp483, label %land.lhs.true485, label %if.then.i1337

land.lhs.true485:                                 ; preds = %land.lhs.true480
  %sv_any486 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %104 = load %struct.xpvgv** %sv_any486, align 8, !tbaa !7
  %xgv_gp487 = getelementptr inbounds %struct.xpvgv* %104, i64 0, i32 7
  %105 = load %struct.gp** %xgv_gp487, align 8, !tbaa !9
  %tobool488 = icmp eq %struct.gp* %105, null
  br i1 %tobool488, label %if.end.i1341, label %cond.true489

cond.true489:                                     ; preds = %land.lhs.true485
  %gp_io = getelementptr inbounds %struct.gp* %105, i64 0, i32 2
  %106 = load %struct.io** %gp_io, align 8, !tbaa !15
  %tobool492 = icmp eq %struct.io* %106, null
  br i1 %tobool492, label %if.end.i1341, label %cond.end503

if.then.i1337:                                    ; preds = %land.lhs.true480, %if.then478
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([26 x i8]* @.str2, i64 0, i64 0)) #2
  br label %if.end.i1341

if.end.i1341:                                     ; preds = %cond.true489, %land.lhs.true485, %if.then.i1337
  %sv_any.i1338 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %107 = load %struct.xpvgv** %sv_any.i1338, align 8, !tbaa !7
  %xgv_gp.i1339 = getelementptr inbounds %struct.xpvgv* %107, i64 0, i32 7
  %108 = load %struct.gp** %xgv_gp.i1339, align 8, !tbaa !9
  %gp_io.i = getelementptr inbounds %struct.gp* %108, i64 0, i32 2
  %109 = load %struct.io** %gp_io.i, align 8, !tbaa !15
  %tobool1.i1340 = icmp eq %struct.io* %109, null
  br i1 %tobool1.i1340, label %if.then2.i1344, label %cond.end503

if.then2.i1344:                                   ; preds = %if.end.i1341
  %call.i1342 = call %struct.io* @Perl_newIO() #2
  %110 = load %struct.xpvgv** %sv_any.i1338, align 8, !tbaa !7
  %xgv_gp4.i1343 = getelementptr inbounds %struct.xpvgv* %110, i64 0, i32 7
  %111 = load %struct.gp** %xgv_gp4.i1343, align 8, !tbaa !9
  %gp_io5.i = getelementptr inbounds %struct.gp* %111, i64 0, i32 2
  store %struct.io* %call.i1342, %struct.io** %gp_io5.i, align 8, !tbaa !15
  br label %cond.end503

cond.end503:                                      ; preds = %if.then2.i1344, %if.end.i1341, %cond.true489
  %cond504 = phi %struct.io* [ %106, %cond.true489 ], [ %109, %if.end.i1341 ], [ %call.i1342, %if.then2.i1344 ]
  %sv_any505 = getelementptr inbounds %struct.io* %cond504, i64 0, i32 0
  %112 = load %struct.xpvio** %sv_any505, align 8, !tbaa !23
  %xio_flags = getelementptr inbounds %struct.xpvio* %112, i64 0, i32 22
  %113 = load i8* %xio_flags, align 1, !tbaa !71
  %or507 = or i8 %113, 3
  store i8 %or507, i8* %xio_flags, align 1, !tbaa !71
  br label %return

sw.bb510:                                         ; preds = %if.else473
  %call511 = call i32 @strncmp(i8* %add.ptr, i8* getelementptr inbounds ([6 x i8]* @.str34, i64 0, i64 0), i64 5) #2
  %tobool512 = icmp eq i32 %call511, 0
  br i1 %tobool512, label %if.then513, label %return

if.then513:                                       ; preds = %sw.bb510
  %sv_any514 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %114 = load %struct.xpvgv** %sv_any514, align 8, !tbaa !7
  %xgv_flags515 = getelementptr inbounds %struct.xpvgv* %114, i64 0, i32 11
  %115 = load i8* %xgv_flags515, align 1, !tbaa !46
  %or517 = or i8 %115, 2
  store i8 %or517, i8* %xgv_flags515, align 1, !tbaa !46
  br label %return

sw.bb520:                                         ; preds = %if.else473
  %call521 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([3 x i8]* @.str35, i64 0, i64 0)) #2
  %tobool522 = icmp eq i32 %call521, 0
  br i1 %tobool522, label %if.then523, label %return

if.then523:                                       ; preds = %sw.bb520
  %sv_any524 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %116 = load %struct.xpvgv** %sv_any524, align 8, !tbaa !7
  %xgv_gp525 = getelementptr inbounds %struct.xpvgv* %116, i64 0, i32 7
  %117 = load %struct.gp** %xgv_gp525, align 8, !tbaa !9
  %gp_av = getelementptr inbounds %struct.gp* %117, i64 0, i32 4
  %118 = load %struct.av** %gp_av, align 8, !tbaa !12
  %tobool526 = icmp eq %struct.av* %118, null
  br i1 %tobool526, label %cond.false531, label %cond.end536

cond.false531:                                    ; preds = %if.then523
  %tobool.i1161 = icmp eq %struct.sv* %62, null
  br i1 %tobool.i1161, label %if.end.i1170, label %lor.lhs.false.i1164

lor.lhs.false.i1164:                              ; preds = %cond.false531
  %119 = load i64* %64, align 8, !tbaa !1
  %and.i1162 = and i64 %119, 255
  %cmp.i1163 = icmp eq i64 %and.i1162, 13
  br i1 %cmp.i1163, label %if.then2.i1174, label %if.end.i1170

if.end.i1170:                                     ; preds = %cond.false531, %lor.lhs.false.i1164
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([21 x i8]* @.str, i64 0, i64 0)) #2
  %.pre = load %struct.xpvgv** %sv_any524, align 8, !tbaa !7
  %xgv_gp.i1167.phi.trans.insert = getelementptr inbounds %struct.xpvgv* %.pre, i64 0, i32 7
  %.pre1384 = load %struct.gp** %xgv_gp.i1167.phi.trans.insert, align 8, !tbaa !9
  %gp_av.i1168.phi.trans.insert = getelementptr inbounds %struct.gp* %.pre1384, i64 0, i32 4
  %.pre1385 = load %struct.av** %gp_av.i1168.phi.trans.insert, align 8, !tbaa !12
  %tobool1.i1169 = icmp eq %struct.av* %.pre1385, null
  br i1 %tobool1.i1169, label %if.then2.i1174, label %cond.end536

if.then2.i1174:                                   ; preds = %lor.lhs.false.i1164, %if.end.i1170
  %call.i1171 = call %struct.av* @Perl_newAV() #2
  %120 = load %struct.xpvgv** %sv_any524, align 8, !tbaa !7
  %xgv_gp4.i1172 = getelementptr inbounds %struct.xpvgv* %120, i64 0, i32 7
  %121 = load %struct.gp** %xgv_gp4.i1172, align 8, !tbaa !9
  %gp_av5.i1173 = getelementptr inbounds %struct.gp* %121, i64 0, i32 4
  store %struct.av* %call.i1171, %struct.av** %gp_av5.i1173, align 8, !tbaa !12
  br label %cond.end536

cond.end536:                                      ; preds = %if.then2.i1174, %if.end.i1170, %if.then523
  %122 = phi %struct.xpvgv* [ %116, %if.then523 ], [ %.pre, %if.end.i1170 ], [ %120, %if.then2.i1174 ]
  %cond537 = phi %struct.av* [ %118, %if.then523 ], [ %.pre1385, %if.end.i1170 ], [ %call.i1171, %if.then2.i1174 ]
  %xgv_flags539 = getelementptr inbounds %struct.xpvgv* %122, i64 0, i32 11
  %123 = load i8* %xgv_flags539, align 1, !tbaa !46
  %or541 = or i8 %123, 2
  store i8 %or541, i8* %xgv_flags539, align 1, !tbaa !46
  %124 = bitcast %struct.av* %cond537 to %struct.sv*
  call void @Perl_sv_magic(%struct.sv* %124, %struct.sv* %62, i32 73, i8* null, i64 0) #2
  %tobool544 = icmp eq i64 %and401, 0
  br i1 %tobool544, label %return, label %land.lhs.true545

land.lhs.true545:                                 ; preds = %cond.end536
  %call546 = call i32 @strcmp(i8* %nambeg, i8* getelementptr inbounds ([17 x i8]* @.str36, i64 0, i64 0)) #2
  %tobool547 = icmp eq i32 %call546, 0
  br i1 %tobool547, label %land.lhs.true548, label %return

land.lhs.true548:                                 ; preds = %land.lhs.true545
  %sv_any549 = getelementptr inbounds %struct.av* %cond537, i64 0, i32 0
  %125 = load %struct.xpvav** %sv_any549, align 8, !tbaa !56
  %xav_fill = getelementptr inbounds %struct.xpvav* %125, i64 0, i32 1
  %126 = load i64* %xav_fill, align 8, !tbaa !59
  %cmp550 = icmp eq i64 %126, -1
  br i1 %cmp550, label %if.end10.i1312, label %return

if.end10.i1312:                                   ; preds = %land.lhs.true548
  %call553 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([10 x i8]* @.str37, i64 0, i64 0), i64 9) #2
  call void @Perl_av_push(%struct.av* %cond537, %struct.sv* %call553) #2
  %127 = getelementptr inbounds [256 x i8]* %smallbuf.i, i64 0, i64 0
  call void @llvm.lifetime.start(i64 256, i8* %127) #2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %127, i8* getelementptr inbounds ([10 x i8]* @.str37, i64 0, i64 0), i64 9, i32 1, i1 false) #2
  %arrayidx.i1305 = getelementptr inbounds [256 x i8]* %smallbuf.i, i64 0, i64 9
  store i8 58, i8* %arrayidx.i1305, align 1, !tbaa !26
  %arrayidx4.i1306 = getelementptr inbounds [256 x i8]* %smallbuf.i, i64 0, i64 10
  store i8 58, i8* %arrayidx4.i1306, align 2, !tbaa !26
  %arrayidx5.i1307 = getelementptr inbounds [256 x i8]* %smallbuf.i, i64 0, i64 11
  store i8 0, i8* %arrayidx5.i1307, align 1, !tbaa !26
  %call6.i1308 = call %struct.gv* @Perl_gv_fetchpv(i8* %127, i64 1, i64 11) #2
  %tobool.i1311 = icmp eq %struct.gv* %call6.i1308, null
  br i1 %tobool.i1311, label %if.end10.i1281, label %if.end12.i1317

if.end12.i1317:                                   ; preds = %if.end10.i1312
  %sv_any.i1313 = getelementptr inbounds %struct.gv* %call6.i1308, i64 0, i32 0
  %128 = load %struct.xpvgv** %sv_any.i1313, align 8, !tbaa !7
  %xgv_gp.i1314 = getelementptr inbounds %struct.xpvgv* %128, i64 0, i32 7
  %129 = load %struct.gp** %xgv_gp.i1314, align 8, !tbaa !9
  %gp_hv.i1315 = getelementptr inbounds %struct.gp* %129, i64 0, i32 5
  %130 = load %struct.hv** %gp_hv.i1315, align 8, !tbaa !14
  %tobool13.i1316 = icmp eq %struct.hv* %130, null
  br i1 %tobool13.i1316, label %if.then14.i1321, label %if.end19.i1327

if.then14.i1321:                                  ; preds = %if.end12.i1317
  %call15.i1318 = call %struct.hv* @Perl_newHV() #2
  %131 = load %struct.xpvgv** %sv_any.i1313, align 8, !tbaa !7
  %xgv_gp17.i1319 = getelementptr inbounds %struct.xpvgv* %131, i64 0, i32 7
  %132 = load %struct.gp** %xgv_gp17.i1319, align 8, !tbaa !9
  %gp_hv18.i1320 = getelementptr inbounds %struct.gp* %132, i64 0, i32 5
  store %struct.hv* %call15.i1318, %struct.hv** %gp_hv18.i1320, align 8, !tbaa !14
  br label %if.end19.i1327

if.end19.i1327:                                   ; preds = %if.then14.i1321, %if.end12.i1317
  %133 = phi %struct.hv* [ %call15.i1318, %if.then14.i1321 ], [ %130, %if.end12.i1317 ]
  %sv_any23.i1324 = getelementptr inbounds %struct.hv* %133, i64 0, i32 0
  %134 = load %struct.xpvhv** %sv_any23.i1324, align 8, !tbaa !20
  %xhv_name.i1325 = getelementptr inbounds %struct.xpvhv* %134, i64 0, i32 10
  %135 = load i8** %xhv_name.i1325, align 8, !tbaa !54
  %tobool24.i1326 = icmp eq i8* %135, null
  br i1 %tobool24.i1326, label %if.then25.i1330, label %if.end10.i1281

if.then25.i1330:                                  ; preds = %if.end19.i1327
  %call26.i1328 = call i8* @Perl_savepv(i8* getelementptr inbounds ([10 x i8]* @.str37, i64 0, i64 0)) #2
  %136 = load %struct.xpvhv** %sv_any23.i1324, align 8, !tbaa !20
  %xhv_name28.i1329 = getelementptr inbounds %struct.xpvhv* %136, i64 0, i32 10
  store i8* %call26.i1328, i8** %xhv_name28.i1329, align 8, !tbaa !54
  br label %if.end10.i1281

if.end10.i1281:                                   ; preds = %if.then25.i1330, %if.end19.i1327, %if.end10.i1312
  call void @llvm.lifetime.end(i64 256, i8* %127) #2
  %call555 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([8 x i8]* @.str38, i64 0, i64 0), i64 7) #2
  call void @Perl_av_push(%struct.av* %cond537, %struct.sv* %call555) #2
  call void @llvm.lifetime.start(i64 256, i8* %127) #2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %127, i8* getelementptr inbounds ([8 x i8]* @.str38, i64 0, i64 0), i64 7, i32 1, i1 false) #2
  %arrayidx.i1274 = getelementptr inbounds [256 x i8]* %smallbuf.i, i64 0, i64 7
  store i8 58, i8* %arrayidx.i1274, align 1, !tbaa !26
  %arrayidx4.i1275 = getelementptr inbounds [256 x i8]* %smallbuf.i, i64 0, i64 8
  store i8 58, i8* %arrayidx4.i1275, align 8, !tbaa !26
  store i8 0, i8* %arrayidx.i1305, align 1, !tbaa !26
  %call6.i1277 = call %struct.gv* @Perl_gv_fetchpv(i8* %127, i64 1, i64 11) #2
  %tobool.i1280 = icmp eq %struct.gv* %call6.i1277, null
  br i1 %tobool.i1280, label %if.end10.i1250, label %if.end12.i1286

if.end12.i1286:                                   ; preds = %if.end10.i1281
  %sv_any.i1282 = getelementptr inbounds %struct.gv* %call6.i1277, i64 0, i32 0
  %137 = load %struct.xpvgv** %sv_any.i1282, align 8, !tbaa !7
  %xgv_gp.i1283 = getelementptr inbounds %struct.xpvgv* %137, i64 0, i32 7
  %138 = load %struct.gp** %xgv_gp.i1283, align 8, !tbaa !9
  %gp_hv.i1284 = getelementptr inbounds %struct.gp* %138, i64 0, i32 5
  %139 = load %struct.hv** %gp_hv.i1284, align 8, !tbaa !14
  %tobool13.i1285 = icmp eq %struct.hv* %139, null
  br i1 %tobool13.i1285, label %if.then14.i1290, label %if.end19.i1296

if.then14.i1290:                                  ; preds = %if.end12.i1286
  %call15.i1287 = call %struct.hv* @Perl_newHV() #2
  %140 = load %struct.xpvgv** %sv_any.i1282, align 8, !tbaa !7
  %xgv_gp17.i1288 = getelementptr inbounds %struct.xpvgv* %140, i64 0, i32 7
  %141 = load %struct.gp** %xgv_gp17.i1288, align 8, !tbaa !9
  %gp_hv18.i1289 = getelementptr inbounds %struct.gp* %141, i64 0, i32 5
  store %struct.hv* %call15.i1287, %struct.hv** %gp_hv18.i1289, align 8, !tbaa !14
  br label %if.end19.i1296

if.end19.i1296:                                   ; preds = %if.then14.i1290, %if.end12.i1286
  %142 = phi %struct.hv* [ %call15.i1287, %if.then14.i1290 ], [ %139, %if.end12.i1286 ]
  %sv_any23.i1293 = getelementptr inbounds %struct.hv* %142, i64 0, i32 0
  %143 = load %struct.xpvhv** %sv_any23.i1293, align 8, !tbaa !20
  %xhv_name.i1294 = getelementptr inbounds %struct.xpvhv* %143, i64 0, i32 10
  %144 = load i8** %xhv_name.i1294, align 8, !tbaa !54
  %tobool24.i1295 = icmp eq i8* %144, null
  br i1 %tobool24.i1295, label %if.then25.i1299, label %if.end10.i1250

if.then25.i1299:                                  ; preds = %if.end19.i1296
  %call26.i1297 = call i8* @Perl_savepv(i8* getelementptr inbounds ([8 x i8]* @.str38, i64 0, i64 0)) #2
  %145 = load %struct.xpvhv** %sv_any23.i1293, align 8, !tbaa !20
  %xhv_name28.i1298 = getelementptr inbounds %struct.xpvhv* %145, i64 0, i32 10
  store i8* %call26.i1297, i8** %xhv_name28.i1298, align 8, !tbaa !54
  br label %if.end10.i1250

if.end10.i1250:                                   ; preds = %if.then25.i1299, %if.end19.i1296, %if.end10.i1281
  call void @llvm.lifetime.end(i64 256, i8* %127) #2
  %call557 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([10 x i8]* @.str39, i64 0, i64 0), i64 9) #2
  call void @Perl_av_push(%struct.av* %cond537, %struct.sv* %call557) #2
  call void @llvm.lifetime.start(i64 256, i8* %127) #2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %127, i8* getelementptr inbounds ([10 x i8]* @.str39, i64 0, i64 0), i64 9, i32 1, i1 false) #2
  store i8 58, i8* %arrayidx.i1305, align 1, !tbaa !26
  store i8 58, i8* %arrayidx4.i1306, align 2, !tbaa !26
  store i8 0, i8* %arrayidx5.i1307, align 1, !tbaa !26
  %call6.i1246 = call %struct.gv* @Perl_gv_fetchpv(i8* %127, i64 1, i64 11) #2
  %tobool.i1249 = icmp eq %struct.gv* %call6.i1246, null
  br i1 %tobool.i1249, label %if.end10.i1219, label %if.end12.i1255

if.end12.i1255:                                   ; preds = %if.end10.i1250
  %sv_any.i1251 = getelementptr inbounds %struct.gv* %call6.i1246, i64 0, i32 0
  %146 = load %struct.xpvgv** %sv_any.i1251, align 8, !tbaa !7
  %xgv_gp.i1252 = getelementptr inbounds %struct.xpvgv* %146, i64 0, i32 7
  %147 = load %struct.gp** %xgv_gp.i1252, align 8, !tbaa !9
  %gp_hv.i1253 = getelementptr inbounds %struct.gp* %147, i64 0, i32 5
  %148 = load %struct.hv** %gp_hv.i1253, align 8, !tbaa !14
  %tobool13.i1254 = icmp eq %struct.hv* %148, null
  br i1 %tobool13.i1254, label %if.then14.i1259, label %if.end19.i1265

if.then14.i1259:                                  ; preds = %if.end12.i1255
  %call15.i1256 = call %struct.hv* @Perl_newHV() #2
  %149 = load %struct.xpvgv** %sv_any.i1251, align 8, !tbaa !7
  %xgv_gp17.i1257 = getelementptr inbounds %struct.xpvgv* %149, i64 0, i32 7
  %150 = load %struct.gp** %xgv_gp17.i1257, align 8, !tbaa !9
  %gp_hv18.i1258 = getelementptr inbounds %struct.gp* %150, i64 0, i32 5
  store %struct.hv* %call15.i1256, %struct.hv** %gp_hv18.i1258, align 8, !tbaa !14
  br label %if.end19.i1265

if.end19.i1265:                                   ; preds = %if.then14.i1259, %if.end12.i1255
  %151 = phi %struct.hv* [ %call15.i1256, %if.then14.i1259 ], [ %148, %if.end12.i1255 ]
  %sv_any23.i1262 = getelementptr inbounds %struct.hv* %151, i64 0, i32 0
  %152 = load %struct.xpvhv** %sv_any23.i1262, align 8, !tbaa !20
  %xhv_name.i1263 = getelementptr inbounds %struct.xpvhv* %152, i64 0, i32 10
  %153 = load i8** %xhv_name.i1263, align 8, !tbaa !54
  %tobool24.i1264 = icmp eq i8* %153, null
  br i1 %tobool24.i1264, label %if.then25.i1268, label %if.end10.i1219

if.then25.i1268:                                  ; preds = %if.end19.i1265
  %call26.i1266 = call i8* @Perl_savepv(i8* getelementptr inbounds ([10 x i8]* @.str39, i64 0, i64 0)) #2
  %154 = load %struct.xpvhv** %sv_any23.i1262, align 8, !tbaa !20
  %xhv_name28.i1267 = getelementptr inbounds %struct.xpvhv* %154, i64 0, i32 10
  store i8* %call26.i1266, i8** %xhv_name28.i1267, align 8, !tbaa !54
  br label %if.end10.i1219

if.end10.i1219:                                   ; preds = %if.then25.i1268, %if.end19.i1265, %if.end10.i1250
  call void @llvm.lifetime.end(i64 256, i8* %127) #2
  %call559 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([10 x i8]* @.str40, i64 0, i64 0), i64 9) #2
  call void @Perl_av_push(%struct.av* %cond537, %struct.sv* %call559) #2
  call void @llvm.lifetime.start(i64 256, i8* %127) #2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %127, i8* getelementptr inbounds ([10 x i8]* @.str40, i64 0, i64 0), i64 9, i32 1, i1 false) #2
  store i8 58, i8* %arrayidx.i1305, align 1, !tbaa !26
  store i8 58, i8* %arrayidx4.i1306, align 2, !tbaa !26
  store i8 0, i8* %arrayidx5.i1307, align 1, !tbaa !26
  %call6.i1215 = call %struct.gv* @Perl_gv_fetchpv(i8* %127, i64 1, i64 11) #2
  %tobool.i1218 = icmp eq %struct.gv* %call6.i1215, null
  br i1 %tobool.i1218, label %if.end10.i, label %if.end12.i1224

if.end12.i1224:                                   ; preds = %if.end10.i1219
  %sv_any.i1220 = getelementptr inbounds %struct.gv* %call6.i1215, i64 0, i32 0
  %155 = load %struct.xpvgv** %sv_any.i1220, align 8, !tbaa !7
  %xgv_gp.i1221 = getelementptr inbounds %struct.xpvgv* %155, i64 0, i32 7
  %156 = load %struct.gp** %xgv_gp.i1221, align 8, !tbaa !9
  %gp_hv.i1222 = getelementptr inbounds %struct.gp* %156, i64 0, i32 5
  %157 = load %struct.hv** %gp_hv.i1222, align 8, !tbaa !14
  %tobool13.i1223 = icmp eq %struct.hv* %157, null
  br i1 %tobool13.i1223, label %if.then14.i1228, label %if.end19.i1234

if.then14.i1228:                                  ; preds = %if.end12.i1224
  %call15.i1225 = call %struct.hv* @Perl_newHV() #2
  %158 = load %struct.xpvgv** %sv_any.i1220, align 8, !tbaa !7
  %xgv_gp17.i1226 = getelementptr inbounds %struct.xpvgv* %158, i64 0, i32 7
  %159 = load %struct.gp** %xgv_gp17.i1226, align 8, !tbaa !9
  %gp_hv18.i1227 = getelementptr inbounds %struct.gp* %159, i64 0, i32 5
  store %struct.hv* %call15.i1225, %struct.hv** %gp_hv18.i1227, align 8, !tbaa !14
  br label %if.end19.i1234

if.end19.i1234:                                   ; preds = %if.then14.i1228, %if.end12.i1224
  %160 = phi %struct.hv* [ %call15.i1225, %if.then14.i1228 ], [ %157, %if.end12.i1224 ]
  %sv_any23.i1231 = getelementptr inbounds %struct.hv* %160, i64 0, i32 0
  %161 = load %struct.xpvhv** %sv_any23.i1231, align 8, !tbaa !20
  %xhv_name.i1232 = getelementptr inbounds %struct.xpvhv* %161, i64 0, i32 10
  %162 = load i8** %xhv_name.i1232, align 8, !tbaa !54
  %tobool24.i1233 = icmp eq i8* %162, null
  br i1 %tobool24.i1233, label %if.then25.i1237, label %if.end10.i

if.then25.i1237:                                  ; preds = %if.end19.i1234
  %call26.i1235 = call i8* @Perl_savepv(i8* getelementptr inbounds ([10 x i8]* @.str40, i64 0, i64 0)) #2
  %163 = load %struct.xpvhv** %sv_any23.i1231, align 8, !tbaa !20
  %xhv_name28.i1236 = getelementptr inbounds %struct.xpvhv* %163, i64 0, i32 10
  store i8* %call26.i1235, i8** %xhv_name28.i1236, align 8, !tbaa !54
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then25.i1237, %if.end19.i1234, %if.end10.i1219
  call void @llvm.lifetime.end(i64 256, i8* %127) #2
  %call561 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([10 x i8]* @.str41, i64 0, i64 0), i64 9) #2
  call void @Perl_av_push(%struct.av* %cond537, %struct.sv* %call561) #2
  call void @llvm.lifetime.start(i64 256, i8* %127) #2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %127, i8* getelementptr inbounds ([10 x i8]* @.str41, i64 0, i64 0), i64 9, i32 1, i1 false) #2
  store i8 58, i8* %arrayidx.i1305, align 1, !tbaa !26
  store i8 58, i8* %arrayidx4.i1306, align 2, !tbaa !26
  store i8 0, i8* %arrayidx5.i1307, align 1, !tbaa !26
  %call6.i = call %struct.gv* @Perl_gv_fetchpv(i8* %127, i64 1, i64 11) #2
  %tobool.i1205 = icmp eq %struct.gv* %call6.i, null
  br i1 %tobool.i1205, label %return, label %if.end12.i

if.end12.i:                                       ; preds = %if.end10.i
  %sv_any.i1206 = getelementptr inbounds %struct.gv* %call6.i, i64 0, i32 0
  %164 = load %struct.xpvgv** %sv_any.i1206, align 8, !tbaa !7
  %xgv_gp.i1207 = getelementptr inbounds %struct.xpvgv* %164, i64 0, i32 7
  %165 = load %struct.gp** %xgv_gp.i1207, align 8, !tbaa !9
  %gp_hv.i1208 = getelementptr inbounds %struct.gp* %165, i64 0, i32 5
  %166 = load %struct.hv** %gp_hv.i1208, align 8, !tbaa !14
  %tobool13.i = icmp eq %struct.hv* %166, null
  br i1 %tobool13.i, label %if.then14.i, label %if.end19.i

if.then14.i:                                      ; preds = %if.end12.i
  %call15.i = call %struct.hv* @Perl_newHV() #2
  %167 = load %struct.xpvgv** %sv_any.i1206, align 8, !tbaa !7
  %xgv_gp17.i = getelementptr inbounds %struct.xpvgv* %167, i64 0, i32 7
  %168 = load %struct.gp** %xgv_gp17.i, align 8, !tbaa !9
  %gp_hv18.i = getelementptr inbounds %struct.gp* %168, i64 0, i32 5
  store %struct.hv* %call15.i, %struct.hv** %gp_hv18.i, align 8, !tbaa !14
  br label %if.end19.i

if.end19.i:                                       ; preds = %if.then14.i, %if.end12.i
  %169 = phi %struct.hv* [ %call15.i, %if.then14.i ], [ %166, %if.end12.i ]
  %sv_any23.i = getelementptr inbounds %struct.hv* %169, i64 0, i32 0
  %170 = load %struct.xpvhv** %sv_any23.i, align 8, !tbaa !20
  %xhv_name.i = getelementptr inbounds %struct.xpvhv* %170, i64 0, i32 10
  %171 = load i8** %xhv_name.i, align 8, !tbaa !54
  %tobool24.i = icmp eq i8* %171, null
  br i1 %tobool24.i, label %if.then25.i, label %return

if.then25.i:                                      ; preds = %if.end19.i
  %call26.i = call i8* @Perl_savepv(i8* getelementptr inbounds ([10 x i8]* @.str41, i64 0, i64 0)) #2
  %172 = load %struct.xpvhv** %sv_any23.i, align 8, !tbaa !20
  %xhv_name28.i = getelementptr inbounds %struct.xpvhv* %172, i64 0, i32 10
  store i8* %call26.i, i8** %xhv_name28.i, align 8, !tbaa !54
  br label %return

sw.bb565:                                         ; preds = %if.else473
  %call566 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([8 x i8]* @.str42, i64 0, i64 0)) #2
  %tobool567 = icmp eq i32 %call566, 0
  br i1 %tobool567, label %if.then568, label %return

if.then568:                                       ; preds = %sw.bb565
  %sv_any569 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %173 = load %struct.xpvgv** %sv_any569, align 8, !tbaa !7
  %xgv_gp570 = getelementptr inbounds %struct.xpvgv* %173, i64 0, i32 7
  %174 = load %struct.gp** %xgv_gp570, align 8, !tbaa !9
  %gp_hv571 = getelementptr inbounds %struct.gp* %174, i64 0, i32 5
  %175 = load %struct.hv** %gp_hv571, align 8, !tbaa !14
  %tobool572 = icmp eq %struct.hv* %175, null
  br i1 %tobool572, label %cond.false577, label %cond.end582

cond.false577:                                    ; preds = %if.then568
  %tobool.i1188 = icmp eq %struct.sv* %62, null
  br i1 %tobool.i1188, label %if.end.i1197, label %lor.lhs.false.i1191

lor.lhs.false.i1191:                              ; preds = %cond.false577
  %176 = load i64* %64, align 8, !tbaa !1
  %and.i1189 = and i64 %176, 255
  %cmp.i1190 = icmp eq i64 %and.i1189, 13
  br i1 %cmp.i1190, label %if.then2.i1201, label %if.end.i1197

if.end.i1197:                                     ; preds = %cond.false577, %lor.lhs.false.i1191
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([20 x i8]* @.str1, i64 0, i64 0)) #2
  %.pre1386 = load %struct.xpvgv** %sv_any569, align 8, !tbaa !7
  %xgv_gp.i1194.phi.trans.insert = getelementptr inbounds %struct.xpvgv* %.pre1386, i64 0, i32 7
  %.pre1387 = load %struct.gp** %xgv_gp.i1194.phi.trans.insert, align 8, !tbaa !9
  %gp_hv.i1195.phi.trans.insert = getelementptr inbounds %struct.gp* %.pre1387, i64 0, i32 5
  %.pre1388 = load %struct.hv** %gp_hv.i1195.phi.trans.insert, align 8, !tbaa !14
  %tobool1.i1196 = icmp eq %struct.hv* %.pre1388, null
  br i1 %tobool1.i1196, label %if.then2.i1201, label %cond.end582

if.then2.i1201:                                   ; preds = %lor.lhs.false.i1191, %if.end.i1197
  %call.i1198 = call %struct.hv* @Perl_newHV() #2
  %177 = load %struct.xpvgv** %sv_any569, align 8, !tbaa !7
  %xgv_gp4.i1199 = getelementptr inbounds %struct.xpvgv* %177, i64 0, i32 7
  %178 = load %struct.gp** %xgv_gp4.i1199, align 8, !tbaa !9
  %gp_hv5.i1200 = getelementptr inbounds %struct.gp* %178, i64 0, i32 5
  store %struct.hv* %call.i1198, %struct.hv** %gp_hv5.i1200, align 8, !tbaa !14
  br label %cond.end582

cond.end582:                                      ; preds = %if.then2.i1201, %if.end.i1197, %if.then568
  %179 = phi %struct.xpvgv* [ %173, %if.then568 ], [ %.pre1386, %if.end.i1197 ], [ %177, %if.then2.i1201 ]
  %cond583 = phi %struct.hv* [ %175, %if.then568 ], [ %.pre1388, %if.end.i1197 ], [ %call.i1198, %if.then2.i1201 ]
  %xgv_flags585 = getelementptr inbounds %struct.xpvgv* %179, i64 0, i32 11
  %180 = load i8* %xgv_flags585, align 1, !tbaa !46
  %or587 = or i8 %180, 2
  store i8 %or587, i8* %xgv_flags585, align 1, !tbaa !46
  call void @Perl_hv_magic(%struct.hv* %cond583, %struct.gv* null, i32 65) #2
  br label %return

sw.bb590:                                         ; preds = %if.else473
  %call591 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([3 x i8]* @.str43, i64 0, i64 0)) #2
  %tobool592 = icmp eq i32 %call591, 0
  br i1 %tobool592, label %if.then593, label %return

if.then593:                                       ; preds = %sw.bb590
  %181 = load %struct.sv*** @PL_psig_ptr, align 8, !tbaa !19
  %tobool595 = icmp eq %struct.sv** %181, null
  br i1 %tobool595, label %if.then596, label %if.end600

if.then596:                                       ; preds = %if.then593
  %call597 = call i8* @Perl_safesysmalloc(i64 128) #2
  %182 = bitcast i8* %call597 to %struct.sv**
  store %struct.sv** %182, %struct.sv*** @PL_psig_ptr, align 8, !tbaa !19
  call void @llvm.memset.p0i8.i64(i8* %call597, i8 0, i64 128, i32 1, i1 false)
  %call598 = call i8* @Perl_safesysmalloc(i64 128) #2
  %183 = bitcast i8* %call598 to %struct.sv**
  store %struct.sv** %183, %struct.sv*** @PL_psig_name, align 8, !tbaa !19
  call void @llvm.memset.p0i8.i64(i8* %call598, i8 0, i64 128, i32 1, i1 false)
  %call599 = call i8* @Perl_safesysmalloc(i64 64) #2
  %184 = bitcast i8* %call599 to i32*
  store i32* %184, i32** @PL_psig_pend, align 8, !tbaa !19
  call void @llvm.memset.p0i8.i64(i8* %call599, i8 0, i64 64, i32 1, i1 false)
  br label %if.end600

if.end600:                                        ; preds = %if.then593, %if.then596
  %sv_any601 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %185 = load %struct.xpvgv** %sv_any601, align 8, !tbaa !7
  %xgv_flags602 = getelementptr inbounds %struct.xpvgv* %185, i64 0, i32 11
  %186 = load i8* %xgv_flags602, align 1, !tbaa !46
  %or604 = or i8 %186, 2
  store i8 %or604, i8* %xgv_flags602, align 1, !tbaa !46
  %xgv_gp607 = getelementptr inbounds %struct.xpvgv* %185, i64 0, i32 7
  %187 = load %struct.gp** %xgv_gp607, align 8, !tbaa !9
  %gp_hv608 = getelementptr inbounds %struct.gp* %187, i64 0, i32 5
  %188 = load %struct.hv** %gp_hv608, align 8, !tbaa !14
  %tobool609 = icmp eq %struct.hv* %188, null
  br i1 %tobool609, label %cond.false614, label %cond.end619

cond.false614:                                    ; preds = %if.end600
  %tobool.i1176 = icmp eq %struct.sv* %62, null
  br i1 %tobool.i1176, label %if.end.i1184, label %lor.lhs.false.i1179

lor.lhs.false.i1179:                              ; preds = %cond.false614
  %189 = load i64* %64, align 8, !tbaa !1
  %and.i1177 = and i64 %189, 255
  %cmp.i1178 = icmp eq i64 %and.i1177, 13
  br i1 %cmp.i1178, label %if.then2.i1187, label %if.end.i1184

if.end.i1184:                                     ; preds = %cond.false614, %lor.lhs.false.i1179
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([20 x i8]* @.str1, i64 0, i64 0)) #2
  %.pre1389 = load %struct.xpvgv** %sv_any601, align 8, !tbaa !7
  %xgv_gp.i1182.phi.trans.insert = getelementptr inbounds %struct.xpvgv* %.pre1389, i64 0, i32 7
  %.pre1390 = load %struct.gp** %xgv_gp.i1182.phi.trans.insert, align 8, !tbaa !9
  %gp_hv.i.phi.trans.insert = getelementptr inbounds %struct.gp* %.pre1390, i64 0, i32 5
  %.pre1391 = load %struct.hv** %gp_hv.i.phi.trans.insert, align 8, !tbaa !14
  %tobool1.i1183 = icmp eq %struct.hv* %.pre1391, null
  br i1 %tobool1.i1183, label %if.then2.i1187, label %cond.end619

if.then2.i1187:                                   ; preds = %lor.lhs.false.i1179, %if.end.i1184
  %call.i1185 = call %struct.hv* @Perl_newHV() #2
  %190 = load %struct.xpvgv** %sv_any601, align 8, !tbaa !7
  %xgv_gp4.i1186 = getelementptr inbounds %struct.xpvgv* %190, i64 0, i32 7
  %191 = load %struct.gp** %xgv_gp4.i1186, align 8, !tbaa !9
  %gp_hv5.i = getelementptr inbounds %struct.gp* %191, i64 0, i32 5
  store %struct.hv* %call.i1185, %struct.hv** %gp_hv5.i, align 8, !tbaa !14
  br label %cond.end619

cond.end619:                                      ; preds = %if.then2.i1187, %if.end.i1184, %if.end600
  %cond620 = phi %struct.hv* [ %188, %if.end600 ], [ %.pre1391, %if.end.i1184 ], [ %call.i1185, %if.then2.i1187 ]
  call void @Perl_hv_magic(%struct.hv* %cond620, %struct.gv* null, i32 83) #2
  br label %for.body624

for.body624:                                      ; preds = %if.end631, %cond.end619
  %i.01377 = phi i64 [ 1, %cond.end619 ], [ %inc636, %if.end631 ]
  %arrayidx625 = getelementptr inbounds [0 x i8*]* @PL_sig_name, i64 0, i64 %i.01377
  %192 = load i8** %arrayidx625, align 8, !tbaa !19
  %call627 = call i64 @strlen(i8* %192) #2
  %call628 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %cond620, i8* %192, i64 %call627, i64 1) #2
  %tobool629 = icmp eq %struct.sv** %call628, null
  br i1 %tobool629, label %if.end631, label %if.then630

if.then630:                                       ; preds = %for.body624
  %193 = load %struct.sv** %call628, align 8, !tbaa !19
  call void @Perl_sv_setsv_flags(%struct.sv* %193, %struct.sv* @PL_sv_undef, i64 2) #2
  br label %if.end631

if.end631:                                        ; preds = %for.body624, %if.then630
  %194 = load %struct.sv*** @PL_psig_ptr, align 8, !tbaa !19
  %arrayidx632 = getelementptr inbounds %struct.sv** %194, i64 %i.01377
  store %struct.sv* null, %struct.sv** %arrayidx632, align 8, !tbaa !19
  %195 = load %struct.sv*** @PL_psig_name, align 8, !tbaa !19
  %arrayidx633 = getelementptr inbounds %struct.sv** %195, i64 %i.01377
  store %struct.sv* null, %struct.sv** %arrayidx633, align 8, !tbaa !19
  %196 = load i32** @PL_psig_pend, align 8, !tbaa !19
  %arrayidx634 = getelementptr inbounds i32* %196, i64 %i.01377
  store i32 0, i32* %arrayidx634, align 4, !tbaa !73
  %inc636 = add nsw i64 %i.01377, 1
  %exitcond = icmp eq i64 %inc636, 16
  br i1 %exitcond, label %return, label %for.body624

sw.bb639:                                         ; preds = %if.else473
  %call640 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([7 x i8]* @.str44, i64 0, i64 0)) #2
  %tobool641 = icmp eq i32 %call640, 0
  br i1 %tobool641, label %if.then642, label %return

if.then642:                                       ; preds = %sw.bb639
  %sv_any643 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %197 = load %struct.xpvgv** %sv_any643, align 8, !tbaa !7
  %xgv_flags644 = getelementptr inbounds %struct.xpvgv* %197, i64 0, i32 11
  %198 = load i8* %xgv_flags644, align 1, !tbaa !46
  %or646 = or i8 %198, 2
  store i8 %or646, i8* %xgv_flags644, align 1, !tbaa !46
  br label %return

sw.bb649:                                         ; preds = %if.else473
  %call650 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([8 x i8]* @.str45, i64 0, i64 0)) #2
  %tobool651 = icmp eq i32 %call650, 0
  br i1 %tobool651, label %magicalize, label %return

sw.bb654:                                         ; preds = %if.else473
  %call655 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([4 x i8]* @.str46, i64 0, i64 0)) #2
  %tobool656 = icmp eq i32 %call655, 0
  br i1 %tobool656, label %magicalize, label %return

sw.bb659:                                         ; preds = %if.else473
  %call660 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([5 x i8]* @.str47, i64 0, i64 0)) #2
  %tobool661 = icmp eq i32 %call660, 0
  br i1 %tobool661, label %ro_magicalize, label %return

sw.bb664:                                         ; preds = %if.else473
  %call665 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([7 x i8]* @.str48, i64 0, i64 0)) #2
  %tobool666 = icmp eq i32 %call665, 0
  br i1 %tobool666, label %ro_magicalize, label %if.end668

if.end668:                                        ; preds = %sw.bb664
  %call669 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([10 x i8]* @.str49, i64 0, i64 0)) #2
  %tobool670 = icmp eq i32 %call669, 0
  br i1 %tobool670, label %ro_magicalize, label %return

sw.bb673:                                         ; preds = %if.else473
  %call674 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([12 x i8]* @.str50, i64 0, i64 0)) #2
  %tobool675 = icmp eq i32 %call674, 0
  br i1 %tobool675, label %magicalize, label %return

sw.bb678:                                         ; preds = %if.else473, %if.else473, %if.else473, %if.else473, %if.else473, %if.else473, %if.else473, %if.else473, %if.else473
  %add.ptr679 = getelementptr inbounds i8* %name.1, i64 %sub.ptr.sub125
  br label %while.cond

while.cond:                                       ; preds = %while.body, %sw.bb678
  %end.0 = phi i8* [ %add.ptr679, %sw.bb678 ], [ %incdec.ptr680, %while.body ]
  %incdec.ptr680 = getelementptr inbounds i8* %end.0, i64 -1
  %cmp681 = icmp ugt i8* %incdec.ptr680, %name.1
  br i1 %cmp681, label %while.body, label %ro_magicalize

while.body:                                       ; preds = %while.cond
  %199 = load i8* %incdec.ptr680, align 1, !tbaa !26
  %.off1358 = add i8 %199, -48
  %200 = icmp ult i8 %.off1358, 10
  br i1 %200, label %while.cond, label %return

if.else694:                                       ; preds = %if.end465
  switch i32 %conv469, label %return [
    i32 38, label %sw.bb696
    i32 96, label %sw.bb696
    i32 39, label %sw.bb696
    i32 58, label %sw.bb713
    i32 63, label %magicalize
    i32 33, label %sw.bb717
    i32 45, label %sw.bb726
    i32 35, label %sw.bb745
    i32 42, label %sw.bb745
    i32 124, label %sw.bb786
    i32 43, label %sw.bb801
    i32 19, label %ro_magicalize
    i32 49, label %ro_magicalize
    i32 50, label %ro_magicalize
    i32 51, label %ro_magicalize
    i32 52, label %ro_magicalize
    i32 53, label %ro_magicalize
    i32 54, label %ro_magicalize
    i32 55, label %ro_magicalize
    i32 56, label %ro_magicalize
    i32 57, label %ro_magicalize
    i32 91, label %magicalize
    i32 94, label %magicalize
    i32 126, label %magicalize
    i32 61, label %magicalize
    i32 37, label %magicalize
    i32 46, label %magicalize
    i32 40, label %magicalize
    i32 41, label %magicalize
    i32 60, label %magicalize
    i32 62, label %magicalize
    i32 44, label %magicalize
    i32 92, label %magicalize
    i32 47, label %magicalize
    i32 1, label %magicalize
    i32 3, label %magicalize
    i32 4, label %magicalize
    i32 5, label %magicalize
    i32 6, label %magicalize
    i32 8, label %magicalize
    i32 9, label %magicalize
    i32 14, label %magicalize
    i32 15, label %magicalize
    i32 16, label %magicalize
    i32 20, label %magicalize
    i32 23, label %magicalize
    i32 12, label %sw.bb830
    i32 59, label %sw.bb837
    i32 93, label %sw.bb841
    i32 22, label %sw.bb861
  ]

sw.bb696:                                         ; preds = %if.else694, %if.else694, %if.else694
  switch i64 %sv_type, label %if.end712 [
    i64 15, label %return
    i64 14, label %return
    i64 12, label %return
    i64 11, label %return
    i64 10, label %return
  ]

if.end712:                                        ; preds = %sw.bb696
  store i8 1, i8* @PL_sawampersand, align 1, !tbaa !26
  br label %ro_magicalize

sw.bb713:                                         ; preds = %if.else694
  %sv_any714 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %201 = load %struct.xpvgv** %sv_any714, align 8, !tbaa !7
  %xgv_gp715 = getelementptr inbounds %struct.xpvgv* %201, i64 0, i32 7
  %202 = load %struct.gp** %xgv_gp715, align 8, !tbaa !9
  %gp_sv = getelementptr inbounds %struct.gp* %202, i64 0, i32 0
  %203 = load %struct.sv** %gp_sv, align 8, !tbaa !28
  %204 = load i8** @PL_chopset, align 8, !tbaa !19
  call void @Perl_sv_setpv(%struct.sv* %203, i8* %204) #2
  br label %magicalize

sw.bb717:                                         ; preds = %if.else694
  %sv_any718 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %205 = load %struct.xpvgv** %sv_any718, align 8, !tbaa !7
  %xgv_gp719 = getelementptr inbounds %struct.xpvgv* %205, i64 0, i32 7
  %206 = load %struct.gp** %xgv_gp719, align 8, !tbaa !9
  %gp_sv720 = getelementptr inbounds %struct.gp* %206, i64 0, i32 0
  %207 = load %struct.sv** %gp_sv720, align 8, !tbaa !28
  call void @Perl_sv_magic(%struct.sv* %207, %struct.sv* %62, i32 0, i8* %name.1, i64 %sub.ptr.sub125) #2
  %cmp721 = icmp eq i64 %sv_type, 11
  br i1 %cmp721, label %if.then723, label %return

if.then723:                                       ; preds = %sw.bb717
  %call724 = call i32 (%struct.gv*, ...)* bitcast (i32 (...)* @require_errno to i32 (%struct.gv*, ...)*)(%struct.gv* %63) #2
  br label %return

sw.bb726:                                         ; preds = %if.else694
  %sv_any728 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %208 = load %struct.xpvgv** %sv_any728, align 8, !tbaa !7
  %xgv_gp729 = getelementptr inbounds %struct.xpvgv* %208, i64 0, i32 7
  %209 = load %struct.gp** %xgv_gp729, align 8, !tbaa !9
  %gp_av730 = getelementptr inbounds %struct.gp* %209, i64 0, i32 4
  %210 = load %struct.av** %gp_av730, align 8, !tbaa !12
  %tobool731 = icmp eq %struct.av* %210, null
  br i1 %tobool731, label %cond.false736, label %cond.end741

cond.false736:                                    ; preds = %sw.bb726
  %tobool.i1146 = icmp eq %struct.sv* %62, null
  br i1 %tobool.i1146, label %if.end.i1155, label %lor.lhs.false.i1149

lor.lhs.false.i1149:                              ; preds = %cond.false736
  %211 = load i64* %64, align 8, !tbaa !1
  %and.i1147 = and i64 %211, 255
  %cmp.i1148 = icmp eq i64 %and.i1147, 13
  br i1 %cmp.i1148, label %if.then2.i1159, label %if.end.i1155

if.end.i1155:                                     ; preds = %cond.false736, %lor.lhs.false.i1149
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([21 x i8]* @.str, i64 0, i64 0)) #2
  %.pre1392 = load %struct.xpvgv** %sv_any728, align 8, !tbaa !7
  %xgv_gp.i1152.phi.trans.insert = getelementptr inbounds %struct.xpvgv* %.pre1392, i64 0, i32 7
  %.pre1393 = load %struct.gp** %xgv_gp.i1152.phi.trans.insert, align 8, !tbaa !9
  %gp_av.i1153.phi.trans.insert = getelementptr inbounds %struct.gp* %.pre1393, i64 0, i32 4
  %.pre1394 = load %struct.av** %gp_av.i1153.phi.trans.insert, align 8, !tbaa !12
  %tobool1.i1154 = icmp eq %struct.av* %.pre1394, null
  br i1 %tobool1.i1154, label %if.then2.i1159, label %cond.end741

if.then2.i1159:                                   ; preds = %lor.lhs.false.i1149, %if.end.i1155
  %call.i1156 = call %struct.av* @Perl_newAV() #2
  %212 = load %struct.xpvgv** %sv_any728, align 8, !tbaa !7
  %xgv_gp4.i1157 = getelementptr inbounds %struct.xpvgv* %212, i64 0, i32 7
  %213 = load %struct.gp** %xgv_gp4.i1157, align 8, !tbaa !9
  %gp_av5.i1158 = getelementptr inbounds %struct.gp* %213, i64 0, i32 4
  store %struct.av* %call.i1156, %struct.av** %gp_av5.i1158, align 8, !tbaa !12
  br label %cond.end741

cond.end741:                                      ; preds = %if.then2.i1159, %if.end.i1155, %sw.bb726
  %cond742 = phi %struct.av* [ %210, %sw.bb726 ], [ %.pre1394, %if.end.i1155 ], [ %call.i1156, %if.then2.i1159 ]
  %214 = bitcast %struct.av* %cond742 to %struct.sv*
  call void @Perl_sv_magic(%struct.sv* %214, %struct.sv* null, i32 68, i8* null, i64 0) #2
  %sv_flags743 = getelementptr inbounds %struct.av* %cond742, i64 0, i32 2
  %215 = load i64* %sv_flags743, align 8, !tbaa !75
  %or744 = or i64 %215, 8388608
  store i64 %or744, i64* %sv_flags743, align 8, !tbaa !75
  br label %magicalize

sw.bb745:                                         ; preds = %if.else694, %if.else694
  %cmp746 = icmp eq i64 %sv_type, 4
  br i1 %cmp746, label %land.lhs.true748, label %magicalize

land.lhs.true748:                                 ; preds = %sw.bb745
  %216 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings749 = getelementptr inbounds %struct.cop* %216, i64 0, i32 14
  %217 = load %struct.sv** %cop_warnings749, align 8, !tbaa !63
  %cmp750 = icmp eq %struct.sv* %217, null
  br i1 %cmp750, label %lor.lhs.false776, label %land.lhs.true752

land.lhs.true752:                                 ; preds = %land.lhs.true748
  %218 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings753 = getelementptr inbounds %struct.cop* %218, i64 0, i32 14
  %219 = load %struct.sv** %cop_warnings753, align 8, !tbaa !63
  %cmp754 = icmp eq %struct.sv* %219, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp754, label %lor.lhs.false776, label %land.lhs.true756

land.lhs.true756:                                 ; preds = %land.lhs.true752
  %220 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings757 = getelementptr inbounds %struct.cop* %220, i64 0, i32 14
  %221 = load %struct.sv** %cop_warnings757, align 8, !tbaa !63
  %cmp758 = icmp eq %struct.sv* %221, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp758, label %if.then784, label %lor.lhs.false760

lor.lhs.false760:                                 ; preds = %land.lhs.true756
  %222 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings761 = getelementptr inbounds %struct.cop* %222, i64 0, i32 14
  %223 = load %struct.sv** %cop_warnings761, align 8, !tbaa !63
  %sv_any762 = getelementptr inbounds %struct.sv* %223, i64 0, i32 0
  %224 = load i8** %sv_any762, align 8, !tbaa !39
  %xpv_pv763 = bitcast i8* %224 to i8**
  %225 = load i8** %xpv_pv763, align 8, !tbaa !30
  %226 = load i8* %225, align 1, !tbaa !26
  %and766 = and i8 %226, 16
  %tobool767 = icmp eq i8 %and766, 0
  br i1 %tobool767, label %lor.lhs.false768, label %if.then784

lor.lhs.false768:                                 ; preds = %lor.lhs.false760
  %227 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings769 = getelementptr inbounds %struct.cop* %227, i64 0, i32 14
  %228 = load %struct.sv** %cop_warnings769, align 8, !tbaa !63
  %sv_any770 = getelementptr inbounds %struct.sv* %228, i64 0, i32 0
  %229 = load i8** %sv_any770, align 8, !tbaa !39
  %xpv_pv771 = bitcast i8* %229 to i8**
  %230 = load i8** %xpv_pv771, align 8, !tbaa !30
  %arrayidx772 = getelementptr inbounds i8* %230, i64 7
  %231 = load i8* %arrayidx772, align 1, !tbaa !26
  %and774 = and i8 %231, 1
  %tobool775 = icmp eq i8 %and774, 0
  br i1 %tobool775, label %lor.lhs.false776, label %if.then784

lor.lhs.false776:                                 ; preds = %lor.lhs.false768, %land.lhs.true752, %land.lhs.true748
  %232 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings777 = getelementptr inbounds %struct.cop* %232, i64 0, i32 14
  %233 = load %struct.sv** %cop_warnings777, align 8, !tbaa !63
  %cmp778 = icmp eq %struct.sv* %233, null
  br i1 %cmp778, label %land.lhs.true780, label %magicalize

land.lhs.true780:                                 ; preds = %lor.lhs.false776
  %234 = load i8* @PL_dowarn, align 1, !tbaa !26
  %and782 = and i8 %234, 1
  %tobool783 = icmp eq i8 %and782, 0
  br i1 %tobool783, label %magicalize, label %if.then784

if.then784:                                       ; preds = %lor.lhs.false768, %lor.lhs.false760, %land.lhs.true780, %land.lhs.true756
  call void (i64, i8*, ...)* @Perl_warner(i64 7170, i8* getelementptr inbounds ([25 x i8]* @.str51, i64 0, i64 0), i8* %name.1) #2
  br label %magicalize

sw.bb786:                                         ; preds = %if.else694
  %sv_any787 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %235 = load %struct.xpvgv** %sv_any787, align 8, !tbaa !7
  %xgv_gp788 = getelementptr inbounds %struct.xpvgv* %235, i64 0, i32 7
  %236 = load %struct.gp** %xgv_gp788, align 8, !tbaa !9
  %gp_sv789 = getelementptr inbounds %struct.gp* %236, i64 0, i32 0
  %237 = load %struct.sv** %gp_sv789, align 8, !tbaa !28
  %238 = load %struct.gv** @PL_defoutgv, align 8, !tbaa !19
  %sv_any790 = getelementptr inbounds %struct.gv* %238, i64 0, i32 0
  %239 = load %struct.xpvgv** %sv_any790, align 8, !tbaa !7
  %xgv_gp791 = getelementptr inbounds %struct.xpvgv* %239, i64 0, i32 7
  %240 = load %struct.gp** %xgv_gp791, align 8, !tbaa !9
  %gp_io792 = getelementptr inbounds %struct.gp* %240, i64 0, i32 2
  %241 = load %struct.io** %gp_io792, align 8, !tbaa !15
  %sv_any793 = getelementptr inbounds %struct.io* %241, i64 0, i32 0
  %242 = load %struct.xpvio** %sv_any793, align 8, !tbaa !23
  %xio_flags794 = getelementptr inbounds %struct.xpvio* %242, i64 0, i32 22
  %243 = load i8* %xio_flags794, align 1, !tbaa !71
  %and796 = lshr i8 %243, 2
  %and796.lobit = and i8 %and796, 1
  %conv800 = zext i8 %and796.lobit to i64
  call void @Perl_sv_setiv(%struct.sv* %237, i64 %conv800) #2
  br label %magicalize

sw.bb801:                                         ; preds = %if.else694
  %sv_any803 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %244 = load %struct.xpvgv** %sv_any803, align 8, !tbaa !7
  %xgv_gp804 = getelementptr inbounds %struct.xpvgv* %244, i64 0, i32 7
  %245 = load %struct.gp** %xgv_gp804, align 8, !tbaa !9
  %gp_av805 = getelementptr inbounds %struct.gp* %245, i64 0, i32 4
  %246 = load %struct.av** %gp_av805, align 8, !tbaa !12
  %tobool806 = icmp eq %struct.av* %246, null
  br i1 %tobool806, label %lor.lhs.false.i, label %cond.end816

lor.lhs.false.i:                                  ; preds = %sw.bb801
  %247 = load i64* %64, align 8, !tbaa !1
  %and.i = and i64 %247, 255
  %cmp.i = icmp eq i64 %and.i, 13
  br i1 %cmp.i, label %if.then2.i, label %if.end.i

if.end.i:                                         ; preds = %lor.lhs.false.i
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([21 x i8]* @.str, i64 0, i64 0)) #2
  %.pre1395 = load %struct.xpvgv** %sv_any803, align 8, !tbaa !7
  %xgv_gp.i.phi.trans.insert = getelementptr inbounds %struct.xpvgv* %.pre1395, i64 0, i32 7
  %.pre1396 = load %struct.gp** %xgv_gp.i.phi.trans.insert, align 8, !tbaa !9
  %gp_av.i.phi.trans.insert = getelementptr inbounds %struct.gp* %.pre1396, i64 0, i32 4
  %.pre1397 = load %struct.av** %gp_av.i.phi.trans.insert, align 8, !tbaa !12
  %tobool1.i = icmp eq %struct.av* %.pre1397, null
  br i1 %tobool1.i, label %if.then2.i, label %cond.end816

if.then2.i:                                       ; preds = %lor.lhs.false.i, %if.end.i
  %call.i = call %struct.av* @Perl_newAV() #2
  %248 = load %struct.xpvgv** %sv_any803, align 8, !tbaa !7
  %xgv_gp4.i = getelementptr inbounds %struct.xpvgv* %248, i64 0, i32 7
  %249 = load %struct.gp** %xgv_gp4.i, align 8, !tbaa !9
  %gp_av5.i = getelementptr inbounds %struct.gp* %249, i64 0, i32 4
  store %struct.av* %call.i, %struct.av** %gp_av5.i, align 8, !tbaa !12
  br label %cond.end816

cond.end816:                                      ; preds = %if.then2.i, %if.end.i, %sw.bb801
  %cond817 = phi %struct.av* [ %246, %sw.bb801 ], [ %.pre1397, %if.end.i ], [ %call.i, %if.then2.i ]
  %250 = bitcast %struct.av* %cond817 to %struct.sv*
  call void @Perl_sv_magic(%struct.sv* %250, %struct.sv* %250, i32 68, i8* null, i64 0) #2
  %sv_flags818 = getelementptr inbounds %struct.av* %cond817, i64 0, i32 2
  %251 = load i64* %sv_flags818, align 8, !tbaa !75
  %or819 = or i64 %251, 8388608
  store i64 %or819, i64* %sv_flags818, align 8, !tbaa !75
  br label %ro_magicalize

ro_magicalize:                                    ; preds = %while.cond, %sw.bb659, %if.end668, %sw.bb664, %cond.end816, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.end712
  %sv_any821 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %252 = load %struct.xpvgv** %sv_any821, align 8, !tbaa !7
  %xgv_gp822 = getelementptr inbounds %struct.xpvgv* %252, i64 0, i32 7
  %253 = load %struct.gp** %xgv_gp822, align 8, !tbaa !9
  %gp_sv823 = getelementptr inbounds %struct.gp* %253, i64 0, i32 0
  %254 = load %struct.sv** %gp_sv823, align 8, !tbaa !28
  %sv_flags824 = getelementptr inbounds %struct.sv* %254, i64 0, i32 2
  %255 = load i64* %sv_flags824, align 8, !tbaa !1
  %or825 = or i64 %255, 8388608
  store i64 %or825, i64* %sv_flags824, align 8, !tbaa !1
  br label %magicalize

magicalize:                                       ; preds = %sw.bb649, %sw.bb654, %sw.bb673, %land.lhs.true780, %ro_magicalize, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %if.else694, %sw.bb745, %lor.lhs.false776, %if.then784, %if.else694, %sw.bb786, %cond.end741, %sw.bb713
  %sv_any827 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %256 = load %struct.xpvgv** %sv_any827, align 8, !tbaa !7
  %xgv_gp828 = getelementptr inbounds %struct.xpvgv* %256, i64 0, i32 7
  %257 = load %struct.gp** %xgv_gp828, align 8, !tbaa !9
  %gp_sv829 = getelementptr inbounds %struct.gp* %257, i64 0, i32 0
  %258 = load %struct.sv** %gp_sv829, align 8, !tbaa !28
  call void @Perl_sv_magic(%struct.sv* %258, %struct.sv* %62, i32 0, i8* %name.1, i64 %sub.ptr.sub125) #2
  br label %return

sw.bb830:                                         ; preds = %if.else694
  %sv_any831 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %259 = load %struct.xpvgv** %sv_any831, align 8, !tbaa !7
  %xgv_gp832 = getelementptr inbounds %struct.xpvgv* %259, i64 0, i32 7
  %260 = load %struct.gp** %xgv_gp832, align 8, !tbaa !9
  %gp_sv833 = getelementptr inbounds %struct.gp* %260, i64 0, i32 0
  %261 = load %struct.sv** %gp_sv833, align 8, !tbaa !28
  call void @Perl_sv_setpv(%struct.sv* %261, i8* getelementptr inbounds ([2 x i8]* @.str52, i64 0, i64 0)) #2
  %262 = load %struct.xpvgv** %sv_any831, align 8, !tbaa !7
  %xgv_gp835 = getelementptr inbounds %struct.xpvgv* %262, i64 0, i32 7
  %263 = load %struct.gp** %xgv_gp835, align 8, !tbaa !9
  %gp_sv836 = getelementptr inbounds %struct.gp* %263, i64 0, i32 0
  %264 = load %struct.sv** %gp_sv836, align 8, !tbaa !28
  store %struct.sv* %264, %struct.sv** @PL_formfeed, align 8, !tbaa !19
  br label %return

sw.bb837:                                         ; preds = %if.else694
  %sv_any838 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %265 = load %struct.xpvgv** %sv_any838, align 8, !tbaa !7
  %xgv_gp839 = getelementptr inbounds %struct.xpvgv* %265, i64 0, i32 7
  %266 = load %struct.gp** %xgv_gp839, align 8, !tbaa !9
  %gp_sv840 = getelementptr inbounds %struct.gp* %266, i64 0, i32 0
  %267 = load %struct.sv** %gp_sv840, align 8, !tbaa !28
  call void @Perl_sv_setpv(%struct.sv* %267, i8* getelementptr inbounds ([2 x i8]* @.str53, i64 0, i64 0)) #2
  br label %return

sw.bb841:                                         ; preds = %if.else694
  %sv_any842 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %268 = load %struct.xpvgv** %sv_any842, align 8, !tbaa !7
  %xgv_gp843 = getelementptr inbounds %struct.xpvgv* %268, i64 0, i32 7
  %269 = load %struct.gp** %xgv_gp843, align 8, !tbaa !9
  %gp_sv844 = getelementptr inbounds %struct.gp* %269, i64 0, i32 0
  %270 = load %struct.sv** %gp_sv844, align 8, !tbaa !28
  %sv_flags845 = getelementptr inbounds %struct.sv* %270, i64 0, i32 2
  %271 = load i64* %sv_flags845, align 8, !tbaa !1
  %and846 = and i64 %271, 254
  %cmp847 = icmp ugt i64 %and846, 5
  br i1 %cmp847, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %sw.bb841
  %call849 = call signext i8 @Perl_sv_upgrade(%struct.sv* %270, i64 6) #2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %sw.bb841
  %272 = load %struct.sv** @PL_patchlevel, align 8, !tbaa !19
  %sv_any852 = getelementptr inbounds %struct.sv* %272, i64 0, i32 0
  %273 = load i8** %sv_any852, align 8, !tbaa !39
  %xnv_nv = getelementptr inbounds i8* %273, i64 32
  %274 = bitcast i8* %xnv_nv to double*
  %275 = load double* %274, align 8, !tbaa !76
  call void (%struct.sv*, i8*, ...)* @Perl_sv_setpvf(%struct.sv* %270, i8* getelementptr inbounds ([6 x i8]* @.str54, i64 0, i64 0), double %275) #2
  %276 = load %struct.sv** @PL_patchlevel, align 8, !tbaa !19
  %sv_any853 = getelementptr inbounds %struct.sv* %276, i64 0, i32 0
  %277 = load i8** %sv_any853, align 8, !tbaa !39
  %xnv_nv854 = getelementptr inbounds i8* %277, i64 32
  %278 = bitcast i8* %xnv_nv854 to double*
  %279 = load double* %278, align 8, !tbaa !76
  %sv_any855 = getelementptr inbounds %struct.sv* %270, i64 0, i32 0
  %280 = load i8** %sv_any855, align 8, !tbaa !39
  %xnv_nv856 = getelementptr inbounds i8* %280, i64 32
  %281 = bitcast i8* %xnv_nv856 to double*
  store double %279, double* %281, align 8, !tbaa !76
  %282 = load i64* %sv_flags845, align 8, !tbaa !1
  %or860 = or i64 %282, 42074112
  store i64 %or860, i64* %sv_flags845, align 8, !tbaa !1
  br label %return

sw.bb861:                                         ; preds = %if.else694
  %sv_any863 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %283 = load %struct.xpvgv** %sv_any863, align 8, !tbaa !7
  %xgv_gp864 = getelementptr inbounds %struct.xpvgv* %283, i64 0, i32 7
  %284 = load %struct.gp** %xgv_gp864, align 8, !tbaa !9
  %gp_sv865 = getelementptr inbounds %struct.gp* %284, i64 0, i32 0
  %285 = load %struct.sv** %gp_sv865, align 8, !tbaa !28
  %286 = load %struct.sv** @PL_patchlevel, align 8, !tbaa !19
  store %struct.sv* %286, %struct.sv** @PL_Sv, align 8, !tbaa !19
  %tobool866 = icmp eq %struct.sv* %286, null
  br i1 %tobool866, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %sw.bb861
  %sv_refcnt867 = getelementptr inbounds %struct.sv* %286, i64 0, i32 1
  %287 = load i64* %sv_refcnt867, align 8, !tbaa !22
  %inc868 = add i64 %287, 1
  store i64 %inc868, i64* %sv_refcnt867, align 8, !tbaa !22
  br label %land.end

land.end:                                         ; preds = %sw.bb861, %land.rhs
  %288 = load %struct.xpvgv** %sv_any863, align 8, !tbaa !7
  %xgv_gp871 = getelementptr inbounds %struct.xpvgv* %288, i64 0, i32 7
  %289 = load %struct.gp** %xgv_gp871, align 8, !tbaa !9
  %gp_sv872 = getelementptr inbounds %struct.gp* %289, i64 0, i32 0
  store %struct.sv* %286, %struct.sv** %gp_sv872, align 8, !tbaa !28
  call void @Perl_sv_free(%struct.sv* %285) #2
  br label %return

return:                                           ; preds = %if.end79, %if.then35, %lor.lhs.false40, %while.body, %if.end631, %if.then25.i, %if.end19.i, %if.end10.i, %if.else473, %cond.end503, %if.then513, %land.lhs.true548, %cond.end582, %if.then642, %if.then468, %sw.bb717, %if.then723, %if.else694, %land.end, %lor.end, %sw.bb837, %sw.bb830, %magicalize, %sw.bb673, %if.end668, %sw.bb659, %sw.bb654, %sw.bb649, %sw.bb639, %sw.bb590, %sw.bb565, %sw.bb520, %cond.end536, %land.lhs.true545, %sw.bb510, %sw.bb475, %sw.bb696, %sw.bb696, %sw.bb696, %sw.bb696, %sw.bb696, %if.else373, %if.then369, %if.then353, %if.then351, %lor.lhs.false342, %if.end339, %if.end335, %if.then307, %cond.false116, %if.then113
  %retval.4 = phi %struct.gv* [ %28, %cond.false116 ], [ %gv.1, %if.then113 ], [ null, %if.then307 ], [ null, %if.end335 ], [ null, %if.end339 ], [ null, %lor.lhs.false342 ], [ %63, %if.then351 ], [ %63, %if.then353 ], [ %63, %if.then369 ], [ %63, %if.else373 ], [ %63, %sw.bb696 ], [ %63, %sw.bb696 ], [ %63, %sw.bb696 ], [ %63, %sw.bb696 ], [ %63, %sw.bb696 ], [ %63, %sw.bb475 ], [ %63, %sw.bb510 ], [ %63, %land.lhs.true545 ], [ %63, %cond.end536 ], [ %63, %sw.bb520 ], [ %63, %sw.bb565 ], [ %63, %sw.bb590 ], [ %63, %sw.bb639 ], [ %63, %sw.bb649 ], [ %63, %sw.bb654 ], [ %63, %sw.bb659 ], [ %63, %if.end668 ], [ %63, %sw.bb673 ], [ %63, %magicalize ], [ %63, %sw.bb830 ], [ %63, %sw.bb837 ], [ %63, %lor.end ], [ %63, %land.end ], [ %63, %if.else694 ], [ %63, %if.then723 ], [ %63, %sw.bb717 ], [ %63, %if.then468 ], [ %63, %if.then642 ], [ %63, %cond.end582 ], [ %63, %land.lhs.true548 ], [ %63, %if.then513 ], [ %63, %cond.end503 ], [ %63, %if.else473 ], [ %63, %if.end10.i ], [ %63, %if.end19.i ], [ %63, %if.then25.i ], [ %63, %if.end631 ], [ %63, %while.body ], [ null, %lor.lhs.false40 ], [ null, %if.then35 ], [ null, %if.end79 ]
  ret %struct.gv* %retval.4
}

declare i8* @Perl_savepv(i8*) #1

declare i8* @Perl_sv_2pv_flags(%struct.sv*, i64*, i64) #1

declare signext i8 @Perl_is_utf8_idcont(i8*) #1

declare signext i8 @Perl_is_utf8_digit(i8*) #1

declare void @Perl_warn(i8*, ...) #1

declare %struct.sv* @Perl_mess(i8*, ...) #1

declare i32 @qerror(...) #1

declare i32 @gv_init_sv(...) #1

declare i32 @require_errno(...) #1

declare void @Perl_av_push(%struct.av*, %struct.sv*) #1

declare %struct.sv* @Perl_newSVpvn(i8*, i64) #1

declare void @Perl_sv_setsv_flags(%struct.sv*, %struct.sv*, i64) #1

declare void @Perl_sv_setiv(%struct.sv*, i64) #1

declare void @Perl_sv_setpvf(%struct.sv*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define void @Perl_gv_fullname4(%struct.sv* %sv, %struct.gv* nocapture readonly %gv, i8* %prefix, i8 signext %keepmain) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.gv* %gv, i64 0, i32 0
  %0 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_stash = getelementptr inbounds %struct.xpvgv* %0, i64 0, i32 10
  %1 = load %struct.hv** %xgv_stash, align 8, !tbaa !43
  %tobool = icmp eq %struct.hv* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %2 = load i64* %sv_flags, align 8, !tbaa !1
  %and = and i64 %2, 1223753727
  store i64 %and, i64* %sv_flags, align 8, !tbaa !1
  %and2 = and i64 %2, 2097152
  %tobool3 = icmp eq i64 %and2, 0
  br i1 %tobool3, label %return, label %land.rhs

land.rhs:                                         ; preds = %if.then
  %call = tail call i32 @Perl_sv_backoff(%struct.sv* %sv) #2
  br label %return

if.end:                                           ; preds = %entry
  %tobool5 = icmp ne i8* %prefix, null
  %cond = select i1 %tobool5, i8* %prefix, i8* getelementptr inbounds ([1 x i8]* @.str3, i64 0, i64 0)
  tail call void @Perl_sv_setpv(%struct.sv* %sv, i8* %cond) #2
  %sv_any6 = getelementptr inbounds %struct.hv* %1, i64 0, i32 0
  %3 = load %struct.xpvhv** %sv_any6, align 8, !tbaa !20
  %xhv_name = getelementptr inbounds %struct.xpvhv* %3, i64 0, i32 10
  %4 = load i8** %xhv_name, align 8, !tbaa !54
  %tobool7 = icmp ne i8* %4, null
  %. = select i1 %tobool7, i8* %4, i8* getelementptr inbounds ([9 x i8]* @.str55, i64 0, i64 0)
  %tobool10 = icmp eq i8 %keepmain, 0
  br i1 %tobool10, label %lor.lhs.false, label %if.then13

lor.lhs.false:                                    ; preds = %if.end
  %call11 = tail call i32 @strcmp(i8* %., i8* getelementptr inbounds ([5 x i8]* @.str56, i64 0, i64 0)) #2
  %tobool12 = icmp eq i32 %call11, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %lor.lhs.false, %if.end
  tail call void @Perl_sv_catpv(%struct.sv* %sv, i8* %.) #2
  tail call void @Perl_sv_catpvn_flags(%struct.sv* %sv, i8* getelementptr inbounds ([3 x i8]* @.str16, i64 0, i64 0), i64 2, i64 2) #2
  br label %if.end14

if.end14:                                         ; preds = %lor.lhs.false, %if.then13
  %5 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_name = getelementptr inbounds %struct.xpvgv* %5, i64 0, i32 8
  %6 = load i8** %xgv_name, align 8, !tbaa !44
  %xgv_namelen = getelementptr inbounds %struct.xpvgv* %5, i64 0, i32 9
  %7 = load i64* %xgv_namelen, align 8, !tbaa !45
  tail call void @Perl_sv_catpvn_flags(%struct.sv* %sv, i8* %6, i64 %7, i64 2) #2
  br label %return

return:                                           ; preds = %land.rhs, %if.then, %if.end14
  ret void
}

declare i32 @Perl_sv_backoff(%struct.sv*) #1

declare void @Perl_sv_catpv(%struct.sv*, i8*) #1

; Function Attrs: nounwind uwtable
define void @Perl_gv_fullname3(%struct.sv* %sv, %struct.gv* nocapture readonly %gv, i8* %prefix) #0 {
entry:
  tail call void @Perl_gv_fullname4(%struct.sv* %sv, %struct.gv* %gv, i8* %prefix, i8 signext 1)
  ret void
}

; Function Attrs: nounwind uwtable
define void @Perl_gv_efullname4(%struct.sv* %sv, %struct.gv* nocapture readonly %gv, i8* %prefix, i8 signext %keepmain) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.gv* %gv, i64 0, i32 0
  %0 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %0, i64 0, i32 7
  %1 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_egv = getelementptr inbounds %struct.gp* %1, i64 0, i32 6
  %2 = load %struct.gv** %gp_egv, align 8, !tbaa !42
  %tobool = icmp eq %struct.gv* %2, null
  %gv. = select i1 %tobool, %struct.gv* %gv, %struct.gv* %2
  tail call void @Perl_gv_fullname4(%struct.sv* %sv, %struct.gv* %gv., i8* %prefix, i8 signext %keepmain)
  ret void
}

; Function Attrs: nounwind uwtable
define void @Perl_gv_efullname3(%struct.sv* %sv, %struct.gv* nocapture readonly %gv, i8* %prefix) #0 {
entry:
  %sv_any.i = getelementptr inbounds %struct.gv* %gv, i64 0, i32 0
  %0 = load %struct.xpvgv** %sv_any.i, align 8, !tbaa !7
  %xgv_gp.i = getelementptr inbounds %struct.xpvgv* %0, i64 0, i32 7
  %1 = load %struct.gp** %xgv_gp.i, align 8, !tbaa !9
  %gp_egv.i = getelementptr inbounds %struct.gp* %1, i64 0, i32 6
  %2 = load %struct.gv** %gp_egv.i, align 8, !tbaa !42
  %tobool.i = icmp eq %struct.gv* %2, null
  %gv..i = select i1 %tobool.i, %struct.gv* %gv, %struct.gv* %2
  tail call void @Perl_gv_fullname4(%struct.sv* %sv, %struct.gv* %gv..i, i8* %prefix, i8 signext 1) #2
  ret void
}

; Function Attrs: nounwind uwtable
define void @Perl_gv_fullname(%struct.sv* %sv, %struct.gv* readonly %gv) #0 {
entry:
  %0 = bitcast %struct.gv* %gv to %struct.sv*
  %cmp = icmp eq %struct.sv* %0, %sv
  %cond = select i1 %cmp, i8* getelementptr inbounds ([2 x i8]* @.str57, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8]* @.str3, i64 0, i64 0)
  tail call void @Perl_gv_fullname4(%struct.sv* %sv, %struct.gv* %gv, i8* %cond, i8 signext 1)
  ret void
}

; Function Attrs: nounwind uwtable
define void @Perl_gv_efullname(%struct.sv* %sv, %struct.gv* readonly %gv) #0 {
entry:
  %0 = bitcast %struct.gv* %gv to %struct.sv*
  %cmp = icmp eq %struct.sv* %0, %sv
  %cond = select i1 %cmp, i8* getelementptr inbounds ([2 x i8]* @.str57, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8]* @.str3, i64 0, i64 0)
  %sv_any.i = getelementptr inbounds %struct.gv* %gv, i64 0, i32 0
  %1 = load %struct.xpvgv** %sv_any.i, align 8, !tbaa !7
  %xgv_gp.i = getelementptr inbounds %struct.xpvgv* %1, i64 0, i32 7
  %2 = load %struct.gp** %xgv_gp.i, align 8, !tbaa !9
  %gp_egv.i = getelementptr inbounds %struct.gp* %2, i64 0, i32 6
  %3 = load %struct.gv** %gp_egv.i, align 8, !tbaa !42
  %tobool.i = icmp eq %struct.gv* %3, null
  %gv..i = select i1 %tobool.i, %struct.gv* %gv, %struct.gv* %3
  tail call void @Perl_gv_fullname4(%struct.sv* %sv, %struct.gv* %gv..i, i8* %cond, i8 signext 1) #2
  ret void
}

declare void @Perl_hv_clear(%struct.hv*) #1

; Function Attrs: nounwind uwtable
define void @Perl_gv_check(%struct.hv* readonly %stash) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.hv* %stash, i64 0, i32 0
  %0 = load %struct.xpvhv** %sv_any, align 8, !tbaa !20
  %1 = bitcast %struct.xpvhv* %0 to %struct.he***
  %2 = load %struct.he*** %1, align 8, !tbaa !19
  %tobool = icmp eq %struct.he** %2, null
  br i1 %tobool, label %for.end87, label %for.cond.preheader

for.cond.preheader:                               ; preds = %entry
  %xhv_max123 = getelementptr inbounds %struct.xpvhv* %0, i64 0, i32 2
  %3 = load i64* %xhv_max123, align 8, !tbaa !78
  %cmp124 = icmp slt i64 %3, 0
  br i1 %cmp124, label %for.end87, label %for.body

for.body:                                         ; preds = %for.cond.preheader, %for.inc86.for.body_crit_edge
  %4 = phi %struct.he** [ %.pre, %for.inc86.for.body_crit_edge ], [ %2, %for.cond.preheader ]
  %i.0125 = phi i64 [ %inc, %for.inc86.for.body_crit_edge ], [ 0, %for.cond.preheader ]
  %arrayidx = getelementptr inbounds %struct.he** %4, i64 %i.0125
  %entry1.0120 = load %struct.he** %arrayidx, align 8
  %tobool6121 = icmp eq %struct.he* %entry1.0120, null
  br i1 %tobool6121, label %for.inc86, label %for.body7

for.body7:                                        ; preds = %for.body, %for.inc
  %entry1.0122 = phi %struct.he* [ %entry1.0, %for.inc ], [ %entry1.0120, %for.body ]
  %hent_hek = getelementptr inbounds %struct.he* %entry1.0122, i64 0, i32 1
  %5 = load %struct.hek** %hent_hek, align 8, !tbaa !79
  %hek_len = getelementptr inbounds %struct.hek* %5, i64 0, i32 1
  %6 = load i64* %hek_len, align 8, !tbaa !81
  %sub = add nsw i64 %6, -1
  %arrayidx9 = getelementptr inbounds %struct.hek* %5, i64 0, i32 2, i64 %sub
  %7 = load i8* %arrayidx9, align 1, !tbaa !26
  %cmp10 = icmp eq i8 %7, 58
  br i1 %cmp10, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %for.body7
  %hent_val = getelementptr inbounds %struct.he* %entry1.0122, i64 0, i32 2
  %8 = load %struct.sv** %hent_val, align 8, !tbaa !83
  %tobool12 = icmp eq %struct.sv* %8, null
  br i1 %tobool12, label %if.else, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %land.lhs.true
  %9 = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %10 = load i64* %9, align 8, !tbaa !27
  %and = and i64 %10, 255
  %cmp14 = icmp eq i64 %and, 13
  br i1 %cmp14, label %land.lhs.true16, label %if.else

land.lhs.true16:                                  ; preds = %land.lhs.true13
  %sv_any17 = bitcast %struct.sv* %8 to %struct.xpvgv**
  %11 = load %struct.xpvgv** %sv_any17, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %11, i64 0, i32 7
  %12 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_hv = getelementptr inbounds %struct.gp* %12, i64 0, i32 5
  %13 = load %struct.hv** %gp_hv, align 8, !tbaa !14
  %tobool18 = icmp eq %struct.hv* %13, null
  br i1 %tobool18, label %if.else, label %if.then19

if.then19:                                        ; preds = %land.lhs.true16
  %14 = load %struct.hv** @PL_defstash, align 8, !tbaa !19
  %cmp20 = icmp eq %struct.hv* %13, %14
  %cmp23 = icmp eq %struct.hv* %13, %stash
  %or.cond = or i1 %cmp20, %cmp23
  br i1 %or.cond, label %for.inc, label %if.then25

if.then25:                                        ; preds = %if.then19
  tail call void @Perl_gv_check(%struct.hv* %13)
  br label %for.inc

if.else:                                          ; preds = %land.lhs.true16, %land.lhs.true, %land.lhs.true13, %for.body7
  %arraydecay = getelementptr inbounds %struct.hek* %5, i64 0, i32 2, i64 0
  %15 = load i8* %arraydecay, align 1, !tbaa !26
  %.off = add i8 %15, -65
  %16 = icmp ult i8 %.off, 26
  %.off117 = add i8 %15, -97
  %17 = icmp ult i8 %.off117, 26
  %or.cond119 = or i1 %16, %17
  br i1 %or.cond119, label %if.then52, label %for.inc

if.then52:                                        ; preds = %if.else
  %hent_val53 = getelementptr inbounds %struct.he* %entry1.0122, i64 0, i32 2
  %18 = load %struct.sv** %hent_val53, align 8, !tbaa !83
  %19 = getelementptr inbounds %struct.sv* %18, i64 0, i32 2
  %20 = load i64* %19, align 8, !tbaa !27
  %and55 = and i64 %20, 255
  %cmp56 = icmp eq i64 %and55, 13
  br i1 %cmp56, label %lor.lhs.false58, label %for.inc

lor.lhs.false58:                                  ; preds = %if.then52
  %sv_any59 = bitcast %struct.sv* %18 to %struct.xpvgv**
  %21 = load %struct.xpvgv** %sv_any59, align 8, !tbaa !7
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %21, i64 0, i32 11
  %22 = load i8* %xgv_flags, align 1, !tbaa !46
  %and61 = and i8 %22, 2
  %tobool62 = icmp eq i8 %and61, 0
  br i1 %tobool62, label %if.end64, label %for.inc

if.end64:                                         ; preds = %lor.lhs.false58
  %xgv_gp66 = getelementptr inbounds %struct.xpvgv* %21, i64 0, i32 7
  %23 = load %struct.gp** %xgv_gp66, align 8, !tbaa !9
  %gp_file = getelementptr inbounds %struct.gp* %23, i64 0, i32 11
  %24 = load i8** %gp_file, align 8, !tbaa !40
  %tobool67 = icmp eq i8* %24, null
  br i1 %tobool67, label %if.end78, label %land.lhs.true68

land.lhs.true68:                                  ; preds = %if.end64
  %25 = load i8* %24, align 1, !tbaa !26
  %cmp70 = icmp eq i8 %25, 47
  br i1 %cmp70, label %land.lhs.true72, label %if.end78

land.lhs.true72:                                  ; preds = %land.lhs.true68
  %call = tail call i8* @Perl_instr(i8* %24, i8* getelementptr inbounds ([6 x i8]* @.str60, i64 0, i64 0)) #2
  %tobool73 = icmp eq i8* %call, null
  br i1 %tobool73, label %lor.lhs.false74, label %for.inc

lor.lhs.false74:                                  ; preds = %land.lhs.true72
  %call75 = tail call i8* @Perl_instr(i8* %24, i8* getelementptr inbounds ([4 x i8]* @.str61, i64 0, i64 0)) #2
  %tobool76 = icmp eq i8* %call75, null
  br i1 %tobool76, label %lor.lhs.false74.if.end78_crit_edge, label %for.inc

lor.lhs.false74.if.end78_crit_edge:               ; preds = %lor.lhs.false74
  %.pre126 = load %struct.xpvgv** %sv_any59, align 8, !tbaa !7
  %xgv_gp80.phi.trans.insert = getelementptr inbounds %struct.xpvgv* %.pre126, i64 0, i32 7
  %.pre127 = load %struct.gp** %xgv_gp80.phi.trans.insert, align 8, !tbaa !9
  br label %if.end78

if.end78:                                         ; preds = %lor.lhs.false74.if.end78_crit_edge, %if.end64, %land.lhs.true68
  %26 = phi %struct.gp* [ %.pre127, %lor.lhs.false74.if.end78_crit_edge ], [ %23, %if.end64 ], [ %23, %land.lhs.true68 ]
  %gp_line = getelementptr inbounds %struct.gp* %26, i64 0, i32 10
  %27 = load i64* %gp_line, align 8, !tbaa !37
  %28 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_line = getelementptr inbounds %struct.cop* %28, i64 0, i32 13
  store i64 %27, i64* %cop_line, align 8, !tbaa !34
  %call81 = tail call %struct.gv* @Perl_gv_fetchfile(i8* %24)
  %29 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_filegv = getelementptr inbounds %struct.cop* %29, i64 0, i32 10
  store %struct.gv* %call81, %struct.gv** %cop_filegv, align 8, !tbaa !38
  %30 = load %struct.xpvhv** %sv_any, align 8, !tbaa !20
  %xhv_name = getelementptr inbounds %struct.xpvhv* %30, i64 0, i32 10
  %31 = load i8** %xhv_name, align 8, !tbaa !54
  %32 = load %struct.xpvgv** %sv_any59, align 8, !tbaa !7
  %xgv_name = getelementptr inbounds %struct.xpvgv* %32, i64 0, i32 8
  %33 = load i8** %xgv_name, align 8, !tbaa !44
  tail call void (i64, i8*, ...)* @Perl_warner(i64 14, i8* getelementptr inbounds ([44 x i8]* @.str62, i64 0, i64 0), i8* %31, i8* %33) #2
  br label %for.inc

for.inc:                                          ; preds = %if.else, %if.then19, %lor.lhs.false74, %land.lhs.true72, %lor.lhs.false58, %if.then52, %if.then25, %if.end78
  %hent_next = getelementptr inbounds %struct.he* %entry1.0122, i64 0, i32 0
  %entry1.0 = load %struct.he** %hent_next, align 8
  %tobool6 = icmp eq %struct.he* %entry1.0, null
  br i1 %tobool6, label %for.inc86, label %for.body7

for.inc86:                                        ; preds = %for.inc, %for.body
  %34 = load %struct.xpvhv** %sv_any, align 8, !tbaa !20
  %xhv_max = getelementptr inbounds %struct.xpvhv* %34, i64 0, i32 2
  %35 = load i64* %xhv_max, align 8, !tbaa !78
  %cmp = icmp slt i64 %i.0125, %35
  br i1 %cmp, label %for.inc86.for.body_crit_edge, label %for.end87

for.inc86.for.body_crit_edge:                     ; preds = %for.inc86
  %inc = add nsw i64 %i.0125, 1
  %.phi.trans.insert = bitcast %struct.xpvhv* %34 to %struct.he***
  %.pre = load %struct.he*** %.phi.trans.insert, align 8, !tbaa !19
  br label %for.body

for.end87:                                        ; preds = %for.inc86, %for.cond.preheader, %entry
  ret void
}

declare i8* @Perl_instr(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define %struct.gv* @Perl_newGVgen(i8* %pack) #0 {
entry:
  %0 = load i64* @PL_gensym, align 8, !tbaa !29
  %inc = add nsw i64 %0, 1
  store i64 %inc, i64* @PL_gensym, align 8, !tbaa !29
  %call = tail call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([13 x i8]* @.str63, i64 0, i64 0), i8* %pack, i64 %0) #2
  %call1 = tail call %struct.gv* @Perl_gv_fetchpv(i8* %call, i64 1, i64 13)
  ret %struct.gv* %call1
}

declare i8* @Perl_form(i8*, ...) #1

; Function Attrs: nounwind uwtable
define void @Perl_gp_free(%struct.gv* readonly %gv) #0 {
entry:
  %tobool = icmp eq %struct.gv* %gv, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %sv_any = getelementptr inbounds %struct.gv* %gv, i64 0, i32 0
  %0 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %0, i64 0, i32 7
  %1 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %tobool1 = icmp eq %struct.gp* %1, null
  br i1 %tobool1, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %gp_refcnt = getelementptr inbounds %struct.gp* %1, i64 0, i32 1
  %2 = load i64* %gp_refcnt, align 8, !tbaa !33
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %if.then2, label %if.end15

if.then2:                                         ; preds = %if.end
  %3 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings = getelementptr inbounds %struct.cop* %3, i64 0, i32 14
  %4 = load %struct.sv** %cop_warnings, align 8, !tbaa !63
  %cmp3 = icmp eq %struct.sv* %4, null
  br i1 %cmp3, label %if.then13, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.then2
  %5 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings5 = getelementptr inbounds %struct.cop* %5, i64 0, i32 14
  %6 = load %struct.sv** %cop_warnings5, align 8, !tbaa !63
  %cmp6 = icmp eq %struct.sv* %6, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp6, label %if.then13, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %lor.lhs.false4
  %7 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings8 = getelementptr inbounds %struct.cop* %7, i64 0, i32 14
  %8 = load %struct.sv** %cop_warnings8, align 8, !tbaa !63
  %cmp9 = icmp eq %struct.sv* %8, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp9, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false7
  %9 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !19
  %cop_warnings10 = getelementptr inbounds %struct.cop* %9, i64 0, i32 14
  %10 = load %struct.sv** %cop_warnings10, align 8, !tbaa !63
  %sv_any11 = getelementptr inbounds %struct.sv* %10, i64 0, i32 0
  %11 = load i8** %sv_any11, align 8, !tbaa !39
  %xpv_pv = bitcast i8* %11 to i8**
  %12 = load i8** %xpv_pv, align 8, !tbaa !30
  %arrayidx = getelementptr inbounds i8* %12, i64 6
  %13 = load i8* %arrayidx, align 1, !tbaa !26
  %and = and i8 %13, 1
  %tobool12 = icmp eq i8 %and, 0
  br i1 %tobool12, label %return, label %if.then13

if.then13:                                        ; preds = %land.lhs.true, %lor.lhs.false4, %if.then2
  tail call void (i64, i8*, ...)* @Perl_warner(i64 24, i8* getelementptr inbounds ([43 x i8]* @.str64, i64 0, i64 0)) #2
  br label %return

if.end15:                                         ; preds = %if.end
  %gp_cv = getelementptr inbounds %struct.gp* %1, i64 0, i32 7
  %14 = load %struct.cv** %gp_cv, align 8, !tbaa !47
  %tobool16 = icmp eq %struct.cv* %14, null
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  %15 = load i64* @PL_sub_generation, align 8, !tbaa !29
  %inc = add i64 %15, 1
  store i64 %inc, i64* @PL_sub_generation, align 8, !tbaa !29
  %.pre = load i64* %gp_refcnt, align 8, !tbaa !33
  br label %if.end18

if.end18:                                         ; preds = %if.end15, %if.then17
  %16 = phi i64 [ %2, %if.end15 ], [ %.pre, %if.then17 ]
  %dec = add i64 %16, -1
  store i64 %dec, i64* %gp_refcnt, align 8, !tbaa !33
  %cmp20 = icmp eq i64 %dec, 0
  br i1 %cmp20, label %if.end28, label %if.then22

if.then22:                                        ; preds = %if.end18
  %gp_egv = getelementptr inbounds %struct.gp* %1, i64 0, i32 6
  %17 = load %struct.gv** %gp_egv, align 8, !tbaa !42
  %cmp23 = icmp eq %struct.gv* %17, %gv
  br i1 %cmp23, label %if.then25, label %return

if.then25:                                        ; preds = %if.then22
  store %struct.gv* null, %struct.gv** %gp_egv, align 8, !tbaa !42
  br label %return

if.end28:                                         ; preds = %if.end18
  %gp_sv = getelementptr inbounds %struct.gp* %1, i64 0, i32 0
  %18 = load %struct.sv** %gp_sv, align 8, !tbaa !28
  %tobool29 = icmp eq %struct.sv* %18, null
  br i1 %tobool29, label %if.end32, label %if.then30

if.then30:                                        ; preds = %if.end28
  tail call void @Perl_sv_free(%struct.sv* %18) #2
  br label %if.end32

if.end32:                                         ; preds = %if.end28, %if.then30
  %gp_av = getelementptr inbounds %struct.gp* %1, i64 0, i32 4
  %19 = load %struct.av** %gp_av, align 8, !tbaa !12
  %tobool33 = icmp eq %struct.av* %19, null
  br i1 %tobool33, label %if.end36, label %if.then34

if.then34:                                        ; preds = %if.end32
  %20 = bitcast %struct.av* %19 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %20) #2
  br label %if.end36

if.end36:                                         ; preds = %if.end32, %if.then34
  %gp_hv = getelementptr inbounds %struct.gp* %1, i64 0, i32 5
  %21 = load %struct.hv** %gp_hv, align 8, !tbaa !14
  %tobool37 = icmp eq %struct.hv* %21, null
  br i1 %tobool37, label %if.end54, label %if.then38

if.then38:                                        ; preds = %if.end36
  %22 = load %struct.hv** @PL_stashcache, align 8, !tbaa !19
  %tobool39 = icmp eq %struct.hv* %22, null
  br i1 %tobool39, label %if.end52, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %if.then38
  %sv_any42 = getelementptr inbounds %struct.hv* %21, i64 0, i32 0
  %23 = load %struct.xpvhv** %sv_any42, align 8, !tbaa !20
  %xhv_name = getelementptr inbounds %struct.xpvhv* %23, i64 0, i32 10
  %24 = load i8** %xhv_name, align 8, !tbaa !54
  %tobool43 = icmp eq i8* %24, null
  br i1 %tobool43, label %if.end52, label %if.then44

if.then44:                                        ; preds = %land.lhs.true40
  %call = tail call i64 @strlen(i8* %24) #2
  %call51 = tail call %struct.sv* @Perl_hv_delete(%struct.hv* %22, i8* %24, i64 %call, i64 2) #2
  %.pre93 = load %struct.hv** %gp_hv, align 8, !tbaa !14
  br label %if.end52

if.end52:                                         ; preds = %land.lhs.true40, %if.then38, %if.then44
  %25 = phi %struct.hv* [ %21, %land.lhs.true40 ], [ %21, %if.then38 ], [ %.pre93, %if.then44 ]
  %26 = bitcast %struct.hv* %25 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %26) #2
  br label %if.end54

if.end54:                                         ; preds = %if.end36, %if.end52
  %gp_io = getelementptr inbounds %struct.gp* %1, i64 0, i32 2
  %27 = load %struct.io** %gp_io, align 8, !tbaa !15
  %tobool55 = icmp eq %struct.io* %27, null
  br i1 %tobool55, label %if.end58, label %if.then56

if.then56:                                        ; preds = %if.end54
  %28 = bitcast %struct.io* %27 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %28) #2
  br label %if.end58

if.end58:                                         ; preds = %if.end54, %if.then56
  %29 = load %struct.cv** %gp_cv, align 8, !tbaa !47
  %tobool60 = icmp eq %struct.cv* %29, null
  br i1 %tobool60, label %if.end63, label %if.then61

if.then61:                                        ; preds = %if.end58
  %30 = bitcast %struct.cv* %29 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %30) #2
  br label %if.end63

if.end63:                                         ; preds = %if.end58, %if.then61
  %gp_form = getelementptr inbounds %struct.gp* %1, i64 0, i32 3
  %31 = load %struct.cv** %gp_form, align 8, !tbaa !84
  %tobool64 = icmp eq %struct.cv* %31, null
  br i1 %tobool64, label %if.end67, label %if.then65

if.then65:                                        ; preds = %if.end63
  %32 = bitcast %struct.cv* %31 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %32) #2
  br label %if.end67

if.end67:                                         ; preds = %if.end63, %if.then65
  %33 = bitcast %struct.gp* %1 to i8*
  tail call void @Perl_safesysfree(i8* %33) #2
  %34 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp69 = getelementptr inbounds %struct.xpvgv* %34, i64 0, i32 7
  store %struct.gp* null, %struct.gp** %xgv_gp69, align 8, !tbaa !9
  br label %return

return:                                           ; preds = %land.lhs.true, %lor.lhs.false7, %lor.lhs.false, %entry, %if.then22, %if.then25, %if.then13, %if.end67
  ret void
}

declare %struct.sv* @Perl_hv_delete(%struct.hv*, i8*, i64, i64) #1

; Function Attrs: nounwind uwtable
define i32 @Perl_magic_freeovrld(%struct.sv* nocapture readnone %sv, %struct.magic* nocapture readonly %mg) #0 {
entry:
  %mg_ptr = getelementptr inbounds %struct.magic* %mg, i64 0, i32 6
  %0 = load i8** %mg_ptr, align 8, !tbaa !85
  %tobool = icmp eq i8* %0, null
  br i1 %tobool, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %flags = getelementptr inbounds i8* %0, i64 16
  %1 = bitcast i8* %flags to i64*
  %2 = load i64* %1, align 8, !tbaa !87
  %and = and i64 %2, 1
  %tobool1 = icmp eq i64 %and, 0
  br i1 %tobool1, label %if.end7, label %for.cond.preheader

for.cond.preheader:                               ; preds = %land.lhs.true
  %table = getelementptr inbounds i8* %0, i64 24
  %3 = bitcast i8* %table to [66 x %struct.cv*]*
  br label %for.body

for.body:                                         ; preds = %for.inc, %for.cond.preheader
  %indvars.iv = phi i64 [ 1, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr inbounds [66 x %struct.cv*]* %3, i64 0, i64 %indvars.iv
  %4 = load %struct.cv** %arrayidx, align 8, !tbaa !19
  %cmp2 = icmp eq %struct.cv* %4, null
  br i1 %cmp2, label %for.inc, label %if.then3

if.then3:                                         ; preds = %for.body
  %5 = bitcast %struct.cv* %4 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %5) #2
  store %struct.cv* null, %struct.cv** %arrayidx, align 8, !tbaa !19
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then3
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 66
  br i1 %exitcond, label %if.end7, label %for.body

if.end7:                                          ; preds = %for.inc, %land.lhs.true, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define signext i8 @Perl_Gv_AMupdate(%struct.hv* %stash) #0 {
entry:
  %amt = alloca %struct.am_table, align 8
  %0 = bitcast %struct.hv* %stash to %struct.sv*
  %call = call %struct.magic* @Perl_mg_find(%struct.sv* %0, i32 99) #2
  %tobool = icmp eq %struct.magic* %call, null
  br i1 %tobool, label %cond.end, label %land.lhs.true

cond.end:                                         ; preds = %entry
  %1 = bitcast %struct.am_table* %amt to i8*
  call void @llvm.lifetime.start(i64 560, i8* %1) #2
  br label %if.end

land.lhs.true:                                    ; preds = %entry
  %mg_ptr = getelementptr inbounds %struct.magic* %call, i64 0, i32 6
  %2 = load i8** %mg_ptr, align 8, !tbaa !85
  %3 = bitcast %struct.am_table* %amt to i8*
  call void @llvm.lifetime.start(i64 560, i8* %3) #2
  %was_ok_am = getelementptr inbounds i8* %2, i64 8
  %4 = bitcast i8* %was_ok_am to i64*
  %5 = load i64* %4, align 8, !tbaa !89
  %6 = load i64* @PL_amagic_generation, align 8, !tbaa !29
  %cmp = icmp eq i64 %5, %6
  br i1 %cmp, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %was_ok_sub = bitcast i8* %2 to i64*
  %7 = load i64* %was_ok_sub, align 8, !tbaa !90
  %8 = load i64* @PL_sub_generation, align 8, !tbaa !29
  %cmp3 = icmp eq i64 %7, %8
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true2
  %flags = getelementptr inbounds i8* %2, i64 16
  %9 = bitcast i8* %flags to i64*
  %10 = load i64* %9, align 8, !tbaa !87
  %.tr = trunc i64 %10 to i8
  %conv = and i8 %.tr, 2
  br label %cleanup

if.end:                                           ; preds = %cond.end, %land.lhs.true2, %land.lhs.true
  %11 = phi i8* [ %3, %land.lhs.true2 ], [ %3, %land.lhs.true ], [ %1, %cond.end ]
  %call4 = call i32 @Perl_sv_unmagic(%struct.sv* %0, i32 99) #2
  call void @llvm.memset.p0i8.i64(i8* %11, i8 0, i64 560, i32 8, i1 false)
  %12 = load i64* @PL_amagic_generation, align 8, !tbaa !29
  %was_ok_am5 = getelementptr inbounds %struct.am_table* %amt, i64 0, i32 1
  store i64 %12, i64* %was_ok_am5, align 8, !tbaa !89
  %13 = load i64* @PL_sub_generation, align 8, !tbaa !29
  %was_ok_sub6 = getelementptr inbounds %struct.am_table* %amt, i64 0, i32 0
  store i64 %13, i64* %was_ok_sub6, align 8, !tbaa !90
  %fallback = getelementptr inbounds %struct.am_table* %amt, i64 0, i32 4
  store i64 2, i64* %fallback, align 8, !tbaa !91
  %flags7 = getelementptr inbounds %struct.am_table* %amt, i64 0, i32 2
  store i64 0, i64* %flags7, align 8, !tbaa !87
  %14 = load i8** getelementptr inbounds ([66 x i8*]* @PL_AMG_names, i64 0, i64 0), align 8, !tbaa !19
  %call8 = call %struct.gv* @Perl_gv_fetchmeth(%struct.hv* %stash, i8* %14, i64 2, i64 -1)
  %tobool9 = icmp eq %struct.gv* %call8, null
  br i1 %tobool9, label %for.cond66.preheader, label %if.else

if.else:                                          ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.gv* %call8, i64 0, i32 0
  %15 = load %struct.xpvgv** %sv_any, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %15, i64 0, i32 7
  %16 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_sv = getelementptr inbounds %struct.gp* %16, i64 0, i32 0
  %17 = load %struct.sv** %gp_sv, align 8, !tbaa !28
  %tobool14 = icmp eq %struct.sv* %17, null
  %sv_flags56.pre = getelementptr inbounds %struct.sv* %17, i64 0, i32 2
  br i1 %tobool14, label %if.else55, label %cond.false16

cond.false16:                                     ; preds = %if.else
  %18 = load i64* %sv_flags56.pre, align 8, !tbaa !1
  %and17 = and i64 %18, 262144
  %tobool18 = icmp eq i64 %and17, 0
  br i1 %tobool18, label %cond.false33, label %cond.true19

cond.true19:                                      ; preds = %cond.false16
  %sv_any20 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %19 = load i8** %sv_any20, align 8, !tbaa !39
  %20 = bitcast i8* %19 to %struct.xpv*
  store %struct.xpv* %20, %struct.xpv** @PL_Xpv, align 8, !tbaa !19
  %tobool21 = icmp eq i8* %19, null
  br i1 %tobool21, label %if.else55, label %land.lhs.true22

land.lhs.true22:                                  ; preds = %cond.true19
  %xpv_cur = getelementptr inbounds i8* %19, i64 8
  %21 = bitcast i8* %xpv_cur to i64*
  %22 = load i64* %21, align 8, !tbaa !62
  %cmp23 = icmp ugt i64 %22, 1
  br i1 %cmp23, label %if.then53, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true22
  %tobool26 = icmp eq i64 %22, 0
  br i1 %tobool26, label %if.else55, label %land.lhs.true27

land.lhs.true27:                                  ; preds = %lor.lhs.false
  %xpv_pv = bitcast i8* %19 to i8**
  %23 = load i8** %xpv_pv, align 8, !tbaa !30
  %24 = load i8* %23, align 1, !tbaa !26
  %cmp29 = icmp eq i8 %24, 48
  br i1 %cmp29, label %if.else55, label %if.then53

cond.false33:                                     ; preds = %cond.false16
  %and35 = and i64 %18, 65536
  %tobool36 = icmp eq i64 %and35, 0
  br i1 %tobool36, label %cond.false41, label %cond.true37

cond.true37:                                      ; preds = %cond.false33
  %sv_any38 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %25 = load i8** %sv_any38, align 8, !tbaa !39
  %xiv_iv = getelementptr inbounds i8* %25, i64 24
  %26 = bitcast i8* %xiv_iv to i64*
  %27 = load i64* %26, align 8, !tbaa !92
  %cmp39 = icmp eq i64 %27, 0
  br i1 %cmp39, label %if.else55, label %if.then53

cond.false41:                                     ; preds = %cond.false33
  %and43 = and i64 %18, 131072
  %tobool44 = icmp eq i64 %and43, 0
  br i1 %tobool44, label %cond.false49, label %cond.true45

cond.true45:                                      ; preds = %cond.false41
  %sv_any46 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %28 = load i8** %sv_any46, align 8, !tbaa !39
  %xnv_nv = getelementptr inbounds i8* %28, i64 32
  %29 = bitcast i8* %xnv_nv to double*
  %30 = load double* %29, align 8, !tbaa !76
  %cmp47 = fcmp une double %30, 0.000000e+00
  br i1 %cmp47, label %if.then53, label %if.else55

cond.false49:                                     ; preds = %cond.false41
  %call50 = call signext i8 @Perl_sv_2bool(%struct.sv* %17) #2
  %tobool52 = icmp eq i8 %call50, 0
  br i1 %tobool52, label %if.else55, label %if.then53

if.then53:                                        ; preds = %land.lhs.true27, %cond.true37, %cond.false49, %land.lhs.true22, %cond.true45
  store i64 3, i64* %fallback, align 8, !tbaa !91
  br label %for.body69

if.else55:                                        ; preds = %if.else, %land.lhs.true27, %lor.lhs.false, %cond.true19, %cond.true37, %cond.false49, %cond.true45
  %31 = load i64* %sv_flags56.pre, align 8, !tbaa !1
  %and57 = and i64 %31, 118423552
  %tobool58 = icmp eq i64 %and57, 0
  br i1 %tobool58, label %for.body69, label %if.then59

if.then59:                                        ; preds = %if.else55
  store i64 1, i64* %fallback, align 8, !tbaa !91
  br label %for.body69

for.cond66.preheader:                             ; preds = %if.end
  %scevgep = getelementptr %struct.am_table* %amt, i64 0, i32 3, i64 1
  %scevgep243 = bitcast %struct.cv** %scevgep to i8*
  call void @llvm.memset.p0i8.i64(i8* %scevgep243, i8 0, i64 512, i32 8, i1 false)
  br label %for.body69

for.body69:                                       ; preds = %if.else55, %if.then59, %if.then53, %for.cond66.preheader, %land.end
  %indvars.iv = phi i64 [ %indvars.iv.next, %land.end ], [ 65, %for.cond66.preheader ], [ 1, %if.else55 ], [ 1, %if.then59 ], [ 1, %if.then53 ]
  %filled.0233 = phi i32 [ %filled.1227, %land.end ], [ 0, %for.cond66.preheader ], [ 0, %if.then53 ], [ 0, %if.then59 ], [ 0, %if.else55 ]
  %have_ovl.0231 = phi i32 [ %have_ovl.1226, %land.end ], [ 0, %for.cond66.preheader ], [ 0, %if.then53 ], [ 0, %if.then59 ], [ 0, %if.else55 ]
  %arrayidx71 = getelementptr inbounds [66 x i8*]* @PL_AMG_names, i64 0, i64 %indvars.iv
  %32 = load i8** %arrayidx71, align 8, !tbaa !19
  %33 = trunc i64 %indvars.iv to i32
  %cmp72 = icmp sgt i32 %33, 64
  %call80 = call i64 @strlen(i8* %32) #2
  br i1 %cmp72, label %if.then83, label %if.else85

if.then83:                                        ; preds = %for.body69
  %call84 = call %struct.gv* @Perl_gv_fetchmeth_autoload(%struct.hv* %stash, i8* %32, i64 %call80, i64 0)
  br label %if.end87

if.else85:                                        ; preds = %for.body69
  %call86 = call %struct.gv* @Perl_gv_fetchmeth(%struct.hv* %stash, i8* %32, i64 %call80, i64 -1)
  br label %if.end87

if.end87:                                         ; preds = %if.else85, %if.then83
  %gv.0 = phi %struct.gv* [ %call84, %if.then83 ], [ %call86, %if.else85 ]
  %tobool88 = icmp eq %struct.gv* %gv.0, null
  br i1 %tobool88, label %if.end158.thread, label %land.lhs.true89

if.end158.thread:                                 ; preds = %if.end87
  store %struct.sv* null, %struct.sv** @PL_Sv, align 8, !tbaa !19
  br label %land.end

land.lhs.true89:                                  ; preds = %if.end87
  %sv_any90 = getelementptr inbounds %struct.gv* %gv.0, i64 0, i32 0
  %34 = load %struct.xpvgv** %sv_any90, align 8, !tbaa !7
  %xgv_gp91 = getelementptr inbounds %struct.xpvgv* %34, i64 0, i32 7
  %35 = load %struct.gp** %xgv_gp91, align 8, !tbaa !9
  %gp_cv = getelementptr inbounds %struct.gp* %35, i64 0, i32 7
  %36 = load %struct.cv** %gp_cv, align 8, !tbaa !47
  %tobool92 = icmp eq %struct.cv* %36, null
  br i1 %tobool92, label %if.then156, label %if.then93

if.then93:                                        ; preds = %land.lhs.true89
  %sv_any94 = getelementptr inbounds %struct.cv* %36, i64 0, i32 0
  %37 = load %struct.xpvcv** %sv_any94, align 8, !tbaa !48
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %37, i64 0, i32 12
  %38 = load %struct.gv** %xcv_gv, align 8, !tbaa !50
  %sv_any95 = getelementptr inbounds %struct.gv* %38, i64 0, i32 0
  %39 = load %struct.xpvgv** %sv_any95, align 8, !tbaa !7
  %xgv_namelen = getelementptr inbounds %struct.xpvgv* %39, i64 0, i32 9
  %40 = load i64* %xgv_namelen, align 8, !tbaa !45
  %cmp96 = icmp eq i64 %40, 3
  br i1 %cmp96, label %land.lhs.true98, label %if.end149

land.lhs.true98:                                  ; preds = %if.then93
  %xgv_name = getelementptr inbounds %struct.xpvgv* %39, i64 0, i32 8
  %41 = load i8** %xgv_name, align 8, !tbaa !44
  %call102 = call i32 @strcmp(i8* %41, i8* getelementptr inbounds ([4 x i8]* @.str65, i64 0, i64 0)) #2
  %tobool103 = icmp eq i32 %call102, 0
  br i1 %tobool103, label %land.lhs.true104, label %if.end149

land.lhs.true104:                                 ; preds = %land.lhs.true98
  %xgv_stash = getelementptr inbounds %struct.xpvgv* %39, i64 0, i32 10
  %42 = load %struct.hv** %xgv_stash, align 8, !tbaa !43
  %sv_any108 = getelementptr inbounds %struct.hv* %42, i64 0, i32 0
  %43 = load %struct.xpvhv** %sv_any108, align 8, !tbaa !20
  %xhv_name = getelementptr inbounds %struct.xpvhv* %43, i64 0, i32 10
  %44 = load i8** %xhv_name, align 8, !tbaa !54
  %call109 = call i32 @strcmp(i8* %44, i8* getelementptr inbounds ([9 x i8]* @.str66, i64 0, i64 0)) #2
  %tobool110 = icmp eq i32 %call109, 0
  br i1 %tobool110, label %if.then111, label %if.end149

if.then111:                                       ; preds = %land.lhs.true104
  %gp_sv114 = getelementptr inbounds %struct.gp* %35, i64 0, i32 0
  %45 = load %struct.sv** %gp_sv114, align 8, !tbaa !28
  %sv_flags115 = getelementptr inbounds %struct.sv* %45, i64 0, i32 2
  %46 = load i64* %sv_flags115, align 8, !tbaa !1
  %and116 = and i64 %46, 262144
  %tobool117 = icmp eq i64 %and116, 0
  br i1 %tobool117, label %if.then126, label %lor.lhs.false118

lor.lhs.false118:                                 ; preds = %if.then111
  %sv_any122 = getelementptr inbounds %struct.sv* %45, i64 0, i32 0
  %47 = load i8** %sv_any122, align 8, !tbaa !39
  %xpv_pv123 = bitcast i8* %47 to i8**
  %48 = load i8** %xpv_pv123, align 8, !tbaa !30
  %call124 = call %struct.gv* @Perl_gv_fetchmethod_autoload(%struct.hv* %stash, i8* %48, i64 0)
  %tobool125 = icmp eq %struct.gv* %call124, null
  br i1 %tobool125, label %lor.lhs.false118.if.then126_crit_edge, label %if.end145

lor.lhs.false118.if.then126_crit_edge:            ; preds = %lor.lhs.false118
  %.pre = load %struct.xpvgv** %sv_any90, align 8, !tbaa !7
  %xgv_gp128.phi.trans.insert = getelementptr inbounds %struct.xpvgv* %.pre, i64 0, i32 7
  %.pre245 = load %struct.gp** %xgv_gp128.phi.trans.insert, align 8, !tbaa !9
  %gp_sv129.phi.trans.insert = getelementptr inbounds %struct.gp* %.pre245, i64 0, i32 0
  %.pre246 = load %struct.sv** %gp_sv129.phi.trans.insert, align 8, !tbaa !28
  %sv_flags130.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre246, i64 0, i32 2
  %.pre247 = load i64* %sv_flags130.phi.trans.insert, align 8, !tbaa !1
  br label %if.then126

if.then126:                                       ; preds = %if.then111, %lor.lhs.false118.if.then126_crit_edge
  %49 = phi i64 [ %.pre247, %lor.lhs.false118.if.then126_crit_edge ], [ %46, %if.then111 ]
  %50 = phi %struct.sv* [ %.pre246, %lor.lhs.false118.if.then126_crit_edge ], [ %45, %if.then111 ]
  %51 = phi %struct.gp* [ %.pre245, %lor.lhs.false118.if.then126_crit_edge ], [ %35, %if.then111 ]
  %add.ptr.le = getelementptr inbounds i8* %32, i64 1
  %cond79.le = select i1 %cmp72, i8* %32, i8* %add.ptr.le
  %and131 = and i64 %49, 262144
  %tobool132 = icmp eq i64 %and131, 0
  br i1 %tobool132, label %cond.end137, label %cond.true133

cond.true133:                                     ; preds = %if.then126
  %sv_any134 = getelementptr inbounds %struct.sv* %50, i64 0, i32 0
  %52 = load i8** %sv_any134, align 8, !tbaa !39
  %xpv_pv135 = bitcast i8* %52 to i8**
  %53 = load i8** %xpv_pv135, align 8, !tbaa !30
  br label %cond.end137

cond.end137:                                      ; preds = %if.then126, %cond.true133
  %cond138 = phi i8* [ %53, %cond.true133 ], [ getelementptr inbounds ([4 x i8]* @.str67, i64 0, i64 0), %if.then126 ]
  %gp_cvgen = getelementptr inbounds %struct.gp* %51, i64 0, i32 8
  %54 = load i64* %gp_cvgen, align 8, !tbaa !41
  %tobool141 = icmp ne i64 %54, 0
  %cond142 = select i1 %tobool141, i8* getelementptr inbounds ([27 x i8]* @.str69, i64 0, i64 0), i8* getelementptr inbounds ([14 x i8]* @.str70, i64 0, i64 0)
  %sv_any143 = getelementptr inbounds %struct.hv* %stash, i64 0, i32 0
  %55 = load %struct.xpvhv** %sv_any143, align 8, !tbaa !20
  %xhv_name144 = getelementptr inbounds %struct.xpvhv* %55, i64 0, i32 10
  %56 = load i8** %xhv_name144, align 8, !tbaa !54
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([56 x i8]* @.str68, i64 0, i64 0), i8* %cond142, i8* %cond138, i8* %cond79.le, i8* %56) #2
  unreachable

if.end145:                                        ; preds = %lor.lhs.false118
  %sv_any146 = getelementptr inbounds %struct.gv* %call124, i64 0, i32 0
  %57 = load %struct.xpvgv** %sv_any146, align 8, !tbaa !7
  %xgv_gp147 = getelementptr inbounds %struct.xpvgv* %57, i64 0, i32 7
  %58 = load %struct.gp** %xgv_gp147, align 8, !tbaa !9
  %gp_cv148 = getelementptr inbounds %struct.gp* %58, i64 0, i32 7
  %59 = load %struct.cv** %gp_cv148, align 8, !tbaa !47
  br label %if.end149

if.end149:                                        ; preds = %land.lhs.true104, %land.lhs.true98, %if.end145, %if.then93
  %cv.0 = phi %struct.cv* [ %36, %land.lhs.true98 ], [ %36, %land.lhs.true104 ], [ %59, %if.end145 ], [ %36, %if.then93 ]
  %cmp150 = icmp slt i32 %33, 65
  %.have_ovl.0 = select i1 %cmp150, i32 1, i32 %have_ovl.0231
  br label %if.end158

if.then156:                                       ; preds = %land.lhs.true89
  %60 = bitcast %struct.gv* %gv.0 to %struct.cv*
  br label %if.end158

if.end158:                                        ; preds = %if.end149, %if.then156
  %have_ovl.1 = phi i32 [ %have_ovl.0231, %if.then156 ], [ %.have_ovl.0, %if.end149 ]
  %cv.2 = phi %struct.cv* [ %60, %if.then156 ], [ %cv.0, %if.end149 ]
  %61 = bitcast %struct.cv* %cv.2 to %struct.sv*
  store %struct.sv* %61, %struct.sv** @PL_Sv, align 8, !tbaa !19
  %tobool159 = icmp eq %struct.cv* %cv.2, null
  br i1 %tobool159, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end158
  %62 = getelementptr inbounds %struct.cv* %cv.2, i64 0, i32 1
  %63 = load i64* %62, align 8, !tbaa !22
  %inc160 = add i64 %63, 1
  store i64 %inc160, i64* %62, align 8, !tbaa !22
  br label %land.end

land.end:                                         ; preds = %if.end158.thread, %if.end158, %land.rhs
  %64 = phi %struct.sv* [ null, %if.end158.thread ], [ %61, %if.end158 ], [ %61, %land.rhs ]
  %filled.1227 = phi i32 [ %filled.0233, %if.end158.thread ], [ 1, %if.end158 ], [ 1, %land.rhs ]
  %have_ovl.1226 = phi i32 [ %have_ovl.0231, %if.end158.thread ], [ %have_ovl.1, %if.end158 ], [ %have_ovl.1, %land.rhs ]
  %65 = bitcast %struct.sv* %64 to %struct.cv*
  %arrayidx164 = getelementptr inbounds %struct.am_table* %amt, i64 0, i32 3, i64 %indvars.iv
  store %struct.cv* %65, %struct.cv** %arrayidx164, align 8, !tbaa !19
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %66 = trunc i64 %indvars.iv.next to i32
  %cmp67 = icmp slt i32 %66, 66
  br i1 %cmp67, label %for.body69, label %for.end167

for.end167:                                       ; preds = %land.end
  %tobool168 = icmp eq i32 %filled.1227, 0
  %67 = load i64* %flags7, align 8, !tbaa !87
  br i1 %tobool168, label %if.end177, label %if.then169

if.then169:                                       ; preds = %for.end167
  %tobool171 = icmp eq i32 %have_ovl.1226, 0
  %or.or174.v = select i1 %tobool171, i64 1, i64 3
  %or.or174 = or i64 %67, %or.or174.v
  store i64 %or.or174, i64* %flags7, align 8, !tbaa !87
  call void @Perl_sv_magic(%struct.sv* %0, %struct.sv* null, i32 99, i8* %11, i64 560) #2
  %conv176 = trunc i32 %have_ovl.1226 to i8
  br label %cleanup

if.end177:                                        ; preds = %for.end167
  %and179 = and i64 %67, -2
  store i64 %and179, i64* %flags7, align 8, !tbaa !87
  call void @Perl_sv_magic(%struct.sv* %0, %struct.sv* null, i32 99, i8* %11, i64 24) #2
  br label %cleanup

cleanup:                                          ; preds = %if.end177, %if.then169, %if.then
  %68 = phi i8* [ %3, %if.then ], [ %11, %if.then169 ], [ %11, %if.end177 ]
  %retval.0 = phi i8 [ %conv, %if.then ], [ %conv176, %if.then169 ], [ 0, %if.end177 ]
  call void @llvm.lifetime.end(i64 560, i8* %68) #2
  ret i8 %retval.0
}

declare %struct.magic* @Perl_mg_find(%struct.sv*, i32) #1

declare i32 @Perl_sv_unmagic(%struct.sv*, i32) #1

declare signext i8 @Perl_sv_2bool(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.cv* @Perl_gv_handler(%struct.hv* %stash, i64 %id) #0 {
entry:
  %tobool = icmp eq %struct.hv* %stash, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %sv_any = getelementptr inbounds %struct.hv* %stash, i64 0, i32 0
  %0 = load %struct.xpvhv** %sv_any, align 8, !tbaa !20
  %xhv_name = getelementptr inbounds %struct.xpvhv* %0, i64 0, i32 10
  %1 = load i8** %xhv_name, align 8, !tbaa !54
  %tobool1 = icmp eq i8* %1, null
  br i1 %tobool1, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %2 = bitcast %struct.hv* %stash to %struct.sv*
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %2, i32 99) #2
  %tobool2 = icmp eq %struct.magic* %call, null
  br i1 %tobool2, label %do_update, label %if.end6

do_update:                                        ; preds = %lor.lhs.false7, %if.end6, %if.end
  %call4 = tail call signext i8 @Perl_Gv_AMupdate(%struct.hv* %stash)
  %call5 = tail call %struct.magic* @Perl_mg_find(%struct.sv* %2, i32 99) #2
  br label %if.end6

if.end6:                                          ; preds = %if.end, %do_update
  %mg.0 = phi %struct.magic* [ %call, %if.end ], [ %call5, %do_update ]
  %mg_ptr = getelementptr inbounds %struct.magic* %mg.0, i64 0, i32 6
  %3 = load i8** %mg_ptr, align 8, !tbaa !85
  %was_ok_am = getelementptr inbounds i8* %3, i64 8
  %4 = bitcast i8* %was_ok_am to i64*
  %5 = load i64* %4, align 8, !tbaa !89
  %6 = load i64* @PL_amagic_generation, align 8, !tbaa !29
  %cmp = icmp eq i64 %5, %6
  br i1 %cmp, label %lor.lhs.false7, label %do_update

lor.lhs.false7:                                   ; preds = %if.end6
  %was_ok_sub = bitcast i8* %3 to i64*
  %7 = load i64* %was_ok_sub, align 8, !tbaa !90
  %8 = load i64* @PL_sub_generation, align 8, !tbaa !29
  %cmp8 = icmp eq i64 %7, %8
  br i1 %cmp8, label %if.end10, label %do_update

if.end10:                                         ; preds = %lor.lhs.false7
  %flags = getelementptr inbounds i8* %3, i64 16
  %9 = bitcast i8* %flags to i64*
  %10 = load i64* %9, align 8, !tbaa !87
  %and = and i64 %10, 1
  %tobool11 = icmp eq i64 %and, 0
  br i1 %tobool11, label %return, label %if.then12

if.then12:                                        ; preds = %if.end10
  %table = getelementptr inbounds i8* %3, i64 24
  %11 = bitcast i8* %table to [66 x %struct.cv*]*
  %arrayidx = getelementptr inbounds [66 x %struct.cv*]* %11, i64 0, i64 %id
  %12 = load %struct.cv** %arrayidx, align 8, !tbaa !19
  %tobool13 = icmp eq %struct.cv* %12, null
  br i1 %tobool13, label %if.end28, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then12
  %sv_flags = getelementptr inbounds %struct.cv* %12, i64 0, i32 2
  %13 = load i64* %sv_flags, align 8, !tbaa !94
  %and14 = and i64 %13, 255
  %cmp15 = icmp eq i64 %and14, 13
  br i1 %cmp15, label %if.then16, label %if.end28

if.then16:                                        ; preds = %land.lhs.true
  %arrayidx17 = getelementptr inbounds [66 x i8*]* @PL_AMG_names, i64 0, i64 %id
  %14 = load i8** %arrayidx17, align 8, !tbaa !19
  %call.i = tail call %struct.gv* @Perl_gv_fetchmethod_autoload(%struct.hv* %stash, i8* %14, i64 1) #2
  %tobool19 = icmp eq %struct.gv* %call.i, null
  br i1 %tobool19, label %if.end28, label %land.lhs.true20

land.lhs.true20:                                  ; preds = %if.then16
  %sv_any21 = getelementptr inbounds %struct.gv* %call.i, i64 0, i32 0
  %15 = load %struct.xpvgv** %sv_any21, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %15, i64 0, i32 7
  %16 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_cv = getelementptr inbounds %struct.gp* %16, i64 0, i32 7
  %17 = load %struct.cv** %gp_cv, align 8, !tbaa !47
  %tobool22 = icmp eq %struct.cv* %17, null
  br i1 %tobool22, label %if.end28, label %return

if.end28:                                         ; preds = %land.lhs.true20, %if.then16, %if.then12, %land.lhs.true
  br label %return

return:                                           ; preds = %if.end10, %land.lhs.true20, %entry, %lor.lhs.false, %if.end28
  %retval.0 = phi %struct.cv* [ %12, %if.end28 ], [ null, %lor.lhs.false ], [ null, %entry ], [ %17, %land.lhs.true20 ], [ null, %if.end10 ]
  ret %struct.cv* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.sv* @Perl_amagic_call(%struct.sv* %left, %struct.sv* %right, i32 %method, i32 %flags) #0 {
entry:
  %myop = alloca %struct.binop, align 8
  %and = and i32 %flags, 4
  %tobool = icmp eq i32 %and, 0
  %and.lobit = lshr exact i32 %and, 2
  %and1 = and i32 %flags, 2
  %tobool2 = icmp eq i32 %and1, 0
  br i1 %tobool2, label %land.lhs.true, label %if.else207

land.lhs.true:                                    ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.sv* %left, i64 0, i32 2
  %0 = load i64* %sv_flags, align 8, !tbaa !1
  %and3 = and i64 %0, 268435456
  %tobool4 = icmp eq i64 %and3, 0
  br i1 %tobool4, label %if.else207, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %land.lhs.true
  %sv_any = getelementptr inbounds %struct.sv* %left, i64 0, i32 0
  %1 = load i8** %sv_any, align 8, !tbaa !39
  %xrv_rv = bitcast i8* %1 to %struct.sv**
  %2 = load %struct.sv** %xrv_rv, align 8, !tbaa !95
  %sv_any6 = getelementptr inbounds %struct.sv* %2, i64 0, i32 0
  %3 = load i8** %sv_any6, align 8, !tbaa !39
  %xmg_stash = getelementptr inbounds i8* %3, i64 48
  %4 = bitcast i8* %xmg_stash to %struct.hv**
  %5 = load %struct.hv** %4, align 8, !tbaa !24
  %tobool7 = icmp eq %struct.hv* %5, null
  br i1 %tobool7, label %if.else207, label %land.lhs.true8

land.lhs.true8:                                   ; preds = %land.lhs.true5
  %6 = bitcast %struct.hv* %5 to %struct.sv*
  %call = call %struct.magic* @Perl_mg_find(%struct.sv* %6, i32 99) #2
  %tobool9 = icmp eq %struct.magic* %call, null
  br i1 %tobool9, label %if.else207, label %land.lhs.true10

land.lhs.true10:                                  ; preds = %land.lhs.true8
  %mg_ptr = getelementptr inbounds %struct.magic* %call, i64 0, i32 6
  %7 = load i8** %mg_ptr, align 8, !tbaa !85
  %8 = bitcast i8* %7 to %struct.am_table*
  %flags11 = getelementptr inbounds i8* %7, i64 16
  %9 = bitcast i8* %flags11 to i64*
  %10 = load i64* %9, align 8, !tbaa !87
  %and12 = and i64 %10, 1
  %tobool13 = icmp eq i64 %and12, 0
  br i1 %tobool13, label %if.else207, label %cond.end

cond.end:                                         ; preds = %land.lhs.true10
  %table = getelementptr inbounds i8* %7, i64 24
  %arraydecay = bitcast i8* %table to %struct.cv**
  %add = add nsw i32 %and.lobit, %method
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds %struct.cv** %arraydecay, i64 %idxprom
  %11 = load %struct.cv** %arrayidx, align 8, !tbaa !19
  %tobool18 = icmp eq %struct.cv* %11, null
  br i1 %tobool18, label %lor.lhs.false, label %if.end370

lor.lhs.false:                                    ; preds = %cond.end
  %fallback27.phi.trans.insert = getelementptr inbounds i8* %7, i64 552
  %.phi.trans.insert = bitcast i8* %fallback27.phi.trans.insert to i64*
  %.pre = load i64* %.phi.trans.insert, align 8, !tbaa !91
  br i1 %tobool, label %land.lhs.true26, label %land.lhs.true20

land.lhs.true20:                                  ; preds = %lor.lhs.false
  %cmp = icmp sgt i64 %.pre, 1
  br i1 %cmp, label %land.lhs.true21, label %if.else207

land.lhs.true21:                                  ; preds = %land.lhs.true20
  %idxprom22 = sext i32 %method to i64
  %arrayidx23 = getelementptr inbounds %struct.cv** %arraydecay, i64 %idxprom22
  %12 = load %struct.cv** %arrayidx23, align 8, !tbaa !19
  %tobool24 = icmp eq %struct.cv* %12, null
  br i1 %tobool24, label %land.lhs.true26, label %if.end370

land.lhs.true26:                                  ; preds = %lor.lhs.false, %land.lhs.true21
  %off.1 = phi i32 [ %method, %land.lhs.true21 ], [ %add, %lor.lhs.false ]
  %cmp28 = icmp slt i64 %.pre, 2
  %and30 = and i32 %flags, 8
  %tobool31 = icmp eq i32 %and30, 0
  %or.cond = or i1 %cmp28, %tobool31
  br i1 %or.cond, label %if.else207, label %if.then32

if.then32:                                        ; preds = %land.lhs.true26
  switch i32 %method, label %not_found [
    i32 44, label %sw.bb
    i32 45, label %sw.bb40
    i32 2, label %sw.bb49
    i32 5, label %sw.bb54
    i32 4, label %sw.bb62
    i32 42, label %sw.bb70
    i32 56, label %sw.bb81
    i32 1, label %sw.bb101
    i32 57, label %sw.bb195
    i32 64, label %return
    i32 63, label %return
    i32 58, label %sw.bb203
    i32 59, label %sw.bb203
    i32 60, label %sw.bb203
    i32 61, label %sw.bb203
    i32 62, label %sw.bb203
  ]

sw.bb:                                            ; preds = %if.then32
  %arrayidx33 = getelementptr inbounds i8* %7, i64 80
  %13 = bitcast i8* %arrayidx33 to %struct.cv**
  %14 = load %struct.cv** %13, align 8, !tbaa !19
  %tobool34 = icmp eq %struct.cv* %14, null
  br i1 %tobool34, label %lor.lhs.false35, label %if.end370

lor.lhs.false35:                                  ; preds = %sw.bb
  %arrayidx36 = getelementptr inbounds i8* %7, i64 72
  %15 = bitcast i8* %arrayidx36 to %struct.cv**
  %16 = load %struct.cv** %15, align 8, !tbaa !19
  %tobool37 = icmp eq %struct.cv* %16, null
  br i1 %tobool37, label %not_found, label %if.end370

sw.bb40:                                          ; preds = %if.then32
  %arrayidx41 = getelementptr inbounds i8* %7, i64 96
  %17 = bitcast i8* %arrayidx41 to %struct.cv**
  %18 = load %struct.cv** %17, align 8, !tbaa !19
  %tobool42 = icmp eq %struct.cv* %18, null
  br i1 %tobool42, label %lor.lhs.false43, label %if.end370

lor.lhs.false43:                                  ; preds = %sw.bb40
  %arrayidx44 = getelementptr inbounds i8* %7, i64 88
  %19 = bitcast i8* %arrayidx44 to %struct.cv**
  %20 = load %struct.cv** %19, align 8, !tbaa !19
  %tobool45 = icmp eq %struct.cv* %20, null
  br i1 %tobool45, label %not_found, label %if.end370

sw.bb49:                                          ; preds = %if.then32
  %arrayidx50 = getelementptr inbounds i8* %7, i64 64
  %21 = bitcast i8* %arrayidx50 to %struct.cv**
  %22 = load %struct.cv** %21, align 8, !tbaa !19
  %tobool51 = icmp eq %struct.cv* %22, null
  br i1 %tobool51, label %lor.rhs, label %if.end370

lor.rhs:                                          ; preds = %sw.bb49
  %arrayidx52 = getelementptr inbounds i8* %7, i64 56
  %23 = bitcast i8* %arrayidx52 to %struct.cv**
  %24 = load %struct.cv** %23, align 8, !tbaa !19
  br label %sw.epilog

sw.bb54:                                          ; preds = %if.then32
  %arrayidx55 = getelementptr inbounds i8* %7, i64 56
  %25 = bitcast i8* %arrayidx55 to %struct.cv**
  %26 = load %struct.cv** %25, align 8, !tbaa !19
  %tobool56 = icmp eq %struct.cv* %26, null
  br i1 %tobool56, label %lor.rhs57, label %if.end370

lor.rhs57:                                        ; preds = %sw.bb54
  %arrayidx58 = getelementptr inbounds i8* %7, i64 40
  %27 = bitcast i8* %arrayidx58 to %struct.cv**
  %28 = load %struct.cv** %27, align 8, !tbaa !19
  br label %sw.epilog

sw.bb62:                                          ; preds = %if.then32
  %arrayidx63 = getelementptr inbounds i8* %7, i64 64
  %29 = bitcast i8* %arrayidx63 to %struct.cv**
  %30 = load %struct.cv** %29, align 8, !tbaa !19
  %tobool64 = icmp eq %struct.cv* %30, null
  br i1 %tobool64, label %lor.rhs65, label %if.end370

lor.rhs65:                                        ; preds = %sw.bb62
  %arrayidx66 = getelementptr inbounds i8* %7, i64 40
  %31 = bitcast i8* %arrayidx66 to %struct.cv**
  %32 = load %struct.cv** %31, align 8, !tbaa !19
  br label %sw.epilog

sw.bb70:                                          ; preds = %if.then32
  %arrayidx71 = getelementptr inbounds i8* %7, i64 40
  %33 = bitcast i8* %arrayidx71 to %struct.cv**
  %34 = load %struct.cv** %33, align 8, !tbaa !19
  %tobool72 = icmp eq %struct.cv* %34, null
  br i1 %tobool72, label %lor.lhs.false73, label %if.end370

lor.lhs.false73:                                  ; preds = %sw.bb70
  %arrayidx74 = getelementptr inbounds i8* %7, i64 64
  %35 = bitcast i8* %arrayidx74 to %struct.cv**
  %36 = load %struct.cv** %35, align 8, !tbaa !19
  %tobool75 = icmp eq %struct.cv* %36, null
  br i1 %tobool75, label %lor.rhs76, label %if.end370

lor.rhs76:                                        ; preds = %lor.lhs.false73
  %arrayidx77 = getelementptr inbounds i8* %7, i64 56
  %37 = bitcast i8* %arrayidx77 to %struct.cv**
  %38 = load %struct.cv** %37, align 8, !tbaa !19
  br label %sw.epilog

sw.bb81:                                          ; preds = %if.then32
  %39 = load i8** %sv_any, align 8, !tbaa !39
  %xrv_rv83 = bitcast i8* %39 to %struct.sv**
  %40 = load %struct.sv** %xrv_rv83, align 8, !tbaa !95
  %sv_flags84 = getelementptr inbounds %struct.sv* %40, i64 0, i32 2
  %41 = load i64* %sv_flags84, align 8, !tbaa !1
  %and85 = and i64 %41, 524288
  %tobool86 = icmp eq i64 %and85, 0
  %and89 = and i64 %41, 248
  %cmp90 = icmp ult i64 %and89, 8
  %or.cond870 = and i1 %tobool86, %cmp90
  br i1 %or.cond870, label %if.then91, label %land.lhs.true290

if.then91:                                        ; preds = %sw.bb81
  %call92 = call %struct.sv* @Perl_newSVsv(%struct.sv* %40) #2
  %sv_flags93 = getelementptr inbounds %struct.sv* %call92, i64 0, i32 2
  %42 = load i64* %sv_flags93, align 8, !tbaa !1
  %or = or i64 %42, 4096
  store i64 %or, i64* %sv_flags93, align 8, !tbaa !1
  %sv_any94 = getelementptr inbounds %struct.sv* %40, i64 0, i32 0
  %43 = load i8** %sv_any94, align 8, !tbaa !39
  %xmg_stash95 = getelementptr inbounds i8* %43, i64 48
  %44 = bitcast i8* %xmg_stash95 to %struct.hv**
  %45 = load %struct.hv** %44, align 8, !tbaa !24
  %46 = bitcast %struct.hv* %45 to %struct.sv*
  store %struct.sv* %46, %struct.sv** @PL_Sv, align 8, !tbaa !19
  %tobool96 = icmp eq %struct.hv* %45, null
  br i1 %tobool96, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.then91
  %47 = getelementptr inbounds %struct.hv* %45, i64 0, i32 1
  %48 = load i64* %47, align 8, !tbaa !22
  %inc = add i64 %48, 1
  store i64 %inc, i64* %47, align 8, !tbaa !22
  br label %land.end

land.end:                                         ; preds = %if.then91, %land.rhs
  %sv_any98 = getelementptr inbounds %struct.sv* %call92, i64 0, i32 0
  %49 = load i8** %sv_any98, align 8, !tbaa !39
  %xmg_stash99 = getelementptr inbounds i8* %49, i64 48
  %50 = bitcast i8* %xmg_stash99 to %struct.hv**
  store %struct.hv* %45, %struct.hv** %50, align 8, !tbaa !24
  br label %return

sw.bb101:                                         ; preds = %if.then32
  %arrayidx102 = getelementptr inbounds i8* %7, i64 248
  %51 = bitcast i8* %arrayidx102 to %struct.cv**
  %52 = load %struct.cv** %51, align 8, !tbaa !19
  %tobool103 = icmp eq %struct.cv* %52, null
  br i1 %tobool103, label %lor.lhs.false104, label %land.lhs.true107

lor.lhs.false104:                                 ; preds = %sw.bb101
  %arrayidx105 = getelementptr inbounds i8* %7, i64 296
  %53 = bitcast i8* %arrayidx105 to %struct.cv**
  %54 = load %struct.cv** %53, align 8, !tbaa !19
  %tobool106 = icmp eq %struct.cv* %54, null
  br i1 %tobool106, label %not_found, label %land.lhs.true107

land.lhs.true107:                                 ; preds = %lor.lhs.false104, %sw.bb101
  %off1.0 = phi i32 [ 28, %sw.bb101 ], [ 34, %lor.lhs.false104 ]
  %arrayidx108 = getelementptr inbounds i8* %7, i64 480
  %55 = bitcast i8* %arrayidx108 to %struct.cv**
  %56 = load %struct.cv** %55, align 8, !tbaa !19
  %tobool109 = icmp eq %struct.cv* %56, null
  br i1 %tobool109, label %lor.lhs.false110, label %if.then113

lor.lhs.false110:                                 ; preds = %land.lhs.true107
  %arrayidx111 = getelementptr inbounds i8* %7, i64 88
  %57 = bitcast i8* %arrayidx111 to %struct.cv**
  %58 = load %struct.cv** %57, align 8, !tbaa !19
  %tobool112 = icmp eq %struct.cv* %58, null
  br i1 %tobool112, label %not_found, label %if.then113

if.then113:                                       ; preds = %lor.lhs.false110, %land.lhs.true107
  %off.8 = phi i32 [ 57, %land.lhs.true107 ], [ 8, %lor.lhs.false110 ]
  %cv.8 = phi %struct.cv* [ %56, %land.lhs.true107 ], [ %58, %lor.lhs.false110 ]
  %call114 = call %struct.sv* @Perl_newSViv(i64 0) #2
  %call115 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call114) #2
  %cmp116 = icmp eq i32 %off1.0, 28
  br i1 %cmp116, label %if.then117, label %if.else170

if.then117:                                       ; preds = %if.then113
  %call118 = call %struct.sv* @Perl_amagic_call(%struct.sv* %left, %struct.sv* %call115, i32 28, i32 1)
  %tobool119 = icmp eq %struct.sv* %call118, null
  br i1 %tobool119, label %return, label %cond.false121

cond.false121:                                    ; preds = %if.then117
  %sv_flags122 = getelementptr inbounds %struct.sv* %call118, i64 0, i32 2
  %59 = load i64* %sv_flags122, align 8, !tbaa !1
  %and123 = and i64 %59, 262144
  %tobool124 = icmp eq i64 %and123, 0
  br i1 %tobool124, label %cond.false143, label %cond.true125

cond.true125:                                     ; preds = %cond.false121
  %sv_any126 = getelementptr inbounds %struct.sv* %call118, i64 0, i32 0
  %60 = load i8** %sv_any126, align 8, !tbaa !39
  %61 = bitcast i8* %60 to %struct.xpv*
  store %struct.xpv* %61, %struct.xpv** @PL_Xpv, align 8, !tbaa !19
  %tobool127 = icmp eq i8* %60, null
  br i1 %tobool127, label %land.end140, label %land.rhs128

land.rhs128:                                      ; preds = %cond.true125
  %xpv_cur = getelementptr inbounds i8* %60, i64 8
  %62 = bitcast i8* %xpv_cur to i64*
  %63 = load i64* %62, align 8, !tbaa !62
  %cmp129 = icmp ugt i64 %63, 1
  br i1 %cmp129, label %land.end140, label %lor.rhs130

lor.rhs130:                                       ; preds = %land.rhs128
  %tobool132 = icmp eq i64 %63, 0
  br i1 %tobool132, label %land.end140, label %land.rhs133

land.rhs133:                                      ; preds = %lor.rhs130
  %xpv_pv = bitcast i8* %60 to i8**
  %64 = load i8** %xpv_pv, align 8, !tbaa !30
  %65 = load i8* %64, align 1, !tbaa !26
  %cmp134 = icmp ne i8 %65, 48
  br label %land.end140

land.end140:                                      ; preds = %lor.rhs130, %cond.true125, %land.rhs128, %land.rhs133
  %66 = phi i1 [ false, %cond.true125 ], [ true, %land.rhs128 ], [ false, %lor.rhs130 ], [ %cmp134, %land.rhs133 ]
  %cond142 = zext i1 %66 to i32
  br label %if.end185

cond.false143:                                    ; preds = %cond.false121
  %and145 = and i64 %59, 65536
  %tobool146 = icmp eq i64 %and145, 0
  br i1 %tobool146, label %cond.false151, label %cond.true147

cond.true147:                                     ; preds = %cond.false143
  %sv_any148 = getelementptr inbounds %struct.sv* %call118, i64 0, i32 0
  %67 = load i8** %sv_any148, align 8, !tbaa !39
  %xiv_iv = getelementptr inbounds i8* %67, i64 24
  %68 = bitcast i8* %xiv_iv to i64*
  %69 = load i64* %68, align 8, !tbaa !92
  %cmp149 = icmp ne i64 %69, 0
  %conv150 = zext i1 %cmp149 to i32
  br label %if.end185

cond.false151:                                    ; preds = %cond.false143
  %and153 = and i64 %59, 131072
  %tobool154 = icmp eq i64 %and153, 0
  br i1 %tobool154, label %cond.false159, label %cond.true155

cond.true155:                                     ; preds = %cond.false151
  %sv_any156 = getelementptr inbounds %struct.sv* %call118, i64 0, i32 0
  %70 = load i8** %sv_any156, align 8, !tbaa !39
  %xnv_nv = getelementptr inbounds i8* %70, i64 32
  %71 = bitcast i8* %xnv_nv to double*
  %72 = load double* %71, align 8, !tbaa !76
  %cmp157 = fcmp une double %72, 0.000000e+00
  %conv158 = zext i1 %cmp157 to i32
  br label %if.end185

cond.false159:                                    ; preds = %cond.false151
  %call160 = call signext i8 @Perl_sv_2bool(%struct.sv* %call118) #2
  %conv161 = sext i8 %call160 to i32
  br label %if.end185

if.else170:                                       ; preds = %if.then113
  %call172 = call %struct.sv* @Perl_amagic_call(%struct.sv* %left, %struct.sv* %call115, i32 34, i32 1)
  %sv_flags173 = getelementptr inbounds %struct.sv* %call172, i64 0, i32 2
  %73 = load i64* %sv_flags173, align 8, !tbaa !1
  %and174 = and i64 %73, 131072
  %tobool175 = icmp eq i64 %and174, 0
  br i1 %tobool175, label %cond.false179, label %cond.true176

cond.true176:                                     ; preds = %if.else170
  %sv_any177 = getelementptr inbounds %struct.sv* %call172, i64 0, i32 0
  %74 = load i8** %sv_any177, align 8, !tbaa !39
  %xnv_nv178 = getelementptr inbounds i8* %74, i64 32
  %75 = bitcast i8* %xnv_nv178 to double*
  %76 = load double* %75, align 8, !tbaa !76
  br label %cond.end181

cond.false179:                                    ; preds = %if.else170
  %call180 = call double @Perl_sv_2nv(%struct.sv* %call172) #2
  br label %cond.end181

cond.end181:                                      ; preds = %cond.false179, %cond.true176
  %cond182 = phi double [ %76, %cond.true176 ], [ %call180, %cond.false179 ]
  %cmp183 = fcmp olt double %cond182, 0.000000e+00
  %conv184 = zext i1 %cmp183 to i32
  br label %if.end185

if.end185:                                        ; preds = %cond.true147, %cond.false159, %cond.true155, %land.end140, %cond.end181
  %logic.0 = phi i32 [ %conv184, %cond.end181 ], [ %cond142, %land.end140 ], [ %conv150, %cond.true147 ], [ %conv158, %cond.true155 ], [ %conv161, %cond.false159 ]
  %tobool186 = icmp eq i32 %logic.0, 0
  br i1 %tobool186, label %return, label %if.then187

if.then187:                                       ; preds = %if.end185
  %cmp188 = icmp eq i32 %off.8, 8
  %. = zext i1 %cmp188 to i32
  %left.right = select i1 %cmp188, %struct.sv* %left, %struct.sv* %right
  %call115.left = select i1 %cmp188, %struct.sv* %call115, %struct.sv* %left
  br label %sw.epilog

sw.bb195:                                         ; preds = %if.then32
  %arrayidx196 = getelementptr inbounds i8* %7, i64 88
  %77 = bitcast i8* %arrayidx196 to %struct.cv**
  %78 = load %struct.cv** %77, align 8, !tbaa !19
  %tobool197 = icmp eq %struct.cv* %78, null
  br i1 %tobool197, label %land.lhs.true290, label %if.then198

if.then198:                                       ; preds = %sw.bb195
  %call199 = call %struct.sv* @Perl_newSViv(i64 0) #2
  %call200 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call199) #2
  br label %if.end370

sw.bb203:                                         ; preds = %if.then32, %if.then32, %if.then32, %if.then32, %if.then32
  br label %return

sw.epilog:                                        ; preds = %if.then187, %lor.rhs76, %lor.rhs65, %lor.rhs57, %lor.rhs
  %postpr.2 = phi i32 [ 0, %lor.rhs ], [ 0, %lor.rhs57 ], [ 0, %lor.rhs65 ], [ 1, %lor.rhs76 ], [ 0, %if.then187 ]
  %lr.0 = phi i32 [ 0, %lor.rhs ], [ 0, %lor.rhs57 ], [ 0, %lor.rhs65 ], [ 0, %lor.rhs76 ], [ %., %if.then187 ]
  %off.9 = phi i32 [ 4, %lor.rhs ], [ 2, %lor.rhs57 ], [ 2, %lor.rhs65 ], [ 4, %lor.rhs76 ], [ %off.8, %if.then187 ]
  %cv.9 = phi %struct.cv* [ %24, %lor.rhs ], [ %28, %lor.rhs57 ], [ %32, %lor.rhs65 ], [ %38, %lor.rhs76 ], [ %cv.8, %if.then187 ]
  %right.addr.0 = phi %struct.sv* [ %right, %lor.rhs ], [ %right, %lor.rhs57 ], [ %right, %lor.rhs65 ], [ %right, %lor.rhs76 ], [ %left.right, %if.then187 ]
  %left.addr.0 = phi %struct.sv* [ %left, %lor.rhs ], [ %left, %lor.rhs57 ], [ %left, %lor.rhs65 ], [ %left, %lor.rhs76 ], [ %call115.left, %if.then187 ]
  %tobool204 = icmp eq %struct.cv* %cv.9, null
  br i1 %tobool204, label %not_found, label %if.end370

if.else207:                                       ; preds = %land.lhs.true20, %land.lhs.true10, %land.lhs.true, %land.lhs.true5, %land.lhs.true8, %entry, %land.lhs.true26
  %tobool25880 = phi i1 [ false, %land.lhs.true26 ], [ true, %entry ], [ true, %land.lhs.true8 ], [ true, %land.lhs.true5 ], [ true, %land.lhs.true ], [ true, %land.lhs.true10 ], [ false, %land.lhs.true20 ]
  %ocvp.0877 = phi %struct.cv** [ %arraydecay, %land.lhs.true26 ], [ null, %entry ], [ null, %land.lhs.true8 ], [ null, %land.lhs.true5 ], [ null, %land.lhs.true ], [ null, %land.lhs.true10 ], [ %arraydecay, %land.lhs.true20 ]
  %oamtp.1875 = phi %struct.am_table* [ %8, %land.lhs.true26 ], [ null, %entry ], [ null, %land.lhs.true8 ], [ null, %land.lhs.true5 ], [ null, %land.lhs.true ], [ null, %land.lhs.true10 ], [ %8, %land.lhs.true20 ]
  %off.1874 = phi i32 [ %off.1, %land.lhs.true26 ], [ 0, %entry ], [ 0, %land.lhs.true8 ], [ 0, %land.lhs.true5 ], [ 0, %land.lhs.true ], [ 0, %land.lhs.true10 ], [ %add, %land.lhs.true20 ]
  %and208 = and i32 %flags, 1
  %tobool209 = icmp eq i32 %and208, 0
  br i1 %tobool209, label %land.lhs.true210, label %if.else241

land.lhs.true210:                                 ; preds = %if.else207
  %sv_flags211 = getelementptr inbounds %struct.sv* %right, i64 0, i32 2
  %79 = load i64* %sv_flags211, align 8, !tbaa !1
  %and212 = and i64 %79, 268435456
  %tobool213 = icmp eq i64 %and212, 0
  br i1 %tobool213, label %if.else241, label %land.lhs.true214

land.lhs.true214:                                 ; preds = %land.lhs.true210
  %sv_any215 = getelementptr inbounds %struct.sv* %right, i64 0, i32 0
  %80 = load i8** %sv_any215, align 8, !tbaa !39
  %xrv_rv216 = bitcast i8* %80 to %struct.sv**
  %81 = load %struct.sv** %xrv_rv216, align 8, !tbaa !95
  %sv_any217 = getelementptr inbounds %struct.sv* %81, i64 0, i32 0
  %82 = load i8** %sv_any217, align 8, !tbaa !39
  %xmg_stash218 = getelementptr inbounds i8* %82, i64 48
  %83 = bitcast i8* %xmg_stash218 to %struct.hv**
  %84 = load %struct.hv** %83, align 8, !tbaa !24
  %tobool219 = icmp eq %struct.hv* %84, null
  br i1 %tobool219, label %if.else241, label %land.lhs.true220

land.lhs.true220:                                 ; preds = %land.lhs.true214
  %85 = bitcast %struct.hv* %84 to %struct.sv*
  %call221 = call %struct.magic* @Perl_mg_find(%struct.sv* %85, i32 99) #2
  %tobool222 = icmp eq %struct.magic* %call221, null
  br i1 %tobool222, label %if.else241, label %land.lhs.true223

land.lhs.true223:                                 ; preds = %land.lhs.true220
  %mg_ptr224 = getelementptr inbounds %struct.magic* %call221, i64 0, i32 6
  %86 = load i8** %mg_ptr224, align 8, !tbaa !85
  %flags225 = getelementptr inbounds i8* %86, i64 16
  %87 = bitcast i8* %flags225 to i64*
  %88 = load i64* %87, align 8, !tbaa !87
  %and226 = and i64 %88, 1
  %tobool227 = icmp eq i64 %and226, 0
  br i1 %tobool227, label %if.else241, label %cond.end233

cond.end233:                                      ; preds = %land.lhs.true223
  %89 = bitcast i8* %86 to %struct.am_table*
  %table230 = getelementptr inbounds i8* %86, i64 24
  %arraydecay231 = bitcast i8* %table230 to %struct.cv**
  %idxprom237 = sext i32 %method to i64
  %arrayidx238 = getelementptr inbounds %struct.cv** %arraydecay231, i64 %idxprom237
  %90 = load %struct.cv** %arrayidx238, align 8, !tbaa !19
  %tobool239 = icmp eq %struct.cv* %90, null
  br i1 %tobool239, label %if.else241, label %if.end370

if.else241:                                       ; preds = %land.lhs.true223, %cond.end233, %land.lhs.true220, %land.lhs.true214, %land.lhs.true210, %if.else207
  %off.10 = phi i32 [ %off.1874, %if.else207 ], [ %method, %cond.end233 ], [ %off.1874, %land.lhs.true220 ], [ %off.1874, %land.lhs.true214 ], [ %off.1874, %land.lhs.true210 ], [ %off.1874, %land.lhs.true223 ]
  %amtp.3 = phi %struct.am_table* [ %oamtp.1875, %if.else207 ], [ %89, %cond.end233 ], [ %oamtp.1875, %land.lhs.true220 ], [ %oamtp.1875, %land.lhs.true214 ], [ %oamtp.1875, %land.lhs.true210 ], [ %oamtp.1875, %land.lhs.true223 ]
  %cvp.1 = phi %struct.cv** [ %ocvp.0877, %if.else207 ], [ %arraydecay231, %cond.end233 ], [ %ocvp.0877, %land.lhs.true220 ], [ %ocvp.0877, %land.lhs.true214 ], [ %ocvp.0877, %land.lhs.true210 ], [ null, %land.lhs.true223 ]
  %tobool242 = icmp eq %struct.cv** %ocvp.0877, null
  br i1 %tobool242, label %lor.lhs.false250, label %land.lhs.true243

land.lhs.true243:                                 ; preds = %if.else241
  %fallback244 = getelementptr inbounds %struct.am_table* %oamtp.1875, i64 0, i32 4
  %91 = load i64* %fallback244, align 8, !tbaa !91
  %cmp245.not = icmp slt i64 %91, 2
  %cvp.1.mux = select i1 %cmp245.not, %struct.cv** %cvp.1, %struct.cv** %ocvp.0877
  br i1 %cmp245.not, label %lor.lhs.false250, label %land.lhs.true257

lor.lhs.false250:                                 ; preds = %if.else241, %land.lhs.true243
  %cvp.2 = phi %struct.cv** [ %cvp.1.mux, %land.lhs.true243 ], [ %cvp.1, %if.else241 ]
  %tobool251 = icmp eq %struct.cv** %cvp.2, null
  br i1 %tobool251, label %not_found, label %land.lhs.true252

land.lhs.true252:                                 ; preds = %lor.lhs.false250
  %fallback253 = getelementptr inbounds %struct.am_table* %amtp.3, i64 0, i32 4
  %92 = load i64* %fallback253, align 8, !tbaa !91
  %cmp254 = icmp sgt i64 %92, 1
  br i1 %cmp254, label %land.lhs.true257, label %not_found

land.lhs.true257:                                 ; preds = %land.lhs.true252, %land.lhs.true243
  %lr.1 = phi i32 [ -1, %land.lhs.true243 ], [ 1, %land.lhs.true252 ]
  %cvp.3 = phi %struct.cv** [ %ocvp.0877, %land.lhs.true243 ], [ %cvp.2, %land.lhs.true252 ]
  %and258 = and i32 %flags, 8
  %tobool259 = icmp eq i32 %and258, 0
  br i1 %tobool259, label %if.then260, label %not_found

if.then260:                                       ; preds = %land.lhs.true257
  switch i32 %method, label %not_found [
    i32 55, label %return
    i32 54, label %return
    i32 53, label %return
    i32 52, label %return
    i32 28, label %if.end282
    i32 29, label %if.end282
    i32 30, label %if.end282
    i32 31, label %if.end282
    i32 32, label %if.end282
    i32 33, label %if.end282
    i32 36, label %sw.bb275
    i32 37, label %sw.bb275
    i32 38, label %sw.bb275
    i32 39, label %sw.bb275
    i32 40, label %sw.bb275
    i32 41, label %sw.bb275
  ]

sw.bb275:                                         ; preds = %if.then260, %if.then260, %if.then260, %if.then260, %if.then260, %if.then260
  br label %if.end282

if.end282:                                        ; preds = %sw.bb275, %if.then260, %if.then260, %if.then260, %if.then260, %if.then260, %if.then260
  %off.11.ph = phi i32 [ 35, %sw.bb275 ], [ 34, %if.then260 ], [ 34, %if.then260 ], [ 34, %if.then260 ], [ 34, %if.then260 ], [ 34, %if.then260 ], [ 34, %if.then260 ]
  %idxprom280936 = zext i32 %off.11.ph to i64
  %arrayidx281 = getelementptr inbounds %struct.cv** %cvp.3, i64 %idxprom280936
  %93 = load %struct.cv** %arrayidx281, align 8, !tbaa !19
  %tobool283 = icmp eq %struct.cv* %93, null
  br i1 %tobool283, label %not_found, label %if.end370

not_found:                                        ; preds = %if.then260, %lor.lhs.false104, %lor.lhs.false35, %lor.lhs.false43, %lor.lhs.false110, %sw.epilog, %if.end282, %land.lhs.true257, %lor.lhs.false250, %land.lhs.true252, %if.then32
  %tobool25879 = phi i1 [ false, %if.then32 ], [ false, %sw.epilog ], [ %tobool25880, %land.lhs.true257 ], [ %tobool25880, %if.end282 ], [ %tobool25880, %land.lhs.true252 ], [ %tobool25880, %lor.lhs.false250 ], [ false, %lor.lhs.false110 ], [ false, %lor.lhs.false43 ], [ false, %lor.lhs.false35 ], [ false, %lor.lhs.false104 ], [ %tobool25880, %if.then260 ]
  %ocvp.0876 = phi %struct.cv** [ %arraydecay, %if.then32 ], [ %arraydecay, %sw.epilog ], [ %ocvp.0877, %land.lhs.true257 ], [ %ocvp.0877, %if.end282 ], [ %ocvp.0877, %land.lhs.true252 ], [ %ocvp.0877, %lor.lhs.false250 ], [ %arraydecay, %lor.lhs.false110 ], [ %arraydecay, %lor.lhs.false43 ], [ %arraydecay, %lor.lhs.false35 ], [ %arraydecay, %lor.lhs.false104 ], [ %ocvp.0877, %if.then260 ]
  %postpr.4 = phi i32 [ 0, %if.then32 ], [ %postpr.2, %sw.epilog ], [ 0, %land.lhs.true257 ], [ 1, %if.end282 ], [ 0, %land.lhs.true252 ], [ 0, %lor.lhs.false250 ], [ 0, %lor.lhs.false110 ], [ 0, %lor.lhs.false43 ], [ 0, %lor.lhs.false35 ], [ 0, %lor.lhs.false104 ], [ 0, %if.then260 ]
  %force_cpy.3 = phi i32 [ 0, %if.then32 ], [ 0, %sw.epilog ], [ 0, %land.lhs.true257 ], [ 0, %if.end282 ], [ 0, %land.lhs.true252 ], [ 0, %lor.lhs.false250 ], [ 0, %lor.lhs.false110 ], [ 1, %lor.lhs.false43 ], [ 1, %lor.lhs.false35 ], [ 0, %lor.lhs.false104 ], [ 0, %if.then260 ]
  %off.12 = phi i32 [ %off.1, %if.then32 ], [ %off.9, %sw.epilog ], [ %off.10, %land.lhs.true257 ], [ %off.11.ph, %if.end282 ], [ %off.10, %land.lhs.true252 ], [ %off.10, %lor.lhs.false250 ], [ 8, %lor.lhs.false110 ], [ 8, %lor.lhs.false43 ], [ 6, %lor.lhs.false35 ], [ %off.1, %lor.lhs.false104 ], [ -1, %if.then260 ]
  %amtp.4 = phi %struct.am_table* [ %8, %if.then32 ], [ %8, %sw.epilog ], [ %amtp.3, %land.lhs.true257 ], [ %amtp.3, %if.end282 ], [ %amtp.3, %land.lhs.true252 ], [ %amtp.3, %lor.lhs.false250 ], [ %8, %lor.lhs.false110 ], [ %8, %lor.lhs.false43 ], [ %8, %lor.lhs.false35 ], [ %8, %lor.lhs.false104 ], [ %amtp.3, %if.then260 ]
  %cvp.4 = phi %struct.cv** [ %arraydecay, %if.then32 ], [ %arraydecay, %sw.epilog ], [ %cvp.3, %land.lhs.true257 ], [ %cvp.3, %if.end282 ], [ %cvp.2, %land.lhs.true252 ], [ null, %lor.lhs.false250 ], [ %arraydecay, %lor.lhs.false110 ], [ %arraydecay, %lor.lhs.false43 ], [ %arraydecay, %lor.lhs.false35 ], [ %arraydecay, %lor.lhs.false104 ], [ %cvp.3, %if.then260 ]
  %right.addr.1 = phi %struct.sv* [ %right, %if.then32 ], [ %right.addr.0, %sw.epilog ], [ %right, %land.lhs.true257 ], [ %right, %if.end282 ], [ %right, %land.lhs.true252 ], [ %right, %lor.lhs.false250 ], [ %right, %lor.lhs.false110 ], [ %right, %lor.lhs.false43 ], [ %right, %lor.lhs.false35 ], [ %right, %lor.lhs.false104 ], [ %right, %if.then260 ]
  %left.addr.1 = phi %struct.sv* [ %left, %if.then32 ], [ %left.addr.0, %sw.epilog ], [ %left, %land.lhs.true257 ], [ %left, %if.end282 ], [ %left, %land.lhs.true252 ], [ %left, %lor.lhs.false250 ], [ %left, %lor.lhs.false110 ], [ %left, %lor.lhs.false43 ], [ %left, %lor.lhs.false35 ], [ %left, %lor.lhs.false104 ], [ %left, %if.then260 ]
  %.off = add i32 %method, -58
  %switch = icmp ult i32 %.off, 5
  br i1 %switch, label %return, label %sw.epilog288

sw.epilog288:                                     ; preds = %not_found
  br i1 %tobool25879, label %if.else294, label %land.lhs.true290

land.lhs.true290:                                 ; preds = %sw.bb81, %sw.bb195, %sw.epilog288
  %ocvp.0876900931 = phi %struct.cv** [ %ocvp.0876, %sw.epilog288 ], [ %arraydecay, %sw.bb195 ], [ %arraydecay, %sw.bb81 ]
  %postpr.4901929 = phi i32 [ %postpr.4, %sw.epilog288 ], [ 0, %sw.bb195 ], [ 0, %sw.bb81 ]
  %force_cpy.3902926 = phi i32 [ %force_cpy.3, %sw.epilog288 ], [ 0, %sw.bb195 ], [ 0, %sw.bb81 ]
  %off.12904920 = phi i32 [ %off.12, %sw.epilog288 ], [ 8, %sw.bb195 ], [ %off.1, %sw.bb81 ]
  %amtp.4905917 = phi %struct.am_table* [ %amtp.4, %sw.epilog288 ], [ %8, %sw.bb195 ], [ %8, %sw.bb81 ]
  %cvp.4906915 = phi %struct.cv** [ %cvp.4, %sw.epilog288 ], [ %arraydecay, %sw.bb195 ], [ %arraydecay, %sw.bb81 ]
  %right.addr.1907913 = phi %struct.sv* [ %right.addr.1, %sw.epilog288 ], [ %right, %sw.bb195 ], [ %right, %sw.bb81 ]
  %left.addr.1909911 = phi %struct.sv* [ %left.addr.1, %sw.epilog288 ], [ %left, %sw.bb195 ], [ %left, %sw.bb81 ]
  %arrayidx291 = getelementptr inbounds %struct.cv** %ocvp.0876900931, i64 3
  %94 = load %struct.cv** %arrayidx291, align 8, !tbaa !19
  %tobool292 = icmp eq %struct.cv* %94, null
  br i1 %tobool292, label %if.else294, label %if.end361

if.else294:                                       ; preds = %land.lhs.true290, %sw.epilog288
  %postpr.4901930 = phi i32 [ %postpr.4901929, %land.lhs.true290 ], [ %postpr.4, %sw.epilog288 ]
  %force_cpy.3902927 = phi i32 [ %force_cpy.3902926, %land.lhs.true290 ], [ %force_cpy.3, %sw.epilog288 ]
  %off.12904921 = phi i32 [ %off.12904920, %land.lhs.true290 ], [ %off.12, %sw.epilog288 ]
  %amtp.4905918 = phi %struct.am_table* [ %amtp.4905917, %land.lhs.true290 ], [ %amtp.4, %sw.epilog288 ]
  %cvp.4906916 = phi %struct.cv** [ %cvp.4906915, %land.lhs.true290 ], [ %cvp.4, %sw.epilog288 ]
  %right.addr.1907914 = phi %struct.sv* [ %right.addr.1907913, %land.lhs.true290 ], [ %right.addr.1, %sw.epilog288 ]
  %left.addr.1909912 = phi %struct.sv* [ %left.addr.1909911, %land.lhs.true290 ], [ %left.addr.1, %sw.epilog288 ]
  %tobool295 = icmp eq %struct.cv** %cvp.4906916, null
  br i1 %tobool295, label %if.else300, label %land.lhs.true296

land.lhs.true296:                                 ; preds = %if.else294
  %arrayidx297 = getelementptr inbounds %struct.cv** %cvp.4906916, i64 3
  %95 = load %struct.cv** %arrayidx297, align 8, !tbaa !19
  %tobool298 = icmp eq %struct.cv* %95, null
  br i1 %tobool298, label %if.else300, label %if.end361

if.else300:                                       ; preds = %land.lhs.true296, %if.else294
  %add305 = add nsw i32 %and.lobit, %method
  %idxprom306 = sext i32 %add305 to i64
  %arrayidx307 = getelementptr inbounds [66 x i8*]* @PL_AMG_names, i64 0, i64 %idxprom306
  %96 = load i8** %arrayidx307, align 8, !tbaa !19
  %add.ptr = getelementptr inbounds i8* %96, i64 1
  %and308 = and i32 %flags, 8
  %tobool309 = icmp ne i32 %and308, 0
  %cond310 = select i1 %tobool309, i8* getelementptr inbounds ([2 x i8]* @.str72, i64 0, i64 0), i8* getelementptr inbounds ([8 x i8]* @.str73, i64 0, i64 0)
  %sv_flags311 = getelementptr inbounds %struct.sv* %left.addr.1909912, i64 0, i32 2
  %97 = load i64* %sv_flags311, align 8, !tbaa !1
  %and312 = and i64 %97, 268435456
  %tobool313 = icmp ne i64 %and312, 0
  %cond314 = select i1 %tobool313, i8* getelementptr inbounds ([23 x i8]* @.str74, i64 0, i64 0), i8* getelementptr inbounds ([24 x i8]* @.str75, i64 0, i64 0)
  br i1 %tobool313, label %cond.true318, label %cond.end325

cond.true318:                                     ; preds = %if.else300
  %sv_any319 = getelementptr inbounds %struct.sv* %left.addr.1909912, i64 0, i32 0
  %98 = load i8** %sv_any319, align 8, !tbaa !39
  %xrv_rv320 = bitcast i8* %98 to %struct.sv**
  %99 = load %struct.sv** %xrv_rv320, align 8, !tbaa !95
  %sv_any321 = getelementptr inbounds %struct.sv* %99, i64 0, i32 0
  %100 = load i8** %sv_any321, align 8, !tbaa !39
  %xmg_stash322 = getelementptr inbounds i8* %100, i64 48
  %101 = bitcast i8* %xmg_stash322 to %struct.hv**
  %102 = load %struct.hv** %101, align 8, !tbaa !24
  %sv_any323 = getelementptr inbounds %struct.hv* %102, i64 0, i32 0
  %103 = load %struct.xpvhv** %sv_any323, align 8, !tbaa !20
  %xhv_name = getelementptr inbounds %struct.xpvhv* %103, i64 0, i32 10
  %104 = load i8** %xhv_name, align 8, !tbaa !54
  br label %cond.end325

cond.end325:                                      ; preds = %if.else300, %cond.true318
  %cond326 = phi i8* [ %104, %cond.true318 ], [ getelementptr inbounds ([1 x i8]* @.str3, i64 0, i64 0), %if.else300 ]
  %sv_flags327 = getelementptr inbounds %struct.sv* %right.addr.1907914, i64 0, i32 2
  %105 = load i64* %sv_flags327, align 8, !tbaa !1
  %and328 = and i64 %105, 268435456
  %tobool329 = icmp eq i64 %and328, 0
  br i1 %tobool329, label %cond.end335.thread, label %cond.true340

cond.end335.thread:                               ; preds = %cond.end325
  %cond334 = select i1 %tobool309, i8* getelementptr inbounds ([1 x i8]* @.str3, i64 0, i64 0), i8* getelementptr inbounds ([42 x i8]* @.str77, i64 0, i64 0)
  br label %cond.end348

cond.true340:                                     ; preds = %cond.end325
  %sv_any341 = getelementptr inbounds %struct.sv* %right.addr.1907914, i64 0, i32 0
  %106 = load i8** %sv_any341, align 8, !tbaa !39
  %xrv_rv342 = bitcast i8* %106 to %struct.sv**
  %107 = load %struct.sv** %xrv_rv342, align 8, !tbaa !95
  %sv_any343 = getelementptr inbounds %struct.sv* %107, i64 0, i32 0
  %108 = load i8** %sv_any343, align 8, !tbaa !39
  %xmg_stash344 = getelementptr inbounds i8* %108, i64 48
  %109 = bitcast i8* %xmg_stash344 to %struct.hv**
  %110 = load %struct.hv** %109, align 8, !tbaa !24
  %sv_any345 = getelementptr inbounds %struct.hv* %110, i64 0, i32 0
  %111 = load %struct.xpvhv** %sv_any345, align 8, !tbaa !20
  %xhv_name346 = getelementptr inbounds %struct.xpvhv* %111, i64 0, i32 10
  %112 = load i8** %xhv_name346, align 8, !tbaa !54
  br label %cond.end348

cond.end348:                                      ; preds = %cond.end335.thread, %cond.true340
  %cond336943 = phi i8* [ getelementptr inbounds ([41 x i8]* @.str76, i64 0, i64 0), %cond.true340 ], [ %cond334, %cond.end335.thread ]
  %cond349 = phi i8* [ %112, %cond.true340 ], [ getelementptr inbounds ([1 x i8]* @.str3, i64 0, i64 0), %cond.end335.thread ]
  %call350 = call %struct.sv* (i8*, ...)* @Perl_newSVpvf(i8* getelementptr inbounds ([52 x i8]* @.str71, i64 0, i64 0), i8* %add.ptr, i8* %cond310, i8* %cond314, i8* %cond326, i8* %cond336943, i8* %cond349) #2
  %call351 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call350) #2
  %tobool352 = icmp eq %struct.am_table* %amtp.4905918, null
  br i1 %tobool352, label %if.else358, label %land.lhs.true353

land.lhs.true353:                                 ; preds = %cond.end348
  %fallback354 = getelementptr inbounds %struct.am_table* %amtp.4905918, i64 0, i32 4
  %113 = load i64* %fallback354, align 8, !tbaa !91
  %cmp355 = icmp sgt i64 %113, 2
  br i1 %cmp355, label %return, label %if.else358

if.else358:                                       ; preds = %cond.end348, %land.lhs.true353
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([3 x i8]* @.str78, i64 0, i64 0), %struct.sv* %call351) #2
  br label %return

if.end361:                                        ; preds = %land.lhs.true296, %land.lhs.true290
  %postpr.4901928 = phi i32 [ %postpr.4901929, %land.lhs.true290 ], [ %postpr.4901930, %land.lhs.true296 ]
  %force_cpy.3902925 = phi i32 [ %force_cpy.3902926, %land.lhs.true290 ], [ %force_cpy.3902927, %land.lhs.true296 ]
  %off.12904919 = phi i32 [ %off.12904920, %land.lhs.true290 ], [ %off.12904921, %land.lhs.true296 ]
  %left.addr.1910 = phi %struct.sv* [ %left.addr.1909911, %land.lhs.true290 ], [ %left.addr.1909912, %land.lhs.true296 ]
  %right.addr.1908 = phi %struct.sv* [ %right.addr.1907913, %land.lhs.true290 ], [ %right.addr.1907914, %land.lhs.true296 ]
  %lr.2 = phi i32 [ -1, %land.lhs.true290 ], [ 1, %land.lhs.true296 ]
  %cv.12 = phi %struct.cv* [ %94, %land.lhs.true290 ], [ %95, %land.lhs.true296 ]
  %114 = or i32 %force_cpy.3902925, %and
  %115 = icmp ne i32 %114, 0
  %lor.ext366 = zext i1 %115 to i32
  br label %if.end370

if.end370:                                        ; preds = %sw.bb40, %lor.lhs.false43, %sw.bb, %lor.lhs.false35, %lor.lhs.false73, %sw.bb70, %sw.bb62, %sw.bb54, %sw.bb49, %if.then198, %cond.end233, %cond.end, %land.lhs.true21, %sw.epilog, %if.end282, %if.end361
  %postpr.5 = phi i32 [ %postpr.4901928, %if.end361 ], [ %postpr.2, %sw.epilog ], [ 1, %if.end282 ], [ 0, %land.lhs.true21 ], [ 0, %cond.end ], [ 0, %cond.end233 ], [ 0, %if.then198 ], [ 0, %sw.bb49 ], [ 0, %sw.bb54 ], [ 0, %sw.bb62 ], [ 1, %sw.bb70 ], [ 1, %lor.lhs.false73 ], [ 0, %sw.bb ], [ 1, %lor.lhs.false35 ], [ 0, %sw.bb40 ], [ 1, %lor.lhs.false43 ]
  %force_cpy.4 = phi i32 [ %lor.ext366, %if.end361 ], [ 0, %sw.epilog ], [ 0, %if.end282 ], [ 0, %land.lhs.true21 ], [ 0, %cond.end ], [ 0, %cond.end233 ], [ 0, %if.then198 ], [ 0, %sw.bb49 ], [ 0, %sw.bb54 ], [ 0, %sw.bb62 ], [ 0, %sw.bb70 ], [ 0, %lor.lhs.false73 ], [ 1, %sw.bb ], [ 0, %lor.lhs.false35 ], [ 1, %sw.bb40 ], [ 0, %lor.lhs.false43 ]
  %notfound.1 = phi i32 [ 1, %if.end361 ], [ 0, %sw.epilog ], [ 0, %if.end282 ], [ 0, %land.lhs.true21 ], [ 0, %cond.end ], [ 0, %cond.end233 ], [ 0, %if.then198 ], [ 0, %sw.bb49 ], [ 0, %sw.bb54 ], [ 0, %sw.bb62 ], [ 0, %sw.bb70 ], [ 0, %lor.lhs.false73 ], [ 0, %sw.bb ], [ 0, %lor.lhs.false35 ], [ 0, %sw.bb40 ], [ 0, %lor.lhs.false43 ]
  %assign.2 = phi i32 [ %and, %if.end361 ], [ %and, %sw.epilog ], [ %and, %if.end282 ], [ %and, %land.lhs.true21 ], [ %and, %cond.end ], [ %and, %cond.end233 ], [ %and, %if.then198 ], [ %and, %sw.bb49 ], [ %and, %sw.bb54 ], [ %and, %sw.bb62 ], [ %and, %sw.bb70 ], [ %and, %lor.lhs.false73 ], [ 1, %sw.bb ], [ 1, %lor.lhs.false35 ], [ 1, %sw.bb40 ], [ 1, %lor.lhs.false43 ]
  %lr.3 = phi i32 [ %lr.2, %if.end361 ], [ %lr.0, %sw.epilog ], [ %lr.1, %if.end282 ], [ -1, %land.lhs.true21 ], [ -1, %cond.end ], [ 1, %cond.end233 ], [ 1, %if.then198 ], [ 0, %sw.bb49 ], [ 0, %sw.bb54 ], [ 0, %sw.bb62 ], [ 0, %sw.bb70 ], [ 0, %lor.lhs.false73 ], [ -1, %sw.bb ], [ -1, %lor.lhs.false35 ], [ -1, %sw.bb40 ], [ -1, %lor.lhs.false43 ]
  %off.13 = phi i32 [ %off.12904919, %if.end361 ], [ %off.9, %sw.epilog ], [ %off.11.ph, %if.end282 ], [ %method, %land.lhs.true21 ], [ %add, %cond.end ], [ %method, %cond.end233 ], [ 8, %if.then198 ], [ 5, %sw.bb49 ], [ 4, %sw.bb54 ], [ 5, %sw.bb62 ], [ 2, %sw.bb70 ], [ 5, %lor.lhs.false73 ], [ 7, %sw.bb ], [ 6, %lor.lhs.false35 ], [ 9, %sw.bb40 ], [ 8, %lor.lhs.false43 ]
  %cv.13 = phi %struct.cv* [ %cv.12, %if.end361 ], [ %cv.9, %sw.epilog ], [ %93, %if.end282 ], [ %12, %land.lhs.true21 ], [ %11, %cond.end ], [ %90, %cond.end233 ], [ %78, %if.then198 ], [ %22, %sw.bb49 ], [ %26, %sw.bb54 ], [ %30, %sw.bb62 ], [ %34, %sw.bb70 ], [ %36, %lor.lhs.false73 ], [ %14, %sw.bb ], [ %16, %lor.lhs.false35 ], [ %18, %sw.bb40 ], [ %20, %lor.lhs.false43 ]
  %right.addr.2 = phi %struct.sv* [ %right.addr.1908, %if.end361 ], [ %right.addr.0, %sw.epilog ], [ %right, %if.end282 ], [ %right, %land.lhs.true21 ], [ %right, %cond.end ], [ %right, %cond.end233 ], [ %left, %if.then198 ], [ %right, %sw.bb49 ], [ %right, %sw.bb54 ], [ %right, %sw.bb62 ], [ %right, %sw.bb70 ], [ %right, %lor.lhs.false73 ], [ @PL_sv_yes, %sw.bb ], [ @PL_sv_yes, %lor.lhs.false35 ], [ @PL_sv_yes, %sw.bb40 ], [ @PL_sv_yes, %lor.lhs.false43 ]
  %left.addr.2 = phi %struct.sv* [ %left.addr.1910, %if.end361 ], [ %left.addr.0, %sw.epilog ], [ %left, %if.end282 ], [ %left, %land.lhs.true21 ], [ %left, %cond.end ], [ %left, %cond.end233 ], [ %call200, %if.then198 ], [ %left, %sw.bb49 ], [ %left, %sw.bb54 ], [ %left, %sw.bb62 ], [ %left, %sw.bb70 ], [ %left, %lor.lhs.false73 ], [ %left, %sw.bb ], [ %left, %lor.lhs.false35 ], [ %left, %sw.bb40 ], [ %left, %lor.lhs.false43 ]
  %add371 = add nsw i32 %and.lobit, %method
  %cmp372 = icmp eq i32 %add371, %off.13
  br i1 %cmp372, label %land.lhs.true374, label %lor.lhs.false382

land.lhs.true374:                                 ; preds = %if.end370
  %tobool375 = icmp ne i32 %assign.2, 0
  %cmp377 = icmp eq i32 %method, 44
  %or.cond704 = or i1 %tobool375, %cmp377
  %cmp380 = icmp eq i32 %method, 45
  %or.cond705 = or i1 %or.cond704, %cmp380
  %tobool383 = icmp ne i32 %force_cpy.4, 0
  %or.cond706 = or i1 %or.cond705, %tobool383
  br i1 %or.cond706, label %if.then384, label %if.end396

lor.lhs.false382:                                 ; preds = %if.end370
  %tobool383.old = icmp eq i32 %force_cpy.4, 0
  br i1 %tobool383.old, label %if.end396, label %if.then384

if.then384:                                       ; preds = %lor.lhs.false382, %land.lhs.true374
  %sv_any386 = getelementptr inbounds %struct.sv* %left.addr.2, i64 0, i32 0
  %116 = load i8** %sv_any386, align 8, !tbaa !39
  %xrv_rv387 = bitcast i8* %116 to %struct.sv**
  %117 = load %struct.sv** %xrv_rv387, align 8, !tbaa !95
  %sv_refcnt388 = getelementptr inbounds %struct.sv* %117, i64 0, i32 1
  %118 = load i64* %sv_refcnt388, align 8, !tbaa !22
  %cmp389 = icmp ugt i64 %118, 1
  br i1 %cmp389, label %if.then391, label %if.end396

if.then391:                                       ; preds = %if.then384
  %call392 = call %struct.sv* @Perl_amagic_call(%struct.sv* %left.addr.2, %struct.sv* @PL_sv_undef, i32 56, i32 9)
  %119 = load i8** %sv_any386, align 8, !tbaa !39
  %xrv_rv394 = bitcast i8* %119 to %struct.sv**
  store %struct.sv* %call392, %struct.sv** %xrv_rv394, align 8, !tbaa !95
  call void @Perl_sv_free(%struct.sv* %117) #2
  br label %if.end396

if.end396:                                        ; preds = %lor.lhs.false382, %if.then384, %if.then391, %land.lhs.true374
  %120 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !19
  %121 = bitcast %struct.binop* %myop to i8*
  call void @llvm.lifetime.start(i64 56, i8* %121) #2
  %122 = load %struct.jmpenv** @PL_top_env, align 8, !tbaa !19
  %je_mustcatch = getelementptr inbounds %struct.jmpenv* %122, i64 0, i32 3
  %123 = load i8* %je_mustcatch, align 1, !tbaa !97
  store i8 1, i8* %je_mustcatch, align 1, !tbaa !97
  call void @llvm.memset.p0i8.i64(i8* %121, i8 0, i64 48, i32 8, i1 false)
  %124 = bitcast %struct.binop* %myop to %struct.op*
  %op_last = getelementptr inbounds %struct.binop* %myop, i64 0, i32 9
  store %struct.op* %124, %struct.op** %op_last, align 8, !tbaa !99
  %op_next = getelementptr inbounds %struct.binop* %myop, i64 0, i32 0
  store %struct.op* null, %struct.op** %op_next, align 8, !tbaa !101
  %op_flags = getelementptr inbounds %struct.binop* %myop, i64 0, i32 6
  store i8 66, i8* %op_flags, align 4, !tbaa !102
  %125 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !19
  %si_next = getelementptr inbounds %struct.stackinfo* %125, i64 0, i32 6
  %126 = load %struct.stackinfo** %si_next, align 8, !tbaa !103
  %tobool398 = icmp eq %struct.stackinfo* %126, null
  br i1 %tobool398, label %if.then399, label %if.end402

if.then399:                                       ; preds = %if.end396
  %call400 = call %struct.stackinfo* @Perl_new_stackinfo(i64 32, i64 12) #2
  %127 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !19
  %si_prev = getelementptr inbounds %struct.stackinfo* %call400, i64 0, i32 5
  store %struct.stackinfo* %127, %struct.stackinfo** %si_prev, align 8, !tbaa !105
  %128 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !19
  %si_next401 = getelementptr inbounds %struct.stackinfo* %128, i64 0, i32 6
  store %struct.stackinfo* %call400, %struct.stackinfo** %si_next401, align 8, !tbaa !103
  br label %if.end402

if.end402:                                        ; preds = %if.end396, %if.then399
  %next.0 = phi %struct.stackinfo* [ %126, %if.end396 ], [ %call400, %if.then399 ]
  %si_type = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 4
  store i64 5, i64* %si_type, align 8, !tbaa !106
  %si_cxix = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 2
  store i64 -1, i64* %si_cxix, align 8, !tbaa !107
  %si_stack = getelementptr inbounds %struct.stackinfo* %next.0, i64 0, i32 0
  %129 = load %struct.av** %si_stack, align 8, !tbaa !108
  %sv_any403 = getelementptr inbounds %struct.av* %129, i64 0, i32 0
  %130 = load %struct.xpvav** %sv_any403, align 8, !tbaa !56
  %xav_fill = getelementptr inbounds %struct.xpvav* %130, i64 0, i32 1
  store i64 0, i64* %xav_fill, align 8, !tbaa !59
  %131 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !19
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %120 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %131 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %132 = load %struct.av** @PL_curstack, align 8, !tbaa !19
  %sv_any404 = getelementptr inbounds %struct.av* %132, i64 0, i32 0
  %133 = load %struct.xpvav** %sv_any404, align 8, !tbaa !56
  %xav_fill405 = getelementptr inbounds %struct.xpvav* %133, i64 0, i32 1
  store i64 %sub.ptr.div, i64* %xav_fill405, align 8, !tbaa !59
  %xav_array = getelementptr inbounds %struct.xpvav* %130, i64 0, i32 0
  %134 = load i8** %xav_array, align 8, !tbaa !61
  %135 = bitcast i8* %134 to %struct.sv**
  store %struct.sv** %135, %struct.sv*** @PL_stack_base, align 8, !tbaa !19
  %136 = load %struct.av** %si_stack, align 8, !tbaa !108
  %sv_any409 = getelementptr inbounds %struct.av* %136, i64 0, i32 0
  %137 = load %struct.xpvav** %sv_any409, align 8, !tbaa !56
  %xav_max = getelementptr inbounds %struct.xpvav* %137, i64 0, i32 2
  %138 = load i64* %xav_max, align 8, !tbaa !109
  %add.ptr410 = getelementptr inbounds %struct.sv** %135, i64 %138
  store %struct.sv** %add.ptr410, %struct.sv*** @PL_stack_max, align 8, !tbaa !19
  %139 = load %struct.av** %si_stack, align 8, !tbaa !108
  %sv_any412 = getelementptr inbounds %struct.av* %139, i64 0, i32 0
  %140 = load %struct.xpvav** %sv_any412, align 8, !tbaa !56
  %xav_fill413 = getelementptr inbounds %struct.xpvav* %140, i64 0, i32 1
  %141 = load i64* %xav_fill413, align 8, !tbaa !59
  %add.ptr414 = getelementptr inbounds %struct.sv** %135, i64 %141
  store %struct.sv** %add.ptr414, %struct.sv*** @PL_stack_sp, align 8, !tbaa !19
  %142 = load %struct.av** %si_stack, align 8, !tbaa !108
  store %struct.av* %142, %struct.av** @PL_curstack, align 8, !tbaa !19
  store %struct.stackinfo* %next.0, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !19
  call void @Perl_push_scope() #2
  %call416 = call i32 (...)* @save_op() #2
  store %struct.op* %124, %struct.op** @PL_op, align 8, !tbaa !19
  %143 = load i64* @PL_perldb, align 8, !tbaa !29
  %and419 = and i64 %143, 1
  %tobool420 = icmp eq i64 %and419, 0
  br i1 %tobool420, label %if.end428, label %land.lhs.true421

land.lhs.true421:                                 ; preds = %if.end402
  %144 = load %struct.hv** @PL_curstash, align 8, !tbaa !19
  %145 = load %struct.hv** @PL_debstash, align 8, !tbaa !19
  %cmp422 = icmp eq %struct.hv* %144, %145
  br i1 %cmp422, label %if.end428, label %if.then424

if.then424:                                       ; preds = %land.lhs.true421
  %146 = getelementptr inbounds %struct.binop* %myop, i64 0, i32 7
  %147 = load i8* %146, align 1, !tbaa !110
  %or426 = or i8 %147, 16
  store i8 %or426, i8* %146, align 1, !tbaa !110
  br label %if.end428

if.end428:                                        ; preds = %land.lhs.true421, %if.end402, %if.then424
  store %struct.sv** %add.ptr414, %struct.sv*** @PL_stack_sp, align 8, !tbaa !19
  %call429 = call %struct.op* @Perl_pp_pushmark() #2
  %148 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !19
  %sub.ptr.lhs.cast430 = ptrtoint %struct.sv** %148 to i64
  %sub.ptr.rhs.cast431 = ptrtoint %struct.sv** %add.ptr414 to i64
  %sub.ptr.sub432 = sub i64 %sub.ptr.lhs.cast430, %sub.ptr.rhs.cast431
  %sub.ptr.div433 = ashr exact i64 %sub.ptr.sub432, 3
  %add434 = add nsw i32 %notfound.1, 5
  %conv435869 = zext i32 %add434 to i64
  %cmp436 = icmp slt i64 %sub.ptr.div433, %conv435869
  br i1 %cmp436, label %if.then438, label %if.end441

if.then438:                                       ; preds = %if.end428
  %call440 = call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr414, %struct.sv** %add.ptr414, i32 %add434) #2
  br label %if.end441

if.end441:                                        ; preds = %if.then438, %if.end428
  %sp.0 = phi %struct.sv** [ %call440, %if.then438 ], [ %add.ptr414, %if.end428 ]
  %cmp442 = icmp sgt i32 %lr.3, 0
  %cond447 = select i1 %cmp442, %struct.sv* %right.addr.2, %struct.sv* %left.addr.2
  %incdec.ptr = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %cond447, %struct.sv** %incdec.ptr, align 8, !tbaa !19
  %cond453 = select i1 %cmp442, %struct.sv* %left.addr.2, %struct.sv* %right.addr.2
  %incdec.ptr454 = getelementptr inbounds %struct.sv** %sp.0, i64 2
  store %struct.sv* %cond453, %struct.sv** %incdec.ptr454, align 8, !tbaa !19
  br i1 %cmp442, label %cond.end461, label %cond.false458

cond.false458:                                    ; preds = %if.end441
  %tobool459 = icmp ne i32 %assign.2, 0
  %cond460 = select i1 %tobool459, %struct.sv* @PL_sv_undef, %struct.sv* @PL_sv_no
  br label %cond.end461

cond.end461:                                      ; preds = %if.end441, %cond.false458
  %cond462 = phi %struct.sv* [ %cond460, %cond.false458 ], [ @PL_sv_yes, %if.end441 ]
  %incdec.ptr463 = getelementptr inbounds %struct.sv** %sp.0, i64 3
  store %struct.sv* %cond462, %struct.sv** %incdec.ptr463, align 8, !tbaa !19
  %tobool464 = icmp eq i32 %notfound.1, 0
  br i1 %tobool464, label %if.end473, label %if.then465

if.then465:                                       ; preds = %cond.end461
  %idxprom467 = sext i32 %add371 to i64
  %arrayidx468 = getelementptr inbounds [66 x i8*]* @PL_AMG_names, i64 0, i64 %idxprom467
  %149 = load i8** %arrayidx468, align 8, !tbaa !19
  %add.ptr469 = getelementptr inbounds i8* %149, i64 1
  %call470 = call %struct.sv* @Perl_newSVpv(i8* %add.ptr469, i64 0) #2
  %call471 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call470) #2
  %incdec.ptr472 = getelementptr inbounds %struct.sv** %sp.0, i64 4
  store %struct.sv* %call471, %struct.sv** %incdec.ptr472, align 8, !tbaa !19
  br label %if.end473

if.end473:                                        ; preds = %cond.end461, %if.then465
  %sp.1 = phi %struct.sv** [ %incdec.ptr472, %if.then465 ], [ %incdec.ptr463, %cond.end461 ]
  %150 = bitcast %struct.cv* %cv.13 to %struct.sv*
  %incdec.ptr474 = getelementptr inbounds %struct.sv** %sp.1, i64 1
  store %struct.sv* %150, %struct.sv** %incdec.ptr474, align 8, !tbaa !19
  store %struct.sv** %incdec.ptr474, %struct.sv*** @PL_stack_sp, align 8, !tbaa !19
  %call475 = call %struct.op* @Perl_pp_entersub() #2
  store %struct.op* %call475, %struct.op** @PL_op, align 8, !tbaa !19
  %tobool476 = icmp eq %struct.op* %call475, null
  br i1 %tobool476, label %if.end479, label %if.then477

if.then477:                                       ; preds = %if.end473
  %151 = load i32 ()** @PL_runops, align 8, !tbaa !19
  %call478 = call i32 %151() #2
  br label %if.end479

if.end479:                                        ; preds = %if.end473, %if.then477
  call void @Perl_pop_scope() #2
  %152 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !19
  %incdec.ptr480 = getelementptr inbounds %struct.sv** %152, i64 -1
  %153 = load %struct.sv** %152, align 8, !tbaa !19
  store %struct.sv** %incdec.ptr480, %struct.sv*** @PL_stack_sp, align 8, !tbaa !19
  %154 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !19
  %si_prev484 = getelementptr inbounds %struct.stackinfo* %154, i64 0, i32 5
  %155 = load %struct.stackinfo** %si_prev484, align 8, !tbaa !105
  %tobool485 = icmp eq %struct.stackinfo* %155, null
  br i1 %tobool485, label %if.then486, label %if.end513

if.then486:                                       ; preds = %if.end479
  %156 = load %struct.gv** @PL_stderrgv, align 8, !tbaa !19
  %tobool487 = icmp eq %struct.gv* %156, null
  br i1 %tobool487, label %cond.false508, label %land.lhs.true488

land.lhs.true488:                                 ; preds = %if.then486
  %sv_flags489 = getelementptr inbounds %struct.gv* %156, i64 0, i32 2
  %157 = load i64* %sv_flags489, align 8, !tbaa !27
  %and490 = and i64 %157, 255
  %cmp491 = icmp eq i64 %and490, 13
  br i1 %cmp491, label %land.lhs.true493, label %cond.false508

land.lhs.true493:                                 ; preds = %land.lhs.true488
  %sv_any494 = getelementptr inbounds %struct.gv* %156, i64 0, i32 0
  %158 = load %struct.xpvgv** %sv_any494, align 8, !tbaa !7
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %158, i64 0, i32 7
  %159 = load %struct.gp** %xgv_gp, align 8, !tbaa !9
  %gp_io = getelementptr inbounds %struct.gp* %159, i64 0, i32 2
  %160 = load %struct.io** %gp_io, align 8, !tbaa !15
  %tobool495 = icmp eq %struct.io* %160, null
  br i1 %tobool495, label %cond.false508, label %land.lhs.true496

land.lhs.true496:                                 ; preds = %land.lhs.true493
  %sv_any500 = getelementptr inbounds %struct.io* %160, i64 0, i32 0
  %161 = load %struct.xpvio** %sv_any500, align 8, !tbaa !23
  %xio_ofp = getelementptr inbounds %struct.xpvio* %161, i64 0, i32 8
  %162 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !112
  %tobool501 = icmp eq %struct._PerlIO** %162, null
  br i1 %tobool501, label %cond.false508, label %cond.end510

cond.false508:                                    ; preds = %land.lhs.true496, %land.lhs.true493, %if.then486, %land.lhs.true488
  %call509 = call %struct._PerlIO** @Perl_PerlIO_stderr() #2
  br label %cond.end510

cond.end510:                                      ; preds = %land.lhs.true496, %cond.false508
  %cond511 = phi %struct._PerlIO** [ %call509, %cond.false508 ], [ %162, %land.lhs.true496 ]
  %call512 = call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %cond511, i8* getelementptr inbounds ([17 x i8]* @.str79, i64 0, i64 0)) #2
  call void @Perl_my_exit(i64 1) #2
  br label %if.end513

if.end513:                                        ; preds = %if.end479, %cond.end510
  %163 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !19
  %sub.ptr.lhs.cast514 = ptrtoint %struct.sv** %incdec.ptr480 to i64
  %sub.ptr.rhs.cast515 = ptrtoint %struct.sv** %163 to i64
  %sub.ptr.sub516 = sub i64 %sub.ptr.lhs.cast514, %sub.ptr.rhs.cast515
  %sub.ptr.div517 = ashr exact i64 %sub.ptr.sub516, 3
  %164 = load %struct.av** @PL_curstack, align 8, !tbaa !19
  %sv_any518 = getelementptr inbounds %struct.av* %164, i64 0, i32 0
  %165 = load %struct.xpvav** %sv_any518, align 8, !tbaa !56
  %xav_fill519 = getelementptr inbounds %struct.xpvav* %165, i64 0, i32 1
  store i64 %sub.ptr.div517, i64* %xav_fill519, align 8, !tbaa !59
  %si_stack520 = getelementptr inbounds %struct.stackinfo* %155, i64 0, i32 0
  %166 = load %struct.av** %si_stack520, align 8, !tbaa !108
  %sv_any521 = getelementptr inbounds %struct.av* %166, i64 0, i32 0
  %167 = load %struct.xpvav** %sv_any521, align 8, !tbaa !56
  %xav_array522 = getelementptr inbounds %struct.xpvav* %167, i64 0, i32 0
  %168 = load i8** %xav_array522, align 8, !tbaa !61
  %169 = bitcast i8* %168 to %struct.sv**
  store %struct.sv** %169, %struct.sv*** @PL_stack_base, align 8, !tbaa !19
  %170 = load %struct.av** %si_stack520, align 8, !tbaa !108
  %sv_any524 = getelementptr inbounds %struct.av* %170, i64 0, i32 0
  %171 = load %struct.xpvav** %sv_any524, align 8, !tbaa !56
  %xav_max525 = getelementptr inbounds %struct.xpvav* %171, i64 0, i32 2
  %172 = load i64* %xav_max525, align 8, !tbaa !109
  %add.ptr526 = getelementptr inbounds %struct.sv** %169, i64 %172
  store %struct.sv** %add.ptr526, %struct.sv*** @PL_stack_max, align 8, !tbaa !19
  %173 = load %struct.av** %si_stack520, align 8, !tbaa !108
  %sv_any528 = getelementptr inbounds %struct.av* %173, i64 0, i32 0
  %174 = load %struct.xpvav** %sv_any528, align 8, !tbaa !56
  %xav_fill529 = getelementptr inbounds %struct.xpvav* %174, i64 0, i32 1
  %175 = load i64* %xav_fill529, align 8, !tbaa !59
  %add.ptr530 = getelementptr inbounds %struct.sv** %169, i64 %175
  store %struct.sv** %add.ptr530, %struct.sv*** @PL_stack_sp, align 8, !tbaa !19
  %176 = load %struct.av** %si_stack520, align 8, !tbaa !108
  store %struct.av* %176, %struct.av** @PL_curstack, align 8, !tbaa !19
  store %struct.stackinfo* %155, %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !19
  %177 = load %struct.jmpenv** @PL_top_env, align 8, !tbaa !19
  %je_mustcatch534 = getelementptr inbounds %struct.jmpenv* %177, i64 0, i32 3
  store i8 %123, i8* %je_mustcatch534, align 1, !tbaa !97
  %tobool535 = icmp eq i32 %postpr.5, 0
  br i1 %tobool535, label %if.else683, label %if.then536

if.then536:                                       ; preds = %if.end513
  switch i32 %method, label %sw.epilog680 [
    i32 29, label %sw.bb538
    i32 37, label %sw.bb538
    i32 28, label %sw.bb551
    i32 36, label %sw.bb551
    i32 31, label %sw.bb564
    i32 39, label %sw.bb564
    i32 30, label %sw.bb577
    i32 38, label %sw.bb577
    i32 32, label %sw.bb590
    i32 40, label %sw.bb590
    i32 33, label %sw.bb603
    i32 41, label %sw.bb603
    i32 44, label %sw.bb616
    i32 45, label %sw.bb616
    i32 42, label %sw.bb621
  ]

sw.bb538:                                         ; preds = %if.then536, %if.then536
  %sv_flags539 = getelementptr inbounds %struct.sv* %153, i64 0, i32 2
  %178 = load i64* %sv_flags539, align 8, !tbaa !1
  %and540 = and i64 %178, 65536
  %tobool541 = icmp eq i64 %and540, 0
  br i1 %tobool541, label %cond.false545, label %cond.true542

cond.true542:                                     ; preds = %sw.bb538
  %sv_any543 = getelementptr inbounds %struct.sv* %153, i64 0, i32 0
  %179 = load i8** %sv_any543, align 8, !tbaa !39
  %xiv_iv544 = getelementptr inbounds i8* %179, i64 24
  %180 = bitcast i8* %xiv_iv544 to i64*
  %181 = load i64* %180, align 8, !tbaa !92
  br label %cond.end547

cond.false545:                                    ; preds = %sw.bb538
  %call546 = call i64 @Perl_sv_2iv(%struct.sv* %153) #2
  br label %cond.end547

cond.end547:                                      ; preds = %cond.false545, %cond.true542
  %cond548 = phi i64 [ %181, %cond.true542 ], [ %call546, %cond.false545 ]
  %cmp549 = icmp slt i64 %cond548, 1
  %conv550 = zext i1 %cmp549 to i32
  br label %sw.epilog680

sw.bb551:                                         ; preds = %if.then536, %if.then536
  %sv_flags552 = getelementptr inbounds %struct.sv* %153, i64 0, i32 2
  %182 = load i64* %sv_flags552, align 8, !tbaa !1
  %and553 = and i64 %182, 65536
  %tobool554 = icmp eq i64 %and553, 0
  br i1 %tobool554, label %cond.false558, label %cond.true555

cond.true555:                                     ; preds = %sw.bb551
  %sv_any556 = getelementptr inbounds %struct.sv* %153, i64 0, i32 0
  %183 = load i8** %sv_any556, align 8, !tbaa !39
  %xiv_iv557 = getelementptr inbounds i8* %183, i64 24
  %184 = bitcast i8* %xiv_iv557 to i64*
  %185 = load i64* %184, align 8, !tbaa !92
  br label %cond.end560

cond.false558:                                    ; preds = %sw.bb551
  %call559 = call i64 @Perl_sv_2iv(%struct.sv* %153) #2
  br label %cond.end560

cond.end560:                                      ; preds = %cond.false558, %cond.true555
  %cond561 = phi i64 [ %185, %cond.true555 ], [ %call559, %cond.false558 ]
  %cond561.lobit = lshr i64 %cond561, 63
  %186 = trunc i64 %cond561.lobit to i32
  br label %sw.epilog680

sw.bb564:                                         ; preds = %if.then536, %if.then536
  %sv_flags565 = getelementptr inbounds %struct.sv* %153, i64 0, i32 2
  %187 = load i64* %sv_flags565, align 8, !tbaa !1
  %and566 = and i64 %187, 65536
  %tobool567 = icmp eq i64 %and566, 0
  br i1 %tobool567, label %cond.false571, label %cond.true568

cond.true568:                                     ; preds = %sw.bb564
  %sv_any569 = getelementptr inbounds %struct.sv* %153, i64 0, i32 0
  %188 = load i8** %sv_any569, align 8, !tbaa !39
  %xiv_iv570 = getelementptr inbounds i8* %188, i64 24
  %189 = bitcast i8* %xiv_iv570 to i64*
  %190 = load i64* %189, align 8, !tbaa !92
  br label %cond.end573

cond.false571:                                    ; preds = %sw.bb564
  %call572 = call i64 @Perl_sv_2iv(%struct.sv* %153) #2
  br label %cond.end573

cond.end573:                                      ; preds = %cond.false571, %cond.true568
  %cond574 = phi i64 [ %190, %cond.true568 ], [ %call572, %cond.false571 ]
  %cond574.lobit = lshr i64 %cond574, 63
  %191 = trunc i64 %cond574.lobit to i32
  %.not = xor i32 %191, 1
  br label %sw.epilog680

sw.bb577:                                         ; preds = %if.then536, %if.then536
  %sv_flags578 = getelementptr inbounds %struct.sv* %153, i64 0, i32 2
  %192 = load i64* %sv_flags578, align 8, !tbaa !1
  %and579 = and i64 %192, 65536
  %tobool580 = icmp eq i64 %and579, 0
  br i1 %tobool580, label %cond.false584, label %cond.true581

cond.true581:                                     ; preds = %sw.bb577
  %sv_any582 = getelementptr inbounds %struct.sv* %153, i64 0, i32 0
  %193 = load i8** %sv_any582, align 8, !tbaa !39
  %xiv_iv583 = getelementptr inbounds i8* %193, i64 24
  %194 = bitcast i8* %xiv_iv583 to i64*
  %195 = load i64* %194, align 8, !tbaa !92
  br label %cond.end586

cond.false584:                                    ; preds = %sw.bb577
  %call585 = call i64 @Perl_sv_2iv(%struct.sv* %153) #2
  br label %cond.end586

cond.end586:                                      ; preds = %cond.false584, %cond.true581
  %cond587 = phi i64 [ %195, %cond.true581 ], [ %call585, %cond.false584 ]
  %cmp588 = icmp sgt i64 %cond587, 0
  %conv589 = zext i1 %cmp588 to i32
  br label %sw.epilog680

sw.bb590:                                         ; preds = %if.then536, %if.then536
  %sv_flags591 = getelementptr inbounds %struct.sv* %153, i64 0, i32 2
  %196 = load i64* %sv_flags591, align 8, !tbaa !1
  %and592 = and i64 %196, 65536
  %tobool593 = icmp eq i64 %and592, 0
  br i1 %tobool593, label %cond.false597, label %cond.true594

cond.true594:                                     ; preds = %sw.bb590
  %sv_any595 = getelementptr inbounds %struct.sv* %153, i64 0, i32 0
  %197 = load i8** %sv_any595, align 8, !tbaa !39
  %xiv_iv596 = getelementptr inbounds i8* %197, i64 24
  %198 = bitcast i8* %xiv_iv596 to i64*
  %199 = load i64* %198, align 8, !tbaa !92
  br label %cond.end599

cond.false597:                                    ; preds = %sw.bb590
  %call598 = call i64 @Perl_sv_2iv(%struct.sv* %153) #2
  br label %cond.end599

cond.end599:                                      ; preds = %cond.false597, %cond.true594
  %cond600 = phi i64 [ %199, %cond.true594 ], [ %call598, %cond.false597 ]
  %cmp601 = icmp eq i64 %cond600, 0
  %conv602 = zext i1 %cmp601 to i32
  br label %sw.epilog680

sw.bb603:                                         ; preds = %if.then536, %if.then536
  %sv_flags604 = getelementptr inbounds %struct.sv* %153, i64 0, i32 2
  %200 = load i64* %sv_flags604, align 8, !tbaa !1
  %and605 = and i64 %200, 65536
  %tobool606 = icmp eq i64 %and605, 0
  br i1 %tobool606, label %cond.false610, label %cond.true607

cond.true607:                                     ; preds = %sw.bb603
  %sv_any608 = getelementptr inbounds %struct.sv* %153, i64 0, i32 0
  %201 = load i8** %sv_any608, align 8, !tbaa !39
  %xiv_iv609 = getelementptr inbounds i8* %201, i64 24
  %202 = bitcast i8* %xiv_iv609 to i64*
  %203 = load i64* %202, align 8, !tbaa !92
  br label %cond.end612

cond.false610:                                    ; preds = %sw.bb603
  %call611 = call i64 @Perl_sv_2iv(%struct.sv* %153) #2
  br label %cond.end612

cond.end612:                                      ; preds = %cond.false610, %cond.true607
  %cond613 = phi i64 [ %203, %cond.true607 ], [ %call611, %cond.false610 ]
  %cmp614 = icmp ne i64 %cond613, 0
  %conv615 = zext i1 %cmp614 to i32
  br label %sw.epilog680

sw.bb616:                                         ; preds = %if.then536, %if.then536
  %cmp617 = icmp eq %struct.sv* %left.addr.2, %153
  br i1 %cmp617, label %return, label %if.then619

if.then619:                                       ; preds = %sw.bb616
  call void @Perl_sv_setsv_flags(%struct.sv* %left.addr.2, %struct.sv* %153, i64 2) #2
  br label %return

sw.bb621:                                         ; preds = %if.then536
  %tobool622 = icmp eq %struct.sv* %153, null
  br i1 %tobool622, label %cond.end677, label %cond.false624

cond.false624:                                    ; preds = %sw.bb621
  %sv_flags625 = getelementptr inbounds %struct.sv* %153, i64 0, i32 2
  %204 = load i64* %sv_flags625, align 8, !tbaa !1
  %and626 = and i64 %204, 262144
  %tobool627 = icmp eq i64 %and626, 0
  br i1 %tobool627, label %cond.false650, label %cond.true628

cond.true628:                                     ; preds = %cond.false624
  %sv_any629 = getelementptr inbounds %struct.sv* %153, i64 0, i32 0
  %205 = load i8** %sv_any629, align 8, !tbaa !39
  %206 = bitcast i8* %205 to %struct.xpv*
  store %struct.xpv* %206, %struct.xpv** @PL_Xpv, align 8, !tbaa !19
  %tobool630 = icmp eq i8* %205, null
  br i1 %tobool630, label %land.end647, label %land.rhs631

land.rhs631:                                      ; preds = %cond.true628
  %xpv_cur632 = getelementptr inbounds i8* %205, i64 8
  %207 = bitcast i8* %xpv_cur632 to i64*
  %208 = load i64* %207, align 8, !tbaa !62
  %cmp633 = icmp ugt i64 %208, 1
  br i1 %cmp633, label %land.end647, label %lor.rhs635

lor.rhs635:                                       ; preds = %land.rhs631
  %tobool637 = icmp eq i64 %208, 0
  br i1 %tobool637, label %land.end647, label %land.rhs638

land.rhs638:                                      ; preds = %lor.rhs635
  %xpv_pv639 = bitcast i8* %205 to i8**
  %209 = load i8** %xpv_pv639, align 8, !tbaa !30
  %210 = load i8* %209, align 1, !tbaa !26
  %cmp641 = icmp ne i8 %210, 48
  br label %land.end647

land.end647:                                      ; preds = %lor.rhs635, %cond.true628, %land.rhs631, %land.rhs638
  %211 = phi i1 [ false, %cond.true628 ], [ true, %land.rhs631 ], [ false, %lor.rhs635 ], [ %cmp641, %land.rhs638 ]
  %cond649 = zext i1 %211 to i32
  br label %cond.end677

cond.false650:                                    ; preds = %cond.false624
  %and652 = and i64 %204, 65536
  %tobool653 = icmp eq i64 %and652, 0
  br i1 %tobool653, label %cond.false659, label %cond.true654

cond.true654:                                     ; preds = %cond.false650
  %sv_any655 = getelementptr inbounds %struct.sv* %153, i64 0, i32 0
  %212 = load i8** %sv_any655, align 8, !tbaa !39
  %xiv_iv656 = getelementptr inbounds i8* %212, i64 24
  %213 = bitcast i8* %xiv_iv656 to i64*
  %214 = load i64* %213, align 8, !tbaa !92
  %cmp657 = icmp ne i64 %214, 0
  %conv658 = zext i1 %cmp657 to i32
  br label %cond.end677

cond.false659:                                    ; preds = %cond.false650
  %and661 = and i64 %204, 131072
  %tobool662 = icmp eq i64 %and661, 0
  br i1 %tobool662, label %cond.false668, label %cond.true663

cond.true663:                                     ; preds = %cond.false659
  %sv_any664 = getelementptr inbounds %struct.sv* %153, i64 0, i32 0
  %215 = load i8** %sv_any664, align 8, !tbaa !39
  %xnv_nv665 = getelementptr inbounds i8* %215, i64 32
  %216 = bitcast i8* %xnv_nv665 to double*
  %217 = load double* %216, align 8, !tbaa !76
  %cmp666 = fcmp une double %217, 0.000000e+00
  %conv667 = zext i1 %cmp666 to i32
  br label %cond.end677

cond.false668:                                    ; preds = %cond.false659
  %call669 = call signext i8 @Perl_sv_2bool(%struct.sv* %153) #2
  %conv670 = sext i8 %call669 to i32
  br label %cond.end677

cond.end677:                                      ; preds = %sw.bb621, %land.end647, %cond.true663, %cond.false668, %cond.true654
  %cond678 = phi i32 [ 0, %sw.bb621 ], [ %cond649, %land.end647 ], [ %conv658, %cond.true654 ], [ %conv667, %cond.true663 ], [ %conv670, %cond.false668 ]
  %lnot = icmp eq i32 %cond678, 0
  %lnot.ext = zext i1 %lnot to i32
  br label %sw.epilog680

sw.epilog680:                                     ; preds = %if.then536, %cond.end677, %cond.end612, %cond.end599, %cond.end586, %cond.end573, %cond.end560, %cond.end547
  %ans.0 = phi i32 [ 0, %if.then536 ], [ %lnot.ext, %cond.end677 ], [ %conv615, %cond.end612 ], [ %conv602, %cond.end599 ], [ %conv589, %cond.end586 ], [ %.not, %cond.end573 ], [ %186, %cond.end560 ], [ %conv550, %cond.end547 ]
  %tobool681 = icmp ne i32 %ans.0, 0
  %cond682 = select i1 %tobool681, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  br label %return

if.else683:                                       ; preds = %if.end513
  %cmp684 = icmp eq i32 %method, 56
  br i1 %cmp684, label %if.then686, label %return

if.then686:                                       ; preds = %if.else683
  %sv_flags687 = getelementptr inbounds %struct.sv* %153, i64 0, i32 2
  %218 = load i64* %sv_flags687, align 8, !tbaa !1
  %and688 = and i64 %218, 524288
  %tobool689 = icmp eq i64 %and688, 0
  br i1 %tobool689, label %if.then690, label %if.end691

if.then690:                                       ; preds = %if.then686
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([39 x i8]* @.str80, i64 0, i64 0)) #2
  br label %if.end691

if.end691:                                        ; preds = %if.then686, %if.then690
  %sv_any692 = getelementptr inbounds %struct.sv* %153, i64 0, i32 0
  %219 = load i8** %sv_any692, align 8, !tbaa !39
  %xrv_rv693 = bitcast i8* %219 to %struct.sv**
  %220 = load %struct.sv** %xrv_rv693, align 8, !tbaa !95
  store %struct.sv* %220, %struct.sv** @PL_Sv, align 8, !tbaa !19
  %tobool694 = icmp eq %struct.sv* %220, null
  br i1 %tobool694, label %return, label %land.rhs695

land.rhs695:                                      ; preds = %if.end691
  %sv_refcnt696 = getelementptr inbounds %struct.sv* %220, i64 0, i32 1
  %221 = load i64* %sv_refcnt696, align 8, !tbaa !22
  %inc697 = add i64 %221, 1
  store i64 %inc697, i64* %sv_refcnt696, align 8, !tbaa !22
  br label %return

return:                                           ; preds = %land.rhs695, %if.end691, %if.then117, %sw.epilog680, %sw.bb616, %if.then619, %if.else683, %if.else358, %land.lhs.true353, %not_found, %if.then260, %if.then260, %if.then260, %if.then260, %if.then32, %if.then32, %if.end185, %sw.bb203, %land.end
  %retval.1 = phi %struct.sv* [ %left, %sw.bb203 ], [ %call92, %land.end ], [ %left, %if.end185 ], [ null, %if.then32 ], [ null, %if.then32 ], [ null, %if.then260 ], [ null, %if.then260 ], [ null, %if.then260 ], [ null, %if.then260 ], [ %left.addr.1, %not_found ], [ null, %land.lhs.true353 ], [ null, %if.else358 ], [ %cond682, %sw.epilog680 ], [ %left.addr.2, %sw.bb616 ], [ %left.addr.2, %if.then619 ], [ %153, %if.else683 ], [ %left, %if.then117 ], [ null, %if.end691 ], [ %220, %land.rhs695 ]
  ret %struct.sv* %retval.1
}

declare %struct.sv* @Perl_newSVsv(%struct.sv*) #1

declare %struct.sv* @Perl_newSViv(i64) #1

declare double @Perl_sv_2nv(%struct.sv*) #1

declare %struct.stackinfo* @Perl_new_stackinfo(i64, i64) #1

declare i32 @save_op(...) #1

declare %struct.op* @Perl_pp_pushmark() #1

declare %struct.sv** @Perl_stack_grow(%struct.sv**, %struct.sv**, i32) #1

declare %struct.sv* @Perl_newSVpv(i8*, i64) #1

declare %struct.op* @Perl_pp_entersub() #1

declare i32 @PerlIO_printf(%struct._PerlIO**, i8*, ...) #1

declare %struct._PerlIO** @Perl_PerlIO_stderr() #1

declare void @Perl_my_exit(i64) #1

declare i64 @Perl_sv_2iv(%struct.sv*) #1

; Function Attrs: nounwind readonly uwtable
define signext i8 @Perl_is_gv_magical(i8* readonly %name, i64 %len, i64 %flags) #5 {
entry:
  %cmp = icmp ugt i64 %len, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %add.ptr = getelementptr inbounds i8* %name, i64 1
  %0 = load i8* %name, align 1, !tbaa !26
  %conv = sext i8 %0 to i32
  switch i32 %conv, label %if.end73 [
    i32 57, label %sw.bb57
    i32 79, label %sw.bb12
    i32 83, label %sw.bb18
    i32 15, label %sw.bb33
    i32 20, label %sw.bb38
    i32 21, label %sw.bb43
    i32 23, label %sw.bb52
    i32 49, label %sw.bb57
    i32 50, label %sw.bb57
    i32 51, label %sw.bb57
    i32 52, label %sw.bb57
    i32 53, label %sw.bb57
    i32 54, label %sw.bb57
    i32 55, label %sw.bb57
    i32 56, label %sw.bb57
  ]

sw.bb12:                                          ; preds = %if.then
  %cmp13 = icmp eq i64 %len, 8
  br i1 %cmp13, label %land.lhs.true15, label %if.end73

land.lhs.true15:                                  ; preds = %sw.bb12
  %call = tail call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([8 x i8]* @.str42, i64 0, i64 0)) #2
  %tobool = icmp eq i32 %call, 0
  br i1 %tobool, label %return, label %if.end73

sw.bb18:                                          ; preds = %if.then
  %cmp19 = icmp eq i64 %len, 3
  br i1 %cmp19, label %land.lhs.true21, label %if.end73

land.lhs.true21:                                  ; preds = %sw.bb18
  %1 = load i8* %add.ptr, align 1, !tbaa !26
  %cmp24 = icmp eq i8 %1, 73
  br i1 %cmp24, label %land.lhs.true26, label %if.end73

land.lhs.true26:                                  ; preds = %land.lhs.true21
  %arrayidx27 = getelementptr inbounds i8* %name, i64 2
  %2 = load i8* %arrayidx27, align 1, !tbaa !26
  %cmp29 = icmp eq i8 %2, 71
  br i1 %cmp29, label %return, label %if.end73

sw.bb33:                                          ; preds = %if.then
  %call34 = tail call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([4 x i8]* @.str46, i64 0, i64 0)) #2
  %tobool35 = icmp eq i32 %call34, 0
  br i1 %tobool35, label %return, label %if.end73

sw.bb38:                                          ; preds = %if.then
  %call39 = tail call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([5 x i8]* @.str47, i64 0, i64 0)) #2
  %tobool40 = icmp eq i32 %call39, 0
  br i1 %tobool40, label %return, label %if.end73

sw.bb43:                                          ; preds = %if.then
  %call44 = tail call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([7 x i8]* @.str48, i64 0, i64 0)) #2
  %tobool45 = icmp eq i32 %call44, 0
  br i1 %tobool45, label %return, label %if.end47

if.end47:                                         ; preds = %sw.bb43
  %call48 = tail call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([10 x i8]* @.str49, i64 0, i64 0)) #2
  %tobool49 = icmp eq i32 %call48, 0
  br i1 %tobool49, label %return, label %if.end73

sw.bb52:                                          ; preds = %if.then
  %call53 = tail call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([12 x i8]* @.str50, i64 0, i64 0)) #2
  %tobool54 = icmp eq i32 %call53, 0
  br i1 %tobool54, label %return, label %if.end73

sw.bb57:                                          ; preds = %if.then, %if.then, %if.then, %if.then, %if.then, %if.then, %if.then, %if.then, %if.then
  %add.ptr58 = getelementptr inbounds i8* %name, i64 %len
  br label %while.cond

while.cond:                                       ; preds = %while.body, %sw.bb57
  %end.0 = phi i8* [ %add.ptr58, %sw.bb57 ], [ %incdec.ptr, %while.body ]
  %incdec.ptr = getelementptr inbounds i8* %end.0, i64 -1
  %cmp59 = icmp ugt i8* %incdec.ptr, %name
  br i1 %cmp59, label %while.body, label %return

while.body:                                       ; preds = %while.cond
  %3 = load i8* %incdec.ptr, align 1, !tbaa !26
  %.off = add i8 %3, -48
  %4 = icmp ult i8 %.off, 10
  br i1 %4, label %while.cond, label %return

if.else:                                          ; preds = %entry
  %5 = load i8* %name, align 1, !tbaa !26
  %conv70 = sext i8 %5 to i32
  switch i32 %conv70, label %if.end73 [
    i32 38, label %return
    i32 96, label %return
    i32 39, label %return
    i32 58, label %return
    i32 63, label %return
    i32 33, label %return
    i32 45, label %return
    i32 42, label %return
    i32 35, label %return
    i32 91, label %return
    i32 94, label %return
    i32 126, label %return
    i32 61, label %return
    i32 37, label %return
    i32 46, label %return
    i32 40, label %return
    i32 41, label %return
    i32 60, label %return
    i32 62, label %return
    i32 44, label %return
    i32 92, label %return
    i32 47, label %return
    i32 124, label %return
    i32 43, label %return
    i32 59, label %return
    i32 93, label %return
    i32 1, label %return
    i32 3, label %return
    i32 4, label %return
    i32 5, label %return
    i32 6, label %return
    i32 8, label %return
    i32 9, label %return
    i32 12, label %return
    i32 14, label %return
    i32 15, label %return
    i32 16, label %return
    i32 19, label %return
    i32 20, label %return
    i32 22, label %return
    i32 23, label %return
    i32 49, label %return
    i32 50, label %return
    i32 51, label %return
    i32 52, label %return
    i32 53, label %return
    i32 54, label %return
    i32 55, label %return
    i32 56, label %return
    i32 57, label %return
  ]

if.end73:                                         ; preds = %land.lhs.true15, %sw.bb33, %sw.bb38, %if.end47, %sw.bb52, %if.else, %if.then, %sw.bb12, %land.lhs.true26, %land.lhs.true21, %sw.bb18
  br label %return

return:                                           ; preds = %while.cond, %while.body, %land.lhs.true26, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %if.else, %sw.bb52, %sw.bb43, %if.end47, %sw.bb38, %sw.bb33, %land.lhs.true15, %if.end73
  %retval.0 = phi i8 [ 0, %if.end73 ], [ 1, %land.lhs.true15 ], [ 1, %sw.bb33 ], [ 1, %sw.bb38 ], [ 1, %if.end47 ], [ 1, %sw.bb43 ], [ 1, %sw.bb52 ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %if.else ], [ 1, %land.lhs.true26 ], [ 1, %while.cond ], [ 0, %while.body ]
  ret i8 %retval.0
}

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind }
attributes #3 = { nounwind readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readonly uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5 (trunk)"}
!1 = metadata !{metadata !2, metadata !6, i64 16}
!2 = metadata !{metadata !"sv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!3 = metadata !{metadata !"any pointer", metadata !4, i64 0}
!4 = metadata !{metadata !"omnipotent char", metadata !5, i64 0}
!5 = metadata !{metadata !"Simple C/C++ TBAA"}
!6 = metadata !{metadata !"long", metadata !4, i64 0}
!7 = metadata !{metadata !8, metadata !3, i64 0}
!8 = metadata !{metadata !"gv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!9 = metadata !{metadata !10, metadata !3, i64 56}
!10 = metadata !{metadata !"xpvgv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !11, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !3, i64 64, metadata !6, i64 72, metadata !3, i64 80, metadata !4, i64 88}
!11 = metadata !{metadata !"double", metadata !4, i64 0}
!12 = metadata !{metadata !13, metadata !3, i64 32}
!13 = metadata !{metadata !"gp", metadata !3, i64 0, metadata !6, i64 8, metadata !3, i64 16, metadata !3, i64 24, metadata !3, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !6, i64 64, metadata !6, i64 72, metadata !6, i64 80, metadata !3, i64 88}
!14 = metadata !{metadata !13, metadata !3, i64 40}
!15 = metadata !{metadata !13, metadata !3, i64 16}
!16 = metadata !{metadata !17, metadata !6, i64 8}
!17 = metadata !{metadata !"io", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!18 = metadata !{metadata !17, metadata !6, i64 16}
!19 = metadata !{metadata !3, metadata !3, i64 0}
!20 = metadata !{metadata !21, metadata !3, i64 0}
!21 = metadata !{metadata !"hv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!22 = metadata !{metadata !2, metadata !6, i64 8}
!23 = metadata !{metadata !17, metadata !3, i64 0}
!24 = metadata !{metadata !25, metadata !3, i64 48}
!25 = metadata !{metadata !"xpvmg", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !11, i64 32, metadata !3, i64 40, metadata !3, i64 48}
!26 = metadata !{metadata !4, metadata !4, i64 0}
!27 = metadata !{metadata !8, metadata !6, i64 16}
!28 = metadata !{metadata !13, metadata !3, i64 0}
!29 = metadata !{metadata !6, metadata !6, i64 0}
!30 = metadata !{metadata !31, metadata !3, i64 0}
!31 = metadata !{metadata !"xpv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!32 = metadata !{metadata !31, metadata !6, i64 16}
!33 = metadata !{metadata !13, metadata !6, i64 8}
!34 = metadata !{metadata !35, metadata !6, i64 80}
!35 = metadata !{metadata !"cop", metadata !3, i64 0, metadata !3, i64 8, metadata !3, i64 16, metadata !6, i64 24, metadata !36, i64 32, metadata !36, i64 34, metadata !4, i64 36, metadata !4, i64 37, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !6, i64 64, metadata !6, i64 72, metadata !6, i64 80, metadata !3, i64 88, metadata !3, i64 96}
!36 = metadata !{metadata !"short", metadata !4, i64 0}
!37 = metadata !{metadata !13, metadata !6, i64 80}
!38 = metadata !{metadata !35, metadata !3, i64 56}
!39 = metadata !{metadata !2, metadata !3, i64 0}
!40 = metadata !{metadata !13, metadata !3, i64 88}
!41 = metadata !{metadata !13, metadata !6, i64 64}
!42 = metadata !{metadata !13, metadata !3, i64 48}
!43 = metadata !{metadata !10, metadata !3, i64 80}
!44 = metadata !{metadata !10, metadata !3, i64 64}
!45 = metadata !{metadata !10, metadata !6, i64 72}
!46 = metadata !{metadata !10, metadata !4, i64 88}
!47 = metadata !{metadata !13, metadata !3, i64 56}
!48 = metadata !{metadata !49, metadata !3, i64 0}
!49 = metadata !{metadata !"cv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!50 = metadata !{metadata !51, metadata !3, i64 96}
!51 = metadata !{metadata !"xpvcv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !11, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !3, i64 64, metadata !3, i64 72, metadata !3, i64 80, metadata !4, i64 88, metadata !3, i64 96, metadata !3, i64 104, metadata !6, i64 112, metadata !3, i64 120, metadata !3, i64 128, metadata !36, i64 136, metadata !6, i64 144}
!52 = metadata !{metadata !51, metadata !3, i64 104}
!53 = metadata !{metadata !51, metadata !3, i64 56}
!54 = metadata !{metadata !55, metadata !3, i64 80}
!55 = metadata !{metadata !"xpvhv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !11, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !6, i64 56, metadata !3, i64 64, metadata !3, i64 72, metadata !3, i64 80}
!56 = metadata !{metadata !57, metadata !3, i64 0}
!57 = metadata !{metadata !"av", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!58 = metadata !{metadata !25, metadata !3, i64 40}
!59 = metadata !{metadata !60, metadata !6, i64 8}
!60 = metadata !{metadata !"xpvav", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !11, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !3, i64 64, metadata !4, i64 72}
!61 = metadata !{metadata !60, metadata !3, i64 0}
!62 = metadata !{metadata !31, metadata !6, i64 8}
!63 = metadata !{metadata !35, metadata !3, i64 88}
!64 = metadata !{metadata !51, metadata !3, i64 72}
!65 = metadata !{metadata !51, metadata !3, i64 80}
!66 = metadata !{metadata !21, metadata !6, i64 16}
!67 = metadata !{metadata !35, metadata !3, i64 48}
!68 = metadata !{metadata !51, metadata !36, i64 136}
!69 = metadata !{metadata !21, metadata !6, i64 8}
!70 = metadata !{metadata !35, metadata !4, i64 37}
!71 = metadata !{metadata !72, metadata !4, i64 163}
!72 = metadata !{metadata !"xpvio", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !11, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !3, i64 64, metadata !4, i64 72, metadata !6, i64 80, metadata !6, i64 88, metadata !6, i64 96, metadata !6, i64 104, metadata !3, i64 112, metadata !3, i64 120, metadata !3, i64 128, metadata !3, i64 136, metadata !3, i64 144, metadata !3, i64 152, metadata !36, i64 160, metadata !4, i64 162, metadata !4, i64 163}
!73 = metadata !{metadata !74, metadata !74, i64 0}
!74 = metadata !{metadata !"int", metadata !4, i64 0}
!75 = metadata !{metadata !57, metadata !6, i64 16}
!76 = metadata !{metadata !77, metadata !11, i64 32}
!77 = metadata !{metadata !"xpvnv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !11, i64 32}
!78 = metadata !{metadata !55, metadata !6, i64 16}
!79 = metadata !{metadata !80, metadata !3, i64 8}
!80 = metadata !{metadata !"he", metadata !3, i64 0, metadata !3, i64 8, metadata !3, i64 16}
!81 = metadata !{metadata !82, metadata !6, i64 8}
!82 = metadata !{metadata !"hek", metadata !6, i64 0, metadata !6, i64 8, metadata !4, i64 16}
!83 = metadata !{metadata !80, metadata !3, i64 16}
!84 = metadata !{metadata !13, metadata !3, i64 24}
!85 = metadata !{metadata !86, metadata !3, i64 32}
!86 = metadata !{metadata !"magic", metadata !3, i64 0, metadata !3, i64 8, metadata !36, i64 16, metadata !4, i64 18, metadata !4, i64 19, metadata !3, i64 24, metadata !3, i64 32, metadata !6, i64 40}
!87 = metadata !{metadata !88, metadata !6, i64 16}
!88 = metadata !{metadata !"am_table", metadata !6, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !4, i64 24, metadata !6, i64 552}
!89 = metadata !{metadata !88, metadata !6, i64 8}
!90 = metadata !{metadata !88, metadata !6, i64 0}
!91 = metadata !{metadata !88, metadata !6, i64 552}
!92 = metadata !{metadata !93, metadata !6, i64 24}
!93 = metadata !{metadata !"xpviv", metadata !3, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24}
!94 = metadata !{metadata !49, metadata !6, i64 16}
!95 = metadata !{metadata !96, metadata !3, i64 0}
!96 = metadata !{metadata !"xrv", metadata !3, i64 0}
!97 = metadata !{metadata !98, metadata !4, i64 212}
!98 = metadata !{metadata !"jmpenv", metadata !4, i64 0, metadata !3, i64 200, metadata !74, i64 208, metadata !4, i64 212}
!99 = metadata !{metadata !100, metadata !3, i64 48}
!100 = metadata !{metadata !"binop", metadata !3, i64 0, metadata !3, i64 8, metadata !3, i64 16, metadata !6, i64 24, metadata !36, i64 32, metadata !36, i64 34, metadata !4, i64 36, metadata !4, i64 37, metadata !3, i64 40, metadata !3, i64 48}
!101 = metadata !{metadata !100, metadata !3, i64 0}
!102 = metadata !{metadata !100, metadata !4, i64 36}
!103 = metadata !{metadata !104, metadata !3, i64 48}
!104 = metadata !{metadata !"stackinfo", metadata !3, i64 0, metadata !3, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !6, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !6, i64 56}
!105 = metadata !{metadata !104, metadata !3, i64 40}
!106 = metadata !{metadata !104, metadata !6, i64 32}
!107 = metadata !{metadata !104, metadata !6, i64 16}
!108 = metadata !{metadata !104, metadata !3, i64 0}
!109 = metadata !{metadata !60, metadata !6, i64 16}
!110 = metadata !{metadata !111, metadata !4, i64 37}
!111 = metadata !{metadata !"op", metadata !3, i64 0, metadata !3, i64 8, metadata !3, i64 16, metadata !6, i64 24, metadata !36, i64 32, metadata !36, i64 34, metadata !4, i64 36, metadata !4, i64 37}
!112 = metadata !{metadata !72, metadata !3, i64 64}
