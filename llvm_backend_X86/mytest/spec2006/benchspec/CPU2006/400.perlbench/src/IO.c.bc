; ModuleID = 'IO.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.sv = type { i8*, i64, i64 }
%struct.op = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8 }
%struct.cv = type { %struct.xpvcv*, i64, i64 }
%struct.xpvcv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.hv*, %struct.op*, %struct.op*, {}*, %union.any, %struct.gv*, i8*, i64, %struct.av*, %struct.cv*, i16, i64 }
%struct.magic = type { %struct.magic*, %struct.mgvtbl*, i16, i8, i8, %struct.sv*, i8*, i64 }
%struct.mgvtbl = type { i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i64 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)*, i32 (%struct.magic*, %struct.clone_params*)* }
%struct.clone_params = type { %struct.av*, i64, %struct.interpreter* }
%struct.interpreter = type { i8 }
%struct.hv = type { %struct.xpvhv*, i64, i64 }
%struct.xpvhv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, i64, %struct.he*, %struct.pmop*, i8* }
%struct.he = type { %struct.he*, %struct.hek*, %struct.sv* }
%struct.hek = type { i64, i64, [1 x i8] }
%struct.pmop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.pmop*, %struct.regexp*, i64, i64, i8, %struct.hv* }
%struct.regexp = type { i64*, i64*, %struct.regnode*, %struct.reg_substr_data*, i8*, %struct.reg_data*, i8*, i64*, i64, i64, i64, i64, i64, i64, i64, i64, [1 x %struct.regnode] }
%struct.regnode = type { i8, i8, i16 }
%struct.reg_substr_data = type opaque
%struct.reg_data = type opaque
%union.any = type { i8* }
%struct.gv = type { %struct.xpvgv*, i64, i64 }
%struct.xpvgv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.gp*, i8*, i64, %struct.hv*, i8 }
%struct.gp = type { %struct.sv*, i64, %struct.io*, %struct.cv*, %struct.av*, %struct.hv*, %struct.gv*, %struct.cv*, i64, i64, i64, i8* }
%struct.io = type { %struct.xpvio*, i64, i64 }
%struct.xpvio = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct._PerlIO**, %struct._PerlIO**, %union.anon, i64, i64, i64, i64, i8*, %struct.gv*, i8*, %struct.gv*, i8*, %struct.gv*, i16, i8, i8 }
%struct._PerlIO = type opaque
%union.anon = type { %struct.__dirstream* }
%struct.__dirstream = type opaque
%struct.av = type { %struct.xpvav*, i64, i64 }
%struct.xpvav = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.sv**, %struct.sv*, i8 }
%struct.pollfd = type { i32, i16, i16 }

@PL_stack_sp = external global %struct.sv**
@PL_stack_base = external global %struct.sv**
@PL_markstack_ptr = external global i64*
@.str = private unnamed_addr constant [36 x i8] c"Usage: IO::Seekable::getpos(handle)\00", align 1
@PL_sv_undef = external global %struct.sv
@.str1 = private unnamed_addr constant [41 x i8] c"Usage: IO::Seekable::setpos(handle, pos)\00", align 1
@.str2 = private unnamed_addr constant [11 x i8] c"0 but true\00", align 1
@.str3 = private unnamed_addr constant [52 x i8] c"Usage: IO::File::new_tmpfile(packname = \22IO::File\22)\00", align 1
@.str4 = private unnamed_addr constant [9 x i8] c"IO::File\00", align 1
@PL_Sv = external global %struct.sv*
@.str5 = private unnamed_addr constant [4 x i8] c"+>&\00", align 1
@.str6 = private unnamed_addr constant [37 x i8] c"Usage: IO::Poll::_poll(timeout, ...)\00", align 1
@.str7 = private unnamed_addr constant [44 x i8] c"Usage: IO::Handle::blocking(handle, blk=-1)\00", align 1
@.str8 = private unnamed_addr constant [37 x i8] c"Usage: IO::Handle::ungetc(handle, c)\00", align 1
@PL_op = external global %struct.op*
@PL_curpad = external global %struct.sv**
@.str9 = private unnamed_addr constant [33 x i8] c"Usage: IO::Handle::error(handle)\00", align 1
@.str10 = private unnamed_addr constant [36 x i8] c"Usage: IO::Handle::clearerr(handle)\00", align 1
@.str11 = private unnamed_addr constant [35 x i8] c"Usage: IO::Handle::untaint(handle)\00", align 1
@.str12 = private unnamed_addr constant [33 x i8] c"Usage: IO::Handle::flush(handle)\00", align 1
@.str13 = private unnamed_addr constant [39 x i8] c"Usage: IO::Handle::setbuf(handle, ...)\00", align 1
@.str14 = private unnamed_addr constant [19 x i8] c"IO::Handle::setbuf\00", align 1
@.str15 = private unnamed_addr constant [52 x i8] c"Usage: IO::Handle::setvbuf(handle, buf, type, size)\00", align 1
@.str16 = private unnamed_addr constant [20 x i8] c"IO::Handle::setvbuf\00", align 1
@.str17 = private unnamed_addr constant [32 x i8] c"Usage: IO::Handle::sync(handle)\00", align 1
@.str18 = private unnamed_addr constant [17 x i8] c"IO::Handle::sync\00", align 1
@.str19 = private unnamed_addr constant [36 x i8] c"Usage: IO::Socket::sockatmark(sock)\00", align 1
@.str20 = private unnamed_addr constant [5 x i8] c"IO.c\00", align 1
@.str21 = private unnamed_addr constant [21 x i8] c"IO::Seekable::getpos\00", align 1
@.str22 = private unnamed_addr constant [21 x i8] c"IO::Seekable::setpos\00", align 1
@.str23 = private unnamed_addr constant [22 x i8] c"IO::File::new_tmpfile\00", align 1
@.str24 = private unnamed_addr constant [16 x i8] c"IO::Poll::_poll\00", align 1
@.str25 = private unnamed_addr constant [21 x i8] c"IO::Handle::blocking\00", align 1
@.str26 = private unnamed_addr constant [4 x i8] c"$;$\00", align 1
@.str27 = private unnamed_addr constant [19 x i8] c"IO::Handle::ungetc\00", align 1
@.str28 = private unnamed_addr constant [18 x i8] c"IO::Handle::error\00", align 1
@.str29 = private unnamed_addr constant [21 x i8] c"IO::Handle::clearerr\00", align 1
@.str30 = private unnamed_addr constant [20 x i8] c"IO::Handle::untaint\00", align 1
@.str31 = private unnamed_addr constant [18 x i8] c"IO::Handle::flush\00", align 1
@.str32 = private unnamed_addr constant [23 x i8] c"IO::Socket::sockatmark\00", align 1
@.str33 = private unnamed_addr constant [2 x i8] c"$\00", align 1
@.str34 = private unnamed_addr constant [9 x i8] c"IO::Poll\00", align 1
@.str35 = private unnamed_addr constant [7 x i8] c"POLLIN\00", align 1
@.str36 = private unnamed_addr constant [8 x i8] c"POLLPRI\00", align 1
@.str37 = private unnamed_addr constant [8 x i8] c"POLLOUT\00", align 1
@.str38 = private unnamed_addr constant [11 x i8] c"POLLRDNORM\00", align 1
@.str39 = private unnamed_addr constant [11 x i8] c"POLLWRNORM\00", align 1
@.str40 = private unnamed_addr constant [11 x i8] c"POLLRDBAND\00", align 1
@.str41 = private unnamed_addr constant [11 x i8] c"POLLWRBAND\00", align 1
@.str42 = private unnamed_addr constant [9 x i8] c"POLLNORM\00", align 1
@.str43 = private unnamed_addr constant [8 x i8] c"POLLERR\00", align 1
@.str44 = private unnamed_addr constant [8 x i8] c"POLLHUP\00", align 1
@.str45 = private unnamed_addr constant [9 x i8] c"POLLNVAL\00", align 1
@.str46 = private unnamed_addr constant [11 x i8] c"IO::Handle\00", align 1
@.str47 = private unnamed_addr constant [7 x i8] c"_IOFBF\00", align 1
@.str48 = private unnamed_addr constant [7 x i8] c"_IOLBF\00", align 1
@.str49 = private unnamed_addr constant [7 x i8] c"_IONBF\00", align 1
@.str50 = private unnamed_addr constant [9 x i8] c"SEEK_SET\00", align 1
@.str51 = private unnamed_addr constant [9 x i8] c"SEEK_CUR\00", align 1
@.str52 = private unnamed_addr constant [9 x i8] c"SEEK_END\00", align 1
@PL_sv_yes = external global %struct.sv
@.str53 = private unnamed_addr constant [40 x i8] c"%s not implemented on this architecture\00", align 1

; Function Attrs: nounwind uwtable
define void @XS_IO__Seekable_getpos(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp eq i64 %sub.ptr.sub3, 8
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([36 x i8]* @.str, i64 0, i64 0)) #2
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %call = tail call %struct.io* @Perl_sv_2io(%struct.sv* %5) #2
  %sv_any = getelementptr inbounds %struct.io* %call, i64 0, i32 0
  %6 = load %struct.xpvio** %sv_any, align 8, !tbaa !7
  %xio_ifp = getelementptr inbounds %struct.xpvio* %6, i64 0, i32 7
  %7 = load %struct._PerlIO*** %xio_ifp, align 8, !tbaa !9
  %tobool = icmp eq %struct._PerlIO** %7, null
  br i1 %tobool, label %if.else, label %if.then6

if.then6:                                         ; preds = %if.end
  %call7 = tail call %struct.sv* @Perl_newSV(i64 0) #2
  %call8 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call7) #2
  %8 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx10 = getelementptr inbounds %struct.sv** %8, i64 %add
  store %struct.sv* %call8, %struct.sv** %arrayidx10, align 8, !tbaa !1
  %9 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx12 = getelementptr inbounds %struct.sv** %9, i64 %add
  %10 = load %struct.sv** %arrayidx12, align 8, !tbaa !1
  %call13 = tail call i32 @PerlIO_getpos(%struct._PerlIO** %7, %struct.sv* %10) #2
  %cmp14 = icmp eq i32 %call13, 0
  br i1 %cmp14, label %if.end22, label %if.then15

if.then15:                                        ; preds = %if.then6
  %11 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx17 = getelementptr inbounds %struct.sv** %11, i64 %add
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx17, align 8, !tbaa !1
  br label %if.end22

if.else:                                          ; preds = %if.end
  %12 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx20 = getelementptr inbounds %struct.sv** %12, i64 %add
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx20, align 8, !tbaa !1
  %call21 = tail call i32* @__errno_location() #2
  store i32 22, i32* %call21, align 4, !tbaa !13
  br label %if.end22

if.end22:                                         ; preds = %if.then6, %if.then15, %if.else
  %13 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr23 = getelementptr inbounds %struct.sv** %13, i64 %add
  store %struct.sv** %add.ptr23, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare void @Perl_croak(i8*, ...) #1

declare %struct.io* @Perl_sv_2io(%struct.sv*) #1

declare %struct.sv* @Perl_sv_2mortal(%struct.sv*) #1

declare %struct.sv* @Perl_newSV(i64) #1

declare i32 @PerlIO_getpos(%struct._PerlIO**, %struct.sv*) #1

declare i32* @__errno_location() #1

; Function Attrs: nounwind uwtable
define void @XS_IO__Seekable_setpos(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp eq i64 %sub.ptr.sub3, 16
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([41 x i8]* @.str1, i64 0, i64 0)) #2
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %call = tail call %struct.io* @Perl_sv_2io(%struct.sv* %5) #2
  %sv_any = getelementptr inbounds %struct.io* %call, i64 0, i32 0
  %6 = load %struct.xpvio** %sv_any, align 8, !tbaa !7
  %xio_ifp = getelementptr inbounds %struct.xpvio* %6, i64 0, i32 7
  %7 = load %struct._PerlIO*** %xio_ifp, align 8, !tbaa !9
  %tobool = icmp eq %struct._PerlIO** %7, null
  br i1 %tobool, label %if.else, label %if.then8

if.then8:                                         ; preds = %if.end
  %8 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add6 = add nsw i64 %sub.ptr.div, 2
  %arrayidx7 = getelementptr inbounds %struct.sv** %8, i64 %add6
  %9 = load %struct.sv** %arrayidx7, align 8, !tbaa !1
  %call9 = tail call i32 @PerlIO_setpos(%struct._PerlIO** %7, %struct.sv* %9) #2
  br label %if.end11

if.else:                                          ; preds = %if.end
  %call10 = tail call i32* @__errno_location() #2
  store i32 22, i32* %call10, align 4, !tbaa !13
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then8
  %RETVAL.0 = phi i32 [ %call9, %if.then8 ], [ -1, %if.else ]
  %call12 = tail call %struct.sv* @Perl_sv_newmortal() #2
  %10 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx14 = getelementptr inbounds %struct.sv** %10, i64 %add
  store %struct.sv* %call12, %struct.sv** %arrayidx14, align 8, !tbaa !1
  %cmp15 = icmp eq i32 %RETVAL.0, -1
  br i1 %cmp15, label %if.end25, label %if.then16

if.then16:                                        ; preds = %if.end11
  %cmp17 = icmp eq i32 %RETVAL.0, 0
  %11 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx20 = getelementptr inbounds %struct.sv** %11, i64 %add
  %12 = load %struct.sv** %arrayidx20, align 8, !tbaa !1
  br i1 %cmp17, label %if.then18, label %if.else21

if.then18:                                        ; preds = %if.then16
  tail call void @Perl_sv_setpvn(%struct.sv* %12, i8* getelementptr inbounds ([11 x i8]* @.str2, i64 0, i64 0), i64 10) #2
  br label %if.end25

if.else21:                                        ; preds = %if.then16
  %conv = sext i32 %RETVAL.0 to i64
  tail call void @Perl_sv_setiv(%struct.sv* %12, i64 %conv) #2
  br label %if.end25

if.end25:                                         ; preds = %if.end11, %if.then18, %if.else21
  %13 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr26 = getelementptr inbounds %struct.sv** %13, i64 %add
  store %struct.sv** %add.ptr26, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare i32 @PerlIO_setpos(%struct._PerlIO**, %struct.sv*) #1

declare %struct.sv* @Perl_sv_newmortal() #1

declare void @Perl_sv_setpvn(%struct.sv*, i8*, i64) #1

declare void @Perl_sv_setiv(%struct.sv*, i64) #1

; Function Attrs: nounwind uwtable
define void @XS_IO__File_new_tmpfile(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %4 = icmp ugt i64 %sub.ptr.sub3, 8
  br i1 %4, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([52 x i8]* @.str3, i64 0, i64 0)) #2
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %cmp6 = icmp slt i64 %sub.ptr.sub3, 8
  br i1 %cmp6, label %if.end14, label %if.else

if.else:                                          ; preds = %if.end
  %5 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.sv** %5, i64 %add
  %6 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i64* %sv_flags, align 8, !tbaa !15
  %and = and i64 %7, 262144
  %cmp9 = icmp eq i64 %and, 0
  br i1 %cmp9, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %sv_any = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !17
  %xpv_pv = bitcast i8* %8 to i8**
  %9 = load i8** %xpv_pv, align 8, !tbaa !18
  br label %if.end14

cond.false:                                       ; preds = %if.else
  %call = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %6) #2
  br label %if.end14

if.end14:                                         ; preds = %cond.true, %cond.false, %if.end
  %packname.0 = phi i8* [ getelementptr inbounds ([9 x i8]* @.str4, i64 0, i64 0), %if.end ], [ %9, %cond.true ], [ %call, %cond.false ]
  %call15 = tail call %struct._PerlIO** @PerlIO_tmpfile() #2
  %call16 = tail call %struct.gv* @Perl_newGVgen(i8* %packname.0) #2
  %10 = bitcast %struct.gv* %call16 to %struct.sv*
  store %struct.sv* %10, %struct.sv** @PL_Sv, align 8, !tbaa !1
  %tobool = icmp eq %struct.gv* %call16, null
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end14
  %11 = getelementptr inbounds %struct.gv* %call16, i64 0, i32 1
  %12 = load i64* %11, align 8, !tbaa !20
  %inc = add i64 %12, 1
  store i64 %inc, i64* %11, align 8, !tbaa !20
  br label %land.end

land.end:                                         ; preds = %if.end14, %land.rhs
  %sv_any18 = getelementptr inbounds %struct.gv* %call16, i64 0, i32 0
  %13 = load %struct.xpvgv** %sv_any18, align 8, !tbaa !21
  %xgv_stash = getelementptr inbounds %struct.xpvgv* %13, i64 0, i32 10
  %14 = load %struct.hv** %xgv_stash, align 8, !tbaa !23
  %xgv_name = getelementptr inbounds %struct.xpvgv* %13, i64 0, i32 8
  %15 = load i8** %xgv_name, align 8, !tbaa !25
  %xgv_namelen = getelementptr inbounds %struct.xpvgv* %13, i64 0, i32 9
  %16 = load i64* %xgv_namelen, align 8, !tbaa !26
  %call21 = tail call %struct.sv* @Perl_hv_delete(%struct.hv* %14, i8* %15, i64 %16, i64 2) #2
  %call22 = tail call signext i8 @Perl_do_open(%struct.gv* %call16, i8* getelementptr inbounds ([4 x i8]* @.str5, i64 0, i64 0), i64 3, i32 0, i32 0, i32 0, %struct._PerlIO** %call15) #2
  %tobool23 = icmp eq i8 %call22, 0
  br i1 %tobool23, label %if.else33, label %if.then24

if.then24:                                        ; preds = %land.end
  %call25 = tail call %struct.sv* @Perl_newRV(%struct.sv* %10) #2
  %call26 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call25) #2
  %17 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx28 = getelementptr inbounds %struct.sv** %17, i64 %add
  store %struct.sv* %call26, %struct.sv** %arrayidx28, align 8, !tbaa !1
  %18 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx30 = getelementptr inbounds %struct.sv** %18, i64 %add
  %19 = load %struct.sv** %arrayidx30, align 8, !tbaa !1
  %call31 = tail call %struct.hv* @Perl_gv_stashpv(i8* %packname.0, i64 1) #2
  %call32 = tail call %struct.sv* @Perl_sv_bless(%struct.sv* %19, %struct.hv* %call31) #2
  tail call void @Perl_sv_free(%struct.sv* %10) #2
  br label %if.end36

if.else33:                                        ; preds = %land.end
  %20 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx35 = getelementptr inbounds %struct.sv** %20, i64 %add
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx35, align 8, !tbaa !1
  tail call void @Perl_sv_free(%struct.sv* %10) #2
  br label %if.end36

if.end36:                                         ; preds = %if.else33, %if.then24
  %21 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr37 = getelementptr inbounds %struct.sv** %21, i64 %add
  store %struct.sv** %add.ptr37, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare i8* @Perl_sv_2pv_nolen(%struct.sv*) #1

declare %struct._PerlIO** @PerlIO_tmpfile() #1

declare %struct.gv* @Perl_newGVgen(i8*) #1

declare %struct.sv* @Perl_hv_delete(%struct.hv*, i8*, i64, i64) #1

declare signext i8 @Perl_do_open(%struct.gv*, i8*, i64, i32, i32, i32, %struct._PerlIO**) #1

declare %struct.sv* @Perl_newRV(%struct.sv*) #1

declare %struct.sv* @Perl_sv_bless(%struct.sv*, %struct.hv*) #1

declare %struct.hv* @Perl_gv_stashpv(i8*, i64) #1

declare void @Perl_sv_free(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define void @XS_IO__Poll__poll(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %sub.ptr.div4 = ashr exact i64 %sub.ptr.sub3, 3
  %cmp = icmp slt i64 %sub.ptr.sub3, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([37 x i8]* @.str6, i64 0, i64 0)) #2
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = phi %struct.sv** [ %.pre, %if.then ], [ %1, %entry ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i64* %sv_flags, align 8, !tbaa !15
  %and = and i64 %6, 65536
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %7 = load i8** %sv_any, align 8, !tbaa !17
  %xiv_iv = getelementptr inbounds i8* %7, i64 24
  %8 = bitcast i8* %xiv_iv to i64*
  %9 = load i64* %8, align 8, !tbaa !27
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = tail call i64 @Perl_sv_2iv(%struct.sv* %5) #2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %9, %cond.true ], [ %call, %cond.false ]
  %conv = trunc i64 %cond to i32
  %sub = add nsw i64 %sub.ptr.div4, -1
  %div = sdiv i64 %sub, 2
  %conv11 = trunc i64 %div to i32
  %sext = shl i64 %div, 32
  %conv12 = ashr exact i64 %sext, 32
  %mul = ashr exact i64 %sext, 29
  %call13 = tail call %struct.sv* @Perl_newSV(i64 %mul) #2
  %sv_any14 = getelementptr inbounds %struct.sv* %call13, i64 0, i32 0
  %10 = load i8** %sv_any14, align 8, !tbaa !17
  %xpv_pv = bitcast i8* %10 to i8**
  %11 = load i8** %xpv_pv, align 8, !tbaa !18
  %12 = bitcast i8* %11 to %struct.pollfd*
  %cmp15143 = icmp sgt i32 %conv11, 0
  br i1 %cmp15143, label %for.body, label %for.end

for.body:                                         ; preds = %cond.end, %cond.end55
  %indvars.iv152 = phi i64 [ %indvars.iv.next153, %cond.end55 ], [ 0, %cond.end ]
  %indvars.iv149 = phi i64 [ %indvars.iv.next150, %cond.end55 ], [ 1, %cond.end ]
  %add18 = add nsw i64 %indvars.iv149, %add
  %13 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx19 = getelementptr inbounds %struct.sv** %13, i64 %add18
  %14 = load %struct.sv** %arrayidx19, align 8, !tbaa !1
  %sv_flags20 = getelementptr inbounds %struct.sv* %14, i64 0, i32 2
  %15 = load i64* %sv_flags20, align 8, !tbaa !15
  %and21 = and i64 %15, 65536
  %tobool22 = icmp eq i64 %and21, 0
  br i1 %tobool22, label %cond.false29, label %cond.true23

cond.true23:                                      ; preds = %for.body
  %sv_any27 = getelementptr inbounds %struct.sv* %14, i64 0, i32 0
  %16 = load i8** %sv_any27, align 8, !tbaa !17
  %xiv_iv28 = getelementptr inbounds i8* %16, i64 24
  %17 = bitcast i8* %xiv_iv28 to i64*
  %18 = load i64* %17, align 8, !tbaa !27
  br label %cond.end34

cond.false29:                                     ; preds = %for.body
  %call33 = tail call i64 @Perl_sv_2iv(%struct.sv* %14) #2
  %.pre156 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %cond.end34

cond.end34:                                       ; preds = %cond.false29, %cond.true23
  %19 = phi %struct.sv** [ %13, %cond.true23 ], [ %.pre156, %cond.false29 ]
  %cond35 = phi i64 [ %18, %cond.true23 ], [ %call33, %cond.false29 ]
  %conv36 = trunc i64 %cond35 to i32
  %fd = getelementptr inbounds %struct.pollfd* %12, i64 %indvars.iv152, i32 0
  store i32 %conv36, i32* %fd, align 4, !tbaa !29
  %20 = add nsw i64 %indvars.iv149, 1
  %add39 = add nsw i64 %20, %add
  %arrayidx40 = getelementptr inbounds %struct.sv** %19, i64 %add39
  %21 = load %struct.sv** %arrayidx40, align 8, !tbaa !1
  %sv_flags41 = getelementptr inbounds %struct.sv* %21, i64 0, i32 2
  %22 = load i64* %sv_flags41, align 8, !tbaa !15
  %and42 = and i64 %22, 65536
  %tobool43 = icmp eq i64 %and42, 0
  br i1 %tobool43, label %cond.false50, label %cond.true44

cond.true44:                                      ; preds = %cond.end34
  %sv_any48 = getelementptr inbounds %struct.sv* %21, i64 0, i32 0
  %23 = load i8** %sv_any48, align 8, !tbaa !17
  %xiv_iv49 = getelementptr inbounds i8* %23, i64 24
  %24 = bitcast i8* %xiv_iv49 to i64*
  %25 = load i64* %24, align 8, !tbaa !27
  br label %cond.end55

cond.false50:                                     ; preds = %cond.end34
  %call54 = tail call i64 @Perl_sv_2iv(%struct.sv* %21) #2
  br label %cond.end55

cond.end55:                                       ; preds = %cond.false50, %cond.true44
  %cond56 = phi i64 [ %25, %cond.true44 ], [ %call54, %cond.false50 ]
  %conv57 = trunc i64 %cond56 to i16
  %events = getelementptr inbounds %struct.pollfd* %12, i64 %indvars.iv152, i32 1
  store i16 %conv57, i16* %events, align 2, !tbaa !31
  %indvars.iv.next150 = add nuw nsw i64 %indvars.iv149, 2
  %revents = getelementptr inbounds %struct.pollfd* %12, i64 %indvars.iv152, i32 2
  store i16 0, i16* %revents, align 2, !tbaa !32
  %indvars.iv.next153 = add nuw nsw i64 %indvars.iv152, 1
  %lftr.wideiv154 = trunc i64 %indvars.iv.next153 to i32
  %exitcond155 = icmp eq i32 %lftr.wideiv154, %conv11
  br i1 %exitcond155, label %for.end, label %for.body

for.end:                                          ; preds = %cond.end55, %cond.end
  %call65 = tail call i32 @Perl_my_poll(%struct.pollfd* %12, i64 %conv12, i32 %conv) #2
  %cmp66.not = icmp slt i32 %call65, 0
  %cmp15143.not = xor i1 %cmp15143, true
  %brmerge = or i1 %cmp66.not, %cmp15143.not
  br i1 %brmerge, label %if.end92, label %for.body72

for.body72:                                       ; preds = %for.end, %for.body72
  %indvars.iv147 = phi i64 [ %indvars.iv.next148, %for.body72 ], [ 0, %for.end ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body72 ], [ 1, %for.end ]
  %add74 = add nsw i64 %indvars.iv, %add
  %26 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx75 = getelementptr inbounds %struct.sv** %26, i64 %add74
  %27 = load %struct.sv** %arrayidx75, align 8, !tbaa !1
  %fd78 = getelementptr inbounds %struct.pollfd* %12, i64 %indvars.iv147, i32 0
  %28 = load i32* %fd78, align 4, !tbaa !29
  %conv79 = sext i32 %28 to i64
  tail call void @Perl_sv_setiv(%struct.sv* %27, i64 %conv79) #2
  %29 = add nsw i64 %indvars.iv, 1
  %add82 = add nsw i64 %29, %add
  %30 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx83 = getelementptr inbounds %struct.sv** %30, i64 %add82
  %31 = load %struct.sv** %arrayidx83, align 8, !tbaa !1
  %revents86 = getelementptr inbounds %struct.pollfd* %12, i64 %indvars.iv147, i32 2
  %32 = load i16* %revents86, align 2, !tbaa !32
  %conv87 = sext i16 %32 to i64
  tail call void @Perl_sv_setiv(%struct.sv* %31, i64 %conv87) #2
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 2
  %indvars.iv.next148 = add nuw nsw i64 %indvars.iv147, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next148 to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %conv11
  br i1 %exitcond, label %if.end92, label %for.body72

if.end92:                                         ; preds = %for.body72, %for.end
  tail call void @Perl_sv_free(%struct.sv* %call13) #2
  %conv93 = sext i32 %call65 to i64
  %call94 = tail call %struct.sv* @Perl_newSViv(i64 %conv93) #2
  %call95 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call94) #2
  %33 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx97 = getelementptr inbounds %struct.sv** %33, i64 %add
  store %struct.sv* %call95, %struct.sv** %arrayidx97, align 8, !tbaa !1
  %34 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr98 = getelementptr inbounds %struct.sv** %34, i64 %add
  store %struct.sv** %add.ptr98, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare i64 @Perl_sv_2iv(%struct.sv*) #1

declare i32 @Perl_my_poll(%struct.pollfd*, i64, i32) #1

declare %struct.sv* @Perl_newSViv(i64) #1

; Function Attrs: nounwind uwtable
define void @XS_IO__Handle_blocking(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %sub.ptr.sub3.off = add i64 %sub.ptr.sub3, -8
  %4 = icmp ugt i64 %sub.ptr.sub3.off, 8
  br i1 %4, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([44 x i8]* @.str7, i64 0, i64 0)) #2
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %5 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %5, i64 %add
  %6 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %call = tail call %struct.io* @Perl_sv_2io(%struct.sv* %6) #2
  %sv_any = getelementptr inbounds %struct.io* %call, i64 0, i32 0
  %7 = load %struct.xpvio** %sv_any, align 8, !tbaa !7
  %xio_ifp = getelementptr inbounds %struct.xpvio* %7, i64 0, i32 7
  %8 = load %struct._PerlIO*** %xio_ifp, align 8, !tbaa !9
  %cmp7 = icmp slt i64 %sub.ptr.sub3, 16
  br i1 %cmp7, label %if.end17, label %if.else

if.else:                                          ; preds = %if.end
  %add9 = add nsw i64 %sub.ptr.div, 2
  %9 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx10 = getelementptr inbounds %struct.sv** %9, i64 %add9
  %10 = load %struct.sv** %arrayidx10, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %10, i64 0, i32 2
  %11 = load i64* %sv_flags, align 8, !tbaa !15
  %and = and i64 %11, 65536
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %sv_any13 = getelementptr inbounds %struct.sv* %10, i64 0, i32 0
  %12 = load i8** %sv_any13, align 8, !tbaa !17
  %xiv_iv = getelementptr inbounds i8* %12, i64 24
  %13 = bitcast i8* %xiv_iv to i64*
  %14 = load i64* %13, align 8, !tbaa !27
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %call16 = tail call i64 @Perl_sv_2iv(%struct.sv* %10) #2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %14, %cond.true ], [ %call16, %cond.false ]
  %conv = trunc i64 %cond to i32
  br label %if.end17

if.end17:                                         ; preds = %if.end, %cond.end
  %blk.0 = phi i32 [ %conv, %cond.end ], [ -1, %if.end ]
  %cmp18 = icmp eq i64 %sub.ptr.sub3, 8
  br i1 %cmp18, label %cond.end24, label %cond.false21

cond.false21:                                     ; preds = %if.end17
  %tobool22 = icmp ne i32 %blk.0, 0
  %cond23 = zext i1 %tobool22 to i32
  br label %cond.end24

cond.end24:                                       ; preds = %if.end17, %cond.false21
  %cond25 = phi i32 [ %cond23, %cond.false21 ], [ -1, %if.end17 ]
  %tobool.i = icmp eq %struct._PerlIO** %8, null
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %cond.end24
  %call.i = tail call i32* @__errno_location() #2
  store i32 9, i32* %call.i, align 4, !tbaa !13
  br label %if.else37

if.end.i:                                         ; preds = %cond.end24
  %call1.i = tail call i32 @Perl_PerlIO_fileno(%struct._PerlIO** %8) #2
  %call2.i = tail call i32 (i32, i32, ...)* @fcntl(i32 %call1.i, i32 3, i32 0) #2
  %cmp.i = icmp sgt i32 %call2.i, -1
  br i1 %cmp.i, label %if.then3.i, label %if.else37

if.then3.i:                                       ; preds = %if.end.i
  %and.i = lshr i32 %call2.i, 11
  %and.lobit.i = and i32 %and.i, 1
  %15 = xor i32 %and.lobit.i, 1
  %cmp5.i = icmp eq i32 %cond25, 0
  br i1 %cmp5.i, label %if.then6.i, label %if.else.i

if.then6.i:                                       ; preds = %if.then3.i
  %or.i = or i32 %call2.i, 2048
  br label %if.end12.i

if.else.i:                                        ; preds = %if.then3.i
  %cmp8.i = icmp sgt i32 %cond25, 0
  %and10.i = and i32 %call2.i, -2049
  %and10.call2.i = select i1 %cmp8.i, i32 %and10.i, i32 %call2.i
  br label %if.end12.i

if.end12.i:                                       ; preds = %if.else.i, %if.then6.i
  %newmode.0.i = phi i32 [ %or.i, %if.then6.i ], [ %and10.call2.i, %if.else.i ]
  %cmp13.i = icmp eq i32 %newmode.0.i, %call2.i
  br i1 %cmp13.i, label %io_blocking.exit, label %if.then14.i

if.then14.i:                                      ; preds = %if.end12.i
  %call15.i = tail call i32 @Perl_PerlIO_fileno(%struct._PerlIO** %8) #2
  %call16.i = tail call i32 (i32, i32, ...)* @fcntl(i32 %call15.i, i32 4, i32 %newmode.0.i) #2
  %cmp17.i = icmp slt i32 %call16.i, 0
  %call16..i = select i1 %cmp17.i, i32 %call16.i, i32 %15
  br label %io_blocking.exit

io_blocking.exit:                                 ; preds = %if.end12.i, %if.then14.i
  %call2655 = phi i32 [ %call16..i, %if.then14.i ], [ %15, %if.end12.i ]
  %cmp27 = icmp sgt i32 %call2655, -1
  br i1 %cmp27, label %if.then29, label %if.else37

if.then29:                                        ; preds = %io_blocking.exit
  %conv30 = sext i32 %call2655 to i64
  %call31 = tail call %struct.sv* @Perl_newSViv(i64 %conv30) #2
  %call32 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call31) #2
  %16 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx34 = getelementptr inbounds %struct.sv** %16, i64 %add
  store %struct.sv* %call32, %struct.sv** %arrayidx34, align 8, !tbaa !1
  br label %return

if.else37:                                        ; preds = %if.end.i, %if.then.i, %io_blocking.exit
  %17 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx39 = getelementptr inbounds %struct.sv** %17, i64 %add
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx39, align 8, !tbaa !1
  br label %return

return:                                           ; preds = %if.else37, %if.then29
  %.pn = load %struct.sv*** @PL_stack_base, align 8
  %storemerge = getelementptr inbounds %struct.sv** %.pn, i64 %add
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

; Function Attrs: nounwind uwtable
define void @XS_IO__Handle_ungetc(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp eq i64 %sub.ptr.sub3, 16
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([37 x i8]* @.str8, i64 0, i64 0)) #2
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %call = tail call %struct.io* @Perl_sv_2io(%struct.sv* %5) #2
  %sv_any = getelementptr inbounds %struct.io* %call, i64 0, i32 0
  %6 = load %struct.xpvio** %sv_any, align 8, !tbaa !7
  %xio_ifp = getelementptr inbounds %struct.xpvio* %6, i64 0, i32 7
  %7 = load %struct._PerlIO*** %xio_ifp, align 8, !tbaa !9
  %add6 = add nsw i64 %sub.ptr.div, 2
  %8 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx7 = getelementptr inbounds %struct.sv** %8, i64 %add6
  %9 = load %struct.sv** %arrayidx7, align 8, !tbaa !1
  %sv_flags = getelementptr inbounds %struct.sv* %9, i64 0, i32 2
  %10 = load i64* %sv_flags, align 8, !tbaa !15
  %and = and i64 %10, 65536
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %sv_any10 = getelementptr inbounds %struct.sv* %9, i64 0, i32 0
  %11 = load i8** %sv_any10, align 8, !tbaa !17
  %xiv_iv = getelementptr inbounds i8* %11, i64 24
  %12 = bitcast i8* %xiv_iv to i64*
  %13 = load i64* %12, align 8, !tbaa !27
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call13 = tail call i64 @Perl_sv_2iv(%struct.sv* %9) #2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %13, %cond.true ], [ %call13, %cond.false ]
  %conv = trunc i64 %cond to i32
  %14 = load %struct.op** @PL_op, align 8, !tbaa !1
  %op_private = getelementptr inbounds %struct.op* %14, i64 0, i32 7
  %15 = load i8* %op_private, align 1, !tbaa !33
  %and15 = and i8 %15, 32
  %tobool16 = icmp eq i8 %and15, 0
  br i1 %tobool16, label %cond.false19, label %cond.true17

cond.true17:                                      ; preds = %cond.end
  %op_targ = getelementptr inbounds %struct.op* %14, i64 0, i32 3
  %16 = load i64* %op_targ, align 8, !tbaa !35
  %17 = load %struct.sv*** @PL_curpad, align 8, !tbaa !1
  %arrayidx18 = getelementptr inbounds %struct.sv** %17, i64 %16
  %18 = load %struct.sv** %arrayidx18, align 8, !tbaa !1
  br label %cond.end21

cond.false19:                                     ; preds = %cond.end
  %call20 = tail call %struct.sv* @Perl_sv_newmortal() #2
  br label %cond.end21

cond.end21:                                       ; preds = %cond.false19, %cond.true17
  %cond22 = phi %struct.sv* [ %18, %cond.true17 ], [ %call20, %cond.false19 ]
  %tobool23 = icmp eq %struct._PerlIO** %7, null
  br i1 %tobool23, label %if.else, label %if.then24

if.then24:                                        ; preds = %cond.end21
  %call25 = tail call i32 @PerlIO_ungetc(%struct._PerlIO** %7, i32 %conv) #2
  %phitmp = sext i32 %call25 to i64
  br label %if.end27

if.else:                                          ; preds = %cond.end21
  %call26 = tail call i32* @__errno_location() #2
  store i32 22, i32* %call26, align 4, !tbaa !13
  br label %if.end27

if.end27:                                         ; preds = %if.else, %if.then24
  %RETVAL.0 = phi i64 [ %phitmp, %if.then24 ], [ -1, %if.else ]
  %19 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  tail call void @Perl_sv_setiv(%struct.sv* %cond22, i64 %RETVAL.0) #2
  %sv_flags31 = getelementptr inbounds %struct.sv* %cond22, i64 0, i32 2
  %20 = load i64* %sv_flags31, align 8, !tbaa !15
  %and32 = and i64 %20, 16384
  %tobool33 = icmp eq i64 %and32, 0
  br i1 %tobool33, label %if.end36, label %if.then34

if.then34:                                        ; preds = %if.end27
  %call35 = tail call i32 @Perl_mg_set(%struct.sv* %cond22) #2
  br label %if.end36

if.end36:                                         ; preds = %if.end27, %if.then34
  %incdec.ptr37 = getelementptr inbounds %struct.sv** %19, i64 %add
  store %struct.sv* %cond22, %struct.sv** %incdec.ptr37, align 8, !tbaa !1
  %21 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr39 = getelementptr inbounds %struct.sv** %21, i64 %add
  store %struct.sv** %add.ptr39, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare i32 @PerlIO_ungetc(%struct._PerlIO**, i32) #1

declare i32 @Perl_mg_set(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define void @XS_IO__Handle_error(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp eq i64 %sub.ptr.sub3, 8
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([33 x i8]* @.str9, i64 0, i64 0)) #2
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %call = tail call %struct.io* @Perl_sv_2io(%struct.sv* %5) #2
  %sv_any = getelementptr inbounds %struct.io* %call, i64 0, i32 0
  %6 = load %struct.xpvio** %sv_any, align 8, !tbaa !7
  %xio_ifp = getelementptr inbounds %struct.xpvio* %6, i64 0, i32 7
  %7 = load %struct._PerlIO*** %xio_ifp, align 8, !tbaa !9
  %8 = load %struct.op** @PL_op, align 8, !tbaa !1
  %op_private = getelementptr inbounds %struct.op* %8, i64 0, i32 7
  %9 = load i8* %op_private, align 1, !tbaa !33
  %and = and i8 %9, 32
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %op_targ = getelementptr inbounds %struct.op* %8, i64 0, i32 3
  %10 = load i64* %op_targ, align 8, !tbaa !35
  %11 = load %struct.sv*** @PL_curpad, align 8, !tbaa !1
  %arrayidx6 = getelementptr inbounds %struct.sv** %11, i64 %10
  %12 = load %struct.sv** %arrayidx6, align 8, !tbaa !1
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call7 = tail call %struct.sv* @Perl_sv_newmortal() #2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %12, %cond.true ], [ %call7, %cond.false ]
  %tobool8 = icmp eq %struct._PerlIO** %7, null
  br i1 %tobool8, label %if.else, label %if.then9

if.then9:                                         ; preds = %cond.end
  %call10 = tail call i32 @Perl_PerlIO_error(%struct._PerlIO** %7) #2
  %phitmp = sext i32 %call10 to i64
  br label %if.end12

if.else:                                          ; preds = %cond.end
  %call11 = tail call i32* @__errno_location() #2
  store i32 22, i32* %call11, align 4, !tbaa !13
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then9
  %RETVAL.0 = phi i64 [ %phitmp, %if.then9 ], [ -1, %if.else ]
  %13 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %RETVAL.0) #2
  %sv_flags = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %14 = load i64* %sv_flags, align 8, !tbaa !15
  %and16 = and i64 %14, 16384
  %tobool17 = icmp eq i64 %and16, 0
  br i1 %tobool17, label %if.end20, label %if.then18

if.then18:                                        ; preds = %if.end12
  %call19 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #2
  br label %if.end20

if.end20:                                         ; preds = %if.end12, %if.then18
  %incdec.ptr21 = getelementptr inbounds %struct.sv** %13, i64 %add
  store %struct.sv* %cond, %struct.sv** %incdec.ptr21, align 8, !tbaa !1
  %15 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr23 = getelementptr inbounds %struct.sv** %15, i64 %add
  store %struct.sv** %add.ptr23, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare i32 @Perl_PerlIO_error(%struct._PerlIO**) #1

; Function Attrs: nounwind uwtable
define void @XS_IO__Handle_clearerr(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp eq i64 %sub.ptr.sub3, 8
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([36 x i8]* @.str10, i64 0, i64 0)) #2
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %call = tail call %struct.io* @Perl_sv_2io(%struct.sv* %5) #2
  %sv_any = getelementptr inbounds %struct.io* %call, i64 0, i32 0
  %6 = load %struct.xpvio** %sv_any, align 8, !tbaa !7
  %xio_ifp = getelementptr inbounds %struct.xpvio* %6, i64 0, i32 7
  %7 = load %struct._PerlIO*** %xio_ifp, align 8, !tbaa !9
  %8 = load %struct.op** @PL_op, align 8, !tbaa !1
  %op_private = getelementptr inbounds %struct.op* %8, i64 0, i32 7
  %9 = load i8* %op_private, align 1, !tbaa !33
  %and = and i8 %9, 32
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %op_targ = getelementptr inbounds %struct.op* %8, i64 0, i32 3
  %10 = load i64* %op_targ, align 8, !tbaa !35
  %11 = load %struct.sv*** @PL_curpad, align 8, !tbaa !1
  %arrayidx6 = getelementptr inbounds %struct.sv** %11, i64 %10
  %12 = load %struct.sv** %arrayidx6, align 8, !tbaa !1
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call7 = tail call %struct.sv* @Perl_sv_newmortal() #2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %12, %cond.true ], [ %call7, %cond.false ]
  %tobool8 = icmp eq %struct._PerlIO** %7, null
  br i1 %tobool8, label %if.else, label %if.then9

if.then9:                                         ; preds = %cond.end
  tail call void @Perl_PerlIO_clearerr(%struct._PerlIO** %7) #2
  br label %if.end11

if.else:                                          ; preds = %cond.end
  %call10 = tail call i32* @__errno_location() #2
  store i32 22, i32* %call10, align 4, !tbaa !13
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then9
  %RETVAL.0 = phi i64 [ 0, %if.then9 ], [ -1, %if.else ]
  %13 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %RETVAL.0) #2
  %sv_flags = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %14 = load i64* %sv_flags, align 8, !tbaa !15
  %and15 = and i64 %14, 16384
  %tobool16 = icmp eq i64 %and15, 0
  br i1 %tobool16, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.end11
  %call18 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #2
  br label %if.end19

if.end19:                                         ; preds = %if.end11, %if.then17
  %incdec.ptr20 = getelementptr inbounds %struct.sv** %13, i64 %add
  store %struct.sv* %cond, %struct.sv** %incdec.ptr20, align 8, !tbaa !1
  %15 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr22 = getelementptr inbounds %struct.sv** %15, i64 %add
  store %struct.sv** %add.ptr22, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare void @Perl_PerlIO_clearerr(%struct._PerlIO**) #1

; Function Attrs: nounwind uwtable
define void @XS_IO__Handle_untaint(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp eq i64 %sub.ptr.sub3, 8
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([35 x i8]* @.str11, i64 0, i64 0)) #2
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %6 = load %struct.op** @PL_op, align 8, !tbaa !1
  %op_private = getelementptr inbounds %struct.op* %6, i64 0, i32 7
  %7 = load i8* %op_private, align 1, !tbaa !33
  %and = and i8 %7, 32
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %op_targ = getelementptr inbounds %struct.op* %6, i64 0, i32 3
  %8 = load i64* %op_targ, align 8, !tbaa !35
  %9 = load %struct.sv*** @PL_curpad, align 8, !tbaa !1
  %arrayidx6 = getelementptr inbounds %struct.sv** %9, i64 %8
  %10 = load %struct.sv** %arrayidx6, align 8, !tbaa !1
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = tail call %struct.sv* @Perl_sv_newmortal() #2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %10, %cond.true ], [ %call, %cond.false ]
  %call7 = tail call %struct.io* @Perl_sv_2io(%struct.sv* %5) #2
  %tobool8 = icmp eq %struct.io* %call7, null
  br i1 %tobool8, label %if.else, label %if.then9

if.then9:                                         ; preds = %cond.end
  %sv_any = getelementptr inbounds %struct.io* %call7, i64 0, i32 0
  %11 = load %struct.xpvio** %sv_any, align 8, !tbaa !7
  %xio_flags = getelementptr inbounds %struct.xpvio* %11, i64 0, i32 22
  %12 = load i8* %xio_flags, align 1, !tbaa !36
  %or = or i8 %12, 16
  store i8 %or, i8* %xio_flags, align 1, !tbaa !36
  br label %if.end13

if.else:                                          ; preds = %cond.end
  %call12 = tail call i32* @__errno_location() #2
  store i32 22, i32* %call12, align 4, !tbaa !13
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  %RETVAL.0 = phi i64 [ 0, %if.then9 ], [ -1, %if.else ]
  %13 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %RETVAL.0) #2
  %sv_flags = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %14 = load i64* %sv_flags, align 8, !tbaa !15
  %and17 = and i64 %14, 16384
  %tobool18 = icmp eq i64 %and17, 0
  br i1 %tobool18, label %if.end21, label %if.then19

if.then19:                                        ; preds = %if.end13
  %call20 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #2
  br label %if.end21

if.end21:                                         ; preds = %if.end13, %if.then19
  %incdec.ptr22 = getelementptr inbounds %struct.sv** %13, i64 %add
  store %struct.sv* %cond, %struct.sv** %incdec.ptr22, align 8, !tbaa !1
  %15 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr24 = getelementptr inbounds %struct.sv** %15, i64 %add
  store %struct.sv** %add.ptr24, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

; Function Attrs: nounwind uwtable
define void @XS_IO__Handle_flush(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp eq i64 %sub.ptr.sub3, 8
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([33 x i8]* @.str12, i64 0, i64 0)) #2
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %call = tail call %struct.io* @Perl_sv_2io(%struct.sv* %5) #2
  %sv_any = getelementptr inbounds %struct.io* %call, i64 0, i32 0
  %6 = load %struct.xpvio** %sv_any, align 8, !tbaa !7
  %xio_ofp = getelementptr inbounds %struct.xpvio* %6, i64 0, i32 8
  %7 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !37
  %tobool = icmp eq %struct._PerlIO** %7, null
  br i1 %tobool, label %if.else, label %if.then6

if.then6:                                         ; preds = %if.end
  %call7 = tail call i32 @Perl_PerlIO_flush(%struct._PerlIO** %7) #2
  br label %if.end9

if.else:                                          ; preds = %if.end
  %call8 = tail call i32* @__errno_location() #2
  store i32 22, i32* %call8, align 4, !tbaa !13
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then6
  %RETVAL.0 = phi i32 [ %call7, %if.then6 ], [ -1, %if.else ]
  %call10 = tail call %struct.sv* @Perl_sv_newmortal() #2
  %8 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx12 = getelementptr inbounds %struct.sv** %8, i64 %add
  store %struct.sv* %call10, %struct.sv** %arrayidx12, align 8, !tbaa !1
  %cmp13 = icmp eq i32 %RETVAL.0, -1
  br i1 %cmp13, label %if.end23, label %if.then14

if.then14:                                        ; preds = %if.end9
  %cmp15 = icmp eq i32 %RETVAL.0, 0
  %9 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx18 = getelementptr inbounds %struct.sv** %9, i64 %add
  %10 = load %struct.sv** %arrayidx18, align 8, !tbaa !1
  br i1 %cmp15, label %if.then16, label %if.else19

if.then16:                                        ; preds = %if.then14
  tail call void @Perl_sv_setpvn(%struct.sv* %10, i8* getelementptr inbounds ([11 x i8]* @.str2, i64 0, i64 0), i64 10) #2
  br label %if.end23

if.else19:                                        ; preds = %if.then14
  %conv = sext i32 %RETVAL.0 to i64
  tail call void @Perl_sv_setiv(%struct.sv* %10, i64 %conv) #2
  br label %if.end23

if.end23:                                         ; preds = %if.end9, %if.then16, %if.else19
  %11 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr24 = getelementptr inbounds %struct.sv** %11, i64 %add
  store %struct.sv** %add.ptr24, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare i32 @Perl_PerlIO_flush(%struct._PerlIO**) #1

; Function Attrs: nounwind uwtable
define void @XS_IO__Handle_setbuf(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp slt i64 %sub.ptr.sub3, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([39 x i8]* @.str13, i64 0, i64 0)) #2
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = phi %struct.sv** [ %.pre, %if.then ], [ %1, %entry ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %call = tail call %struct.io* @Perl_sv_2io(%struct.sv* %5) #2
  %sv_any = getelementptr inbounds %struct.io* %call, i64 0, i32 0
  %6 = load %struct.xpvio** %sv_any, align 8, !tbaa !7
  %xio_ofp = getelementptr inbounds %struct.xpvio* %6, i64 0, i32 8
  %7 = load %struct._PerlIO*** %xio_ofp, align 8, !tbaa !37
  %tobool = icmp eq %struct._PerlIO** %7, null
  br i1 %tobool, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([40 x i8]* @.str53, i64 0, i64 0), i8* getelementptr inbounds ([19 x i8]* @.str14, i64 0, i64 0)) #2
  br label %if.end8

if.end8:                                          ; preds = %if.end, %if.then6
  %8 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr10 = getelementptr inbounds %struct.sv** %8, i64 %sub.ptr.div
  store %struct.sv** %add.ptr10, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

; Function Attrs: nounwind uwtable
define void @XS_IO__Handle_setvbuf(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp eq i64 %sub.ptr.sub3, 32
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([52 x i8]* @.str15, i64 0, i64 0)) #2
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([40 x i8]* @.str53, i64 0, i64 0), i8* getelementptr inbounds ([20 x i8]* @.str16, i64 0, i64 0)) #2
  %call5 = tail call %struct.sv* @Perl_sv_newmortal() #2
  %4 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  store %struct.sv* %call5, %struct.sv** %arrayidx, align 8, !tbaa !1
  %5 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr17 = getelementptr inbounds %struct.sv** %5, i64 %add
  store %struct.sv** %add.ptr17, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

; Function Attrs: nounwind uwtable
define void @XS_IO__Handle_sync(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp eq i64 %sub.ptr.sub3, 8
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([32 x i8]* @.str17, i64 0, i64 0)) #2
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %call = tail call %struct.io* @Perl_sv_2io(%struct.sv* %5) #2
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([40 x i8]* @.str53, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8]* @.str18, i64 0, i64 0)) #2
  %call7 = tail call %struct.sv* @Perl_sv_newmortal() #2
  %6 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx9 = getelementptr inbounds %struct.sv** %6, i64 %add
  store %struct.sv* %call7, %struct.sv** %arrayidx9, align 8, !tbaa !1
  %7 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr20 = getelementptr inbounds %struct.sv** %7, i64 %add
  store %struct.sv** %add.ptr20, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

; Function Attrs: nounwind uwtable
define void @XS_IO__Socket_sockatmark(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %flag = alloca i32, align 4
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %2 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %2, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %3 = load i64* %2, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.idx = shl nuw i64 %3, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %cmp = icmp eq i64 %sub.ptr.sub3, 8
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([36 x i8]* @.str19, i64 0, i64 0)) #2
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %4 = phi %struct.sv** [ %1, %entry ], [ %.pre, %if.then ]
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  %5 = load %struct.sv** %arrayidx, align 8, !tbaa !1
  %call = call %struct.io* @Perl_sv_2io(%struct.sv* %5) #2
  %sv_any = getelementptr inbounds %struct.io* %call, i64 0, i32 0
  %6 = load %struct.xpvio** %sv_any, align 8, !tbaa !7
  %xio_ifp = getelementptr inbounds %struct.xpvio* %6, i64 0, i32 7
  %7 = load %struct._PerlIO*** %xio_ifp, align 8, !tbaa !9
  %call6 = call i32 @Perl_PerlIO_fileno(%struct._PerlIO** %7) #2
  store i32 0, i32* %flag, align 4, !tbaa !13
  %call7 = call i32 (i32, i32, ...)* @ioctl(i32 %call6, i32 35077, i32* %flag) #2
  %cmp8 = icmp eq i32 %call7, 0
  br i1 %cmp8, label %if.end14, label %if.then9

if.then9:                                         ; preds = %if.end
  %8 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx11 = getelementptr inbounds %struct.sv** %8, i64 %add
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx11, align 8, !tbaa !1
  br label %return

if.end14:                                         ; preds = %if.end
  %9 = load i32* %flag, align 4, !tbaa !13
  %call15 = call %struct.sv* @Perl_sv_newmortal() #2
  %10 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx17 = getelementptr inbounds %struct.sv** %10, i64 %add
  store %struct.sv* %call15, %struct.sv** %arrayidx17, align 8, !tbaa !1
  %cmp18 = icmp eq i32 %9, -1
  br i1 %cmp18, label %return, label %if.then19

if.then19:                                        ; preds = %if.end14
  %cmp20 = icmp eq i32 %9, 0
  %11 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx23 = getelementptr inbounds %struct.sv** %11, i64 %add
  %12 = load %struct.sv** %arrayidx23, align 8, !tbaa !1
  br i1 %cmp20, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.then19
  call void @Perl_sv_setpvn(%struct.sv* %12, i8* getelementptr inbounds ([11 x i8]* @.str2, i64 0, i64 0), i64 10) #2
  br label %return

if.else:                                          ; preds = %if.then19
  %conv = sext i32 %9 to i64
  call void @Perl_sv_setiv(%struct.sv* %12, i64 %conv) #2
  br label %return

return:                                           ; preds = %if.else, %if.then21, %if.end14, %if.then9
  %.pn = load %struct.sv*** @PL_stack_base, align 8
  %storemerge = getelementptr inbounds %struct.sv** %.pn, i64 %add
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare i32 @Perl_PerlIO_fileno(%struct._PerlIO**) #1

declare i32 @ioctl(i32, i32, ...) #1

; Function Attrs: nounwind uwtable
define void @boot_IO(%struct.cv* nocapture readnone %cv) #0 {
entry:
  %0 = load i64** @PL_markstack_ptr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i64* %0, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !1
  %1 = load i64* %0, align 8, !tbaa !5
  %add.ptr.idx = shl nuw i64 %1, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %call = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([21 x i8]* @.str21, i64 0, i64 0), void (%struct.cv*)* @XS_IO__Seekable_getpos, i8* getelementptr inbounds ([5 x i8]* @.str20, i64 0, i64 0)) #2
  %call5 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([21 x i8]* @.str22, i64 0, i64 0), void (%struct.cv*)* @XS_IO__Seekable_setpos, i8* getelementptr inbounds ([5 x i8]* @.str20, i64 0, i64 0)) #2
  %call6 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([22 x i8]* @.str23, i64 0, i64 0), void (%struct.cv*)* @XS_IO__File_new_tmpfile, i8* getelementptr inbounds ([5 x i8]* @.str20, i64 0, i64 0)) #2
  %call7 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([16 x i8]* @.str24, i64 0, i64 0), void (%struct.cv*)* @XS_IO__Poll__poll, i8* getelementptr inbounds ([5 x i8]* @.str20, i64 0, i64 0)) #2
  %call8 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([21 x i8]* @.str25, i64 0, i64 0), void (%struct.cv*)* @XS_IO__Handle_blocking, i8* getelementptr inbounds ([5 x i8]* @.str20, i64 0, i64 0)) #2
  %2 = bitcast %struct.cv* %call8 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %2, i8* getelementptr inbounds ([4 x i8]* @.str26, i64 0, i64 0)) #2
  %call9 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([19 x i8]* @.str27, i64 0, i64 0), void (%struct.cv*)* @XS_IO__Handle_ungetc, i8* getelementptr inbounds ([5 x i8]* @.str20, i64 0, i64 0)) #2
  %call10 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([18 x i8]* @.str28, i64 0, i64 0), void (%struct.cv*)* @XS_IO__Handle_error, i8* getelementptr inbounds ([5 x i8]* @.str20, i64 0, i64 0)) #2
  %call11 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([21 x i8]* @.str29, i64 0, i64 0), void (%struct.cv*)* @XS_IO__Handle_clearerr, i8* getelementptr inbounds ([5 x i8]* @.str20, i64 0, i64 0)) #2
  %call12 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([20 x i8]* @.str30, i64 0, i64 0), void (%struct.cv*)* @XS_IO__Handle_untaint, i8* getelementptr inbounds ([5 x i8]* @.str20, i64 0, i64 0)) #2
  %call13 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([18 x i8]* @.str31, i64 0, i64 0), void (%struct.cv*)* @XS_IO__Handle_flush, i8* getelementptr inbounds ([5 x i8]* @.str20, i64 0, i64 0)) #2
  %call14 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([19 x i8]* @.str14, i64 0, i64 0), void (%struct.cv*)* @XS_IO__Handle_setbuf, i8* getelementptr inbounds ([5 x i8]* @.str20, i64 0, i64 0)) #2
  %call15 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([20 x i8]* @.str16, i64 0, i64 0), void (%struct.cv*)* @XS_IO__Handle_setvbuf, i8* getelementptr inbounds ([5 x i8]* @.str20, i64 0, i64 0)) #2
  %call16 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([17 x i8]* @.str18, i64 0, i64 0), void (%struct.cv*)* @XS_IO__Handle_sync, i8* getelementptr inbounds ([5 x i8]* @.str20, i64 0, i64 0)) #2
  %call17 = tail call %struct.cv* @Perl_newXS(i8* getelementptr inbounds ([23 x i8]* @.str32, i64 0, i64 0), void (%struct.cv*)* @XS_IO__Socket_sockatmark, i8* getelementptr inbounds ([5 x i8]* @.str20, i64 0, i64 0)) #2
  %3 = bitcast %struct.cv* %call17 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %3, i8* getelementptr inbounds ([2 x i8]* @.str33, i64 0, i64 0)) #2
  %call18 = tail call %struct.hv* @Perl_gv_stashpvn(i8* getelementptr inbounds ([9 x i8]* @.str34, i64 0, i64 0), i64 8, i64 1) #2
  %call19 = tail call %struct.sv* @Perl_newSViv(i64 1) #2
  %call20 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call18, i8* getelementptr inbounds ([7 x i8]* @.str35, i64 0, i64 0), %struct.sv* %call19) #2
  %call21 = tail call %struct.sv* @Perl_newSViv(i64 2) #2
  %call22 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call18, i8* getelementptr inbounds ([8 x i8]* @.str36, i64 0, i64 0), %struct.sv* %call21) #2
  %call23 = tail call %struct.sv* @Perl_newSViv(i64 4) #2
  %call24 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call18, i8* getelementptr inbounds ([8 x i8]* @.str37, i64 0, i64 0), %struct.sv* %call23) #2
  %call25 = tail call %struct.sv* @Perl_newSViv(i64 64) #2
  %call26 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call18, i8* getelementptr inbounds ([11 x i8]* @.str38, i64 0, i64 0), %struct.sv* %call25) #2
  %call27 = tail call %struct.sv* @Perl_newSViv(i64 4) #2
  %call28 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call18, i8* getelementptr inbounds ([11 x i8]* @.str39, i64 0, i64 0), %struct.sv* %call27) #2
  %call29 = tail call %struct.sv* @Perl_newSViv(i64 128) #2
  %call30 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call18, i8* getelementptr inbounds ([11 x i8]* @.str40, i64 0, i64 0), %struct.sv* %call29) #2
  %call31 = tail call %struct.sv* @Perl_newSViv(i64 256) #2
  %call32 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call18, i8* getelementptr inbounds ([11 x i8]* @.str41, i64 0, i64 0), %struct.sv* %call31) #2
  %call33 = tail call %struct.sv* @Perl_newSViv(i64 64) #2
  %call34 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call18, i8* getelementptr inbounds ([9 x i8]* @.str42, i64 0, i64 0), %struct.sv* %call33) #2
  %call35 = tail call %struct.sv* @Perl_newSViv(i64 8) #2
  %call36 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call18, i8* getelementptr inbounds ([8 x i8]* @.str43, i64 0, i64 0), %struct.sv* %call35) #2
  %call37 = tail call %struct.sv* @Perl_newSViv(i64 16) #2
  %call38 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call18, i8* getelementptr inbounds ([8 x i8]* @.str44, i64 0, i64 0), %struct.sv* %call37) #2
  %call39 = tail call %struct.sv* @Perl_newSViv(i64 32) #2
  %call40 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call18, i8* getelementptr inbounds ([9 x i8]* @.str45, i64 0, i64 0), %struct.sv* %call39) #2
  %call41 = tail call %struct.hv* @Perl_gv_stashpvn(i8* getelementptr inbounds ([11 x i8]* @.str46, i64 0, i64 0), i64 10, i64 1) #2
  %call42 = tail call %struct.sv* @Perl_newSViv(i64 0) #2
  %call43 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call41, i8* getelementptr inbounds ([7 x i8]* @.str47, i64 0, i64 0), %struct.sv* %call42) #2
  %call44 = tail call %struct.sv* @Perl_newSViv(i64 1) #2
  %call45 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call41, i8* getelementptr inbounds ([7 x i8]* @.str48, i64 0, i64 0), %struct.sv* %call44) #2
  %call46 = tail call %struct.sv* @Perl_newSViv(i64 2) #2
  %call47 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call41, i8* getelementptr inbounds ([7 x i8]* @.str49, i64 0, i64 0), %struct.sv* %call46) #2
  %call48 = tail call %struct.sv* @Perl_newSViv(i64 0) #2
  %call49 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call41, i8* getelementptr inbounds ([9 x i8]* @.str50, i64 0, i64 0), %struct.sv* %call48) #2
  %call50 = tail call %struct.sv* @Perl_newSViv(i64 1) #2
  %call51 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call41, i8* getelementptr inbounds ([9 x i8]* @.str51, i64 0, i64 0), %struct.sv* %call50) #2
  %call52 = tail call %struct.sv* @Perl_newSViv(i64 2) #2
  %call53 = tail call %struct.cv* @Perl_newCONSTSUB(%struct.hv* %call41, i8* getelementptr inbounds ([9 x i8]* @.str52, i64 0, i64 0), %struct.sv* %call52) #2
  %4 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.sv** %4, i64 %add
  store %struct.sv* @PL_sv_yes, %struct.sv** %arrayidx, align 8, !tbaa !1
  %5 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !1
  %add.ptr55 = getelementptr inbounds %struct.sv** %5, i64 %add
  store %struct.sv** %add.ptr55, %struct.sv*** @PL_stack_sp, align 8, !tbaa !1
  ret void
}

declare %struct.cv* @Perl_newXS(i8*, void (%struct.cv*)*, i8*) #1

declare void @Perl_sv_setpv(%struct.sv*, i8*) #1

declare %struct.hv* @Perl_gv_stashpvn(i8*, i64, i64) #1

declare %struct.cv* @Perl_newCONSTSUB(%struct.hv*, i8*, %struct.sv*) #1

declare i32 @fcntl(i32, i32, ...) #1

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5 (trunk)"}
!1 = metadata !{metadata !2, metadata !2, i64 0}
!2 = metadata !{metadata !"any pointer", metadata !3, i64 0}
!3 = metadata !{metadata !"omnipotent char", metadata !4, i64 0}
!4 = metadata !{metadata !"Simple C/C++ TBAA"}
!5 = metadata !{metadata !6, metadata !6, i64 0}
!6 = metadata !{metadata !"long", metadata !3, i64 0}
!7 = metadata !{metadata !8, metadata !2, i64 0}
!8 = metadata !{metadata !"io", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!9 = metadata !{metadata !10, metadata !2, i64 56}
!10 = metadata !{metadata !"xpvio", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !11, i64 32, metadata !2, i64 40, metadata !2, i64 48, metadata !2, i64 56, metadata !2, i64 64, metadata !3, i64 72, metadata !6, i64 80, metadata !6, i64 88, metadata !6, i64 96, metadata !6, i64 104, metadata !2, i64 112, metadata !2, i64 120, metadata !2, i64 128, metadata !2, i64 136, metadata !2, i64 144, metadata !2, i64 152, metadata !12, i64 160, metadata !3, i64 162, metadata !3, i64 163}
!11 = metadata !{metadata !"double", metadata !3, i64 0}
!12 = metadata !{metadata !"short", metadata !3, i64 0}
!13 = metadata !{metadata !14, metadata !14, i64 0}
!14 = metadata !{metadata !"int", metadata !3, i64 0}
!15 = metadata !{metadata !16, metadata !6, i64 16}
!16 = metadata !{metadata !"sv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!17 = metadata !{metadata !16, metadata !2, i64 0}
!18 = metadata !{metadata !19, metadata !2, i64 0}
!19 = metadata !{metadata !"xpv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!20 = metadata !{metadata !16, metadata !6, i64 8}
!21 = metadata !{metadata !22, metadata !2, i64 0}
!22 = metadata !{metadata !"gv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16}
!23 = metadata !{metadata !24, metadata !2, i64 80}
!24 = metadata !{metadata !"xpvgv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24, metadata !11, i64 32, metadata !2, i64 40, metadata !2, i64 48, metadata !2, i64 56, metadata !2, i64 64, metadata !6, i64 72, metadata !2, i64 80, metadata !3, i64 88}
!25 = metadata !{metadata !24, metadata !2, i64 64}
!26 = metadata !{metadata !24, metadata !6, i64 72}
!27 = metadata !{metadata !28, metadata !6, i64 24}
!28 = metadata !{metadata !"xpviv", metadata !2, i64 0, metadata !6, i64 8, metadata !6, i64 16, metadata !6, i64 24}
!29 = metadata !{metadata !30, metadata !14, i64 0}
!30 = metadata !{metadata !"pollfd", metadata !14, i64 0, metadata !12, i64 4, metadata !12, i64 6}
!31 = metadata !{metadata !30, metadata !12, i64 4}
!32 = metadata !{metadata !30, metadata !12, i64 6}
!33 = metadata !{metadata !34, metadata !3, i64 37}
!34 = metadata !{metadata !"op", metadata !2, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !6, i64 24, metadata !12, i64 32, metadata !12, i64 34, metadata !3, i64 36, metadata !3, i64 37}
!35 = metadata !{metadata !34, metadata !6, i64 24}
!36 = metadata !{metadata !10, metadata !3, i64 163}
!37 = metadata !{metadata !10, metadata !2, i64 64}
