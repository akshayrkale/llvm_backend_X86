; ModuleID = 'op.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.hv = type { %struct.xpvhv*, i64, i64 }
%struct.xpvhv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, i64, %struct.he*, %struct.pmop*, i8* }
%struct.magic = type { %struct.magic*, %struct.mgvtbl*, i16, i8, i8, %struct.sv*, i8*, i64 }
%struct.mgvtbl = type { i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i64 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)*, i32 (%struct.magic*, %struct.clone_params*)* }
%struct.clone_params = type { %struct.av*, i64, %struct.interpreter* }
%struct.av = type { %struct.xpvav*, i64, i64 }
%struct.xpvav = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.sv**, %struct.sv*, i8 }
%struct.interpreter = type { i8 }
%struct.sv = type { i8*, i64, i64 }
%struct.he = type { %struct.he*, %struct.hek*, %struct.sv* }
%struct.hek = type { i64, i64, [1 x i8] }
%struct.pmop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.pmop*, %struct.regexp*, i64, i64, i8, %struct.hv* }
%struct.op = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8 }
%struct.regexp = type { i64*, i64*, %struct.regnode*, %struct.reg_substr_data*, i8*, %struct.reg_data*, i8*, i64*, i64, i64, i64, i64, i64, i64, i64, i64, [1 x %struct.regnode] }
%struct.regnode = type { i8, i8, i16 }
%struct.reg_substr_data = type opaque
%struct.reg_data = type opaque
%struct.cop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, i8*, %struct.hv*, %struct.gv*, i64, i64, i64, %struct.sv*, %struct.sv* }
%struct.gv = type { %struct.xpvgv*, i64, i64 }
%struct.xpvgv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.gp*, i8*, i64, %struct.hv*, i8 }
%struct.gp = type { %struct.sv*, i64, %struct.io*, %struct.cv*, %struct.av*, %struct.hv*, %struct.gv*, %struct.cv*, i64, i64, i64, i8* }
%struct.io = type { %struct.xpvio*, i64, i64 }
%struct.xpvio = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct._PerlIO**, %struct._PerlIO**, %union.anon, i64, i64, i64, i64, i8*, %struct.gv*, i8*, %struct.gv*, i8*, %struct.gv*, i16, i8, i8 }
%struct._PerlIO = type opaque
%union.anon = type { %struct.__dirstream* }
%struct.__dirstream = type opaque
%struct.cv = type { %struct.xpvcv*, i64, i64 }
%struct.xpvcv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.hv*, %struct.op*, %struct.op*, void (%struct.cv*)*, %union.any, %struct.gv*, i8*, i64, %struct.av*, %struct.cv*, i16, i64 }
%union.any = type { i8* }
%struct.xpv = type { i8*, i64, i64 }
%struct.stackinfo = type { %struct.av*, %struct.context*, i64, i64, i64, %struct.stackinfo*, %struct.stackinfo*, i64 }
%struct.context = type { i64, %union.anon.0 }
%union.anon.0 = type { %struct.block }
%struct.block = type { i64, %struct.cop*, i64, i64, i64, %struct.pmop*, i8, %union.anon.1 }
%union.anon.1 = type { %struct.block_loop }
%struct.block_loop = type { i8*, i64, %struct.op*, %struct.op*, %struct.op*, %struct.sv**, %struct.sv*, %struct.sv*, %struct.av*, i64, i64 }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.listop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op* }
%struct.unop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op* }
%struct.loop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.op* }
%struct.svop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.sv* }

@PL_in_my = external global i64
@PL_hints = external global i64
@.str = private unnamed_addr constant [5 x i8] c"\09\0A\0D\0C\00", align 1
@.str2 = private unnamed_addr constant [28 x i8] c"Can't use global %s in \22my\22\00", align 1
@PL_curstash = external global %struct.hv*
@PL_defstash = external global %struct.hv*
@PL_in_my_stash = external global %struct.hv*
@.str3 = private unnamed_addr constant [46 x i8] c"Can't declare class for non-scalar %s in \22%s\22\00", align 1
@.str4 = private unnamed_addr constant [4 x i8] c"our\00", align 1
@.str5 = private unnamed_addr constant [3 x i8] c"my\00", align 1
@PL_check = external global [0 x %struct.op* (%struct.op*)*]
@PL_regfree = external global void (%struct.regexp*)*
@PL_ppaddr = external global [0 x %struct.op* ()*]
@PL_error_count = external global i64
@.str6 = private unnamed_addr constant [21 x i8] c"implicit split to @_\00", align 1
@PL_compiling = external global %struct.cop
@PL_curcop = external global %struct.cop*
@PL_dowarn = external global i8
@.str7 = private unnamed_addr constant [38 x i8] c"Useless use of sort in scalar context\00", align 1
@PL_opargs = external global [0 x i64]
@PL_op_desc = external global [0 x i8*]
@.str8 = private unnamed_addr constant [11 x i8] c"a variable\00", align 1
@.str9 = private unnamed_addr constant [11 x i8] c"a constant\00", align 1
@.str10 = private unnamed_addr constant [3 x i8] c"di\00", align 1
@.str11 = private unnamed_addr constant [3 x i8] c"ds\00", align 1
@.str12 = private unnamed_addr constant [3 x i8] c"ig\00", align 1
@.str13 = private unnamed_addr constant [34 x i8] c"Useless use of %s in void context\00", align 1
@PL_modcount = external global i64
@PL_eval_start = external global %struct.op*
@.str14 = private unnamed_addr constant [30 x i8] c"That use of $[ is unsupported\00", align 1
@.str15 = private unnamed_addr constant [58 x i8] c"panic: unexpected lvalue entersub args: type/targ %ld:%lu\00", align 1
@.str16 = private unnamed_addr constant [62 x i8] c"panic: unexpected lvalue entersub entry via type/targ %ld:%lu\00", align 1
@.str17 = private unnamed_addr constant [64 x i8] c"Unexpected constant lvalue entersub entry via type/targ %ld:%lu\00", align 1
@.str18 = private unnamed_addr constant [22 x i8] c"Can't modify %s in %s\00", align 1
@.str19 = private unnamed_addr constant [9 x i8] c"do block\00", align 1
@.str20 = private unnamed_addr constant [27 x i8] c"non-lvalue subroutine call\00", align 1
@.str21 = private unnamed_addr constant [6 x i8] c"local\00", align 1
@.str22 = private unnamed_addr constant [35 x i8] c"Can't localize lexical variable %s\00", align 1
@PL_comppad_name = external global %struct.av*
@.str23 = private unnamed_addr constant [11 x i8] c"attributes\00", align 1
@.str24 = private unnamed_addr constant [7 x i8] c"@array\00", align 1
@.str25 = private unnamed_addr constant [6 x i8] c"%hash\00", align 1
@.str26 = private unnamed_addr constant [41 x i8] c"Applying %s to %s will act on scalar(%s)\00", align 1
@PL_perldb = external global i64
@PL_tainting = external global i8
@.str27 = private unnamed_addr constant [54 x i8] c"internal error: obsolete function save_hints() called\00", align 1
@PL_savestack_ix = external global i64
@PL_yynerrs = external global i32
@PL_savestack_max = external global i64
@PL_hintgv = external global %struct.gv*
@PL_savestack = external global %union.any*
@PL_in_eval = external global i32
@PL_eval_root = external global %struct.op*
@PL_peepp = external global void (%struct.op*)*
@PL_compcv = external global %struct.cv*
@PL_main_root = external global %struct.op*
@PL_main_start = external global %struct.op*
@.str28 = private unnamed_addr constant [14 x i8] c"DB::postponed\00", align 1
@PL_stack_sp = external global %struct.sv**
@PL_markstack_ptr = external global i64*
@PL_markstack_max = external global i64*
@PL_stack_base = external global %struct.sv**
@PL_stack_max = external global %struct.sv**
@PL_bufptr = external global i8*
@PL_oldbufptr = external global i8*
@.str29 = private unnamed_addr constant [5 x i8] c", \09\0A\00", align 1
@.str30 = private unnamed_addr constant [5 x i8] c"@$%*\00", align 1
@.str31 = private unnamed_addr constant [37 x i8] c"Parentheses missing around \22%s\22 list\00", align 1
@.str32 = private unnamed_addr constant [2 x i8] c";\00", align 1
@PL_op = external global %struct.op*
@PL_runops = external global i32 ()*
@PL_curpad = external global %struct.sv**
@PL_Sv = external global %struct.sv*
@PL_tmps_floor = external global i64
@PL_op_mask = external global i8*
@.str33 = private unnamed_addr constant [31 x i8] c"'%s' trapped by operation mask\00", align 1
@.str34 = private unnamed_addr constant [11 x i8] c"# comment\0A\00", align 1
@.str35 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str36 = private unnamed_addr constant [18 x i8] c"%04lx\09%04lx\09XXXX\0A\00", align 1
@.str37 = private unnamed_addr constant [13 x i8] c"%04lx\09\09XXXX\0A\00", align 1
@.str38 = private unnamed_addr constant [19 x i8] c"%04lx\09%04lx\09%04lx\0A\00", align 1
@.str39 = private unnamed_addr constant [14 x i8] c"%04lx\09\09%04lx\0A\00", align 1
@.str40 = private unnamed_addr constant [5 x i8] c"utf8\00", align 1
@.str41 = private unnamed_addr constant [6 x i8] c"FINAL\00", align 1
@.str42 = private unnamed_addr constant [4 x i8] c"\5Cs+\00", align 1
@PL_regcompp = external global %struct.regexp* (i8*, i8*, %struct.pmop*)*
@PL_multi_end = external global i64
@.str43 = private unnamed_addr constant [17 x i8] c"&`'123456789+-\0E\12\00", align 1
@PL_curstname = external global %struct.sv*
@.str44 = private unnamed_addr constant [28 x i8] c"\22package\22 with no arguments\00", align 1
@.str45 = private unnamed_addr constant [7 x i8] c"<none>\00", align 1
@PL_copline = external global i64
@PL_expect = external global i32
@.str46 = private unnamed_addr constant [29 x i8] c"Module name must be constant\00", align 1
@.str47 = private unnamed_addr constant [39 x i8] c"Version number must be constant number\00", align 1
@.str48 = private unnamed_addr constant [8 x i8] c"VERSION\00", align 1
@.str49 = private unnamed_addr constant [7 x i8] c"import\00", align 1
@.str50 = private unnamed_addr constant [9 x i8] c"unimport\00", align 1
@.str51 = private unnamed_addr constant [6 x i8] c"BEGIN\00", align 1
@PL_cop_seqmax = external global i64
@.str52 = private unnamed_addr constant [3 x i8] c"do\00", align 1
@.str53 = private unnamed_addr constant [17 x i8] c"CORE::GLOBAL::do\00", align 1
@PL_generation = external global i32
@PL_defgv = external global %struct.gv*
@PL_debstash = external global %struct.hv*
@PL_sv_undef = external global %struct.sv
@PL_Xpv = external global %struct.xpv*
@.str54 = private unnamed_addr constant [31 x i8] c"Can't use %s for loop variable\00", align 1
@.str55 = private unnamed_addr constant [30 x i8] c"Can't undef active subroutine\00", align 1
@PL_comppad = external global %struct.av*
@.str56 = private unnamed_addr constant [20 x i8] c"Prototype mismatch:\00", align 1
@.str57 = private unnamed_addr constant [8 x i8] c" sub %_\00", align 1
@.str58 = private unnamed_addr constant [6 x i8] c" (%_)\00", align 1
@.str59 = private unnamed_addr constant [7 x i8] c": none\00", align 1
@.str60 = private unnamed_addr constant [5 x i8] c" vs \00", align 1
@.str61 = private unnamed_addr constant [5 x i8] c"(%s)\00", align 1
@.str62 = private unnamed_addr constant [5 x i8] c"none\00", align 1
@.str63 = private unnamed_addr constant [3 x i8] c"%_\00", align 1
@.str64 = private unnamed_addr constant [29 x i8] c"\22my sub\22 not yet implemented\00", align 1
@.str65 = private unnamed_addr constant [11 x i8] c"%s[%s:%ld]\00", align 1
@.str66 = private unnamed_addr constant [9 x i8] c"__ANON__\00", align 1
@.str67 = private unnamed_addr constant [19 x i8] c"__ANON__::__ANON__\00", align 1
@.str68 = private unnamed_addr constant [18 x i8] c"Runaway prototype\00", align 1
@PL_sub_generation = external global i64
@PL_curstackinfo = external global %struct.stackinfo*
@PL_sortcop = external global %struct.op*
@.str69 = private unnamed_addr constant [41 x i8] c"Can't redefine active sort subroutine %s\00", align 1
@.str70 = private unnamed_addr constant [33 x i8] c"Constant subroutine %s redefined\00", align 1
@.str71 = private unnamed_addr constant [24 x i8] c"Subroutine %s redefined\00", align 1
@.str72 = private unnamed_addr constant [49 x i8] c"BEGIN not safe after errors--compilation aborted\00", align 1
@PL_errgv = external global %struct.gv*
@.str73 = private unnamed_addr constant [11 x i8] c"%s:%ld-%ld\00", align 1
@PL_subline = external global i64
@PL_DBsub = external global %struct.gv*
@PL_scopestack_ix = external global i64
@PL_beginav = external global %struct.av*
@.str74 = private unnamed_addr constant [4 x i8] c"END\00", align 1
@PL_endav = external global %struct.av*
@.str75 = private unnamed_addr constant [6 x i8] c"CHECK\00", align 1
@PL_checkav = external global %struct.av*
@.str76 = private unnamed_addr constant [28 x i8] c"Too late to run CHECK block\00", align 1
@.str77 = private unnamed_addr constant [5 x i8] c"INIT\00", align 1
@PL_initav = external global %struct.av*
@.str78 = private unnamed_addr constant [27 x i8] c"Too late to run INIT block\00", align 1
@.str79 = private unnamed_addr constant [8 x i8] c"autouse\00", align 1
@.str80 = private unnamed_addr constant [7 x i8] c"STDOUT\00", align 1
@.str81 = private unnamed_addr constant [20 x i8] c"Format %s redefined\00", align 1
@.str82 = private unnamed_addr constant [13 x i8] c"oops: oopsAV\00", align 1
@.str83 = private unnamed_addr constant [13 x i8] c"oops: oopsHV\00", align 1
@.str84 = private unnamed_addr constant [44 x i8] c"Using an array as a reference is deprecated\00", align 1
@.str85 = private unnamed_addr constant [42 x i8] c"Using a hash as a reference is deprecated\00", align 1
@.str86 = private unnamed_addr constant [17 x i8] c"NOT IMPL LINE %d\00", align 1
@.str87 = private unnamed_addr constant [51 x i8] c"Possible precedence problem on bitwise %c operator\00", align 1
@.str88 = private unnamed_addr constant [52 x i8] c"%s argument is not a HASH or ARRAY element or slice\00", align 1
@PL_argvgv = external global %struct.gv*
@.str89 = private unnamed_addr constant [37 x i8] c"%s argument is not a subroutine name\00", align 1
@.str90 = private unnamed_addr constant [43 x i8] c"%s argument is not a HASH or ARRAY element\00", align 1
@.str91 = private unnamed_addr constant [9 x i8] c"a SCALAR\00", align 1
@.str92 = private unnamed_addr constant [9 x i8] c"an ARRAY\00", align 1
@.str93 = private unnamed_addr constant [7 x i8] c"a HASH\00", align 1
@.str94 = private unnamed_addr constant [7 x i8] c"a CODE\00", align 1
@.str95 = private unnamed_addr constant [29 x i8] c"Constant is not %s reference\00", align 1
@.str96 = private unnamed_addr constant [63 x i8] c"Can't use bareword (\22%s\22) as %s ref while \22strict refs\22 in use\00", align 1
@PL_stdingv = external global %struct.gv*
@.str97 = private unnamed_addr constant [33 x i8] c"Useless use of %s with no values\00", align 1
@.str98 = private unnamed_addr constant [48 x i8] c"Array @%s missing the @ in argument %ld of %s()\00", align 1
@.str99 = private unnamed_addr constant [6 x i8] c"array\00", align 1
@.str100 = private unnamed_addr constant [49 x i8] c"Hash %%%s missing the %% in argument %ld of %s()\00", align 1
@.str101 = private unnamed_addr constant [5 x i8] c"hash\00", align 1
@.str102 = private unnamed_addr constant [7 x i8] c"HANDLE\00", align 1
@.str103 = private unnamed_addr constant [3 x i8] c"[]\00", align 1
@.str104 = private unnamed_addr constant [3 x i8] c"{}\00", align 1
@.str105 = private unnamed_addr constant [10 x i8] c"%s%c...%c\00", align 1
@.str106 = private unnamed_addr constant [11 x i8] c"__ANONIO__\00", align 1
@.str107 = private unnamed_addr constant [2 x i8] c"$\00", align 1
@.str108 = private unnamed_addr constant [5 x i8] c"glob\00", align 1
@.str109 = private unnamed_addr constant [19 x i8] c"CORE::GLOBAL::glob\00", align 1
@.str110 = private unnamed_addr constant [11 x i8] c"File::Glob\00", align 1
@.str111 = private unnamed_addr constant [21 x i8] c"File::Glob::csh_glob\00", align 1
@PL_glob_index = external global i32
@.str112 = private unnamed_addr constant [5 x i8] c"main\00", align 1
@.str113 = private unnamed_addr constant [15 x i8] c"panic: ck_grep\00", align 1
@.str114 = private unnamed_addr constant [30 x i8] c"defined(@array) is deprecated\00", align 1
@.str115 = private unnamed_addr constant [46 x i8] c"\09(Maybe you should just omit the defined()?)\0A\00", align 1
@.str116 = private unnamed_addr constant [30 x i8] c"defined(%%hash) is deprecated\00", align 1
@.str117 = private unnamed_addr constant [8 x i8] c"open_IN\00", align 1
@.str118 = private unnamed_addr constant [9 x i8] c"open_OUT\00", align 1
@.str119 = private unnamed_addr constant [4 x i8] c".pm\00", align 1
@.str120 = private unnamed_addr constant [8 x i8] c"require\00", align 1
@.str121 = private unnamed_addr constant [22 x i8] c"CORE::GLOBAL::require\00", align 1
@.str122 = private unnamed_addr constant [16 x i8] c"panic: ck_split\00", align 1
@.str123 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str124 = private unnamed_addr constant [43 x i8] c"Use of /g modifier is meaningless in split\00", align 1
@.str125 = private unnamed_addr constant [7 x i8] c"STRING\00", align 1
@.str126 = private unnamed_addr constant [40 x i8] c"/%s/ should probably be written as \22%s\22\00", align 1
@.str127 = private unnamed_addr constant [16 x i8] c"block or sub {}\00", align 1
@.str128 = private unnamed_addr constant [7 x i8] c"sub {}\00", align 1
@.str129 = private unnamed_addr constant [10 x i8] c"one of %s\00", align 1
@.str130 = private unnamed_addr constant [7 x i8] c"symbol\00", align 1
@.str131 = private unnamed_addr constant [17 x i8] c"subroutine entry\00", align 1
@.str132 = private unnamed_addr constant [7 x i8] c"scalar\00", align 1
@.str133 = private unnamed_addr constant [31 x i8] c"Malformed prototype for %s: %_\00", align 1
@PL_op_seqmax = external global i16
@.str134 = private unnamed_addr constant [41 x i8] c"%_() called too early to check prototype\00", align 1
@.str135 = private unnamed_addr constant [33 x i8] c"Statement unlikely to be reached\00", align 1
@.str136 = private unnamed_addr constant [51 x i8] c"\09(Maybe you meant system() when you said exec()?)\0A\00", align 1
@.str137 = private unnamed_addr constant [7 x i8] c"FIELDS\00", align 1
@.str138 = private unnamed_addr constant [57 x i8] c"No such pseudo-hash field \22%s\22 in variable %s of type %s\00", align 1
@.str139 = private unnamed_addr constant [41 x i8] c"Bad index while coercing array into hash\00", align 1
@PL_custom_op_names = external global %struct.hv*
@PL_op_name = external global [0 x i8*]
@PL_custom_op_descs = external global %struct.hv*

; Function Attrs: nounwind uwtable
define i64 @Perl_allocmy(i8* %name) #0 {
entry:
  %0 = load i64* @PL_in_my, align 8, !tbaa !1
  %cmp = icmp eq i64 %0, 137
  br i1 %cmp, label %if.end89, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %arrayidx = getelementptr inbounds i8* %name, i64 1
  %1 = load i8* %arrayidx, align 1, !tbaa !5
  %.off = add i8 %1, -65
  %2 = icmp ult i8 %.off, 26
  %.off162 = add i8 %1, -97
  %3 = icmp ult i8 %.off162, 26
  %or.cond = or i1 %2, %3
  br i1 %or.cond, label %if.end89, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %lor.lhs.false
  %4 = load i64* @PL_hints, align 8, !tbaa !1
  %and = and i64 %4, 8388608
  %tobool = icmp ne i64 %and, 0
  %.off163 = add i8 %1, 64
  %5 = icmp ult i8 %.off163, 62
  %or.cond167 = and i1 %tobool, %5
  br i1 %or.cond167, label %if.end89, label %lor.lhs.false28

lor.lhs.false28:                                  ; preds = %lor.lhs.false17
  %cmp31 = icmp eq i8 %1, 95
  br i1 %cmp31, label %land.lhs.true33, label %if.then

land.lhs.true33:                                  ; preds = %lor.lhs.false28
  %call = tail call i64 @strlen(i8* %name) #4
  %conv34 = trunc i64 %call to i32
  %cmp35 = icmp sgt i32 %conv34, 2
  br i1 %cmp35, label %if.end89, label %if.then

if.then:                                          ; preds = %land.lhs.true33, %lor.lhs.false28
  %notlhs = icmp sgt i8 %1, 32
  %notrhs = icmp ne i8 %1, 127
  %or.cond159.not = and i1 %notrhs, %notlhs
  %cmp49 = icmp eq i8 %1, 32
  %or.cond161 = or i1 %or.cond159.not, %cmp49
  br i1 %or.cond161, label %lor.lhs.false51, label %if.then56

lor.lhs.false51:                                  ; preds = %if.then
  %conv53 = sext i8 %1 to i32
  %memchr = tail call i8* @memchr(i8* getelementptr inbounds ([5 x i8]* @.str, i64 0, i64 0), i32 %conv53, i64 5)
  %tobool55 = icmp eq i8* %memchr, null
  br i1 %tobool55, label %if.end86, label %if.then56

if.then56:                                        ; preds = %if.then, %lor.lhs.false51
  %strlen = tail call i64 @strlen(i8* %name) #4
  %sub.ptr.rhs.cast = ptrtoint i8* %name to i64
  %cmp58 = icmp sgt i64 %strlen, 200
  br i1 %cmp58, label %if.then60, label %if.else

if.then60:                                        ; preds = %if.then56
  %add.ptr = getelementptr inbounds i8* %name, i64 200
  %6 = bitcast i8* %add.ptr to i32*
  store i32 3026478, i32* %6, align 1
  %add.ptr62 = getelementptr inbounds i8* %name, i64 199
  br label %for.cond.preheader

if.else:                                          ; preds = %if.then56
  %strchr = getelementptr i8* %name, i64 %strlen
  %strchr.sum = add i64 %strlen, 1
  %arrayidx63 = getelementptr inbounds i8* %name, i64 %strchr.sum
  store i8 0, i8* %arrayidx63, align 1, !tbaa !5
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.else, %if.then60
  %p.0.ph = phi i8* [ %add.ptr62, %if.then60 ], [ %strchr, %if.else ]
  %sub.ptr.lhs.cast64168 = ptrtoint i8* %p.0.ph to i64
  %sub.ptr.sub66169 = sub i64 %sub.ptr.lhs.cast64168, %sub.ptr.rhs.cast
  %cmp67170 = icmp sgt i64 %sub.ptr.sub66169, 2
  br i1 %cmp67170, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond.preheader, %for.body
  %p.0171 = phi i8* [ %add.ptr69, %for.body ], [ %p.0.ph, %for.cond.preheader ]
  %add.ptr69 = getelementptr inbounds i8* %p.0171, i64 -1
  %7 = load i8* %add.ptr69, align 1, !tbaa !5
  store i8 %7, i8* %p.0171, align 1, !tbaa !5
  %sub.ptr.lhs.cast64 = ptrtoint i8* %add.ptr69 to i64
  %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast
  %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2
  br i1 %cmp67, label %for.body, label %for.end

for.end:                                          ; preds = %for.body, %for.cond.preheader
  %8 = load i8* %arrayidx, align 1, !tbaa !5
  %.off164 = add i8 %8, -97
  %9 = icmp ult i8 %.off164, 26
  %sub = add i8 %8, -32
  %sub. = select i1 %9, i8 %sub, i8 %8
  %xor = xor i8 %sub., 64
  %arrayidx84 = getelementptr inbounds i8* %name, i64 2
  store i8 %xor, i8* %arrayidx84, align 1, !tbaa !5
  store i8 94, i8* %arrayidx, align 1, !tbaa !5
  br label %if.end86

if.end86:                                         ; preds = %lor.lhs.false51, %for.end
  %call87 = tail call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([28 x i8]* @.str2, i64 0, i64 0), i8* %name) #4
  %call88 = tail call i32 (i8*, ...)* bitcast (i32 (...)* @yyerror to i32 (i8*, ...)*)(i8* %call87) #4
  %.pre = load i64* @PL_in_my, align 8, !tbaa !1
  br label %if.end89

if.end89:                                         ; preds = %lor.lhs.false17, %lor.lhs.false, %if.end86, %land.lhs.true33, %entry
  %10 = phi i64 [ %0, %lor.lhs.false17 ], [ %0, %lor.lhs.false ], [ %.pre, %if.end86 ], [ %0, %land.lhs.true33 ], [ 137, %entry ]
  %cmp90 = icmp eq i64 %10, 137
  %conv93 = zext i1 %cmp90 to i32
  %11 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  %tobool94 = icmp ne %struct.hv* %11, null
  %12 = load %struct.hv** @PL_defstash, align 8, !tbaa !6
  %cond98 = select i1 %tobool94, %struct.hv* %11, %struct.hv* %12
  %call99 = tail call i32 (i8*, i32, %struct.hv*, ...)* bitcast (i32 (...)* @pad_check_dup to i32 (i8*, i32, %struct.hv*, ...)*)(i8* %name, i32 %conv93, %struct.hv* %cond98) #4
  %13 = load %struct.hv** @PL_in_my_stash, align 8, !tbaa !6
  %tobool100 = icmp eq %struct.hv* %13, null
  br i1 %tobool100, label %if.end111, label %land.lhs.true101

land.lhs.true101:                                 ; preds = %if.end89
  %14 = load i8* %name, align 1, !tbaa !5
  %cmp103 = icmp eq i8 %14, 36
  br i1 %cmp103, label %if.end111, label %if.then105

if.then105:                                       ; preds = %land.lhs.true101
  %15 = load i64* @PL_in_my, align 8, !tbaa !1
  %cmp106 = icmp eq i64 %15, 137
  %cond108 = select i1 %cmp106, i8* getelementptr inbounds ([4 x i8]* @.str4, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8]* @.str5, i64 0, i64 0)
  %call109 = tail call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([46 x i8]* @.str3, i64 0, i64 0), i8* %name, i8* %cond108) #4
  %call110 = tail call i32 (i8*, ...)* bitcast (i32 (...)* @yyerror to i32 (i8*, ...)*)(i8* %call109) #4
  %.pre172 = load %struct.hv** @PL_in_my_stash, align 8, !tbaa !6
  br label %if.end111

if.end111:                                        ; preds = %land.lhs.true101, %if.end89, %if.then105
  %16 = phi %struct.hv* [ %13, %land.lhs.true101 ], [ null, %if.end89 ], [ %.pre172, %if.then105 ]
  %17 = load i64* @PL_in_my, align 8, !tbaa !1
  %cmp112 = icmp eq i64 %17, 137
  br i1 %cmp112, label %cond.true114, label %cond.end121

cond.true114:                                     ; preds = %if.end111
  %18 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  %tobool115 = icmp ne %struct.hv* %18, null
  %19 = load %struct.hv** @PL_defstash, align 8, !tbaa !6
  %cond119 = select i1 %tobool115, %struct.hv* %18, %struct.hv* %19
  br label %cond.end121

cond.end121:                                      ; preds = %if.end111, %cond.true114
  %cond122 = phi %struct.hv* [ %cond119, %cond.true114 ], [ null, %if.end111 ]
  %call123 = tail call i32 (i8*, %struct.hv*, %struct.hv*, i32, ...)* bitcast (i32 (...)* @pad_add_name to i32 (i8*, %struct.hv*, %struct.hv*, i32, ...)*)(i8* %name, %struct.hv* %16, %struct.hv* %cond122, i32 0) #4
  %conv124 = sext i32 %call123 to i64
  ret i64 %conv124
}

; Function Attrs: nounwind readonly
declare i64 @strlen(i8* nocapture) #1

; Function Attrs: nounwind readonly
declare i8* @strchr(i8*, i32) #1

declare i32 @yyerror(...) #2

declare i8* @Perl_form(i8*, ...) #2

declare i32 @pad_check_dup(...) #2

declare i32 @pad_add_name(...) #2

; Function Attrs: nounwind uwtable
define void @Perl_op_free(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %op_seq = getelementptr inbounds %struct.op* %o, i64 0, i32 5
  %0 = load i16* %op_seq, align 2, !tbaa !8
  %cmp = icmp eq i16 %0, -1
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %1 = load i8* %op_private, align 1, !tbaa !11
  %and = and i8 %1, 64
  %tobool3 = icmp eq i8 %and, 0
  br i1 %tobool3, label %if.end9, label %if.then4

if.then4:                                         ; preds = %if.end
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !12
  %conv5 = zext i16 %2 to i32
  switch i32 %conv5, label %if.end9 [
    i32 167, label %sw.bb
    i32 168, label %sw.bb
    i32 312, label %sw.bb
    i32 178, label %sw.bb
    i32 179, label %sw.bb
    i32 207, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.then4, %if.then4, %if.then4, %if.then4, %if.then4, %if.then4
  %op_targ = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !13
  %dec = add i64 %3, -1
  store i64 %dec, i64* %op_targ, align 8, !tbaa !13
  %tobool6 = icmp eq i64 %dec, 0
  br i1 %tobool6, label %if.end9, label %return

if.end9:                                          ; preds = %sw.bb, %if.end, %if.then4
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %4 = load i8* %op_flags, align 1, !tbaa !14
  %and11 = and i8 %4, 4
  %tobool12 = icmp eq i8 %and11, 0
  br i1 %tobool12, label %if.end15, label %if.then13

if.then13:                                        ; preds = %if.end9
  %5 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %6 = load %struct.op** %5, align 8, !tbaa !15
  %tobool1454 = icmp eq %struct.op* %6, null
  br i1 %tobool1454, label %if.end15, label %for.body

for.body:                                         ; preds = %if.then13, %for.body
  %kid.055 = phi %struct.op* [ %7, %for.body ], [ %6, %if.then13 ]
  %op_sibling = getelementptr inbounds %struct.op* %kid.055, i64 0, i32 1
  %7 = load %struct.op** %op_sibling, align 8, !tbaa !17
  tail call void @Perl_op_free(%struct.op* %kid.055)
  %tobool14 = icmp eq %struct.op* %7, null
  br i1 %tobool14, label %if.end15, label %for.body

if.end15:                                         ; preds = %for.body, %if.then13, %if.end9
  %op_type16 = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %8 = load i16* %op_type16, align 2, !tbaa !12
  %cmp18 = icmp eq i16 %8, 0
  br i1 %cmp18, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end15
  %op_targ21 = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %9 = load i64* %op_targ21, align 8, !tbaa !13
  %conv22 = trunc i64 %9 to i16
  br label %if.end23

if.end23:                                         ; preds = %if.then20, %if.end15
  %type.0 = phi i16 [ %conv22, %if.then20 ], [ %8, %if.end15 ]
  switch i16 %type.0, label %if.end36 [
    i16 174, label %if.then35
    i16 349, label %if.then35
    i16 175, label %if.then35
  ]

if.then35:                                        ; preds = %if.end23, %if.end23, %if.end23
  %10 = bitcast %struct.op* %o to %struct.cop*
  %call = tail call i32 (%struct.cop*, ...)* bitcast (i32 (...)* @cop_free to i32 (%struct.cop*, ...)*)(%struct.cop* %10) #4
  br label %if.end36

if.end36:                                         ; preds = %if.end23, %if.then35
  %call37 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %11 = bitcast %struct.op* %o to i8*
  tail call void @Perl_safesysfree(i8* %11) #4
  br label %return

return:                                           ; preds = %sw.bb, %entry, %lor.lhs.false, %if.end36
  ret void
}

declare i32 @cop_free(...) #2

declare i32 @op_clear(...) #2

declare void @Perl_safesysfree(i8*) #2

; Function Attrs: nounwind uwtable
define void @Perl_op_clear(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %conv = zext i16 %0 to i32
  switch i32 %conv, label %sw.default [
    i32 0, label %sw.bb
    i32 311, label %sw.bb
    i32 6, label %sw.bb4
    i32 7, label %sw.bb4
    i32 126, label %sw.bb4
    i32 350, label %sw.bb16
    i32 5, label %sw.bb16
    i32 189, label %sw.bb19
    i32 186, label %sw.bb19
    i32 185, label %sw.bb19
    i32 187, label %sw.bb19
    i32 35, label %sw.bb26
    i32 33, label %sw.bb35
    i32 13, label %sw.bb36
    i32 31, label %clear_pmop
    i32 32, label %clear_pmop
  ]

sw.bb:                                            ; preds = %entry, %entry
  %op_targ = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  store i64 0, i64* %op_targ, align 8, !tbaa !13
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %1, 16
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %sw.epilog, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.default
  %idxprom = zext i16 %0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %idxprom
  %2 = load %struct.op* (%struct.op*)** %arrayidx, align 8, !tbaa !6
  %cmp = icmp eq %struct.op* (%struct.op*)* %2, @Perl_ck_ftst
  br i1 %cmp, label %sw.bb4, label %sw.epilog

sw.bb4:                                           ; preds = %lor.lhs.false, %entry, %entry, %entry
  %cmp7 = icmp eq i16 %0, 126
  br i1 %cmp7, label %land.lhs.true, label %if.then13

land.lhs.true:                                    ; preds = %sw.bb4
  %op_flags9 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %3 = load i8* %op_flags9, align 1, !tbaa !14
  %tobool12 = icmp slt i8 %3, 0
  br i1 %tobool12, label %sw.epilog, label %if.then13

if.then13:                                        ; preds = %land.lhs.true, %sw.bb4
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %4 = bitcast %struct.op* %op_sv to %struct.sv**
  %5 = load %struct.sv** %4, align 8, !tbaa !18
  tail call void @Perl_sv_free(%struct.sv* %5) #4
  %6 = getelementptr inbounds %struct.op* %op_sv, i64 0, i32 0
  store %struct.op* null, %struct.op** %6, align 8, !tbaa !18
  br label %sw.epilog

sw.bb16:                                          ; preds = %entry, %entry
  %op_sv17 = getelementptr inbounds %struct.op* %o, i64 1
  %7 = bitcast %struct.op* %op_sv17 to %struct.sv**
  %8 = load %struct.sv** %7, align 8, !tbaa !18
  tail call void @Perl_sv_free(%struct.sv* %8) #4
  %9 = getelementptr inbounds %struct.op* %op_sv17, i64 0, i32 0
  store %struct.op* null, %struct.op** %9, align 8, !tbaa !18
  br label %sw.epilog

sw.bb19:                                          ; preds = %entry, %entry, %entry, %entry
  %op_flags20 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %10 = load i8* %op_flags20, align 1, !tbaa !14
  %and22 = and i8 %10, -60
  %tobool23 = icmp eq i8 %and22, 0
  br i1 %tobool23, label %sw.bb26, label %sw.epilog

sw.bb26:                                          ; preds = %sw.bb19, %entry
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %11 = load i8* %op_private, align 1, !tbaa !11
  %and28 = and i8 %11, 3
  %tobool29 = icmp eq i8 %and28, 0
  %op_pv = getelementptr inbounds %struct.op* %o, i64 1
  br i1 %tobool29, label %if.else, label %if.then30

if.then30:                                        ; preds = %sw.bb26
  %12 = bitcast %struct.op* %op_pv to %struct.sv**
  %13 = load %struct.sv** %12, align 8, !tbaa !18
  tail call void @Perl_sv_free(%struct.sv* %13) #4
  %14 = getelementptr inbounds %struct.op* %op_pv, i64 0, i32 0
  store %struct.op* null, %struct.op** %14, align 8, !tbaa !18
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb26
  %15 = bitcast %struct.op* %op_pv to i8**
  %16 = load i8** %15, align 8, !tbaa !20
  tail call void @Perl_safesysfree(i8* %16) #4
  %17 = getelementptr inbounds %struct.op* %op_pv, i64 0, i32 0
  store %struct.op* null, %struct.op** %17, align 8, !tbaa !20
  br label %sw.epilog

sw.bb35:                                          ; preds = %entry
  %op_pmreplroot = getelementptr inbounds %struct.op* %o, i64 1, i32 2
  %18 = load %struct.op* ()** %op_pmreplroot, align 8
  %19 = bitcast %struct.op* ()* %18 to %struct.op*
  tail call void @Perl_op_free(%struct.op* %19)
  br label %clear_pmop

sw.bb36:                                          ; preds = %entry
  %op_pmreplroot37 = getelementptr inbounds %struct.op* %o, i64 1, i32 2
  %20 = load %struct.op* ()** %op_pmreplroot37, align 8
  %21 = bitcast %struct.op* ()* %20 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %21) #4
  br label %clear_pmop

clear_pmop:                                       ; preds = %sw.bb36, %entry, %entry, %sw.bb35
  %22 = bitcast %struct.op* %o to %struct.pmop*
  %op_pmstash = getelementptr inbounds %struct.op* %o, i64 2, i32 4
  %23 = bitcast i16* %op_pmstash to %struct.hv**
  %24 = load %struct.hv** %23, align 8, !tbaa !22
  %tobool39 = icmp eq %struct.hv* %24, null
  br i1 %tobool39, label %if.end57, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %clear_pmop
  %sv_refcnt = getelementptr inbounds %struct.hv* %24, i64 0, i32 1
  %25 = load i64* %sv_refcnt, align 8, !tbaa !24
  %tobool41 = icmp eq i64 %25, 0
  br i1 %tobool41, label %if.end57, label %if.then42

if.then42:                                        ; preds = %land.lhs.true40
  %sv_any = getelementptr inbounds %struct.hv* %24, i64 0, i32 0
  %26 = load %struct.xpvhv** %sv_any, align 8, !tbaa !26
  %xhv_pmroot = getelementptr inbounds %struct.xpvhv* %26, i64 0, i32 9
  %pmop.0101 = load %struct.pmop** %xhv_pmroot, align 8
  %tobool43102 = icmp eq %struct.pmop* %pmop.0101, null
  br i1 %tobool43102, label %if.end57, label %while.body

while.cond:                                       ; preds = %while.body
  %op_pmnext56 = getelementptr inbounds %struct.pmop* %pmop.0104, i64 0, i32 12
  %pmop.0 = load %struct.pmop** %op_pmnext56, align 8
  %tobool43 = icmp eq %struct.pmop* %pmop.0, null
  br i1 %tobool43, label %if.end57, label %while.body

while.body:                                       ; preds = %if.then42, %while.cond
  %pmop.0104 = phi %struct.pmop* [ %pmop.0, %while.cond ], [ %pmop.0101, %if.then42 ]
  %lastpmop.0103 = phi %struct.pmop* [ %pmop.0104, %while.cond ], [ null, %if.then42 ]
  %cmp44 = icmp eq %struct.pmop* %22, %pmop.0104
  br i1 %cmp44, label %if.then46, label %while.cond

if.then46:                                        ; preds = %while.body
  %tobool47 = icmp eq %struct.pmop* %lastpmop.0103, null
  %op_pmnext = getelementptr inbounds %struct.op* %o, i64 1, i32 4
  %27 = bitcast i16* %op_pmnext to %struct.pmop**
  %28 = load %struct.pmop** %27, align 8, !tbaa !27
  br i1 %tobool47, label %if.else50, label %if.then48

if.then48:                                        ; preds = %if.then46
  %op_pmnext49 = getelementptr inbounds %struct.pmop* %lastpmop.0103, i64 0, i32 12
  store %struct.pmop* %28, %struct.pmop** %op_pmnext49, align 8, !tbaa !27
  br label %if.end57

if.else50:                                        ; preds = %if.then46
  store %struct.pmop* %28, %struct.pmop** %xhv_pmroot, align 8, !tbaa !28
  br label %if.end57

if.end57:                                         ; preds = %while.cond, %if.then42, %land.lhs.true40, %clear_pmop, %if.else50, %if.then48
  %op_pmreplroot58 = getelementptr inbounds %struct.op* %o, i64 1, i32 2
  store %struct.op* ()* null, %struct.op* ()** %op_pmreplroot58, align 8, !tbaa !31
  %29 = load void (%struct.regexp*)** @PL_regfree, align 8, !tbaa !6
  %op_pmregexp = getelementptr inbounds %struct.op* %o, i64 2
  %30 = bitcast %struct.op* %op_pmregexp to %struct.regexp**
  %31 = load %struct.regexp** %30, align 8, !tbaa !32
  tail call void %29(%struct.regexp* %31) #4
  %32 = getelementptr inbounds %struct.op* %op_pmregexp, i64 0, i32 0
  store %struct.op* null, %struct.op** %32, align 8, !tbaa !32
  br label %sw.epilog

sw.epilog:                                        ; preds = %lor.lhs.false, %sw.default, %sw.bb19, %if.then30, %if.else, %land.lhs.true, %if.then13, %if.end57, %sw.bb16, %sw.bb
  %op_targ60 = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %33 = load i64* %op_targ60, align 8, !tbaa !13
  %cmp61 = icmp eq i64 %33, 0
  br i1 %cmp61, label %if.end66, label %if.then63

if.then63:                                        ; preds = %sw.epilog
  %call = tail call i32 (i64, ...)* bitcast (i32 (...)* @pad_free to i32 (i64, ...)*)(i64 %33) #4
  store i64 0, i64* %op_targ60, align 8, !tbaa !13
  br label %if.end66

if.end66:                                         ; preds = %sw.epilog, %if.then63
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_ftst(%struct.op* %o) #0 {
entry:
  %n_a = alloca i64, align 8
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %conv = zext i16 %0 to i64
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !14
  %conv1 = zext i8 %1 to i32
  %and = and i32 %conv1, 16
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.else, label %if.end74

if.else:                                          ; preds = %entry
  %and4 = and i32 %conv1, 4
  %tobool5 = icmp eq i32 %and4, 0
  br i1 %tobool5, label %if.else63, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %2 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %3 = load %struct.op** %2, align 8, !tbaa !15
  %op_type6 = getelementptr inbounds %struct.op* %3, i64 0, i32 4
  %4 = load i16* %op_type6, align 2, !tbaa !12
  switch i16 %4, label %if.else26 [
    i16 1, label %if.else63
    i16 5, label %land.lhs.true15
  ]

land.lhs.true15:                                  ; preds = %land.lhs.true
  %5 = getelementptr inbounds %struct.op* %3, i64 0, i32 7
  %6 = load i8* %5, align 1, !tbaa !33
  %and17 = and i8 %6, 64
  %tobool18 = icmp eq i8 %and17, 0
  br i1 %tobool18, label %if.else26, label %if.then19

if.then19:                                        ; preds = %land.lhs.true15
  %op_sv = getelementptr inbounds %struct.op* %3, i64 1
  %7 = bitcast %struct.op* %op_sv to %struct.sv**
  %8 = load %struct.sv** %7, align 8, !tbaa !18
  store %struct.sv* %8, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %sv_flags = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %9 = load i64* %sv_flags, align 8, !tbaa !34
  %and20 = and i64 %9, 262144
  %cmp21 = icmp eq i64 %and20, 0
  br i1 %cmp21, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then19
  %sv_any = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %10 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_cur = getelementptr inbounds i8* %10, i64 8
  %11 = bitcast i8* %xpv_cur to i64*
  %12 = load i64* %11, align 8, !tbaa !37
  store i64 %12, i64* %n_a, align 8, !tbaa !1
  %xpv_pv = bitcast i8* %10 to i8**
  %13 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %cond.end

cond.false:                                       ; preds = %if.then19
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %8, i64* %n_a, i64 2) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %13, %cond.true ], [ %call, %cond.false ]
  %call24 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond, i64 1, i64 15) #4
  %14 = bitcast %struct.gv* %call24 to %struct.sv*
  store %struct.sv* %14, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool.i = icmp eq %struct.gv* %call24, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %cond.end
  %15 = getelementptr inbounds %struct.gv* %call24, i64 0, i32 1
  %16 = load i64* %15, align 8, !tbaa !40
  %inc.i = add i64 %16, 1
  store i64 %inc.i, i64* %15, align 8, !tbaa !40
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %cond.end, %land.rhs.i
  %call.i = call %struct.op* @Perl_newSVOP(i64 %conv, i64 16, %struct.sv* %14) #4
  call void @Perl_op_free(%struct.op* %o)
  br label %if.end74

if.else26:                                        ; preds = %land.lhs.true, %land.lhs.true15
  %17 = load i64* @PL_hints, align 8, !tbaa !1
  %and27 = and i64 %17, 4194304
  %tobool28 = icmp ne i64 %and27, 0
  %.off = add i16 %0, -236
  %switch = icmp ult i16 %.off, 6
  %or.cond = and i1 %tobool28, %switch
  br i1 %or.cond, label %if.then58, label %if.end74

if.then58:                                        ; preds = %if.else26
  %op_private59 = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %18 = load i8* %op_private59, align 1, !tbaa !11
  %or = or i8 %18, 2
  store i8 %or, i8* %op_private59, align 1, !tbaa !11
  br label %if.end74

if.else63:                                        ; preds = %land.lhs.true, %if.else
  call void @Perl_op_free(%struct.op* %o)
  %cmp64 = icmp eq i16 %0, 260
  br i1 %cmp64, label %if.then66, label %if.else68

if.then66:                                        ; preds = %if.else63
  %19 = load %struct.gv** @PL_stdingv, align 8, !tbaa !6
  %20 = bitcast %struct.gv* %19 to %struct.sv*
  store %struct.sv* %20, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool.i93 = icmp eq %struct.gv* %19, null
  br i1 %tobool.i93, label %Perl_newGVOP.exit97, label %land.rhs.i95

land.rhs.i95:                                     ; preds = %if.then66
  %21 = getelementptr inbounds %struct.gv* %19, i64 0, i32 1
  %22 = load i64* %21, align 8, !tbaa !40
  %inc.i94 = add i64 %22, 1
  store i64 %inc.i94, i64* %21, align 8, !tbaa !40
  br label %Perl_newGVOP.exit97

Perl_newGVOP.exit97:                              ; preds = %if.then66, %land.rhs.i95
  %call.i96 = call %struct.op* @Perl_newSVOP(i64 %conv, i64 16, %struct.sv* %20) #4
  br label %if.end74

if.else68:                                        ; preds = %if.else63
  %call69 = call i32 (...)* @newDEFSVOP() #4
  %conv70 = sext i32 %call69 to i64
  %23 = inttoptr i64 %conv70 to %struct.op*
  %call71 = call %struct.op* @Perl_newUNOP(i64 %conv, i64 0, %struct.op* %23)
  br label %if.end74

if.end74:                                         ; preds = %if.else26, %entry, %if.then58, %Perl_newGVOP.exit, %if.else68, %Perl_newGVOP.exit97
  %o.addr.0 = phi %struct.op* [ %o, %entry ], [ %call.i, %Perl_newGVOP.exit ], [ %o, %if.then58 ], [ %o, %if.else26 ], [ %call.i96, %Perl_newGVOP.exit97 ], [ %call71, %if.else68 ]
  ret %struct.op* %o.addr.0
}

declare void @Perl_sv_free(%struct.sv*) #2

declare i32 @pad_free(...) #2

; Function Attrs: nounwind uwtable
define void @Perl_op_null(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %0, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %1 = load i16* %op_type, align 2, !tbaa !12
  %conv3 = zext i16 %1 to i64
  %op_targ = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  store i64 %conv3, i64* %op_targ, align 8, !tbaa !13
  store i16 0, i16* %op_type, align 2, !tbaa !12
  %2 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %2, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: nounwind readnone uwtable
define void @Perl_op_refcnt_lock() #3 {
entry:
  ret void
}

; Function Attrs: nounwind readnone uwtable
define void @Perl_op_refcnt_unlock() #3 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_linklist(%struct.op* %o) #0 {
entry:
  %op_next = getelementptr inbounds %struct.op* %o, i64 0, i32 0
  %0 = load %struct.op** %op_next, align 8, !tbaa !42
  %tobool = icmp eq %struct.op* %0, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !15
  %tobool2 = icmp eq %struct.op* %2, null
  br i1 %tobool2, label %if.else31, label %if.then3

if.then3:                                         ; preds = %if.end
  %op_next5 = getelementptr inbounds %struct.op* %2, i64 0, i32 0
  %3 = load %struct.op** %op_next5, align 8, !tbaa !42
  %tobool6 = icmp eq %struct.op* %3, null
  br i1 %tobool6, label %cond.end, label %cond.end.thread

cond.end.thread:                                  ; preds = %if.then3
  store %struct.op* %3, %struct.op** %op_next, align 8, !tbaa !42
  br label %for.body

cond.end:                                         ; preds = %if.then3
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %2) #4
  %conv = sext i32 %call to i64
  %4 = inttoptr i64 %conv to %struct.op*
  %kid.049.pre = load %struct.op** %1, align 8
  store %struct.op* %4, %struct.op** %op_next, align 8, !tbaa !42
  %tobool1250 = icmp eq %struct.op* %kid.049.pre, null
  br i1 %tobool1250, label %return, label %for.body

for.body:                                         ; preds = %for.cond.backedge.thread59, %for.cond.backedge, %cond.end, %cond.end.thread
  %kid.051 = phi %struct.op* [ %kid.049.pre, %cond.end ], [ %2, %cond.end.thread ], [ %kid.0.pre.pre, %for.cond.backedge ], [ %5, %for.cond.backedge.thread59 ]
  %op_sibling = getelementptr inbounds %struct.op* %kid.051, i64 0, i32 1
  %5 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %tobool13 = icmp eq %struct.op* %5, null
  br i1 %tobool13, label %for.cond.backedge.thread, label %if.then14

if.then14:                                        ; preds = %for.body
  %op_next16 = getelementptr inbounds %struct.op* %5, i64 0, i32 0
  %6 = load %struct.op** %op_next16, align 8, !tbaa !42
  %tobool17 = icmp eq %struct.op* %6, null
  br i1 %tobool17, label %for.cond.backedge, label %for.cond.backedge.thread59

for.cond.backedge.thread59:                       ; preds = %if.then14
  %op_next2760 = getelementptr inbounds %struct.op* %kid.051, i64 0, i32 0
  store %struct.op* %6, %struct.op** %op_next2760, align 8, !tbaa !42
  br label %for.body

for.cond.backedge:                                ; preds = %if.then14
  %call23 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %5) #4
  %conv24 = sext i32 %call23 to i64
  %7 = inttoptr i64 %conv24 to %struct.op*
  %kid.0.pre.pre = load %struct.op** %op_sibling, align 8
  %op_next27 = getelementptr inbounds %struct.op* %kid.051, i64 0, i32 0
  store %struct.op* %7, %struct.op** %op_next27, align 8, !tbaa !42
  %tobool12 = icmp eq %struct.op* %kid.0.pre.pre, null
  br i1 %tobool12, label %for.cond.if.end33.loopexit_crit_edge, label %for.body

for.cond.backedge.thread:                         ; preds = %for.body
  %op_next28 = getelementptr inbounds %struct.op* %kid.051, i64 0, i32 0
  store %struct.op* %o, %struct.op** %op_next28, align 8, !tbaa !42
  br label %for.cond.if.end33.loopexit_crit_edge

if.else31:                                        ; preds = %if.end
  store %struct.op* %o, %struct.op** %op_next, align 8, !tbaa !42
  br label %return

for.cond.if.end33.loopexit_crit_edge:             ; preds = %for.cond.backedge, %for.cond.backedge.thread
  %.pre.pre = load %struct.op** %op_next, align 8, !tbaa !42
  br label %return

return:                                           ; preds = %if.else31, %for.cond.if.end33.loopexit_crit_edge, %cond.end, %entry
  %retval.0 = phi %struct.op* [ %0, %entry ], [ %o, %if.else31 ], [ %.pre.pre, %for.cond.if.end33.loopexit_crit_edge ], [ %4, %cond.end ]
  ret %struct.op* %retval.0
}

declare i32 @linklist(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_scalarkids(%struct.op* readonly %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 4
  %tobool1 = icmp eq i8 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.08 = load %struct.op** %1, align 8
  %tobool29 = icmp eq %struct.op* %kid.08, null
  br i1 %tobool29, label %if.end, label %for.body

for.body:                                         ; preds = %if.then, %for.body
  %kid.010 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.08, %if.then ]
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %kid.010) #4
  %op_sibling = getelementptr inbounds %struct.op* %kid.010, i64 0, i32 1
  %kid.0 = load %struct.op** %op_sibling, align 8
  %tobool2 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool2, label %if.end, label %for.body

if.end:                                           ; preds = %for.body, %if.then, %land.lhs.true, %entry
  ret %struct.op* %o
}

declare i32 @scalar(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_scalar(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 3
  %tobool1 = icmp ne i8 %and, 0
  %1 = load i64* @PL_error_count, align 8
  %tobool3 = icmp ne i64 %1, 0
  %or.cond = or i1 %tobool1, %tobool3
  br i1 %or.cond, label %return, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %2, 184
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false4
  %and9 = and i8 %0, -4
  %or = or i8 %and9, 2
  store i8 %or, i8* %op_flags, align 1, !tbaa !14
  %conv13 = zext i16 %2 to i32
  switch i32 %conv13, label %sw.default [
    i32 61, label %sw.bb
    i32 160, label %sw.bb14
    i32 159, label %sw.bb14
    i32 162, label %sw.bb14
    i32 139, label %sw.bb19
    i32 150, label %sw.bb74
    i32 141, label %sw.bb58
    i32 173, label %sw.bb58
    i32 179, label %sw.bb58
    i32 178, label %sw.bb47
    i32 314, label %sw.bb47
  ]

sw.bb:                                            ; preds = %if.end
  %3 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %4 = load %struct.op** %3, align 8, !tbaa !43
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %4) #4
  br label %return

sw.bb14:                                          ; preds = %if.end, %if.end, %if.end
  %5 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %6 = load %struct.op** %5, align 8, !tbaa !15
  %kid.0.in134 = getelementptr inbounds %struct.op* %6, i64 0, i32 1
  %kid.0135 = load %struct.op** %kid.0.in134, align 8
  %tobool16136 = icmp eq %struct.op* %kid.0135, null
  br i1 %tobool16136, label %return, label %for.body

for.body:                                         ; preds = %sw.bb14, %for.body
  %kid.0137 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.0135, %sw.bb14 ]
  %call17 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %kid.0137) #4
  %kid.0.in = getelementptr inbounds %struct.op* %kid.0137, i64 0, i32 1
  %kid.0 = load %struct.op** %kid.0.in, align 8
  %tobool16 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool16, label %return, label %for.body

sw.bb19:                                          ; preds = %if.end
  %7 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %8 = load %struct.op** %7, align 8, !tbaa !45
  %tobool21 = icmp eq %struct.op* %8, null
  br i1 %tobool21, label %sw.default, label %land.lhs.true

land.lhs.true:                                    ; preds = %sw.bb19
  %op_type22 = getelementptr inbounds %struct.op* %8, i64 0, i32 4
  %9 = load i16* %op_type22, align 2, !tbaa !12
  %cmp24 = icmp eq i16 %9, 13
  br i1 %cmp24, label %if.then26, label %sw.default

if.then26:                                        ; preds = %land.lhs.true
  %op_pmreplroot = getelementptr inbounds %struct.op* %8, i64 1, i32 2
  %10 = load %struct.op* ()** %op_pmreplroot, align 8
  %tobool27 = icmp eq %struct.op* ()* %10, null
  br i1 %tobool27, label %if.then28, label %sw.default

if.then28:                                        ; preds = %if.then26
  %call29 = tail call i32 (i8*, ...)* bitcast (i32 (...)* @deprecate_old to i32 (i8*, ...)*)(i8* getelementptr inbounds ([21 x i8]* @.str6, i64 0, i64 0)) #4
  %.pre = load i8* %op_flags, align 1, !tbaa !14
  br label %sw.default

sw.default:                                       ; preds = %if.then26, %sw.bb19, %if.then28, %land.lhs.true, %if.end
  %11 = phi i8 [ %or, %if.then26 ], [ %or, %sw.bb19 ], [ %.pre, %if.then28 ], [ %or, %land.lhs.true ], [ %or, %if.end ]
  %and35 = and i8 %11, 4
  %tobool36 = icmp eq i8 %and35, 0
  br i1 %tobool36, label %return, label %if.then37

if.then37:                                        ; preds = %sw.default
  %12 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.1131 = load %struct.op** %12, align 8
  %tobool40132 = icmp eq %struct.op* %kid.1131, null
  br i1 %tobool40132, label %return, label %for.body41

for.body41:                                       ; preds = %if.then37, %for.body41
  %kid.1133 = phi %struct.op* [ %kid.1, %for.body41 ], [ %kid.1131, %if.then37 ]
  %call42 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %kid.1133) #4
  %op_sibling44 = getelementptr inbounds %struct.op* %kid.1133, i64 0, i32 1
  %kid.1 = load %struct.op** %op_sibling44, align 8
  %tobool40 = icmp eq %struct.op* %kid.1, null
  br i1 %tobool40, label %return, label %for.body41

sw.bb47:                                          ; preds = %if.end, %if.end
  %13 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %14 = load %struct.op** %13, align 8, !tbaa !45
  %call49 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %14) #4
  %op_sibling50141 = getelementptr inbounds %struct.op* %14, i64 0, i32 1
  %15 = load %struct.op** %op_sibling50141, align 8, !tbaa !17
  %tobool51142 = icmp eq %struct.op* %15, null
  br i1 %tobool51142, label %while.end, label %while.body

while.body:                                       ; preds = %sw.bb47, %while.cond.backedge
  %16 = phi %struct.op* [ %18, %while.cond.backedge ], [ %15, %sw.bb47 ]
  %op_sibling52 = getelementptr inbounds %struct.op* %16, i64 0, i32 1
  %17 = load %struct.op** %op_sibling52, align 8, !tbaa !17
  %tobool53 = icmp eq %struct.op* %17, null
  br i1 %tobool53, label %if.else, label %if.then54

if.then54:                                        ; preds = %while.body
  %call55 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarvoid to i32 (%struct.op*, ...)*)(%struct.op* %16) #4
  br label %while.cond.backedge

if.else:                                          ; preds = %while.body
  %call56 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %16) #4
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.else, %if.then54
  %18 = load %struct.op** %op_sibling52, align 8, !tbaa !17
  %tobool51 = icmp eq %struct.op* %18, null
  br i1 %tobool51, label %while.end, label %while.body

while.end:                                        ; preds = %while.cond.backedge, %sw.bb47
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !6
  br label %return

sw.bb58:                                          ; preds = %if.end, %if.end, %if.end
  %19 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.3138 = load %struct.op** %19, align 8
  %tobool61139 = icmp eq %struct.op* %kid.3138, null
  br i1 %tobool61139, label %for.end72, label %for.body62

for.body62:                                       ; preds = %sw.bb58, %for.cond60.backedge
  %kid.3140 = phi %struct.op* [ %kid.3, %for.cond60.backedge ], [ %kid.3138, %sw.bb58 ]
  %op_sibling63 = getelementptr inbounds %struct.op* %kid.3140, i64 0, i32 1
  %20 = load %struct.op** %op_sibling63, align 8, !tbaa !17
  %tobool64 = icmp eq %struct.op* %20, null
  br i1 %tobool64, label %if.else67, label %if.then65

if.then65:                                        ; preds = %for.body62
  %call66 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarvoid to i32 (%struct.op*, ...)*)(%struct.op* %kid.3140) #4
  br label %for.cond60.backedge

for.cond60.backedge:                              ; preds = %if.then65, %if.else67
  %kid.3 = load %struct.op** %op_sibling63, align 8
  %tobool61 = icmp eq %struct.op* %kid.3, null
  br i1 %tobool61, label %for.end72, label %for.body62

if.else67:                                        ; preds = %for.body62
  %call68 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %kid.3140) #4
  br label %for.cond60.backedge

for.end72:                                        ; preds = %for.cond60.backedge, %sw.bb58
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !6
  br label %return

sw.bb74:                                          ; preds = %if.end
  %21 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %21, i64 0, i32 14
  %22 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp75 = icmp eq %struct.sv* %22, null
  br i1 %cmp75, label %lor.lhs.false90, label %land.lhs.true77

land.lhs.true77:                                  ; preds = %sw.bb74
  %23 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings78 = getelementptr inbounds %struct.cop* %23, i64 0, i32 14
  %24 = load %struct.sv** %cop_warnings78, align 8, !tbaa !47
  %cmp79 = icmp eq %struct.sv* %24, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp79, label %lor.lhs.false90, label %land.lhs.true81

land.lhs.true81:                                  ; preds = %land.lhs.true77
  %25 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings82 = getelementptr inbounds %struct.cop* %25, i64 0, i32 14
  %26 = load %struct.sv** %cop_warnings82, align 8, !tbaa !47
  %cmp83 = icmp eq %struct.sv* %26, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp83, label %if.then98, label %lor.lhs.false85

lor.lhs.false85:                                  ; preds = %land.lhs.true81
  %27 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings86 = getelementptr inbounds %struct.cop* %27, i64 0, i32 14
  %28 = load %struct.sv** %cop_warnings86, align 8, !tbaa !47
  %sv_any = getelementptr inbounds %struct.sv* %28, i64 0, i32 0
  %29 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %29 to i8**
  %30 = load i8** %xpv_pv, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8* %30, i64 11
  %31 = load i8* %arrayidx, align 1, !tbaa !5
  %and88 = and i8 %31, 4
  %tobool89 = icmp eq i8 %and88, 0
  br i1 %tobool89, label %lor.lhs.false90, label %if.then98

lor.lhs.false90:                                  ; preds = %lor.lhs.false85, %land.lhs.true77, %sw.bb74
  %32 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings91 = getelementptr inbounds %struct.cop* %32, i64 0, i32 14
  %33 = load %struct.sv** %cop_warnings91, align 8, !tbaa !47
  %cmp92 = icmp eq %struct.sv* %33, null
  br i1 %cmp92, label %land.lhs.true94, label %return

land.lhs.true94:                                  ; preds = %lor.lhs.false90
  %34 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and96 = and i8 %34, 1
  %tobool97 = icmp eq i8 %and96, 0
  br i1 %tobool97, label %return, label %if.then98

if.then98:                                        ; preds = %lor.lhs.false85, %land.lhs.true94, %land.lhs.true81
  tail call void (i64, i8*, ...)* @Perl_warner(i64 45, i8* getelementptr inbounds ([38 x i8]* @.str7, i64 0, i64 0)) #4
  br label %return

return:                                           ; preds = %for.body, %for.body41, %sw.bb14, %if.then37, %sw.bb, %while.end, %for.end72, %if.then98, %lor.lhs.false90, %land.lhs.true94, %sw.default, %lor.lhs.false, %lor.lhs.false4, %entry
  ret %struct.op* %o
}

declare i32 @deprecate_old(...) #2

declare i32 @scalarvoid(...) #2

declare void @Perl_warner(i64, i8*, ...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_scalarvoid(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  switch i16 %0, label %if.end [
    i16 174, label %if.then
    i16 349, label %if.then
    i16 175, label %if.then
    i16 0, label %land.lhs.true
  ]

land.lhs.true:                                    ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %1 = load i64* %op_targ, align 8, !tbaa !13
  switch i64 %1, label %if.end [
    i64 174, label %if.then
    i64 349, label %if.then
    i64 175, label %if.then
  ]

if.then:                                          ; preds = %land.lhs.true, %land.lhs.true, %land.lhs.true, %entry, %entry, %entry
  %2 = bitcast %struct.op* %o to %struct.cop*
  store volatile %struct.cop* %2, %struct.cop** @PL_curcop, align 8, !tbaa !6
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry, %if.then
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %3 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %3, 3
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false33, label %land.lhs.true29

land.lhs.true29:                                  ; preds = %if.end
  %cmp31 = icmp ne i8 %and, 2
  %4 = load i64* @PL_error_count, align 8
  %tobool34 = icmp ne i64 %4, 0
  %or.cond = or i1 %cmp31, %tobool34
  br i1 %or.cond, label %return, label %lor.lhs.false35

lor.lhs.false33:                                  ; preds = %if.end
  %.old = load i64* @PL_error_count, align 8, !tbaa !1
  %tobool34.old = icmp eq i64 %.old, 0
  br i1 %tobool34.old, label %lor.lhs.false35, label %return

lor.lhs.false35:                                  ; preds = %lor.lhs.false33, %land.lhs.true29
  %5 = load i16* %op_type, align 2, !tbaa !12
  %cmp38 = icmp eq i16 %5, 184
  br i1 %cmp38, label %return, label %if.end41

if.end41:                                         ; preds = %lor.lhs.false35
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %6 = load i8* %op_private, align 1, !tbaa !11
  %and43 = and i8 %6, 16
  %tobool44 = icmp eq i8 %and43, 0
  br i1 %tobool44, label %if.end51, label %land.lhs.true45

land.lhs.true45:                                  ; preds = %if.end41
  %idxprom = zext i16 %5 to i64
  %arrayidx = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %idxprom
  %7 = load i64* %arrayidx, align 8, !tbaa !1
  %and47 = and i64 %7, 256
  %tobool48 = icmp eq i64 %and47, 0
  br i1 %tobool48, label %if.end51, label %if.then49

if.then49:                                        ; preds = %land.lhs.true45
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv50 = sext i32 %call to i64
  %8 = inttoptr i64 %conv50 to %struct.op*
  br label %return

if.end51:                                         ; preds = %land.lhs.true45, %if.end41
  %and54 = and i8 %3, -4
  %or = or i8 %and54, 1
  store i8 %or, i8* %op_flags, align 1, !tbaa !14
  %conv58 = zext i16 %5 to i32
  switch i32 %conv58, label %sw.default [
    i32 61, label %sw.bb
    i32 111, label %sw.bb72
    i32 6, label %func_ops
    i32 4, label %func_ops
    i32 7, label %func_ops
    i32 9, label %func_ops
    i32 10, label %func_ops
    i32 11, label %func_ops
    i32 12, label %func_ops
    i32 16, label %func_ops
    i32 22, label %func_ops
    i32 20, label %func_ops
    i32 21, label %func_ops
    i32 42, label %func_ops
    i32 107, label %func_ops
    i32 108, label %func_ops
    i32 110, label %func_ops
    i32 112, label %func_ops
    i32 113, label %func_ops
    i32 114, label %func_ops
    i32 115, label %func_ops
    i32 127, label %func_ops
    i32 126, label %func_ops
    i32 128, label %func_ops
    i32 135, label %func_ops
    i32 136, label %func_ops
    i32 137, label %func_ops
    i32 138, label %func_ops
    i32 140, label %func_ops
    i32 142, label %func_ops
    i32 143, label %func_ops
    i32 144, label %func_ops
    i32 150, label %func_ops
    i32 151, label %func_ops
    i32 156, label %func_ops
    i32 157, label %func_ops
    i32 158, label %func_ops
    i32 169, label %func_ops
    i32 194, label %func_ops
    i32 216, label %func_ops
    i32 217, label %func_ops
    i32 232, label %func_ops
    i32 233, label %func_ops
    i32 272, label %func_ops
    i32 277, label %func_ops
    i32 287, label %func_ops
    i32 288, label %func_ops
    i32 290, label %func_ops
    i32 292, label %func_ops
    i32 293, label %func_ops
    i32 294, label %func_ops
    i32 295, label %func_ops
    i32 315, label %func_ops
    i32 316, label %func_ops
    i32 317, label %func_ops
    i32 318, label %func_ops
    i32 319, label %func_ops
    i32 320, label %func_ops
    i32 321, label %func_ops
    i32 322, label %func_ops
    i32 323, label %func_ops
    i32 324, label %func_ops
    i32 325, label %func_ops
    i32 326, label %func_ops
    i32 335, label %func_ops
    i32 336, label %func_ops
    i32 340, label %func_ops
    i32 341, label %func_ops
    i32 345, label %func_ops
    i32 19, label %func_ops
    i32 14, label %sw.bb94
    i32 15, label %sw.bb94
    i32 125, label %sw.bb94
    i32 134, label %sw.bb94
    i32 5, label %sw.bb109
    i32 50, label %sw.bb201
    i32 52, label %sw.bb203
    i32 160, label %sw.bb206
    i32 159, label %sw.bb206
    i32 162, label %sw.bb206
    i32 0, label %sw.bb211
    i32 174, label %sw.bb218
    i32 175, label %sw.bb218
    i32 313, label %sw.bb218
    i32 177, label %sw.bb218
    i32 179, label %sw.bb225
    i32 178, label %sw.bb225
    i32 314, label %sw.bb225
    i32 183, label %sw.bb225
    i32 173, label %sw.bb225
    i32 141, label %sw.bb225
    i32 311, label %sw.bb234
    i32 309, label %sw.bb236
    i32 2, label %sw.bb241
    i32 139, label %sw.bb244
  ]

sw.default:                                       ; preds = %if.end51
  %idxprom60 = zext i16 %5 to i64
  %arrayidx61 = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %idxprom60
  %9 = load i64* %arrayidx61, align 8, !tbaa !1
  %and62 = and i64 %9, 2
  %tobool63 = icmp ne i64 %and62, 0
  %and68 = and i8 %3, 64
  %tobool69 = icmp eq i8 %and68, 0
  %or.cond368 = and i1 %tobool63, %tobool69
  %and82 = and i8 %6, -112
  %tobool83 = icmp eq i8 %and82, 0
  %or.cond370 = and i1 %or.cond368, %tobool83
  br i1 %or.cond370, label %if.then84, label %return

sw.bb:                                            ; preds = %if.end51
  %.old367 = and i8 %3, 64
  %.old369 = and i8 %6, -112
  %10 = or i8 %.old367, %.old369
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %if.then84, label %return

sw.bb72:                                          ; preds = %if.end51
  %cmp75 = icmp ne i8 %6, 4
  %.old371 = and i8 %6, -112
  %tobool83.old.old = icmp eq i8 %.old371, 0
  %or.cond374 = and i1 %cmp75, %tobool83.old.old
  br i1 %or.cond374, label %if.then84, label %return

func_ops:                                         ; preds = %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51
  %.old373 = and i8 %6, -112
  %tobool83.old.old.old = icmp eq i8 %.old373, 0
  br i1 %tobool83.old.old.old, label %if.then84, label %return

if.then84:                                        ; preds = %sw.bb72, %sw.bb, %sw.default, %func_ops
  %cmp87 = icmp eq i16 %5, 351
  br i1 %cmp87, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then84
  %12 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %tobool.i = icmp eq %struct.hv* %12, null
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %cond.true
  %13 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %sw.epilog

if.end.i:                                         ; preds = %cond.true
  %op_ppaddr.i = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  %14 = load %struct.op* ()** %op_ppaddr.i, align 8, !tbaa !41
  %15 = ptrtoint %struct.op* ()* %14 to i64
  %call.i = tail call %struct.sv* @Perl_newSViv(i64 %15) #4
  %call1.i = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call.i) #4
  %16 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %call2.i = tail call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %16, %struct.sv* %call1.i, i64 0, i64 0) #4
  %tobool3.i = icmp eq %struct.he* %call2.i, null
  br i1 %tobool3.i, label %if.then4.i, label %if.end5.i

if.then4.i:                                       ; preds = %if.end.i
  %17 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %sw.epilog

if.end5.i:                                        ; preds = %if.end.i
  %hent_val.i = getelementptr inbounds %struct.he* %call2.i, i64 0, i32 2
  %18 = load %struct.sv** %hent_val.i, align 8, !tbaa !49
  %sv_flags.i = getelementptr inbounds %struct.sv* %18, i64 0, i32 2
  %19 = load i64* %sv_flags.i, align 8, !tbaa !34
  %and.i = and i64 %19, 262144
  %cmp.i = icmp eq i64 %and.i, 0
  br i1 %cmp.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.end5.i
  %sv_any.i = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %20 = load i8** %sv_any.i, align 8, !tbaa !36
  %xpv_pv.i = bitcast i8* %20 to i8**
  %21 = load i8** %xpv_pv.i, align 8, !tbaa !39
  br label %sw.epilog

cond.false.i:                                     ; preds = %if.end5.i
  %call8.i = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %18) #4
  br label %sw.epilog

cond.false:                                       ; preds = %if.then84
  %idxprom91 = zext i16 %5 to i64
  %arrayidx92 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom91
  %22 = load i8** %arrayidx92, align 8, !tbaa !6
  br label %sw.epilog

sw.bb94:                                          ; preds = %if.end51, %if.end51, %if.end51, %if.end51
  %and97 = and i8 %6, -112
  %tobool98 = icmp eq i8 %and97, 0
  br i1 %tobool98, label %land.lhs.true99, label %return

land.lhs.true99:                                  ; preds = %sw.bb94
  %op_sibling = getelementptr inbounds %struct.op* %o, i64 0, i32 1
  %23 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %tobool100 = icmp eq %struct.op* %23, null
  br i1 %tobool100, label %land.lhs.true259, label %lor.lhs.false101

lor.lhs.false101:                                 ; preds = %land.lhs.true99
  %op_type103 = getelementptr inbounds %struct.op* %23, i64 0, i32 4
  %24 = load i16* %op_type103, align 2, !tbaa !12
  %cmp105 = icmp eq i16 %24, 26
  br i1 %cmp105, label %return, label %land.lhs.true259

sw.bb109:                                         ; preds = %if.end51
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %25 = bitcast %struct.op* %op_sv to %struct.sv**
  %26 = load %struct.sv** %25, align 8, !tbaa !18
  %and112 = and i8 %6, 8
  %tobool113 = icmp eq i8 %and112, 0
  br i1 %tobool113, label %if.else, label %if.then114

if.then114:                                       ; preds = %sw.bb109
  %call115 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @no_bareword_allowed to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  br label %if.end200

if.else:                                          ; preds = %sw.bb109
  %27 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %27, i64 0, i32 14
  %28 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp116 = icmp eq %struct.sv* %28, null
  br i1 %cmp116, label %lor.lhs.false132, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else
  %29 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings119 = getelementptr inbounds %struct.cop* %29, i64 0, i32 14
  %30 = load %struct.sv** %cop_warnings119, align 8, !tbaa !47
  %cmp120 = icmp eq %struct.sv* %30, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp120, label %lor.lhs.false132, label %land.lhs.true122

land.lhs.true122:                                 ; preds = %land.lhs.true118
  %31 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings123 = getelementptr inbounds %struct.cop* %31, i64 0, i32 14
  %32 = load %struct.sv** %cop_warnings123, align 8, !tbaa !47
  %cmp124 = icmp eq %struct.sv* %32, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp124, label %if.then140, label %lor.lhs.false126

lor.lhs.false126:                                 ; preds = %land.lhs.true122
  %33 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings127 = getelementptr inbounds %struct.cop* %33, i64 0, i32 14
  %34 = load %struct.sv** %cop_warnings127, align 8, !tbaa !47
  %sv_any = getelementptr inbounds %struct.sv* %34, i64 0, i32 0
  %35 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %35 to i8**
  %36 = load i8** %xpv_pv, align 8, !tbaa !39
  %arrayidx128 = getelementptr inbounds i8* %36, i64 11
  %37 = load i8* %arrayidx128, align 1, !tbaa !5
  %and130 = and i8 %37, 4
  %tobool131 = icmp eq i8 %and130, 0
  br i1 %tobool131, label %lor.lhs.false132, label %if.then140

lor.lhs.false132:                                 ; preds = %lor.lhs.false126, %land.lhs.true118, %if.else
  %38 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings133 = getelementptr inbounds %struct.cop* %38, i64 0, i32 14
  %39 = load %struct.sv** %cop_warnings133, align 8, !tbaa !47
  %cmp134 = icmp eq %struct.sv* %39, null
  br i1 %cmp134, label %land.lhs.true136, label %if.end200

land.lhs.true136:                                 ; preds = %lor.lhs.false132
  %40 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and138 = and i8 %40, 1
  %tobool139 = icmp eq i8 %and138, 0
  br i1 %tobool139, label %if.end200, label %if.then140

if.then140:                                       ; preds = %lor.lhs.false126, %land.lhs.true136, %land.lhs.true122
  %41 = load i8* %op_private, align 1, !tbaa !33
  %and143 = and i8 %41, 4
  %tobool144 = icmp eq i8 %and143, 0
  br i1 %tobool144, label %if.else146, label %if.end200

if.else146:                                       ; preds = %if.then140
  %sv_flags = getelementptr inbounds %struct.sv* %26, i64 0, i32 2
  %42 = load i64* %sv_flags, align 8, !tbaa !34
  %and147 = and i64 %42, 196608
  %tobool148 = icmp eq i64 %and147, 0
  br i1 %tobool148, label %if.else175, label %land.lhs.true149

land.lhs.true149:                                 ; preds = %if.else146
  %and151 = and i64 %42, 131072
  %tobool152 = icmp eq i64 %and151, 0
  br i1 %tobool152, label %cond.false155, label %cond.true153

cond.true153:                                     ; preds = %land.lhs.true149
  %sv_any154 = getelementptr inbounds %struct.sv* %26, i64 0, i32 0
  %43 = load i8** %sv_any154, align 8, !tbaa !36
  %xnv_nv = getelementptr inbounds i8* %43, i64 32
  %44 = bitcast i8* %xnv_nv to double*
  %45 = load double* %44, align 8, !tbaa !51
  br label %cond.end157

cond.false155:                                    ; preds = %land.lhs.true149
  %call156 = tail call double @Perl_sv_2nv(%struct.sv* %26) #4
  br label %cond.end157

cond.end157:                                      ; preds = %cond.false155, %cond.true153
  %cond158 = phi double [ %45, %cond.true153 ], [ %call156, %cond.false155 ]
  %cmp159 = fcmp oeq double %cond158, 0.000000e+00
  br i1 %cmp159, label %if.end200, label %lor.lhs.false161

lor.lhs.false161:                                 ; preds = %cond.end157
  %46 = load i64* %sv_flags, align 8, !tbaa !34
  %and163 = and i64 %46, 131072
  %tobool164 = icmp eq i64 %and163, 0
  br i1 %tobool164, label %cond.false168, label %cond.true165

cond.true165:                                     ; preds = %lor.lhs.false161
  %sv_any166 = getelementptr inbounds %struct.sv* %26, i64 0, i32 0
  %47 = load i8** %sv_any166, align 8, !tbaa !36
  %xnv_nv167 = getelementptr inbounds i8* %47, i64 32
  %48 = bitcast i8* %xnv_nv167 to double*
  %49 = load double* %48, align 8, !tbaa !51
  br label %cond.end170

cond.false168:                                    ; preds = %lor.lhs.false161
  %call169 = tail call double @Perl_sv_2nv(%struct.sv* %26) #4
  br label %cond.end170

cond.end170:                                      ; preds = %cond.false168, %cond.true165
  %cond171 = phi double [ %49, %cond.true165 ], [ %call169, %cond.false168 ]
  %cmp172 = fcmp oeq double %cond171, 1.000000e+00
  br i1 %cmp172, label %if.end200, label %cond.end170.if.else175_crit_edge

cond.end170.if.else175_crit_edge:                 ; preds = %cond.end170
  %.pre = load i64* %sv_flags, align 8, !tbaa !34
  br label %if.else175

if.else175:                                       ; preds = %cond.end170.if.else175_crit_edge, %if.else146
  %50 = phi i64 [ %.pre, %cond.end170.if.else175_crit_edge ], [ %42, %if.else146 ]
  %and177 = and i64 %50, 262144
  %tobool178 = icmp eq i64 %and177, 0
  br i1 %tobool178, label %if.end200, label %if.then179

if.then179:                                       ; preds = %if.else175
  %sv_any180 = getelementptr inbounds %struct.sv* %26, i64 0, i32 0
  %51 = load i8** %sv_any180, align 8, !tbaa !36
  %xpv_pv181 = bitcast i8* %51 to i8**
  %52 = load i8** %xpv_pv181, align 8, !tbaa !39
  %call182 = tail call i32 @strncmp(i8* %52, i8* getelementptr inbounds ([3 x i8]* @.str10, i64 0, i64 0), i64 2) #4
  %tobool183 = icmp eq i32 %call182, 0
  br i1 %tobool183, label %if.then194, label %lor.lhs.false184

lor.lhs.false184:                                 ; preds = %if.then179
  %call187 = tail call i32 @strncmp(i8* %52, i8* getelementptr inbounds ([3 x i8]* @.str11, i64 0, i64 0), i64 2) #4
  %tobool188 = icmp eq i32 %call187, 0
  br i1 %tobool188, label %if.then194, label %lor.lhs.false189

lor.lhs.false189:                                 ; preds = %lor.lhs.false184
  %call192 = tail call i32 @strncmp(i8* %52, i8* getelementptr inbounds ([3 x i8]* @.str12, i64 0, i64 0), i64 2) #4
  %tobool193 = icmp eq i32 %call192, 0
  br i1 %tobool193, label %if.then194, label %if.end200

if.then194:                                       ; preds = %lor.lhs.false189, %lor.lhs.false184, %if.then179
  br label %if.end200

if.end200:                                        ; preds = %cond.end157, %cond.end170, %if.then140, %lor.lhs.false189, %if.else175, %land.lhs.true136, %lor.lhs.false132, %if.then194, %if.then114
  %useless.0 = phi i8* [ null, %if.then114 ], [ getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), %lor.lhs.false189 ], [ null, %if.then194 ], [ getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), %if.else175 ], [ null, %land.lhs.true136 ], [ null, %lor.lhs.false132 ], [ null, %if.then140 ], [ null, %cond.end170 ], [ null, %cond.end157 ]
  %53 = load i16* %op_type, align 2, !tbaa !12
  %cmp.i351 = icmp eq i16 %53, 0
  br i1 %cmp.i351, label %sw.epilog, label %if.end.i354

if.end.i354:                                      ; preds = %if.end200
  %call.i352 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %54 = load i16* %op_type, align 2, !tbaa !12
  %conv3.i = zext i16 %54 to i64
  %op_targ.i = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  store i64 %conv3.i, i64* %op_targ.i, align 8, !tbaa !13
  store i16 0, i16* %op_type, align 2, !tbaa !12
  %55 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i353 = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %55, %struct.op* ()** %op_ppaddr.i353, align 8, !tbaa !41
  br label %sw.epilog

sw.bb201:                                         ; preds = %if.end51
  store i16 46, i16* %op_type, align 2, !tbaa !12
  %56 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 46), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %56, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  br label %return

sw.bb203:                                         ; preds = %if.end51
  store i16 48, i16* %op_type, align 2, !tbaa !12
  %57 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 48), align 8, !tbaa !6
  %op_ppaddr205 = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %57, %struct.op* ()** %op_ppaddr205, align 8, !tbaa !41
  br label %return

sw.bb206:                                         ; preds = %if.end51, %if.end51, %if.end51
  %58 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %59 = load %struct.op** %58, align 8, !tbaa !15
  %kid.0.in360 = getelementptr inbounds %struct.op* %59, i64 0, i32 1
  %kid.0361 = load %struct.op** %kid.0.in360, align 8
  %tobool208362 = icmp eq %struct.op* %kid.0361, null
  br i1 %tobool208362, label %return, label %for.body

for.body:                                         ; preds = %sw.bb206, %for.body
  %kid.0363 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.0361, %sw.bb206 ]
  %call209 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarvoid to i32 (%struct.op*, ...)*)(%struct.op* %kid.0363) #4
  %kid.0.in = getelementptr inbounds %struct.op* %kid.0363, i64 0, i32 1
  %kid.0 = load %struct.op** %kid.0.in, align 8
  %tobool208 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool208, label %return, label %for.body

sw.bb211:                                         ; preds = %if.end51
  %60 = and i8 %3, 68
  %61 = icmp eq i8 %60, 4
  br i1 %61, label %sw.bb225, label %return

sw.bb218:                                         ; preds = %if.end51, %if.end51, %if.end51, %if.end51
  %.old375 = and i8 %3, 4
  %tobool222.old = icmp eq i8 %.old375, 0
  br i1 %tobool222.old, label %return, label %sw.bb225

sw.bb225:                                         ; preds = %sw.bb211, %sw.bb218, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51, %if.end51
  %62 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.1364 = load %struct.op** %62, align 8
  %tobool228365 = icmp eq %struct.op* %kid.1364, null
  br i1 %tobool228365, label %return, label %for.body229

for.body229:                                      ; preds = %sw.bb225, %for.body229
  %kid.1366 = phi %struct.op* [ %kid.1, %for.body229 ], [ %kid.1364, %sw.bb225 ]
  %call230 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarvoid to i32 (%struct.op*, ...)*)(%struct.op* %kid.1366) #4
  %op_sibling232 = getelementptr inbounds %struct.op* %kid.1366, i64 0, i32 1
  %kid.1 = load %struct.op** %op_sibling232, align 8
  %tobool228 = icmp eq %struct.op* %kid.1, null
  br i1 %tobool228, label %return, label %for.body229

sw.bb234:                                         ; preds = %if.end51
  %call235 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarkids to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  br label %return

sw.bb236:                                         ; preds = %if.end51
  store i8 %and54, i8* %op_flags, align 1, !tbaa !14
  br label %sw.bb241

sw.bb241:                                         ; preds = %if.end51, %sw.bb236
  %call242 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv243 = sext i32 %call242 to i64
  %63 = inttoptr i64 %conv243 to %struct.op*
  br label %return

sw.bb244:                                         ; preds = %if.end51
  %64 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %65 = load %struct.op** %64, align 8, !tbaa !45
  %tobool246 = icmp eq %struct.op* %65, null
  br i1 %tobool246, label %return, label %land.lhs.true247

land.lhs.true247:                                 ; preds = %sw.bb244
  %op_type248 = getelementptr inbounds %struct.op* %65, i64 0, i32 4
  %66 = load i16* %op_type248, align 2, !tbaa !12
  %cmp250 = icmp eq i16 %66, 13
  br i1 %cmp250, label %if.then252, label %return

if.then252:                                       ; preds = %land.lhs.true247
  %op_pmreplroot = getelementptr inbounds %struct.op* %65, i64 1, i32 2
  %67 = load %struct.op* ()** %op_pmreplroot, align 8
  %tobool253 = icmp eq %struct.op* ()* %67, null
  br i1 %tobool253, label %if.then254, label %return

if.then254:                                       ; preds = %if.then252
  %call255 = tail call i32 (i8*, ...)* bitcast (i32 (...)* @deprecate_old to i32 (i8*, ...)*)(i8* getelementptr inbounds ([21 x i8]* @.str6, i64 0, i64 0)) #4
  br label %return

sw.epilog:                                        ; preds = %if.end.i354, %if.end200, %cond.false.i, %cond.true.i, %if.then4.i, %if.then.i, %cond.false
  %useless.1 = phi i8* [ %22, %cond.false ], [ %17, %if.then4.i ], [ %13, %if.then.i ], [ %21, %cond.true.i ], [ %call8.i, %cond.false.i ], [ %useless.0, %if.end200 ], [ %useless.0, %if.end.i354 ]
  %tobool258 = icmp eq i8* %useless.1, null
  br i1 %tobool258, label %return, label %land.lhs.true259

land.lhs.true259:                                 ; preds = %lor.lhs.false101, %land.lhs.true99, %sw.epilog
  %useless.1358 = phi i8* [ %useless.1, %sw.epilog ], [ getelementptr inbounds ([11 x i8]* @.str8, i64 0, i64 0), %land.lhs.true99 ], [ getelementptr inbounds ([11 x i8]* @.str8, i64 0, i64 0), %lor.lhs.false101 ]
  %68 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings260 = getelementptr inbounds %struct.cop* %68, i64 0, i32 14
  %69 = load %struct.sv** %cop_warnings260, align 8, !tbaa !47
  %cmp261 = icmp eq %struct.sv* %69, null
  br i1 %cmp261, label %lor.lhs.false279, label %land.lhs.true263

land.lhs.true263:                                 ; preds = %land.lhs.true259
  %70 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings264 = getelementptr inbounds %struct.cop* %70, i64 0, i32 14
  %71 = load %struct.sv** %cop_warnings264, align 8, !tbaa !47
  %cmp265 = icmp eq %struct.sv* %71, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp265, label %lor.lhs.false279, label %land.lhs.true267

land.lhs.true267:                                 ; preds = %land.lhs.true263
  %72 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings268 = getelementptr inbounds %struct.cop* %72, i64 0, i32 14
  %73 = load %struct.sv** %cop_warnings268, align 8, !tbaa !47
  %cmp269 = icmp eq %struct.sv* %73, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp269, label %if.then287, label %lor.lhs.false271

lor.lhs.false271:                                 ; preds = %land.lhs.true267
  %74 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings272 = getelementptr inbounds %struct.cop* %74, i64 0, i32 14
  %75 = load %struct.sv** %cop_warnings272, align 8, !tbaa !47
  %sv_any273 = getelementptr inbounds %struct.sv* %75, i64 0, i32 0
  %76 = load i8** %sv_any273, align 8, !tbaa !36
  %xpv_pv274 = bitcast i8* %76 to i8**
  %77 = load i8** %xpv_pv274, align 8, !tbaa !39
  %arrayidx275 = getelementptr inbounds i8* %77, i64 11
  %78 = load i8* %arrayidx275, align 1, !tbaa !5
  %and277 = and i8 %78, 4
  %tobool278 = icmp eq i8 %and277, 0
  br i1 %tobool278, label %lor.lhs.false279, label %if.then287

lor.lhs.false279:                                 ; preds = %lor.lhs.false271, %land.lhs.true263, %land.lhs.true259
  %79 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings280 = getelementptr inbounds %struct.cop* %79, i64 0, i32 14
  %80 = load %struct.sv** %cop_warnings280, align 8, !tbaa !47
  %cmp281 = icmp eq %struct.sv* %80, null
  br i1 %cmp281, label %land.lhs.true283, label %return

land.lhs.true283:                                 ; preds = %lor.lhs.false279
  %81 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and285 = and i8 %81, 1
  %tobool286 = icmp eq i8 %and285, 0
  br i1 %tobool286, label %return, label %if.then287

if.then287:                                       ; preds = %lor.lhs.false271, %land.lhs.true283, %land.lhs.true267
  tail call void (i64, i8*, ...)* @Perl_warner(i64 45, i8* getelementptr inbounds ([34 x i8]* @.str13, i64 0, i64 0), i8* %useless.1358) #4
  br label %return

return:                                           ; preds = %for.body229, %for.body, %sw.bb211, %sw.bb72, %sw.default, %sw.bb225, %sw.bb206, %lor.lhs.false101, %sw.bb94, %sw.bb201, %sw.bb203, %sw.bb218, %sw.bb234, %sw.bb244, %land.lhs.true247, %if.then254, %if.then252, %func_ops, %sw.bb, %lor.lhs.false279, %if.then287, %sw.epilog, %land.lhs.true283, %land.lhs.true29, %lor.lhs.false35, %lor.lhs.false33, %sw.bb241, %if.then49
  %retval.0 = phi %struct.op* [ %8, %if.then49 ], [ %63, %sw.bb241 ], [ %o, %lor.lhs.false33 ], [ %o, %lor.lhs.false35 ], [ %o, %land.lhs.true29 ], [ %o, %land.lhs.true283 ], [ %o, %sw.epilog ], [ %o, %if.then287 ], [ %o, %lor.lhs.false279 ], [ %o, %sw.bb ], [ %o, %func_ops ], [ %o, %sw.default ], [ %o, %if.then252 ], [ %o, %if.then254 ], [ %o, %land.lhs.true247 ], [ %o, %sw.bb244 ], [ %o, %sw.bb234 ], [ %o, %sw.bb218 ], [ %o, %sw.bb211 ], [ %o, %sw.bb203 ], [ %o, %sw.bb201 ], [ %o, %sw.bb94 ], [ %o, %lor.lhs.false101 ], [ %o, %sw.bb72 ], [ %o, %sw.bb206 ], [ %o, %sw.bb225 ], [ %o, %for.body ], [ %o, %for.body229 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define i8* @Perl_custom_op_desc(%struct.op* nocapture readonly %o) #0 {
entry:
  %0 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %tobool = icmp eq %struct.hv* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %return

if.end:                                           ; preds = %entry
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  %2 = load %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %3 = ptrtoint %struct.op* ()* %2 to i64
  %call = tail call %struct.sv* @Perl_newSViv(i64 %3) #4
  %call1 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call) #4
  %4 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %call2 = tail call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %4, %struct.sv* %call1, i64 0, i64 0) #4
  %tobool3 = icmp eq %struct.he* %call2, null
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %5 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %return

if.end5:                                          ; preds = %if.end
  %hent_val = getelementptr inbounds %struct.he* %call2, i64 0, i32 2
  %6 = load %struct.sv** %hent_val, align 8, !tbaa !49
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i64* %sv_flags, align 8, !tbaa !34
  %and = and i64 %7, 262144
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end5
  %sv_any = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %8 to i8**
  %9 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %return

cond.false:                                       ; preds = %if.end5
  %call8 = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %6) #4
  br label %return

return:                                           ; preds = %cond.true, %cond.false, %if.then4, %if.then
  %retval.0 = phi i8* [ %5, %if.then4 ], [ %1, %if.then ], [ %9, %cond.true ], [ %call8, %cond.false ]
  ret i8* %retval.0
}

declare i32 @no_bareword_allowed(...) #2

declare double @Perl_sv_2nv(%struct.sv*) #2

; Function Attrs: nounwind readonly
declare i32 @strncmp(i8* nocapture, i8* nocapture, i64) #1

declare i32 @scalarkids(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_listkids(%struct.op* readonly %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 4
  %tobool1 = icmp eq i8 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.08 = load %struct.op** %1, align 8
  %tobool29 = icmp eq %struct.op* %kid.08, null
  br i1 %tobool29, label %if.end, label %for.body

for.body:                                         ; preds = %if.then, %for.body
  %kid.010 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.08, %if.then ]
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %kid.010) #4
  %op_sibling = getelementptr inbounds %struct.op* %kid.010, i64 0, i32 1
  %kid.0 = load %struct.op** %op_sibling, align 8
  %tobool2 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool2, label %if.end, label %for.body

if.end:                                           ; preds = %for.body, %if.then, %land.lhs.true, %entry
  ret %struct.op* %o
}

declare i32 @list(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_list(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 3
  %tobool1 = icmp ne i8 %and, 0
  %1 = load i64* @PL_error_count, align 8
  %tobool3 = icmp ne i64 %1, 0
  %or.cond = or i1 %tobool1, %tobool3
  br i1 %or.cond, label %return, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %2, 184
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false4
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %3 = load i8* %op_private, align 1, !tbaa !11
  %and8 = and i8 %3, 16
  %tobool9 = icmp eq i8 %and8, 0
  br i1 %tobool9, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %idxprom = zext i16 %2 to i64
  %arrayidx = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %idxprom
  %4 = load i64* %arrayidx, align 8, !tbaa !1
  %and11 = and i64 %4, 256
  %tobool12 = icmp eq i64 %and11, 0
  br i1 %tobool12, label %if.end14, label %return

if.end14:                                         ; preds = %land.lhs.true, %if.end
  %or = or i8 %0, 3
  store i8 %or, i8* %op_flags, align 1, !tbaa !14
  %conv21 = zext i16 %2 to i32
  switch i32 %conv21, label %sw.bb27 [
    i32 158, label %sw.bb
    i32 61, label %sw.bb
    i32 160, label %sw.bb22
    i32 159, label %sw.bb22
    i32 162, label %sw.bb22
    i32 309, label %sw.bb76
    i32 173, label %sw.bb60
    i32 179, label %sw.bb60
    i32 314, label %sw.bb49
    i32 141, label %sw.bb47
    i32 178, label %sw.bb49
  ]

sw.bb:                                            ; preds = %if.end14, %if.end14
  %5 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %6 = load %struct.op** %5, align 8, !tbaa !43
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %6) #4
  br label %return

sw.bb22:                                          ; preds = %if.end14, %if.end14, %if.end14
  %7 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %8 = load %struct.op** %7, align 8, !tbaa !15
  %kid.0.in115 = getelementptr inbounds %struct.op* %8, i64 0, i32 1
  %kid.0116 = load %struct.op** %kid.0.in115, align 8
  %tobool24117 = icmp eq %struct.op* %kid.0116, null
  br i1 %tobool24117, label %return, label %for.body

for.body:                                         ; preds = %sw.bb22, %for.body
  %kid.0118 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.0116, %sw.bb22 ]
  %call25 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %kid.0118) #4
  %kid.0.in = getelementptr inbounds %struct.op* %kid.0118, i64 0, i32 1
  %kid.0 = load %struct.op** %kid.0.in, align 8
  %tobool24 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool24, label %return, label %for.body

sw.bb27:                                          ; preds = %if.end14
  %and30 = and i8 %0, 4
  %tobool31 = icmp eq i8 %and30, 0
  br i1 %tobool31, label %return, label %if.end33

if.end33:                                         ; preds = %sw.bb27
  %op_next = getelementptr inbounds %struct.op* %o, i64 0, i32 0
  %9 = load %struct.op** %op_next, align 8, !tbaa !42
  %tobool34 = icmp eq %struct.op* %9, null
  br i1 %tobool34, label %land.lhs.true35, label %sw.bb47

land.lhs.true35:                                  ; preds = %if.end33
  %10 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %11 = load %struct.op** %10, align 8, !tbaa !15
  %op_type37 = getelementptr inbounds %struct.op* %11, i64 0, i32 4
  %12 = load i16* %op_type37, align 2, !tbaa !12
  %cmp39 = icmp eq i16 %12, 158
  br i1 %cmp39, label %if.then41, label %sw.bb47

if.then41:                                        ; preds = %land.lhs.true35
  %call43 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %11) #4
  %call44 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @gen_constant_list to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv45 = sext i32 %call44 to i64
  %13 = inttoptr i64 %conv45 to %struct.op*
  br label %return

sw.bb47:                                          ; preds = %if.end33, %land.lhs.true35, %if.end14
  %call48 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @listkids to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  br label %return

sw.bb49:                                          ; preds = %if.end14, %if.end14
  %14 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %15 = load %struct.op** %14, align 8, !tbaa !45
  %call51 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %15) #4
  %op_sibling52122 = getelementptr inbounds %struct.op* %15, i64 0, i32 1
  %16 = load %struct.op** %op_sibling52122, align 8, !tbaa !17
  %tobool53123 = icmp eq %struct.op* %16, null
  br i1 %tobool53123, label %while.end, label %while.body

while.body:                                       ; preds = %sw.bb49, %while.cond.backedge
  %17 = phi %struct.op* [ %19, %while.cond.backedge ], [ %16, %sw.bb49 ]
  %op_sibling54 = getelementptr inbounds %struct.op* %17, i64 0, i32 1
  %18 = load %struct.op** %op_sibling54, align 8, !tbaa !17
  %tobool55 = icmp eq %struct.op* %18, null
  br i1 %tobool55, label %if.else, label %if.then56

if.then56:                                        ; preds = %while.body
  %call57 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarvoid to i32 (%struct.op*, ...)*)(%struct.op* %17) #4
  br label %while.cond.backedge

if.else:                                          ; preds = %while.body
  %call58 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %17) #4
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.else, %if.then56
  %19 = load %struct.op** %op_sibling54, align 8, !tbaa !17
  %tobool53 = icmp eq %struct.op* %19, null
  br i1 %tobool53, label %while.end, label %while.body

while.end:                                        ; preds = %while.cond.backedge, %sw.bb49
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !6
  br label %return

sw.bb60:                                          ; preds = %if.end14, %if.end14
  %20 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.2119 = load %struct.op** %20, align 8
  %tobool63120 = icmp eq %struct.op* %kid.2119, null
  br i1 %tobool63120, label %for.end74, label %for.body64

for.body64:                                       ; preds = %sw.bb60, %for.cond62.backedge
  %kid.2121 = phi %struct.op* [ %kid.2, %for.cond62.backedge ], [ %kid.2119, %sw.bb60 ]
  %op_sibling65 = getelementptr inbounds %struct.op* %kid.2121, i64 0, i32 1
  %21 = load %struct.op** %op_sibling65, align 8, !tbaa !17
  %tobool66 = icmp eq %struct.op* %21, null
  br i1 %tobool66, label %if.else69, label %if.then67

if.then67:                                        ; preds = %for.body64
  %call68 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarvoid to i32 (%struct.op*, ...)*)(%struct.op* %kid.2121) #4
  br label %for.cond62.backedge

for.cond62.backedge:                              ; preds = %if.then67, %if.else69
  %kid.2 = load %struct.op** %op_sibling65, align 8
  %tobool63 = icmp eq %struct.op* %kid.2, null
  br i1 %tobool63, label %for.end74, label %for.body64

if.else69:                                        ; preds = %for.body64
  %call70 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %kid.2121) #4
  br label %for.cond62.backedge

for.end74:                                        ; preds = %for.cond62.backedge, %sw.bb60
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !6
  br label %return

sw.bb76:                                          ; preds = %if.end14
  %and79 = and i8 %0, -4
  store i8 %and79, i8* %op_flags, align 1, !tbaa !14
  %call81 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv82 = sext i32 %call81 to i64
  %22 = inttoptr i64 %conv82 to %struct.op*
  br label %return

return:                                           ; preds = %for.body, %sw.bb22, %sw.bb, %sw.bb47, %while.end, %for.end74, %sw.bb27, %land.lhs.true, %lor.lhs.false, %lor.lhs.false4, %entry, %sw.bb76, %if.then41
  %retval.0 = phi %struct.op* [ %13, %if.then41 ], [ %22, %sw.bb76 ], [ null, %entry ], [ %o, %lor.lhs.false4 ], [ %o, %lor.lhs.false ], [ %o, %land.lhs.true ], [ %o, %sw.bb27 ], [ %o, %for.end74 ], [ %o, %while.end ], [ %o, %sw.bb47 ], [ %o, %sw.bb ], [ %o, %sw.bb22 ], [ %o, %for.body ]
  ret %struct.op* %retval.0
}

declare i32 @gen_constant_list(...) #2

declare i32 @listkids(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_scalarseq(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  switch i16 %0, label %if.end21 [
    i16 173, label %if.then16
    i16 179, label %if.then16
    i16 178, label %if.then16
    i16 314, label %if.then16
  ]

if.then16:                                        ; preds = %if.then, %if.then, %if.then, %if.then
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.044 = load %struct.op** %1, align 8
  %tobool1745 = icmp eq %struct.op* %kid.044, null
  br i1 %tobool1745, label %for.end, label %for.body

for.body:                                         ; preds = %if.then16, %for.cond.backedge
  %kid.046 = phi %struct.op* [ %kid.0.pre, %for.cond.backedge ], [ %kid.044, %if.then16 ]
  %op_sibling = getelementptr inbounds %struct.op* %kid.046, i64 0, i32 1
  %2 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %tobool18 = icmp eq %struct.op* %2, null
  br i1 %tobool18, label %for.end, label %for.cond.backedge

for.cond.backedge:                                ; preds = %for.body
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarvoid to i32 (%struct.op*, ...)*)(%struct.op* %kid.046) #4
  %kid.0.pre = load %struct.op** %op_sibling, align 8
  %tobool17 = icmp eq %struct.op* %kid.0.pre, null
  br i1 %tobool17, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %for.cond.backedge, %if.then16
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !6
  br label %if.end21

if.end21:                                         ; preds = %if.then, %for.end
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %3 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %3, -9
  store i8 %and, i8* %op_flags, align 1, !tbaa !14
  %4 = load i64* @PL_hints, align 8, !tbaa !1
  %and24 = and i64 %4, 256
  %tobool25 = icmp eq i64 %and24, 0
  br i1 %tobool25, label %if.end32, label %if.then26

if.then26:                                        ; preds = %if.end21
  %or = or i8 %3, 8
  store i8 %or, i8* %op_flags, align 1, !tbaa !14
  br label %if.end32

if.else:                                          ; preds = %entry
  %call.i = tail call i8* @Perl_safesysmalloc(i64 40) #4
  %5 = bitcast i8* %call.i to %struct.op*
  tail call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 40, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i, i64 32
  %6 = bitcast i8* %op_type.i to i16*
  store i16 1, i16* %6, align 2, !tbaa !12
  %7 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 1), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %8 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %7, %struct.op* ()** %8, align 8, !tbaa !41
  %9 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %9, align 1, !tbaa !14
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %5, %struct.op** %op_next.i, align 8, !tbaa !42
  %10 = getelementptr inbounds i8* %call.i, i64 37
  store i8 0, i8* %10, align 1, !tbaa !11
  %11 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 1), align 8, !tbaa !1
  %and.i = and i64 %11, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %if.else
  %call4.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %5) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 1), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.else
  %12 = phi i64 [ %11, %if.else ], [ %.pre.i, %if.then.i ]
  %and6.i = and i64 %12, 8
  %tobool7.i = icmp eq i64 %and6.i, 0
  br i1 %tobool7.i, label %if.end11.i, label %if.then8.i

if.then8.i:                                       ; preds = %if.end.i
  %call9.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 1, i32 512) #4
  %conv10.i = sext i32 %call9.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %13 = bitcast i8* %op_targ.i to i64*
  store i64 %conv10.i, i64* %13, align 8, !tbaa !13
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then8.i, %if.end.i
  %14 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12.i = icmp eq i8* %14, null
  br i1 %tobool12.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end11.i
  %arrayidx13.i = getelementptr inbounds i8* %14, i64 1
  %15 = load i8* %arrayidx13.i, align 1, !tbaa !5
  %tobool15.i = icmp eq i8 %15, 0
  br i1 %tobool15.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %5) #4
  %16 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 1), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %16) #4
  br label %if.end32

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end11.i
  %17 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 1), align 8, !tbaa !6
  %call18.i = tail call %struct.op* %17(%struct.op* %5) #4
  br label %if.end32

if.end32:                                         ; preds = %cond.false.i, %cond.true.i, %if.end21, %if.then26
  %o.addr.0 = phi %struct.op* [ %o, %if.then26 ], [ %o, %if.end21 ], [ null, %cond.true.i ], [ %call18.i, %cond.false.i ]
  ret %struct.op* %o.addr.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newOP(i64 %type, i64 %flags) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 40) #4
  %0 = bitcast i8* %call to %struct.op*
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 40, i32 1, i1 false)
  %conv = trunc i64 %type to i16
  %op_type = getelementptr inbounds i8* %call, i64 32
  %1 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %1, align 2, !tbaa !12
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %type
  %2 = load %struct.op* ()** %arrayidx, align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %3 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %2, %struct.op* ()** %3, align 8, !tbaa !41
  %conv1 = trunc i64 %flags to i8
  %4 = getelementptr inbounds i8* %call, i64 36
  store i8 %conv1, i8* %4, align 1, !tbaa !14
  %op_next = bitcast i8* %call to %struct.op**
  store %struct.op* %0, %struct.op** %op_next, align 8, !tbaa !42
  %shr37 = lshr i64 %flags, 8
  %conv2 = trunc i64 %shr37 to i8
  %5 = getelementptr inbounds i8* %call, i64 37
  store i8 %conv2, i8* %5, align 1, !tbaa !11
  %arrayidx3 = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %type
  %6 = load i64* %arrayidx3, align 8, !tbaa !1
  %and = and i64 %6, 4
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call4 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %0) #4
  %.pre = load i64* %arrayidx3, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %7 = phi i64 [ %6, %entry ], [ %.pre, %if.then ]
  %and6 = and i64 %7, 8
  %tobool7 = icmp eq i64 %and6, 0
  br i1 %tobool7, label %if.end11, label %if.then8

if.then8:                                         ; preds = %if.end
  %call9 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 %type, i32 512) #4
  %conv10 = sext i32 %call9 to i64
  %op_targ = getelementptr inbounds i8* %call, i64 24
  %8 = bitcast i8* %op_targ to i64*
  store i64 %conv10, i64* %8, align 8, !tbaa !13
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then8
  %9 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12 = icmp eq i8* %9, null
  br i1 %tobool12, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end11
  %arrayidx13 = getelementptr inbounds i8* %9, i64 %type
  %10 = load i8* %arrayidx13, align 1, !tbaa !5
  %tobool15 = icmp eq i8 %10, 0
  br i1 %tobool15, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  tail call void @Perl_op_free(%struct.op* %0)
  %arrayidx16 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %type
  %11 = load i8** %arrayidx16, align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %11) #4
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end11
  %arrayidx17 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %type
  %12 = load %struct.op* (%struct.op*)** %arrayidx17, align 8, !tbaa !6
  %call18 = tail call %struct.op* %12(%struct.op* %0) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call18, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_mod(%struct.op* %o, i64 %type) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  %0 = load i64* @PL_error_count, align 8
  %tobool1 = icmp ne i64 %0, 0
  %or.cond = or i1 %tobool, %tobool1
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %entry
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %1 = load i8* %op_private, align 1, !tbaa !11
  %and = and i8 %1, 16
  %tobool2 = icmp eq i8 %and, 0
  %op_type7.phi.trans.insert = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %.pre = load i16* %op_type7.phi.trans.insert, align 2, !tbaa !12
  br i1 %tobool2, label %if.end6, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %idxprom = zext i16 %.pre to i64
  %arrayidx = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %idxprom
  %2 = load i64* %arrayidx, align 8, !tbaa !1
  %and3 = and i64 %2, 256
  %tobool4 = icmp eq i64 %and3, 0
  br i1 %tobool4, label %if.end6, label %return

if.end6:                                          ; preds = %if.end, %land.lhs.true
  %op_type7 = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %conv8 = zext i16 %.pre to i32
  switch i32 %conv8, label %nomod [
    i32 43, label %sw.bb
    i32 5, label %sw.bb9
    i32 1, label %sw.bb36
    i32 166, label %sw.bb42
    i32 46, label %sw.bb258
    i32 48, label %sw.bb258
    i32 54, label %sw.bb258
    i32 55, label %sw.bb258
    i32 57, label %sw.bb258
    i32 59, label %sw.bb258
    i32 61, label %sw.bb258
    i32 62, label %sw.bb258
    i32 64, label %sw.bb258
    i32 66, label %sw.bb258
    i32 68, label %sw.bb258
    i32 69, label %sw.bb258
    i32 91, label %sw.bb258
    i32 92, label %sw.bb258
    i32 93, label %sw.bb258
    i32 56, label %sw.bb258
    i32 58, label %sw.bb258
    i32 60, label %sw.bb258
    i32 63, label %sw.bb258
    i32 65, label %sw.bb258
    i32 162, label %sw.bb266
    i32 125, label %sw.bb272
    i32 134, label %sw.bb272
    i32 14, label %sw.bb282
    i32 128, label %sw.bb291
    i32 136, label %sw.bb291
    i32 37, label %sw.bb300
    i32 174, label %sw.bb300
    i32 175, label %sw.bb300
    i32 15, label %sw.bb301
    i32 7, label %sw.bb306
    i32 16, label %sw.bb306
    i32 36, label %sw.bb308
    i32 163, label %sw.bb308
    i32 164, label %sw.bb308
    i32 126, label %sw.bb308
    i32 10, label %sw.bb310
    i32 11, label %sw.bb310
    i32 9, label %sw.bb332
    i32 3, label %sw.epilog
    i32 131, label %sw.bb353
    i32 111, label %sw.bb358
    i32 45, label %sw.bb365
    i32 112, label %sw.bb365
    i32 127, label %sw.bb390
    i32 135, label %sw.bb390
    i32 179, label %sw.bb417
    i32 178, label %sw.bb417
    i32 177, label %sw.bb417
    i32 173, label %sw.bb417
    i32 0, label %sw.bb425
    i32 141, label %sw.bb446
    i32 184, label %sw.bb455
  ]

sw.bb:                                            ; preds = %if.end6
  %3 = load i64* @PL_modcount, align 8, !tbaa !1
  %inc = add nsw i64 %3, 1
  store i64 %inc, i64* @PL_modcount, align 8, !tbaa !1
  br label %return

sw.bb9:                                           ; preds = %if.end6
  %and12 = and i8 %1, 32
  %tobool13 = icmp eq i8 %and12, 0
  br i1 %tobool13, label %nomod, label %if.end15

if.end15:                                         ; preds = %sw.bb9
  %4 = load %struct.op** @PL_eval_start, align 8, !tbaa !6
  %tobool16 = icmp eq %struct.op* %4, null
  br i1 %tobool16, label %if.else, label %land.lhs.true17

land.lhs.true17:                                  ; preds = %if.end15
  %op_type18 = getelementptr inbounds %struct.op* %4, i64 0, i32 4
  %5 = load i16* %op_type18, align 2, !tbaa !12
  %cmp = icmp eq i16 %5, 5
  br i1 %cmp, label %if.then21, label %if.else

if.then21:                                        ; preds = %land.lhs.true17
  %op_sv = getelementptr inbounds %struct.op* %4, i64 1
  %6 = bitcast %struct.op* %op_sv to %struct.sv**
  %7 = load %struct.sv** %6, align 8, !tbaa !18
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i64* %sv_flags, align 8, !tbaa !34
  %and22 = and i64 %8, 65536
  %tobool23 = icmp eq i64 %and22, 0
  br i1 %tobool23, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then21
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !36
  %xiv_iv = getelementptr inbounds i8* %9, i64 24
  %10 = bitcast i8* %xiv_iv to i64*
  %11 = load i64* %10, align 8, !tbaa !53
  br label %cond.end

cond.false:                                       ; preds = %if.then21
  %call = tail call i64 @Perl_sv_2iv(%struct.sv* %7) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %11, %cond.true ], [ %call, %cond.false ]
  store i64 %cond, i64* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 12), align 8, !tbaa !55
  store %struct.op* null, %struct.op** @PL_eval_start, align 8, !tbaa !6
  br label %sw.epilog

if.else:                                          ; preds = %if.end15, %land.lhs.true17
  switch i64 %type, label %if.else32 [
    i64 0, label %sw.epilog.thread
    i64 20, label %land.lhs.true462
  ]

sw.epilog.thread:                                 ; preds = %if.else
  tail call void @Perl_save_I32(i64* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 12)) #4
  store i64 0, i64* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 12), align 8, !tbaa !55
  br label %if.end477.thread682

if.else32:                                        ; preds = %if.else
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([30 x i8]* @.str14, i64 0, i64 0)) #4
  br label %sw.epilog

sw.bb36:                                          ; preds = %if.end6
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %12 = load i8* %op_flags, align 1, !tbaa !14
  %and38 = and i8 %12, 8
  %tobool39 = icmp eq i8 %and38, 0
  br i1 %tobool39, label %nomod, label %sw.epilog

sw.bb42:                                          ; preds = %if.end6
  switch i64 %type, label %if.else56 [
    i64 43, label %land.lhs.true48
    i64 20, label %land.lhs.true48
  ]

land.lhs.true48:                                  ; preds = %sw.bb42, %sw.bb42
  %op_flags49 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %13 = load i8* %op_flags49, align 1, !tbaa !14
  %and51 = and i8 %13, 64
  %tobool52 = icmp eq i8 %and51, 0
  br i1 %tobool52, label %if.then53, label %if.else56

if.then53:                                        ; preds = %land.lhs.true48
  store i16 17, i16* %op_type7, align 2, !tbaa !12
  %14 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 17), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %14, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %15 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %16 = load %struct.op** %15, align 8, !tbaa !15
  %17 = getelementptr inbounds %struct.op* %16, i64 1, i32 0
  %18 = load %struct.op** %17, align 8, !tbaa !45
  %op_type.i = getelementptr inbounds %struct.op* %18, i64 0, i32 4
  %19 = load i16* %op_type.i, align 2, !tbaa !12
  %cmp.i = icmp eq i16 %19, 0
  br i1 %cmp.i, label %sw.epilog, label %if.end.i

if.end.i:                                         ; preds = %if.then53
  %call.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %18) #4
  %20 = load i16* %op_type.i, align 2, !tbaa !12
  %conv3.i = zext i16 %20 to i64
  %op_targ.i = getelementptr inbounds %struct.op* %18, i64 0, i32 3
  store i64 %conv3.i, i64* %op_targ.i, align 8, !tbaa !13
  store i16 0, i16* %op_type.i, align 2, !tbaa !12
  %21 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds %struct.op* %18, i64 0, i32 2
  store %struct.op* ()* %21, %struct.op* ()** %op_ppaddr.i, align 8, !tbaa !41
  br label %sw.epilog

if.else56:                                        ; preds = %sw.bb42, %land.lhs.true48
  %and59 = and i8 %1, 64
  %tobool60 = icmp eq i8 %and59, 0
  br i1 %tobool60, label %if.else62, label %return

if.else62:                                        ; preds = %if.else56
  %or = or i8 %1, -128
  store i8 %or, i8* %op_private, align 1, !tbaa !11
  store i64 1073741823, i64* @PL_modcount, align 8, !tbaa !1
  switch i64 %type, label %if.else79 [
    i64 166, label %if.then74
    i64 152, label %if.then74
    i64 20, label %if.then74
  ]

if.then74:                                        ; preds = %if.else62, %if.else62, %if.else62
  %or77 = or i8 %1, -124
  store i8 %or77, i8* %op_private, align 1, !tbaa !11
  br label %sw.epilog

if.else79:                                        ; preds = %if.else62
  %22 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %23 = load %struct.op** %22, align 8, !tbaa !15
  %op_type82 = getelementptr inbounds %struct.op* %23, i64 0, i32 4
  %24 = load i16* %op_type82, align 2, !tbaa !12
  switch i16 %24, label %if.else79.if.then95_crit_edge [
    i16 3, label %while.cond
    i16 0, label %lor.lhs.false92
  ]

if.else79.if.then95_crit_edge:                    ; preds = %if.else79
  %op_targ98.phi.trans.insert = getelementptr inbounds %struct.op* %23, i64 0, i32 3
  %.pre694 = load i64* %op_targ98.phi.trans.insert, align 8, !tbaa !13
  br label %if.then95

lor.lhs.false92:                                  ; preds = %if.else79
  %op_targ = getelementptr inbounds %struct.op* %23, i64 0, i32 3
  %25 = load i64* %op_targ, align 8, !tbaa !13
  %cmp93 = icmp eq i64 %25, 141
  br i1 %cmp93, label %if.end99, label %if.then95

if.then95:                                        ; preds = %if.else79.if.then95_crit_edge, %lor.lhs.false92
  %26 = phi i64 [ %.pre694, %if.else79.if.then95_crit_edge ], [ %25, %lor.lhs.false92 ]
  %conv97 = zext i16 %24 to i64
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([58 x i8]* @.str15, i64 0, i64 0), i64 %conv97, i64 %26) #4
  br label %if.end99

if.end99:                                         ; preds = %lor.lhs.false92, %if.then95
  %27 = getelementptr inbounds %struct.op* %23, i64 1, i32 0
  %28 = load %struct.op** %27, align 8, !tbaa !45
  br label %while.cond

while.cond:                                       ; preds = %if.else79, %if.end99, %while.cond
  %kid80.0 = phi %struct.op* [ %29, %while.cond ], [ %23, %if.else79 ], [ %28, %if.end99 ]
  %op_sibling = getelementptr inbounds %struct.op* %kid80.0, i64 0, i32 1
  %29 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %tobool101 = icmp eq %struct.op* %29, null
  br i1 %tobool101, label %while.end, label %while.cond

while.end:                                        ; preds = %while.cond
  %op_type103 = getelementptr inbounds %struct.op* %kid80.0, i64 0, i32 4
  %30 = load i16* %op_type103, align 2, !tbaa !12
  switch i16 %30, label %if.then136 [
    i16 0, label %land.lhs.true107
    i16 350, label %if.then121
    i16 165, label %if.then121
    i16 17, label %if.end140
  ]

land.lhs.true107:                                 ; preds = %while.end
  %op_targ108 = getelementptr inbounds %struct.op* %kid80.0, i64 0, i32 3
  %31 = load i64* %op_targ108, align 8, !tbaa !13
  %cmp109 = icmp eq i64 %31, 17
  br i1 %cmp109, label %if.end145, label %if.then136

if.then121:                                       ; preds = %while.end, %while.end
  %call122 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call122, i8 0, i64 48, i32 1, i1 false)
  %op_type123 = getelementptr inbounds i8* %call122, i64 32
  %32 = bitcast i8* %op_type123 to i16*
  store i16 17, i16* %32, align 2, !tbaa !56
  %33 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 17), align 8, !tbaa !6
  %op_ppaddr124 = getelementptr inbounds i8* %call122, i64 16
  %34 = bitcast i8* %op_ppaddr124 to %struct.op* ()**
  store %struct.op* ()* %33, %struct.op* ()** %34, align 8, !tbaa !57
  %op_first125 = getelementptr inbounds i8* %call122, i64 40
  %35 = bitcast i8* %op_first125 to %struct.op**
  store %struct.op* null, %struct.op** %35, align 8, !tbaa !15
  %36 = bitcast i8* %call122 to %struct.op*
  %op_next = bitcast i8* %call122 to %struct.op**
  store %struct.op* %36, %struct.op** %op_next, align 8, !tbaa !58
  store %struct.op* %36, %struct.op** %op_sibling, align 8, !tbaa !17
  %37 = getelementptr inbounds i8* %call122, i64 37
  store i8 -128, i8* %37, align 1, !tbaa !59
  br label %sw.epilog

if.then136:                                       ; preds = %while.end, %land.lhs.true107
  %conv138 = zext i16 %30 to i64
  %op_targ139 = getelementptr inbounds %struct.op* %kid80.0, i64 0, i32 3
  %38 = load i64* %op_targ139, align 8, !tbaa !13
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([62 x i8]* @.str16, i64 0, i64 0), i64 %conv138, i64 %38) #4
  br label %if.end140

if.end140:                                        ; preds = %while.end, %if.then136
  %op_private141 = getelementptr inbounds %struct.op* %kid80.0, i64 0, i32 7
  %39 = load i8* %op_private141, align 1, !tbaa !11
  %or143 = or i8 %39, -128
  store i8 %or143, i8* %op_private141, align 1, !tbaa !11
  br label %sw.epilog

if.end145:                                        ; preds = %land.lhs.true107
  %40 = getelementptr inbounds %struct.op* %kid80.0, i64 1, i32 0
  %41 = load %struct.op** %40, align 8, !tbaa !15
  %op_type147 = getelementptr inbounds %struct.op* %41, i64 0, i32 4
  %42 = load i16* %op_type147, align 2, !tbaa !12
  %cmp149 = icmp eq i16 %42, 0
  br i1 %cmp149, label %land.lhs.true151, label %if.end166

land.lhs.true151:                                 ; preds = %if.end145
  %op_targ152 = getelementptr inbounds %struct.op* %41, i64 0, i32 3
  %43 = load i64* %op_targ152, align 8, !tbaa !13
  %cmp153 = icmp eq i64 %43, 15
  br i1 %cmp153, label %if.end157, label %if.then162

if.end157:                                        ; preds = %land.lhs.true151
  %44 = getelementptr inbounds %struct.op* %41, i64 1, i32 0
  %45 = load %struct.op** %44, align 8, !tbaa !15
  %op_type158.phi.trans.insert = getelementptr inbounds %struct.op* %45, i64 0, i32 4
  %.pre695 = load i16* %op_type158.phi.trans.insert, align 2, !tbaa !12
  %cmp160 = icmp eq i16 %.pre695, 0
  br i1 %cmp160, label %if.then162, label %if.end166

if.then162:                                       ; preds = %land.lhs.true151, %if.end157
  %kid80.1697 = phi %struct.op* [ %45, %if.end157 ], [ %41, %land.lhs.true151 ]
  %op_type158 = getelementptr inbounds %struct.op* %kid80.1697, i64 0, i32 4
  %op_targ165 = getelementptr inbounds %struct.op* %kid80.1697, i64 0, i32 3
  %46 = load i64* %op_targ165, align 8, !tbaa !13
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([64 x i8]* @.str17, i64 0, i64 0), i64 0, i64 %46) #4
  %.pr678 = load i16* %op_type158, align 2, !tbaa !12
  br label %if.end166

if.end166:                                        ; preds = %if.end145, %if.then162, %if.end157
  %kid80.1698 = phi %struct.op* [ %kid80.1697, %if.then162 ], [ %45, %if.end157 ], [ %41, %if.end145 ]
  %47 = phi i16 [ %.pr678, %if.then162 ], [ %.pre695, %if.end157 ], [ %42, %if.end145 ]
  %cmp169 = icmp eq i16 %47, 7
  br i1 %cmp169, label %if.end192, label %restore_2cv

restore_2cv:                                      ; preds = %if.end192, %if.end166
  %op_next172 = getelementptr inbounds %struct.op* %kid80.1698, i64 0, i32 0
  %48 = load %struct.op** %op_next172, align 8, !tbaa !42
  %tobool173 = icmp eq %struct.op* %48, null
  %cmp176 = icmp eq %struct.op* %48, %kid80.1698
  %or.cond673 = or i1 %tobool173, %cmp176
  %op_next183 = getelementptr inbounds %struct.op* %kid80.0, i64 0, i32 0
  br i1 %or.cond673, label %if.else182, label %if.then178

if.then178:                                       ; preds = %restore_2cv
  store %struct.op* %48, %struct.op** %op_next183, align 8, !tbaa !42
  store %struct.op* %kid80.0, %struct.op** %op_next172, align 8, !tbaa !42
  br label %if.end184

if.else182:                                       ; preds = %restore_2cv
  store %struct.op* null, %struct.op** %op_next183, align 8, !tbaa !42
  br label %if.end184

if.end184:                                        ; preds = %if.else182, %if.then178
  store i16 17, i16* %op_type103, align 2, !tbaa !12
  store i64 0, i64* %op_targ108, align 8, !tbaa !13
  %49 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 17), align 8, !tbaa !6
  %op_ppaddr187 = getelementptr inbounds %struct.op* %kid80.0, i64 0, i32 2
  store %struct.op* ()* %49, %struct.op* ()** %op_ppaddr187, align 8, !tbaa !41
  %op_private188 = getelementptr inbounds %struct.op* %kid80.0, i64 0, i32 7
  %50 = load i8* %op_private188, align 1, !tbaa !11
  %or190 = or i8 %50, -128
  store i8 %or190, i8* %op_private188, align 1, !tbaa !11
  br label %sw.epilog

if.end192:                                        ; preds = %if.end166
  %op_sv193 = getelementptr inbounds %struct.op* %kid80.1698, i64 1
  %51 = bitcast %struct.op* %op_sv193 to %struct.sv**
  %52 = load %struct.sv** %51, align 8, !tbaa !18
  %sv_any194 = bitcast %struct.sv* %52 to %struct.xpvgv**
  %53 = load %struct.xpvgv** %sv_any194, align 8, !tbaa !60
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %53, i64 0, i32 7
  %54 = load %struct.gp** %xgv_gp, align 8, !tbaa !62
  %gp_cv = getelementptr inbounds %struct.gp* %54, i64 0, i32 7
  %55 = load %struct.cv** %gp_cv, align 8, !tbaa !64
  %tobool195 = icmp eq %struct.cv* %55, null
  br i1 %tobool195, label %restore_2cv, label %if.end197

if.end197:                                        ; preds = %if.end192
  %sv_any198 = getelementptr inbounds %struct.cv* %55, i64 0, i32 0
  %56 = load %struct.xpvcv** %sv_any198, align 8, !tbaa !66
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %56, i64 0, i32 17
  %57 = load i16* %xcv_flags, align 2, !tbaa !68
  %and200 = and i16 %57, 256
  %tobool201 = icmp eq i16 %and200, 0
  br i1 %tobool201, label %nomod, label %sw.epilog

nomod:                                            ; preds = %sw.bb9, %sw.bb36, %if.end197, %sw.bb258, %sw.bb282, %if.end319, %sw.bb425, %sw.bb358, %if.end6
  switch i64 %type, label %nomod.if.end216_crit_edge [
    i64 20, label %land.lhs.true462
    i64 152, label %if.end477
    i64 166, label %if.end477
  ]

nomod.if.end216_crit_edge:                        ; preds = %nomod
  %.pre693 = load i16* %op_type7, align 2, !tbaa !12
  br label %if.end216

if.end216:                                        ; preds = %nomod.if.end216_crit_edge, %sw.bb455, %sw.bb353
  %.pr679 = phi i16 [ %.pre693, %nomod.if.end216_crit_edge ], [ %.pre, %sw.bb455 ], [ %.pre, %sw.bb353 ]
  switch i16 %.pr679, label %cond.false240 [
    i16 0, label %land.lhs.true221
    i16 166, label %cond.end248
    i16 351, label %cond.true238
  ]

land.lhs.true221:                                 ; preds = %if.end216
  %op_flags222 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %58 = load i8* %op_flags222, align 1, !tbaa !14
  %tobool225 = icmp slt i8 %58, 0
  br i1 %tobool225, label %cond.end248, label %cond.false240

cond.true238:                                     ; preds = %if.end216
  %59 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %tobool.i = icmp eq %struct.hv* %59, null
  br i1 %tobool.i, label %if.then.i, label %if.end.i676

if.then.i:                                        ; preds = %cond.true238
  %60 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end248

if.end.i676:                                      ; preds = %cond.true238
  %op_ppaddr.i674 = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  %61 = load %struct.op* ()** %op_ppaddr.i674, align 8, !tbaa !41
  %62 = ptrtoint %struct.op* ()* %61 to i64
  %call.i675 = tail call %struct.sv* @Perl_newSViv(i64 %62) #4
  %call1.i = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call.i675) #4
  %63 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %call2.i = tail call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %63, %struct.sv* %call1.i, i64 0, i64 0) #4
  %tobool3.i = icmp eq %struct.he* %call2.i, null
  br i1 %tobool3.i, label %if.then4.i, label %if.end5.i

if.then4.i:                                       ; preds = %if.end.i676
  %64 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end248

if.end5.i:                                        ; preds = %if.end.i676
  %hent_val.i = getelementptr inbounds %struct.he* %call2.i, i64 0, i32 2
  %65 = load %struct.sv** %hent_val.i, align 8, !tbaa !49
  %sv_flags.i = getelementptr inbounds %struct.sv* %65, i64 0, i32 2
  %66 = load i64* %sv_flags.i, align 8, !tbaa !34
  %and.i = and i64 %66, 262144
  %cmp.i677 = icmp eq i64 %and.i, 0
  br i1 %cmp.i677, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.end5.i
  %sv_any.i = getelementptr inbounds %struct.sv* %65, i64 0, i32 0
  %67 = load i8** %sv_any.i, align 8, !tbaa !36
  %xpv_pv.i = bitcast i8* %67 to i8**
  %68 = load i8** %xpv_pv.i, align 8, !tbaa !39
  br label %cond.end248

cond.false.i:                                     ; preds = %if.end5.i
  %call8.i = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %65) #4
  br label %cond.end248

cond.false240:                                    ; preds = %if.end216, %land.lhs.true221
  %idxprom242 = zext i16 %.pr679 to i64
  %arrayidx243 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom242
  %69 = load i8** %arrayidx243, align 8, !tbaa !6
  br label %cond.end248

cond.end248:                                      ; preds = %if.end216, %cond.false.i, %cond.true.i, %if.then4.i, %if.then.i, %cond.false240, %land.lhs.true221
  %cond249 = phi i8* [ getelementptr inbounds ([9 x i8]* @.str19, i64 0, i64 0), %land.lhs.true221 ], [ %69, %cond.false240 ], [ %64, %if.then4.i ], [ %60, %if.then.i ], [ %68, %cond.true.i ], [ %call8.i, %cond.false.i ], [ getelementptr inbounds ([27 x i8]* @.str20, i64 0, i64 0), %if.end216 ]
  %tobool250 = icmp eq i64 %type, 0
  br i1 %tobool250, label %cond.end254, label %cond.true251

cond.true251:                                     ; preds = %cond.end248
  %arrayidx252 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %type
  %70 = load i8** %arrayidx252, align 8, !tbaa !6
  br label %cond.end254

cond.end254:                                      ; preds = %cond.end248, %cond.true251
  %cond255 = phi i8* [ %70, %cond.true251 ], [ getelementptr inbounds ([6 x i8]* @.str21, i64 0, i64 0), %cond.end248 ]
  %call256 = tail call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([22 x i8]* @.str18, i64 0, i64 0), i8* %cond249, i8* %cond255) #4
  %call257 = tail call i32 (i8*, ...)* bitcast (i32 (...)* @yyerror to i32 (i8*, ...)*)(i8* %call256) #4
  br label %return

sw.bb258:                                         ; preds = %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6
  %op_flags259 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %71 = load i8* %op_flags259, align 1, !tbaa !14
  %and261 = and i8 %71, 64
  %tobool262 = icmp eq i8 %and261, 0
  br i1 %tobool262, label %nomod, label %if.end264

if.end264:                                        ; preds = %sw.bb258
  %72 = load i64* @PL_modcount, align 8, !tbaa !1
  %inc265 = add nsw i64 %72, 1
  store i64 %inc265, i64* @PL_modcount, align 8, !tbaa !1
  br label %sw.epilog

sw.bb266:                                         ; preds = %if.end6
  %73 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %74 = load %struct.op** %73, align 8, !tbaa !15
  %kid.0.in686 = getelementptr inbounds %struct.op* %74, i64 0, i32 1
  %kid.0687 = load %struct.op** %kid.0.in686, align 8
  %tobool269688 = icmp eq %struct.op* %kid.0687, null
  br i1 %tobool269688, label %sw.epilog, label %for.body

for.body:                                         ; preds = %sw.bb266, %for.body
  %kid.0689 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.0687, %sw.bb266 ]
  %call270 = tail call i32 (%struct.op*, i64, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i64, ...)*)(%struct.op* %kid.0689, i64 %type) #4
  %kid.0.in = getelementptr inbounds %struct.op* %kid.0689, i64 0, i32 1
  %kid.0 = load %struct.op** %kid.0.in, align 8
  %tobool269 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool269, label %sw.epilog, label %for.body

sw.bb272:                                         ; preds = %if.end6, %if.end6
  %cmp273 = icmp eq i64 %type, 20
  br i1 %cmp273, label %land.lhs.true275, label %sw.bb282

land.lhs.true275:                                 ; preds = %sw.bb272
  %op_flags276 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %75 = load i8* %op_flags276, align 1, !tbaa !14
  %and278 = and i8 %75, 8
  %tobool279 = icmp eq i8 %and278, 0
  br i1 %tobool279, label %sw.bb282, label %if.then280

if.then280:                                       ; preds = %land.lhs.true275
  store i64 1073741823, i64* @PL_modcount, align 8, !tbaa !1
  br label %return

sw.bb282:                                         ; preds = %land.lhs.true275, %sw.bb272, %if.end6
  %call283 = tail call i32 (%struct.op*, i64, ...)* bitcast (i32 (...)* @scalar_mod_type to i32 (%struct.op*, i64, ...)*)(%struct.op* %o, i64 %type) #4
  %tobool284 = icmp eq i32 %call283, 0
  br i1 %tobool284, label %if.end286, label %nomod

if.end286:                                        ; preds = %sw.bb282
  %76 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %77 = load %struct.op** %76, align 8, !tbaa !15
  %78 = load i16* %op_type7, align 2, !tbaa !12
  %conv289 = zext i16 %78 to i32
  %call290 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i32, ...)*)(%struct.op* %77, i32 %conv289) #4
  br label %sw.bb291

sw.bb291:                                         ; preds = %if.end6, %if.end6, %if.end286
  %cmp292 = icmp eq i64 %type, 168
  br i1 %cmp292, label %if.then294, label %sw.bb300

if.then294:                                       ; preds = %sw.bb291
  %79 = load i8* %op_private, align 1, !tbaa !11
  %or297 = or i8 %79, 8
  store i8 %or297, i8* %op_private, align 1, !tbaa !11
  br label %sw.bb300

sw.bb300:                                         ; preds = %sw.bb291, %if.then294, %if.end6, %if.end6, %if.end6
  store i64 1073741823, i64* @PL_modcount, align 8, !tbaa !1
  br label %sw.epilog

sw.bb301:                                         ; preds = %if.end6
  %80 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %81 = load %struct.op** %80, align 8, !tbaa !15
  %call305 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i32, ...)*)(%struct.op* %81, i32 15) #4
  br label %sw.bb306

sw.bb306:                                         ; preds = %if.end6, %if.end6, %sw.bb301
  %82 = load i64* @PL_hints, align 8, !tbaa !1
  %or307 = or i64 %82, 256
  store i64 %or307, i64* @PL_hints, align 8, !tbaa !1
  br label %sw.bb308

sw.bb308:                                         ; preds = %if.end6, %if.end6, %if.end6, %if.end6, %sw.bb306
  %83 = load i64* @PL_modcount, align 8, !tbaa !1
  %inc309 = add nsw i64 %83, 1
  store i64 %inc309, i64* @PL_modcount, align 8, !tbaa !1
  br label %sw.epilog

sw.bb310:                                         ; preds = %if.end6, %if.end6
  store i64 1073741823, i64* @PL_modcount, align 8, !tbaa !1
  %cmp311 = icmp eq i64 %type, 20
  br i1 %cmp311, label %land.lhs.true313, label %if.end319

land.lhs.true313:                                 ; preds = %sw.bb310
  %op_flags314 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %84 = load i8* %op_flags314, align 1, !tbaa !14
  %and316 = and i8 %84, 8
  %tobool317 = icmp eq i8 %and316, 0
  br i1 %tobool317, label %if.end319, label %return

if.end319:                                        ; preds = %land.lhs.true313, %sw.bb310
  %call320 = tail call i32 (%struct.op*, i64, ...)* bitcast (i32 (...)* @scalar_mod_type to i32 (%struct.op*, i64, ...)*)(%struct.op* %o, i64 %type) #4
  %tobool321 = icmp eq i32 %call320, 0
  br i1 %tobool321, label %if.end323, label %nomod

if.end323:                                        ; preds = %if.end319
  %cmp324 = icmp eq i64 %type, 168
  br i1 %cmp324, label %sw.bb332.thread, label %sw.bb332

sw.bb332.thread:                                  ; preds = %if.end323
  %85 = load i8* %op_private, align 1, !tbaa !11
  %or329 = or i8 %85, 8
  store i8 %or329, i8* %op_private, align 1, !tbaa !11
  %86 = load i64* @PL_modcount, align 8, !tbaa !1
  %inc333680 = add nsw i64 %86, 1
  store i64 %inc333680, i64* @PL_modcount, align 8, !tbaa !1
  br label %return

sw.bb332:                                         ; preds = %if.end323, %if.end6
  %87 = load i64* @PL_modcount, align 8, !tbaa !1
  %inc333 = add nsw i64 %87, 1
  store i64 %inc333, i64* @PL_modcount, align 8, !tbaa !1
  switch i64 %type, label %if.end477 [
    i64 0, label %if.then335
    i64 20, label %land.lhs.true462
    i64 168, label %return
  ]

if.then335:                                       ; preds = %sw.bb332
  %88 = load %struct.av** @PL_comppad_name, align 8, !tbaa !6
  %op_targ336 = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %89 = load i64* %op_targ336, align 8, !tbaa !13
  %call337 = tail call %struct.sv** @Perl_av_fetch(%struct.av* %88, i64 %89, i64 0) #4
  %90 = load %struct.sv** %call337, align 8, !tbaa !6
  %sv_flags338 = getelementptr inbounds %struct.sv* %90, i64 0, i32 2
  %91 = load i64* %sv_flags338, align 8, !tbaa !34
  %and339 = and i64 %91, 262144
  %cmp340 = icmp eq i64 %and339, 0
  %92 = load %struct.av** @PL_comppad_name, align 8, !tbaa !6
  %93 = load i64* %op_targ336, align 8, !tbaa !13
  %call344 = tail call %struct.sv** @Perl_av_fetch(%struct.av* %92, i64 %93, i64 0) #4
  %94 = load %struct.sv** %call344, align 8, !tbaa !6
  br i1 %cmp340, label %cond.false346, label %cond.true342

cond.true342:                                     ; preds = %if.then335
  %sv_any345 = getelementptr inbounds %struct.sv* %94, i64 0, i32 0
  %95 = load i8** %sv_any345, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %95 to i8**
  %96 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %cond.end350

cond.false346:                                    ; preds = %if.then335
  %call349 = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %94) #4
  br label %cond.end350

cond.end350:                                      ; preds = %cond.false346, %cond.true342
  %cond351 = phi i8* [ %96, %cond.true342 ], [ %call349, %cond.false346 ]
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([35 x i8]* @.str22, i64 0, i64 0), i8* %cond351) #4
  br label %sw.epilog

sw.bb353:                                         ; preds = %if.end6
  switch i64 %type, label %if.end216 [
    i64 36, label %lvalue_func
    i64 20, label %land.lhs.true462
    i64 152, label %if.end477
    i64 166, label %if.end477
  ]

sw.bb358:                                         ; preds = %if.end6
  %cmp361 = icmp eq i8 %1, 4
  br i1 %cmp361, label %nomod, label %sw.bb365

sw.bb365:                                         ; preds = %sw.bb358, %if.end6, %if.end6
  %cmp366 = icmp eq i64 %type, 168
  br i1 %cmp366, label %if.then368, label %lvalue_func

if.then368:                                       ; preds = %sw.bb365
  %or371 = or i8 %1, 8
  store i8 %or371, i8* %op_private, align 1, !tbaa !11
  br label %lvalue_func

lvalue_func:                                      ; preds = %sw.bb353, %sw.bb365, %if.then368
  %op_targ374 = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %97 = load i64* %op_targ374, align 8, !tbaa !13
  %call375 = tail call i32 (i64, ...)* bitcast (i32 (...)* @pad_free to i32 (i64, ...)*)(i64 %97) #4
  %98 = load i16* %op_type7, align 2, !tbaa !12
  %conv377 = zext i16 %98 to i32
  %call378 = tail call i32 (i32, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i32, i32, ...)*)(i32 %conv377, i32 1024) #4
  %conv379 = sext i32 %call378 to i64
  store i64 %conv379, i64* %op_targ374, align 8, !tbaa !13
  %op_flags381 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %99 = load i8* %op_flags381, align 1, !tbaa !14
  %and383 = and i8 %99, 4
  %tobool384 = icmp eq i8 %and383, 0
  br i1 %tobool384, label %sw.epilog, label %if.then385

if.then385:                                       ; preds = %lvalue_func
  %100 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %101 = load %struct.op** %100, align 8, !tbaa !43
  %op_sibling387 = getelementptr inbounds %struct.op* %101, i64 0, i32 1
  %102 = load %struct.op** %op_sibling387, align 8, !tbaa !17
  %call388 = tail call i32 (%struct.op*, i64, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i64, ...)*)(%struct.op* %102, i64 %type) #4
  br label %sw.epilog

sw.bb390:                                         ; preds = %if.end6, %if.end6
  %103 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %104 = load %struct.op** %103, align 8, !tbaa !43
  %call394 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i32, ...)*)(%struct.op* %104, i32 %conv8) #4
  switch i64 %type, label %if.end415 [
    i64 166, label %land.lhs.true397
    i64 168, label %if.then410
  ]

land.lhs.true397:                                 ; preds = %sw.bb390
  %105 = load i8* %op_private, align 1, !tbaa !11
  %tobool401 = icmp ult i8 %105, 32
  br i1 %tobool401, label %if.then402, label %if.end415

if.then402:                                       ; preds = %land.lhs.true397
  %or405 = or i8 %105, 16
  store i8 %or405, i8* %op_private, align 1, !tbaa !11
  br label %if.end415

if.then410:                                       ; preds = %sw.bb390
  %106 = load i8* %op_private, align 1, !tbaa !11
  %or413 = or i8 %106, 8
  store i8 %or413, i8* %op_private, align 1, !tbaa !11
  br label %if.end415

if.end415:                                        ; preds = %if.then402, %land.lhs.true397, %sw.bb390, %if.then410
  %107 = load i64* @PL_modcount, align 8, !tbaa !1
  %inc416 = add nsw i64 %107, 1
  store i64 %inc416, i64* @PL_modcount, align 8, !tbaa !1
  br label %sw.epilog

sw.bb417:                                         ; preds = %if.end6, %if.end6, %if.end6, %if.end6
  %op_flags418 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %108 = load i8* %op_flags418, align 1, !tbaa !14
  %and420 = and i8 %108, 4
  %tobool421 = icmp eq i8 %and420, 0
  br i1 %tobool421, label %sw.epilog, label %if.then422

if.then422:                                       ; preds = %sw.bb417
  %109 = getelementptr inbounds %struct.op* %o, i64 1, i32 1
  %110 = load %struct.op** %109, align 8, !tbaa !70
  %call423 = tail call i32 (%struct.op*, i64, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i64, ...)*)(%struct.op* %110, i64 %type) #4
  br label %sw.epilog

sw.bb425:                                         ; preds = %if.end6
  %op_flags426 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %111 = load i8* %op_flags426, align 1, !tbaa !14
  %conv427 = zext i8 %111 to i32
  %and428 = and i32 %conv427, 128
  %tobool429 = icmp eq i32 %and428, 0
  br i1 %tobool429, label %if.else431, label %nomod

if.else431:                                       ; preds = %sw.bb425
  %and434 = and i32 %conv427, 4
  %tobool435 = icmp eq i32 %and434, 0
  br i1 %tobool435, label %sw.epilog, label %if.end438

if.end438:                                        ; preds = %if.else431
  %op_targ439 = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %112 = load i64* %op_targ439, align 8, !tbaa !13
  %cmp440 = icmp eq i64 %112, 141
  br i1 %cmp440, label %sw.bb446, label %if.then442

if.then442:                                       ; preds = %if.end438
  %113 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %114 = load %struct.op** %113, align 8, !tbaa !43
  %call444 = tail call i32 (%struct.op*, i64, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i64, ...)*)(%struct.op* %114, i64 %type) #4
  br label %sw.epilog

sw.bb446:                                         ; preds = %if.end438, %if.end6
  %115 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.1690 = load %struct.op** %115, align 8
  %tobool449691 = icmp eq %struct.op* %kid.1690, null
  br i1 %tobool449691, label %sw.epilog, label %for.body450

for.body450:                                      ; preds = %sw.bb446, %for.body450
  %kid.1692 = phi %struct.op* [ %kid.1, %for.body450 ], [ %kid.1690, %sw.bb446 ]
  %call451 = tail call i32 (%struct.op*, i64, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i64, ...)*)(%struct.op* %kid.1692, i64 %type) #4
  %op_sibling453 = getelementptr inbounds %struct.op* %kid.1692, i64 0, i32 1
  %kid.1 = load %struct.op** %op_sibling453, align 8
  %tobool449 = icmp eq %struct.op* %kid.1, null
  br i1 %tobool449, label %sw.epilog, label %for.body450

sw.bb455:                                         ; preds = %if.end6
  switch i64 %type, label %if.end216 [
    i64 20, label %land.lhs.true462
    i64 168, label %return
    i64 152, label %if.end477
    i64 166, label %if.end477
  ]

sw.epilog:                                        ; preds = %for.body450, %for.body, %sw.bb446, %sw.bb266, %if.end.i, %if.then53, %sw.bb36, %if.end197, %lvalue_func, %sw.bb417, %if.else431, %if.then422, %if.then385, %cond.end350, %cond.end, %if.else32, %if.then442, %if.end415, %if.end6, %sw.bb308, %sw.bb300, %if.end264, %if.end184, %if.end140, %if.then121, %if.then74
  switch i64 %type, label %if.end477 [
    i64 20, label %land.lhs.true462
    i64 168, label %return
  ]

land.lhs.true462:                                 ; preds = %sw.bb455, %sw.bb353, %nomod, %sw.bb332, %sw.epilog, %if.else
  %116 = load i16* %op_type7, align 2, !tbaa !12
  %idxprom464 = zext i16 %116 to i64
  %arrayidx465 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %idxprom464
  %117 = load %struct.op* (%struct.op*)** %arrayidx465, align 8, !tbaa !6
  %cmp466 = icmp eq %struct.op* (%struct.op*)* %117, @Perl_ck_ftst
  br i1 %cmp466, label %return, label %if.end477.thread682

if.end477.thread682:                              ; preds = %land.lhs.true462, %sw.epilog.thread
  %op_flags473683 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %118 = load i8* %op_flags473683, align 1, !tbaa !14
  %or475684 = or i8 %118, 32
  store i8 %or475684, i8* %op_flags473683, align 1, !tbaa !14
  br label %if.else488

if.end477:                                        ; preds = %sw.epilog, %sw.bb332, %nomod, %nomod, %sw.bb353, %sw.bb353, %sw.bb455, %sw.bb455
  %op_flags473 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %119 = load i8* %op_flags473, align 1, !tbaa !14
  %or475 = or i8 %119, 32
  store i8 %or475, i8* %op_flags473, align 1, !tbaa !14
  %120 = and i64 %type, -2
  %121 = icmp eq i64 %120, 36
  br i1 %121, label %if.then483, label %if.else488

if.then483:                                       ; preds = %if.end477
  %or486 = or i8 %119, -80
  store i8 %or486, i8* %op_flags473, align 1, !tbaa !14
  br label %return

if.else488:                                       ; preds = %if.end477.thread682, %if.end477
  %122 = phi i8 [ %or475684, %if.end477.thread682 ], [ %or475, %if.end477 ]
  switch i64 %type, label %if.then509 [
    i64 0, label %if.then490
    i64 168, label %return
    i64 166, label %return
    i64 152, label %return
  ]

if.then490:                                       ; preds = %if.else488
  %123 = load i8* %op_private, align 1, !tbaa !11
  %or493 = or i8 %123, -128
  store i8 %or493, i8* %op_private, align 1, !tbaa !11
  %op_flags495 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %and497 = and i8 %122, 127
  store i8 %and497, i8* %op_flags495, align 1, !tbaa !14
  %124 = load i64* @PL_hints, align 8, !tbaa !1
  %or499 = or i64 %124, 256
  store i64 %or499, i64* @PL_hints, align 8, !tbaa !1
  br label %return

if.then509:                                       ; preds = %if.else488
  %op_flags510 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %or512 = or i8 %122, 16
  store i8 %or512, i8* %op_flags510, align 1, !tbaa !14
  br label %return

return:                                           ; preds = %sw.bb332.thread, %sw.bb455, %sw.bb332, %sw.epilog, %if.else488, %if.else488, %if.else488, %if.then483, %if.then509, %if.then490, %land.lhs.true462, %land.lhs.true313, %if.else56, %land.lhs.true, %entry, %if.then280, %cond.end254, %sw.bb
  ret %struct.op* %o
}

declare i64 @Perl_sv_2iv(%struct.sv*) #2

declare void @Perl_save_I32(i64*) #2

declare void @Perl_croak(i8*, ...) #2

declare i8* @Perl_safesysmalloc(i64) #2

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #4

declare i32 @mod(...) #2

declare i32 @scalar_mod_type(...) #2

declare i32 @ref(...) #2

declare %struct.sv** @Perl_av_fetch(%struct.av*, i64, i64) #2

declare i8* @Perl_sv_2pv_nolen(%struct.sv*) #2

declare i32 @pad_alloc(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_refkids(%struct.op* readonly %o, i64 %type) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 4
  %tobool1 = icmp eq i8 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.08 = load %struct.op** %1, align 8
  %tobool29 = icmp eq %struct.op* %kid.08, null
  br i1 %tobool29, label %if.end, label %for.body

for.body:                                         ; preds = %if.then, %for.body
  %kid.010 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.08, %if.then ]
  %call = tail call i32 (%struct.op*, i64, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i64, ...)*)(%struct.op* %kid.010, i64 %type) #4
  %op_sibling = getelementptr inbounds %struct.op* %kid.010, i64 0, i32 1
  %kid.0 = load %struct.op** %op_sibling, align 8
  %tobool2 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool2, label %if.end, label %for.body

if.end:                                           ; preds = %for.body, %if.then, %land.lhs.true, %entry
  ret %struct.op* %o
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ref(%struct.op* %o, i64 %type) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  %0 = load i64* @PL_error_count, align 8
  %tobool1 = icmp ne i64 %0, 0
  %or.cond = or i1 %tobool, %tobool1
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %1 = load i16* %op_type, align 2, !tbaa !12
  %conv = zext i16 %1 to i32
  switch i32 %conv, label %sw.epilog [
    i32 166, label %sw.bb
    i32 162, label %sw.bb18
    i32 15, label %sw.bb22
    i32 9, label %sw.bb35
    i32 348, label %sw.bb58
    i32 125, label %sw.bb63
    i32 134, label %sw.bb63
    i32 14, label %sw.bb68
    i32 10, label %sw.bb81
    i32 11, label %sw.bb81
    i32 2, label %sw.bb86
    i32 0, label %sw.bb86
    i32 127, label %sw.bb95
    i32 135, label %sw.bb95
    i32 179, label %sw.bb127
    i32 178, label %sw.bb127
    i32 177, label %sw.bb127
    i32 141, label %sw.bb127
  ]

sw.bb:                                            ; preds = %if.end
  switch i64 %type, label %sw.epilog [
    i64 347, label %land.lhs.true
    i64 133, label %land.lhs.true
    i64 42, label %land.lhs.true
  ]

land.lhs.true:                                    ; preds = %sw.bb, %sw.bb, %sw.bb
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %2, 64
  %tobool10 = icmp eq i8 %and, 0
  br i1 %tobool10, label %if.then11, label %sw.epilog

if.then11:                                        ; preds = %land.lhs.true
  store i16 17, i16* %op_type, align 2, !tbaa !12
  %3 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 17), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %3, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %4 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %5 = load %struct.op** %4, align 8, !tbaa !15
  %6 = getelementptr inbounds %struct.op* %5, i64 1, i32 0
  %7 = load %struct.op** %6, align 8, !tbaa !45
  %op_type.i = getelementptr inbounds %struct.op* %7, i64 0, i32 4
  %8 = load i16* %op_type.i, align 2, !tbaa !12
  %cmp.i = icmp eq i16 %8, 0
  br i1 %cmp.i, label %Perl_op_null.exit, label %if.end.i

if.end.i:                                         ; preds = %if.then11
  %call.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %7) #4
  %9 = load i16* %op_type.i, align 2, !tbaa !12
  %conv3.i = zext i16 %9 to i64
  %op_targ.i = getelementptr inbounds %struct.op* %7, i64 0, i32 3
  store i64 %conv3.i, i64* %op_targ.i, align 8, !tbaa !13
  store i16 0, i16* %op_type.i, align 2, !tbaa !12
  %10 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds %struct.op* %7, i64 0, i32 2
  store %struct.op* ()* %10, %struct.op* ()** %op_ppaddr.i, align 8, !tbaa !41
  %.pre = load i8* %op_flags, align 1, !tbaa !14
  br label %Perl_op_null.exit

Perl_op_null.exit:                                ; preds = %if.then11, %if.end.i
  %11 = phi i8 [ %2, %if.then11 ], [ %.pre, %if.end.i ]
  %or = or i8 %11, -128
  store i8 %or, i8* %op_flags, align 1, !tbaa !14
  br label %sw.epilog

sw.bb18:                                          ; preds = %if.end
  %12 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %13 = load %struct.op** %12, align 8, !tbaa !15
  %kid.0.in189 = getelementptr inbounds %struct.op* %13, i64 0, i32 1
  %kid.0190 = load %struct.op** %kid.0.in189, align 8
  %tobool20191 = icmp eq %struct.op* %kid.0190, null
  br i1 %tobool20191, label %sw.epilog, label %for.body

for.body:                                         ; preds = %sw.bb18, %for.body
  %kid.0192 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.0190, %sw.bb18 ]
  %call = tail call i32 (%struct.op*, i64, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i64, ...)*)(%struct.op* %kid.0192, i64 %type) #4
  %kid.0.in = getelementptr inbounds %struct.op* %kid.0192, i64 0, i32 1
  %kid.0 = load %struct.op** %kid.0.in, align 8
  %tobool20 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool20, label %sw.epilog, label %for.body

sw.bb22:                                          ; preds = %if.end
  %cmp23 = icmp eq i64 %type, 42
  br i1 %cmp23, label %if.then25, label %if.end30

if.then25:                                        ; preds = %sw.bb22
  %op_flags26 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %14 = load i8* %op_flags26, align 1, !tbaa !14
  %or28 = or i8 %14, -128
  store i8 %or28, i8* %op_flags26, align 1, !tbaa !14
  br label %if.end30

if.end30:                                         ; preds = %if.then25, %sw.bb22
  %15 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %16 = load %struct.op** %15, align 8, !tbaa !15
  %call34 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i32, ...)*)(%struct.op* %16, i32 15) #4
  br label %sw.bb35

sw.bb35:                                          ; preds = %if.end, %if.end30
  %cmp42 = icmp eq i64 %type, 134
  switch i64 %type, label %sw.epilog [
    i64 125, label %cond.end
    i64 15, label %cond.false
    i64 134, label %cond.false
  ]

cond.false:                                       ; preds = %sw.bb35, %sw.bb35
  %cond = select i1 %cmp42, i8 64, i8 96
  br label %cond.end

cond.end:                                         ; preds = %sw.bb35, %cond.false
  %cond49 = phi i8 [ %cond, %cond.false ], [ 32, %sw.bb35 ]
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %17 = load i8* %op_private, align 1, !tbaa !11
  %or51 = or i8 %17, %cond49
  store i8 %or51, i8* %op_private, align 1, !tbaa !11
  %op_flags53 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %18 = load i8* %op_flags53, align 1, !tbaa !14
  %or55 = or i8 %18, 32
  store i8 %or55, i8* %op_flags53, align 1, !tbaa !14
  br label %sw.epilog

sw.bb58:                                          ; preds = %if.end
  %op_flags59 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %19 = load i8* %op_flags59, align 1, !tbaa !14
  %or61 = or i8 %19, 32
  store i8 %or61, i8* %op_flags59, align 1, !tbaa !14
  br label %sw.epilog

sw.bb63:                                          ; preds = %if.end, %if.end
  %op_flags64 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %20 = load i8* %op_flags64, align 1, !tbaa !14
  %or66 = or i8 %20, 16
  store i8 %or66, i8* %op_flags64, align 1, !tbaa !14
  br label %sw.bb68

sw.bb68:                                          ; preds = %if.end, %sw.bb63
  %cmp69 = icmp eq i64 %type, 42
  br i1 %cmp69, label %if.then71, label %if.end76

if.then71:                                        ; preds = %sw.bb68
  %op_flags72 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %21 = load i8* %op_flags72, align 1, !tbaa !14
  %or74 = or i8 %21, -128
  store i8 %or74, i8* %op_flags72, align 1, !tbaa !14
  br label %if.end76

if.end76:                                         ; preds = %if.then71, %sw.bb68
  %22 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %23 = load %struct.op** %22, align 8, !tbaa !15
  %call80 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i32, ...)*)(%struct.op* %23, i32 %conv) #4
  br label %sw.epilog

sw.bb81:                                          ; preds = %if.end, %if.end
  %op_flags82 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %24 = load i8* %op_flags82, align 1, !tbaa !14
  %or84 = or i8 %24, 16
  store i8 %or84, i8* %op_flags82, align 1, !tbaa !14
  br label %sw.epilog

sw.bb86:                                          ; preds = %if.end, %if.end
  %op_flags87 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %25 = load i8* %op_flags87, align 1, !tbaa !14
  %and89 = and i8 %25, 4
  %tobool90 = icmp eq i8 %and89, 0
  br i1 %tobool90, label %sw.epilog, label %if.end92

if.end92:                                         ; preds = %sw.bb86
  %26 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %27 = load %struct.op** %26, align 8, !tbaa !43
  %call94 = tail call i32 (%struct.op*, i64, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i64, ...)*)(%struct.op* %27, i64 %type) #4
  br label %sw.epilog

sw.bb95:                                          ; preds = %if.end, %if.end
  %28 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %29 = load %struct.op** %28, align 8, !tbaa !43
  %call99 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i32, ...)*)(%struct.op* %29, i32 %conv) #4
  %cmp106 = icmp eq i64 %type, 134
  switch i64 %type, label %sw.epilog [
    i64 125, label %cond.end116
    i64 15, label %cond.false112
    i64 134, label %cond.false112
  ]

cond.false112:                                    ; preds = %sw.bb95, %sw.bb95
  %cond115 = select i1 %cmp106, i8 64, i8 96
  br label %cond.end116

cond.end116:                                      ; preds = %sw.bb95, %cond.false112
  %cond117 = phi i8 [ %cond115, %cond.false112 ], [ 32, %sw.bb95 ]
  %op_private118 = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %30 = load i8* %op_private118, align 1, !tbaa !11
  %or120 = or i8 %30, %cond117
  store i8 %or120, i8* %op_private118, align 1, !tbaa !11
  %op_flags122 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %31 = load i8* %op_flags122, align 1, !tbaa !14
  %or124 = or i8 %31, 32
  store i8 %or124, i8* %op_flags122, align 1, !tbaa !14
  br label %sw.epilog

sw.bb127:                                         ; preds = %if.end, %if.end, %if.end, %if.end
  %op_flags128 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %32 = load i8* %op_flags128, align 1, !tbaa !14
  %and130 = and i8 %32, 4
  %tobool131 = icmp eq i8 %and130, 0
  br i1 %tobool131, label %sw.epilog, label %if.end133

if.end133:                                        ; preds = %sw.bb127
  %33 = getelementptr inbounds %struct.op* %o, i64 1, i32 1
  %34 = load %struct.op** %33, align 8, !tbaa !70
  %call134 = tail call i32 (%struct.op*, i64, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i64, ...)*)(%struct.op* %34, i64 %type) #4
  br label %sw.epilog

sw.epilog:                                        ; preds = %for.body, %sw.bb18, %sw.bb95, %sw.bb35, %sw.bb, %land.lhs.true, %sw.bb86, %sw.bb127, %if.end, %cond.end116, %cond.end, %Perl_op_null.exit, %if.end133, %if.end92, %sw.bb81, %if.end76, %sw.bb58
  %call135 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv136 = sext i32 %call135 to i64
  %35 = inttoptr i64 %conv136 to %struct.op*
  br label %return

return:                                           ; preds = %entry, %sw.epilog
  %retval.0 = phi %struct.op* [ %35, %sw.epilog ], [ %o, %entry ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define void @Perl_apply_attrs_string(i8* %stashpv, %struct.cv* %cv, i8* %attrstr, i64 %len) #0 {
entry:
  %tobool = icmp eq i64 %len, 0
  br i1 %tobool, label %while.cond.preheader, label %for.cond.preheader.lr.ph

while.cond.preheader:                             ; preds = %entry
  %call = tail call i64 @strlen(i8* %attrstr) #4
  %tobool1148152 = icmp eq i64 %call, 0
  br i1 %tobool1148152, label %while.end, label %for.cond.preheader.lr.ph

for.cond.preheader.lr.ph:                         ; preds = %entry, %while.cond.preheader, %Perl_newSVOP.exit
  %attrstr.addr.0.ph155 = phi i8* [ %attrstr.addr.2, %Perl_newSVOP.exit ], [ %attrstr, %while.cond.preheader ], [ %attrstr, %entry ]
  %attrs.0.ph154 = phi %struct.op* [ %15, %Perl_newSVOP.exit ], [ null, %while.cond.preheader ], [ null, %entry ]
  %len.addr.0.ph144153 = phi i64 [ %len.addr.2, %Perl_newSVOP.exit ], [ %len, %entry ], [ %call, %while.cond.preheader ]
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader.lr.ph, %for.inc
  %len.addr.1 = phi i64 [ %dec, %for.inc ], [ %len.addr.0.ph144153, %for.cond.preheader.lr.ph ]
  %attrstr.addr.1 = phi i8* [ %incdec.ptr, %for.inc ], [ %attrstr.addr.0.ph155, %for.cond.preheader.lr.ph ]
  %0 = load i8* %attrstr.addr.1, align 1, !tbaa !5
  switch i8 %0, label %lor.lhs.false14 [
    i8 32, label %land.rhs
    i8 9, label %land.rhs
    i8 10, label %land.rhs
    i8 13, label %land.rhs
  ]

lor.lhs.false14:                                  ; preds = %for.cond
  %cmp16 = icmp eq i8 %0, 12
  %tobool18 = icmp ne i64 %len.addr.1, 0
  %or.cond = and i1 %cmp16, %tobool18
  br i1 %or.cond, label %for.inc, label %for.end

land.rhs:                                         ; preds = %for.cond, %for.cond, %for.cond, %for.cond
  %cond = icmp eq i64 %len.addr.1, 0
  br i1 %cond, label %while.end, label %for.inc

for.inc:                                          ; preds = %land.rhs, %lor.lhs.false14
  %dec = add i64 %len.addr.1, -1
  %incdec.ptr = getelementptr inbounds i8* %attrstr.addr.1, i64 1
  br label %for.cond

for.end:                                          ; preds = %lor.lhs.false14
  %tobool19 = icmp eq i64 %len.addr.1, 0
  br i1 %tobool19, label %while.end, label %for.cond21

for.cond21:                                       ; preds = %for.end, %for.inc45
  %1 = phi i8 [ %.pre, %for.inc45 ], [ %0, %for.end ]
  %len.addr.2 = phi i64 [ %dec46, %for.inc45 ], [ %len.addr.1, %for.end ]
  %attrstr.addr.2 = phi i8* [ %incdec.ptr47, %for.inc45 ], [ %attrstr.addr.1, %for.end ]
  switch i8 %1, label %lor.lhs.false37 [
    i8 32, label %for.end48
    i8 9, label %for.end48
    i8 10, label %for.end48
    i8 13, label %for.end48
  ]

lor.lhs.false37:                                  ; preds = %for.cond21
  %cmp39 = icmp ne i8 %1, 12
  %tobool42 = icmp ne i64 %len.addr.2, 0
  %or.cond66 = and i1 %cmp39, %tobool42
  br i1 %or.cond66, label %for.inc45, label %for.end48

for.inc45:                                        ; preds = %lor.lhs.false37
  %dec46 = add i64 %len.addr.2, -1
  %incdec.ptr47 = getelementptr inbounds i8* %attrstr.addr.2, i64 1
  %.pre = load i8* %incdec.ptr47, align 1, !tbaa !5
  br label %for.cond21

for.end48:                                        ; preds = %for.cond21, %for.cond21, %for.cond21, %for.cond21, %lor.lhs.false37
  %sub.ptr.lhs.cast = ptrtoint i8* %attrstr.addr.2 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %attrstr.addr.1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call49 = tail call %struct.sv* @Perl_newSVpvn(i8* %attrstr.addr.1, i64 %sub.ptr.sub) #4
  %call.i = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i, i64 32
  %2 = bitcast i8* %op_type.i to i16*
  store i16 5, i16* %2, align 2, !tbaa !71
  %3 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %4 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %3, %struct.op* ()** %4, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i, i64 40
  %5 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %call49, %struct.sv** %5, align 8, !tbaa !18
  %6 = bitcast i8* %call.i to %struct.op*
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %6, %struct.op** %op_next.i, align 8, !tbaa !73
  %7 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %7, align 1, !tbaa !74
  %8 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i = and i64 %8, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %for.end48
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %6) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %for.end48
  %9 = phi i64 [ %8, %for.end48 ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %9, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %10 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %10, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %11 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %11, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %11, i64 5
  %12 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %12, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %6) #4
  %13 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %13) #4
  br label %Perl_newSVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %14 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %14(%struct.op* %6) #4
  br label %Perl_newSVOP.exit

Perl_newSVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  %call51 = tail call i32 (i32, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, %struct.op*, ...)*)(i32 141, %struct.op* %attrs.0.ph154, %struct.op* %cond.i) #4
  %conv52 = sext i32 %call51 to i64
  %15 = inttoptr i64 %conv52 to %struct.op*
  %tobool1148 = icmp eq i64 %len.addr.2, 0
  br i1 %tobool1148, label %while.end, label %for.cond.preheader.lr.ph

while.end:                                        ; preds = %for.end, %Perl_newSVOP.exit, %land.rhs, %while.cond.preheader
  %attrs.0.ph.lcssa = phi %struct.op* [ null, %while.cond.preheader ], [ %attrs.0.ph154, %land.rhs ], [ %attrs.0.ph154, %for.end ], [ %15, %Perl_newSVOP.exit ]
  %call54 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8]* @.str23, i64 0, i64 0), i64 10) #4
  %call55 = tail call %struct.sv* @Perl_newSVpv(i8* %stashpv, i64 0) #4
  %call.i90 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i90, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i91 = getelementptr inbounds i8* %call.i90, i64 32
  %16 = bitcast i8* %op_type.i91 to i16*
  store i16 5, i16* %16, align 2, !tbaa !71
  %17 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i92 = getelementptr inbounds i8* %call.i90, i64 16
  %18 = bitcast i8* %op_ppaddr.i92 to %struct.op* ()**
  store %struct.op* ()* %17, %struct.op* ()** %18, align 8, !tbaa !72
  %op_sv.i93 = getelementptr inbounds i8* %call.i90, i64 40
  %19 = bitcast i8* %op_sv.i93 to %struct.sv**
  store %struct.sv* %call55, %struct.sv** %19, align 8, !tbaa !18
  %20 = bitcast i8* %call.i90 to %struct.op*
  %op_next.i94 = bitcast i8* %call.i90 to %struct.op**
  store %struct.op* %20, %struct.op** %op_next.i94, align 8, !tbaa !73
  %21 = getelementptr inbounds i8* %call.i90, i64 36
  store i8 0, i8* %21, align 1, !tbaa !74
  %22 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i95 = and i64 %22, 4
  %tobool.i96 = icmp eq i64 %and.i95, 0
  br i1 %tobool.i96, label %if.end.i102, label %if.then.i99

if.then.i99:                                      ; preds = %while.end
  %call3.i97 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %20) #4
  %.pre.i98 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i102

if.end.i102:                                      ; preds = %if.then.i99, %while.end
  %23 = phi i64 [ %22, %while.end ], [ %.pre.i98, %if.then.i99 ]
  %and5.i100 = and i64 %23, 8
  %tobool6.i101 = icmp eq i64 %and5.i100, 0
  br i1 %tobool6.i101, label %if.end10.i108, label %if.then7.i106

if.then7.i106:                                    ; preds = %if.end.i102
  %call8.i103 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i104 = sext i32 %call8.i103 to i64
  %op_targ.i105 = getelementptr inbounds i8* %call.i90, i64 24
  %24 = bitcast i8* %op_targ.i105 to i64*
  store i64 %conv9.i104, i64* %24, align 8, !tbaa !75
  br label %if.end10.i108

if.end10.i108:                                    ; preds = %if.then7.i106, %if.end.i102
  %25 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i107 = icmp eq i8* %25, null
  br i1 %tobool11.i107, label %cond.false.i114, label %land.lhs.true.i111

land.lhs.true.i111:                               ; preds = %if.end10.i108
  %arrayidx12.i109 = getelementptr inbounds i8* %25, i64 5
  %26 = load i8* %arrayidx12.i109, align 1, !tbaa !5
  %tobool14.i110 = icmp eq i8 %26, 0
  br i1 %tobool14.i110, label %cond.false.i114, label %cond.true.i112

cond.true.i112:                                   ; preds = %land.lhs.true.i111
  tail call void @Perl_op_free(%struct.op* %20) #4
  %27 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %27) #4
  br label %Perl_newSVOP.exit116

cond.false.i114:                                  ; preds = %land.lhs.true.i111, %if.end10.i108
  %28 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i113 = tail call %struct.op* %28(%struct.op* %20) #4
  br label %Perl_newSVOP.exit116

Perl_newSVOP.exit116:                             ; preds = %cond.true.i112, %cond.false.i114
  %cond.i115 = phi %struct.op* [ null, %cond.true.i112 ], [ %call17.i113, %cond.false.i114 ]
  %29 = bitcast %struct.cv* %cv to %struct.sv*
  %call57 = tail call %struct.sv* @Perl_newRV(%struct.sv* %29) #4
  %call.i117 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i117, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i118 = getelementptr inbounds i8* %call.i117, i64 32
  %30 = bitcast i8* %op_type.i118 to i16*
  store i16 5, i16* %30, align 2, !tbaa !71
  %31 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i119 = getelementptr inbounds i8* %call.i117, i64 16
  %32 = bitcast i8* %op_ppaddr.i119 to %struct.op* ()**
  store %struct.op* ()* %31, %struct.op* ()** %32, align 8, !tbaa !72
  %op_sv.i120 = getelementptr inbounds i8* %call.i117, i64 40
  %33 = bitcast i8* %op_sv.i120 to %struct.sv**
  store %struct.sv* %call57, %struct.sv** %33, align 8, !tbaa !18
  %34 = bitcast i8* %call.i117 to %struct.op*
  %op_next.i121 = bitcast i8* %call.i117 to %struct.op**
  store %struct.op* %34, %struct.op** %op_next.i121, align 8, !tbaa !73
  %35 = getelementptr inbounds i8* %call.i117, i64 36
  store i8 0, i8* %35, align 1, !tbaa !74
  %36 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i122 = and i64 %36, 4
  %tobool.i123 = icmp eq i64 %and.i122, 0
  br i1 %tobool.i123, label %if.end.i129, label %if.then.i126

if.then.i126:                                     ; preds = %Perl_newSVOP.exit116
  %call3.i124 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %34) #4
  %.pre.i125 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i129

if.end.i129:                                      ; preds = %if.then.i126, %Perl_newSVOP.exit116
  %37 = phi i64 [ %36, %Perl_newSVOP.exit116 ], [ %.pre.i125, %if.then.i126 ]
  %and5.i127 = and i64 %37, 8
  %tobool6.i128 = icmp eq i64 %and5.i127, 0
  br i1 %tobool6.i128, label %if.end10.i135, label %if.then7.i133

if.then7.i133:                                    ; preds = %if.end.i129
  %call8.i130 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i131 = sext i32 %call8.i130 to i64
  %op_targ.i132 = getelementptr inbounds i8* %call.i117, i64 24
  %38 = bitcast i8* %op_targ.i132 to i64*
  store i64 %conv9.i131, i64* %38, align 8, !tbaa !75
  br label %if.end10.i135

if.end10.i135:                                    ; preds = %if.then7.i133, %if.end.i129
  %39 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i134 = icmp eq i8* %39, null
  br i1 %tobool11.i134, label %cond.false.i141, label %land.lhs.true.i138

land.lhs.true.i138:                               ; preds = %if.end10.i135
  %arrayidx12.i136 = getelementptr inbounds i8* %39, i64 5
  %40 = load i8* %arrayidx12.i136, align 1, !tbaa !5
  %tobool14.i137 = icmp eq i8 %40, 0
  br i1 %tobool14.i137, label %cond.false.i141, label %cond.true.i139

cond.true.i139:                                   ; preds = %land.lhs.true.i138
  tail call void @Perl_op_free(%struct.op* %34) #4
  %41 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %41) #4
  br label %Perl_newSVOP.exit143

cond.false.i141:                                  ; preds = %land.lhs.true.i138, %if.end10.i135
  %42 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i140 = tail call %struct.op* %42(%struct.op* %34) #4
  br label %Perl_newSVOP.exit143

Perl_newSVOP.exit143:                             ; preds = %cond.true.i139, %cond.false.i141
  %cond.i142 = phi %struct.op* [ null, %cond.true.i139 ], [ %call17.i140, %cond.false.i141 ]
  %call59 = tail call i32 (i32, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @prepend_elem to i32 (i32, %struct.op*, %struct.op*, ...)*)(i32 141, %struct.op* %cond.i142, %struct.op* %attrs.0.ph.lcssa) #4
  %call60 = tail call i32 (i32, %struct.op*, i32, ...)* bitcast (i32 (...)* @prepend_elem to i32 (i32, %struct.op*, i32, ...)*)(i32 141, %struct.op* %cond.i115, i32 %call59) #4
  tail call void (i64, %struct.sv*, %struct.sv*, ...)* @Perl_load_module(i64 4, %struct.sv* %call54, %struct.sv* null, i32 %call60)
  ret void
}

declare i32 @append_elem(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newSVOP(i64 %type, i64 %flags, %struct.sv* %sv) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 48, i32 1, i1 false)
  %conv = trunc i64 %type to i16
  %op_type = getelementptr inbounds i8* %call, i64 32
  %0 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %0, align 2, !tbaa !71
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %type
  %1 = load %struct.op* ()** %arrayidx, align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %2 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %1, %struct.op* ()** %2, align 8, !tbaa !72
  %op_sv = getelementptr inbounds i8* %call, i64 40
  %3 = bitcast i8* %op_sv to %struct.sv**
  store %struct.sv* %sv, %struct.sv** %3, align 8, !tbaa !18
  %4 = bitcast i8* %call to %struct.op*
  %op_next = bitcast i8* %call to %struct.op**
  store %struct.op* %4, %struct.op** %op_next, align 8, !tbaa !73
  %conv1 = trunc i64 %flags to i8
  %5 = getelementptr inbounds i8* %call, i64 36
  store i8 %conv1, i8* %5, align 1, !tbaa !74
  %arrayidx2 = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %type
  %6 = load i64* %arrayidx2, align 8, !tbaa !1
  %and = and i64 %6, 4
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call3 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %4) #4
  %.pre = load i64* %arrayidx2, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %7 = phi i64 [ %6, %entry ], [ %.pre, %if.then ]
  %and5 = and i64 %7, 8
  %tobool6 = icmp eq i64 %and5, 0
  br i1 %tobool6, label %if.end10, label %if.then7

if.then7:                                         ; preds = %if.end
  %call8 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 %type, i32 512) #4
  %conv9 = sext i32 %call8 to i64
  %op_targ = getelementptr inbounds i8* %call, i64 24
  %8 = bitcast i8* %op_targ to i64*
  store i64 %conv9, i64* %8, align 8, !tbaa !75
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then7
  %9 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11 = icmp eq i8* %9, null
  br i1 %tobool11, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end10
  %arrayidx12 = getelementptr inbounds i8* %9, i64 %type
  %10 = load i8* %arrayidx12, align 1, !tbaa !5
  %tobool14 = icmp eq i8 %10, 0
  br i1 %tobool14, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  tail call void @Perl_op_free(%struct.op* %4)
  %arrayidx15 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %type
  %11 = load i8** %arrayidx15, align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %11) #4
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end10
  %arrayidx16 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %type
  %12 = load %struct.op* (%struct.op*)** %arrayidx16, align 8, !tbaa !6
  %call17 = tail call %struct.op* %12(%struct.op* %4) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call17, %cond.false ]
  ret %struct.op* %cond
}

declare %struct.sv* @Perl_newSVpvn(i8*, i64) #2

; Function Attrs: nounwind uwtable
define void @Perl_load_module(i64 %flags, %struct.sv* %name, %struct.sv* %ver, ...) #0 {
entry:
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %args to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  call void @Perl_vload_module(i64 %flags, %struct.sv* %name, %struct.sv* %ver, [1 x %struct.__va_list_tag]* %args)
  call void @llvm.va_end(i8* %arraydecay1)
  ret void
}

declare i32 @prepend_elem(...) #2

declare %struct.sv* @Perl_newSVpv(i8*, i64) #2

declare %struct.sv* @Perl_newRV(%struct.sv*) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_my_attrs(%struct.op* %o, %struct.op* %attrs) #0 {
entry:
  %rops = alloca %struct.op*, align 8
  store %struct.op* null, %struct.op** %rops, align 8, !tbaa !6
  %tobool = icmp eq %struct.op* %attrs, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @save_freeop to i32 (%struct.op*, ...)*)(%struct.op* %attrs) #4
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %call1 = call i32 (%struct.op*, %struct.op*, %struct.op**, ...)* bitcast (i32 (...)* @my_kid to i32 (%struct.op*, %struct.op*, %struct.op**, ...)*)(%struct.op* %o, %struct.op* %attrs, %struct.op** %rops) #4
  %conv = sext i32 %call1 to i64
  %0 = inttoptr i64 %conv to %struct.op*
  %1 = load %struct.op** %rops, align 8, !tbaa !6
  %tobool2 = icmp eq %struct.op* %1, null
  br i1 %tobool2, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %op_type = getelementptr inbounds %struct.op* %0, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %2, 9
  br i1 %cmp, label %if.then7, label %if.else

if.then7:                                         ; preds = %land.lhs.true
  %3 = bitcast %struct.op* %1 to %struct.listop*
  %4 = inttoptr i64 %conv to %struct.listop*
  %call8 = call i32 (i32, %struct.listop*, %struct.listop*, ...)* bitcast (i32 (...)* @append_list to i32 (i32, %struct.listop*, %struct.listop*, ...)*)(i32 141, %struct.listop* %3, %struct.listop* %4) #4
  %call9 = call i32 (i32, ...)* bitcast (i32 (...)* @scalar to i32 (i32, ...)*)(i32 %call8) #4
  %conv10 = sext i32 %call9 to i64
  %5 = inttoptr i64 %conv10 to %struct.op*
  %op_private = getelementptr inbounds %struct.op* %5, i64 0, i32 7
  %6 = load i8* %op_private, align 1, !tbaa !11
  %or = or i8 %6, -128
  store i8 %or, i8* %op_private, align 1, !tbaa !11
  br label %if.end16

if.else:                                          ; preds = %land.lhs.true
  %7 = inttoptr i64 %conv to %struct.listop*
  %8 = bitcast %struct.op* %1 to %struct.listop*
  %call13 = call i32 (i32, %struct.listop*, %struct.listop*, ...)* bitcast (i32 (...)* @append_list to i32 (i32, %struct.listop*, %struct.listop*, ...)*)(i32 141, %struct.listop* %7, %struct.listop* %8) #4
  %conv14 = sext i32 %call13 to i64
  %9 = inttoptr i64 %conv14 to %struct.op*
  br label %if.end16

if.end16:                                         ; preds = %if.end, %if.then7, %if.else
  %o.addr.0 = phi %struct.op* [ %5, %if.then7 ], [ %9, %if.else ], [ %0, %if.end ]
  store i64 0, i64* @PL_in_my, align 8, !tbaa !1
  store %struct.hv* null, %struct.hv** @PL_in_my_stash, align 8, !tbaa !6
  ret %struct.op* %o.addr.0
}

declare i32 @save_freeop(...) #2

declare i32 @my_kid(...) #2

declare i32 @append_list(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_my(%struct.op* %o) #0 {
entry:
  %call = tail call i32 (%struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @my_attrs to i32 (%struct.op*, %struct.op*, ...)*)(%struct.op* %o, %struct.op* null) #4
  %conv = sext i32 %call to i64
  %0 = inttoptr i64 %conv to %struct.op*
  ret %struct.op* %0
}

declare i32 @my_attrs(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_sawparens(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %or = or i8 %0, 8
  store i8 %or, i8* %op_flags, align 1, !tbaa !14
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret %struct.op* %o
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_bind_match(i64 %type, %struct.op* %left, %struct.op* %right) #0 {
entry:
  %0 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %0, i64 0, i32 14
  %1 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp = icmp eq %struct.sv* %1, null
  br i1 %cmp, label %lor.lhs.false7, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %2 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings1 = getelementptr inbounds %struct.cop* %2, i64 0, i32 14
  %3 = load %struct.sv** %cop_warnings1, align 8, !tbaa !47
  %cmp2 = icmp eq %struct.sv* %3, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp2, label %lor.lhs.false7, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings4 = getelementptr inbounds %struct.cop* %4, i64 0, i32 14
  %5 = load %struct.sv** %cop_warnings4, align 8, !tbaa !47
  %cmp5 = icmp eq %struct.sv* %5, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp5, label %land.lhs.true15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true3
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings6 = getelementptr inbounds %struct.cop* %6, i64 0, i32 14
  %7 = load %struct.sv** %cop_warnings6, align 8, !tbaa !47
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %8 to i8**
  %9 = load i8** %xpv_pv, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8* %9, i64 3
  %10 = load i8* %arrayidx, align 1, !tbaa !5
  %and = and i8 %10, 1
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false7, label %land.lhs.true15

lor.lhs.false7:                                   ; preds = %lor.lhs.false, %land.lhs.true, %entry
  %11 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings8 = getelementptr inbounds %struct.cop* %11, i64 0, i32 14
  %12 = load %struct.sv** %cop_warnings8, align 8, !tbaa !47
  %cmp9 = icmp eq %struct.sv* %12, null
  br i1 %cmp9, label %land.lhs.true11, label %if.end

land.lhs.true11:                                  ; preds = %lor.lhs.false7
  %13 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and13 = and i8 %13, 1
  %tobool14 = icmp eq i8 %and13, 0
  br i1 %tobool14, label %if.end, label %land.lhs.true15

land.lhs.true15:                                  ; preds = %lor.lhs.false, %land.lhs.true11, %land.lhs.true3
  %op_type = getelementptr inbounds %struct.op* %left, i64 0, i32 4
  %14 = load i16* %op_type, align 2, !tbaa !12
  switch i16 %14, label %if.end [
    i16 125, label %if.then
    i16 134, label %if.then
    i16 10, label %if.then
    i16 11, label %if.then
  ]

if.then:                                          ; preds = %land.lhs.true15, %land.lhs.true15, %land.lhs.true15, %land.lhs.true15
  %op_type34 = getelementptr inbounds %struct.op* %right, i64 0, i32 4
  %15 = load i16* %op_type34, align 2, !tbaa !12
  switch i16 %15, label %cond.end [
    i16 33, label %cond.true
    i16 35, label %cond.true
  ]

cond.true:                                        ; preds = %if.then, %if.then
  %phitmp = zext i16 %15 to i64
  br label %cond.end

cond.end:                                         ; preds = %if.then, %cond.true
  %cond = phi i64 [ %phitmp, %cond.true ], [ 31, %if.then ]
  %arrayidx45 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %cond
  %16 = load i8** %arrayidx45, align 8, !tbaa !6
  %cmp48 = icmp eq i16 %14, 125
  br i1 %cmp48, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end
  %cmp52 = icmp eq i16 %14, 10
  %phitmp169 = select i1 %cmp52, i8* getelementptr inbounds ([7 x i8]* @.str24, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8]* @.str25, i64 0, i64 0)
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end
  %17 = phi i8* [ getelementptr inbounds ([7 x i8]* @.str24, i64 0, i64 0), %cond.end ], [ %phitmp169, %lor.rhs ]
  tail call void (i64, i8*, ...)* @Perl_warner(i64 12, i8* getelementptr inbounds ([41 x i8]* @.str26, i64 0, i64 0), i8* %16, i8* %17, i8* %17) #4
  br label %if.end

if.end:                                           ; preds = %land.lhs.true15, %land.lhs.true11, %lor.end, %lor.lhs.false7
  %op_type55 = getelementptr inbounds %struct.op* %right, i64 0, i32 4
  %18 = load i16* %op_type55, align 2, !tbaa !12
  %cmp57 = icmp eq i16 %18, 5
  br i1 %cmp57, label %land.lhs.true59, label %if.end69

land.lhs.true59:                                  ; preds = %if.end
  %19 = getelementptr inbounds %struct.op* %right, i64 0, i32 7
  %20 = load i8* %19, align 1, !tbaa !33
  %21 = and i8 %20, 72
  %22 = icmp eq i8 %21, 72
  br i1 %22, label %if.then68, label %if.end69

if.then68:                                        ; preds = %land.lhs.true59
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @no_bareword_allowed to i32 (%struct.op*, ...)*)(%struct.op* %right) #4
  br label %if.end69

if.end69:                                         ; preds = %land.lhs.true59, %if.then68, %if.end
  %op_flags = getelementptr inbounds %struct.op* %right, i64 0, i32 6
  %23 = load i8* %op_flags, align 1, !tbaa !14
  %and71 = and i8 %23, 64
  %tobool72 = icmp eq i8 %and71, 0
  br i1 %tobool72, label %land.lhs.true73, label %if.else133

land.lhs.true73:                                  ; preds = %if.end69
  %24 = load i16* %op_type55, align 2, !tbaa !12
  switch i16 %24, label %if.else133 [
    i16 31, label %if.then88
    i16 33, label %if.then88
    i16 35, label %if.then88
  ]

if.then88:                                        ; preds = %land.lhs.true73, %land.lhs.true73, %land.lhs.true73
  %or = or i8 %23, 64
  store i8 %or, i8* %op_flags, align 1, !tbaa !14
  switch i16 %24, label %if.end111 [
    i16 31, label %if.else
    i16 35, label %land.lhs.true101
  ]

land.lhs.true101:                                 ; preds = %if.then88
  %op_private102 = getelementptr inbounds %struct.op* %right, i64 0, i32 7
  %25 = load i8* %op_private102, align 1, !tbaa !11
  %and104 = and i8 %25, 4
  %tobool105 = icmp eq i8 %and104, 0
  br i1 %tobool105, label %if.end111, label %if.then116

if.end111:                                        ; preds = %land.lhs.true101, %if.then88
  %conv108 = zext i16 %24 to i32
  %call109 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i32, ...)*)(%struct.op* %left, i32 %conv108) #4
  %conv110 = sext i32 %call109 to i64
  %26 = inttoptr i64 %conv110 to %struct.op*
  %.pr.pre = load i16* %op_type55, align 2, !tbaa !12
  %cmp114 = icmp eq i16 %.pr.pre, 35
  br i1 %cmp114, label %if.then116, label %if.else

if.then116:                                       ; preds = %land.lhs.true101, %if.end111
  %left.addr.0.ph175 = phi %struct.op* [ %26, %if.end111 ], [ %left, %land.lhs.true101 ]
  %call117 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %left.addr.0.ph175) #4
  %conv118 = sext i32 %call117 to i64
  %27 = inttoptr i64 %conv118 to %struct.op*
  %call119 = tail call %struct.op* @Perl_newBINOP(i64 0, i64 64, %struct.op* %27, %struct.op* %right)
  br label %if.end125

if.else:                                          ; preds = %if.then88, %if.end111
  %left.addr.0172 = phi %struct.op* [ %26, %if.end111 ], [ %left, %if.then88 ]
  %28 = phi i16 [ %.pr.pre, %if.end111 ], [ 31, %if.then88 ]
  %conv113 = zext i16 %28 to i32
  %call122 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %left.addr.0172) #4
  %call123 = tail call i32 (i32, i32, %struct.op*, ...)* bitcast (i32 (...)* @prepend_elem to i32 (i32, i32, %struct.op*, ...)*)(i32 %conv113, i32 %call122, %struct.op* %right) #4
  %conv124 = sext i32 %call123 to i64
  %29 = inttoptr i64 %conv124 to %struct.op*
  br label %if.end125

if.end125:                                        ; preds = %if.else, %if.then116
  %o.0 = phi %struct.op* [ %call119, %if.then116 ], [ %29, %if.else ]
  %cmp126 = icmp eq i64 %type, 96
  br i1 %cmp126, label %if.then128, label %return

if.then128:                                       ; preds = %if.end125
  %call129 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %o.0) #4
  %conv130 = sext i32 %call129 to i64
  %30 = inttoptr i64 %conv130 to %struct.op*
  %call131 = tail call %struct.op* @Perl_newUNOP(i64 96, i64 0, %struct.op* %30)
  br label %return

if.else133:                                       ; preds = %land.lhs.true73, %if.end69
  %call134 = tail call %struct.op* @Perl_newPMOP(i64 31, i64 0)
  %call135 = tail call i32 (%struct.op*, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @pmruntime to i32 (%struct.op*, %struct.op*, %struct.op*, ...)*)(%struct.op* %call134, %struct.op* %right, %struct.op* null) #4
  %call136 = tail call i32 (i64, %struct.op*, i32, ...)* bitcast (i32 (...)* @bind_match to i32 (i64, %struct.op*, i32, ...)*)(i64 %type, %struct.op* %left, i32 %call135) #4
  %conv137 = sext i32 %call136 to i64
  %31 = inttoptr i64 %conv137 to %struct.op*
  br label %return

return:                                           ; preds = %if.end125, %if.else133, %if.then128
  %retval.0 = phi %struct.op* [ %31, %if.else133 ], [ %call131, %if.then128 ], [ %o.0, %if.end125 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newBINOP(i64 %type, i64 %flags, %struct.op* %first, %struct.op* %last) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 56) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 56, i32 1, i1 false)
  %tobool = icmp eq %struct.op* %first, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call.i = tail call i8* @Perl_safesysmalloc(i64 40) #4
  %0 = bitcast i8* %call.i to %struct.op*
  call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 40, i32 1, i1 false)
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %2 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %1, %struct.op* ()** %2, align 8, !tbaa !41
  %3 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %3, align 1, !tbaa !14
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %0, %struct.op** %op_next.i, align 8, !tbaa !42
  %4 = getelementptr inbounds i8* %call.i, i64 37
  store i8 0, i8* %4, align 1, !tbaa !11
  %5 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 0), align 8, !tbaa !1
  %and.i = and i64 %5, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %call4.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %0) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 0), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then
  %6 = phi i64 [ %5, %if.then ], [ %.pre.i, %if.then.i ]
  %and6.i = and i64 %6, 8
  %tobool7.i = icmp eq i64 %and6.i, 0
  br i1 %tobool7.i, label %if.end11.i, label %if.then8.i

if.then8.i:                                       ; preds = %if.end.i
  %call9.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 0, i32 512) #4
  %conv10.i = sext i32 %call9.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %7 = bitcast i8* %op_targ.i to i64*
  store i64 %conv10.i, i64* %7, align 8, !tbaa !13
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then8.i, %if.end.i
  %8 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12.i = icmp eq i8* %8, null
  br i1 %tobool12.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end11.i
  %9 = load i8* %8, align 1, !tbaa !5
  %tobool15.i = icmp eq i8 %9, 0
  br i1 %tobool15.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %0) #4
  %10 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 0), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %10) #4
  br label %if.end

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end11.i
  %11 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 0), align 8, !tbaa !6
  %call18.i = tail call %struct.op* %11(%struct.op* %0) #4
  br label %if.end

if.end:                                           ; preds = %cond.false.i, %cond.true.i, %entry
  %first.addr.0 = phi %struct.op* [ %first, %entry ], [ null, %cond.true.i ], [ %call18.i, %cond.false.i ]
  %conv = trunc i64 %type to i16
  %op_type = getelementptr inbounds i8* %call, i64 32
  %12 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %12, align 2, !tbaa !76
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %type
  %13 = load %struct.op* ()** %arrayidx, align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %14 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %13, %struct.op* ()** %14, align 8, !tbaa !77
  %op_first = getelementptr inbounds i8* %call, i64 40
  %15 = bitcast i8* %op_first to %struct.op**
  store %struct.op* %first.addr.0, %struct.op** %15, align 8, !tbaa !43
  %or = or i64 %flags, 4
  %conv2 = trunc i64 %or to i8
  %16 = getelementptr inbounds i8* %call, i64 36
  store i8 %conv2, i8* %16, align 1, !tbaa !78
  %tobool3 = icmp eq %struct.op* %last, null
  %shr56 = lshr i64 %flags, 8
  br i1 %tobool3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %or5 = or i64 %shr56, 1
  %conv6 = trunc i64 %or5 to i8
  %17 = getelementptr inbounds i8* %call, i64 37
  store i8 %conv6, i8* %17, align 1, !tbaa !79
  br label %if.end11

if.else:                                          ; preds = %if.end
  %or8 = or i64 %shr56, 2
  %conv9 = trunc i64 %or8 to i8
  %18 = getelementptr inbounds i8* %call, i64 37
  store i8 %conv9, i8* %18, align 1, !tbaa !79
  %op_sibling = getelementptr inbounds %struct.op* %first.addr.0, i64 0, i32 1
  store %struct.op* %last, %struct.op** %op_sibling, align 8, !tbaa !17
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then4
  %19 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12 = icmp eq i8* %19, null
  br i1 %tobool12, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end11
  %arrayidx13 = getelementptr inbounds i8* %19, i64 %type
  %20 = load i8* %arrayidx13, align 1, !tbaa !5
  %tobool15 = icmp eq i8 %20, 0
  br i1 %tobool15, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  %21 = bitcast i8* %call to %struct.op*
  tail call void @Perl_op_free(%struct.op* %21)
  %arrayidx16 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %type
  %22 = load i8** %arrayidx16, align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %22) #4
  unreachable

cond.false:                                       ; preds = %land.lhs.true, %if.end11
  %arrayidx17 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %type
  %23 = load %struct.op* (%struct.op*)** %arrayidx17, align 8, !tbaa !6
  %24 = bitcast i8* %call to %struct.op*
  %call18 = tail call %struct.op* %23(%struct.op* %24) #4
  %op_next = getelementptr inbounds %struct.op* %call18, i64 0, i32 0
  %25 = load %struct.op** %op_next, align 8, !tbaa !80
  %tobool19 = icmp eq %struct.op* %25, null
  br i1 %tobool19, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %cond.false
  %26 = getelementptr inbounds %struct.op* %call18, i64 0, i32 4
  %27 = load i16* %26, align 2, !tbaa !76
  %cmp = icmp eq i16 %27, %conv
  br i1 %cmp, label %if.end26, label %return

if.end26:                                         ; preds = %lor.lhs.false
  %28 = getelementptr inbounds %struct.op* %call18, i64 1, i32 0
  %29 = load %struct.op** %28, align 8, !tbaa !43
  %op_sibling28 = getelementptr inbounds %struct.op* %29, i64 0, i32 1
  %30 = load %struct.op** %op_sibling28, align 8, !tbaa !17
  %31 = getelementptr inbounds %struct.op* %call18, i64 1, i32 1
  store %struct.op* %30, %struct.op** %31, align 8, !tbaa !81
  %call29 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @fold_constants to i32 (%struct.op*, ...)*)(%struct.op* %call18) #4
  %conv30 = sext i32 %call29 to i64
  %32 = inttoptr i64 %conv30 to %struct.op*
  br label %return

return:                                           ; preds = %cond.false, %lor.lhs.false, %if.end26
  %retval.0 = phi %struct.op* [ %32, %if.end26 ], [ %call18, %lor.lhs.false ], [ %call18, %cond.false ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newUNOP(i64 %type, i64 %flags, %struct.op* %first) #0 {
entry:
  %tobool = icmp eq %struct.op* %first, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call.i = tail call i8* @Perl_safesysmalloc(i64 40) #4
  %0 = bitcast i8* %call.i to %struct.op*
  tail call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 40, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i, i64 32
  %1 = bitcast i8* %op_type.i to i16*
  store i16 1, i16* %1, align 2, !tbaa !12
  %2 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 1), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %3 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %2, %struct.op* ()** %3, align 8, !tbaa !41
  %4 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %4, align 1, !tbaa !14
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %0, %struct.op** %op_next.i, align 8, !tbaa !42
  %5 = getelementptr inbounds i8* %call.i, i64 37
  store i8 0, i8* %5, align 1, !tbaa !11
  %6 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 1), align 8, !tbaa !1
  %and.i = and i64 %6, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %call4.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %0) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 1), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then
  %7 = phi i64 [ %6, %if.then ], [ %.pre.i, %if.then.i ]
  %and6.i = and i64 %7, 8
  %tobool7.i = icmp eq i64 %and6.i, 0
  br i1 %tobool7.i, label %if.end11.i, label %if.then8.i

if.then8.i:                                       ; preds = %if.end.i
  %call9.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 1, i32 512) #4
  %conv10.i = sext i32 %call9.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %8 = bitcast i8* %op_targ.i to i64*
  store i64 %conv10.i, i64* %8, align 8, !tbaa !13
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then8.i, %if.end.i
  %9 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12.i = icmp eq i8* %9, null
  br i1 %tobool12.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end11.i
  %arrayidx13.i = getelementptr inbounds i8* %9, i64 1
  %10 = load i8* %arrayidx13.i, align 1, !tbaa !5
  %tobool15.i = icmp eq i8 %10, 0
  br i1 %tobool15.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %0) #4
  %11 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 1), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %11) #4
  br label %if.end

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end11.i
  %12 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 1), align 8, !tbaa !6
  %call18.i = tail call %struct.op* %12(%struct.op* %0) #4
  br label %if.end

if.end:                                           ; preds = %cond.false.i, %cond.true.i, %entry
  %first.addr.0 = phi %struct.op* [ %first, %entry ], [ null, %cond.true.i ], [ %call18.i, %cond.false.i ]
  %arrayidx = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %type
  %13 = load i64* %arrayidx, align 8, !tbaa !1
  %and = and i64 %13, 1
  %tobool1 = icmp eq i64 %and, 0
  br i1 %tobool1, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %call3 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @force_list to i32 (%struct.op*, ...)*)(%struct.op* %first.addr.0) #4
  %conv = sext i32 %call3 to i64
  %14 = inttoptr i64 %conv to %struct.op*
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.then2
  %first.addr.1 = phi %struct.op* [ %14, %if.then2 ], [ %first.addr.0, %if.end ]
  %call5 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call5, i8 0, i64 48, i32 1, i1 false)
  %conv6 = trunc i64 %type to i16
  %op_type = getelementptr inbounds i8* %call5, i64 32
  %15 = bitcast i8* %op_type to i16*
  store i16 %conv6, i16* %15, align 2, !tbaa !56
  %arrayidx7 = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %type
  %16 = load %struct.op* ()** %arrayidx7, align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds i8* %call5, i64 16
  %17 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %16, %struct.op* ()** %17, align 8, !tbaa !57
  %op_first = getelementptr inbounds i8* %call5, i64 40
  %18 = bitcast i8* %op_first to %struct.op**
  store %struct.op* %first.addr.1, %struct.op** %18, align 8, !tbaa !15
  %or = or i64 %flags, 4
  %conv8 = trunc i64 %or to i8
  %19 = getelementptr inbounds i8* %call5, i64 36
  store i8 %conv8, i8* %19, align 1, !tbaa !82
  %shr40 = lshr i64 %flags, 8
  %or9 = or i64 %shr40, 1
  %conv10 = trunc i64 %or9 to i8
  %20 = getelementptr inbounds i8* %call5, i64 37
  store i8 %conv10, i8* %20, align 1, !tbaa !59
  %21 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11 = icmp eq i8* %21, null
  br i1 %tobool11, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end4
  %arrayidx12 = getelementptr inbounds i8* %21, i64 %type
  %22 = load i8* %arrayidx12, align 1, !tbaa !5
  %tobool14 = icmp eq i8 %22, 0
  br i1 %tobool14, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  %23 = bitcast i8* %call5 to %struct.op*
  tail call void @Perl_op_free(%struct.op* %23)
  %arrayidx15 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %type
  %24 = load i8** %arrayidx15, align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %24) #4
  unreachable

cond.false:                                       ; preds = %land.lhs.true, %if.end4
  %arrayidx16 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %type
  %25 = load %struct.op* (%struct.op*)** %arrayidx16, align 8, !tbaa !6
  %26 = bitcast i8* %call5 to %struct.op*
  %call17 = tail call %struct.op* %25(%struct.op* %26) #4
  %op_next = getelementptr inbounds %struct.op* %call17, i64 0, i32 0
  %27 = load %struct.op** %op_next, align 8, !tbaa !58
  %tobool18 = icmp eq %struct.op* %27, null
  br i1 %tobool18, label %if.end20, label %return

if.end20:                                         ; preds = %cond.false
  %call21 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @fold_constants to i32 (%struct.op*, ...)*)(%struct.op* %call17) #4
  %conv22 = sext i32 %call21 to i64
  %28 = inttoptr i64 %conv22 to %struct.op*
  br label %return

return:                                           ; preds = %cond.false, %if.end20
  %retval.0 = phi %struct.op* [ %28, %if.end20 ], [ %call17, %cond.false ]
  ret %struct.op* %retval.0
}

declare i32 @bind_match(...) #2

declare i32 @pmruntime(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newPMOP(i64 %type, i64 %flags) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 120) #4
  %0 = bitcast i8* %call to %struct.pmop*
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 120, i32 1, i1 false)
  %conv = trunc i64 %type to i16
  %op_type = getelementptr inbounds i8* %call, i64 32
  %1 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %1, align 2, !tbaa !83
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %type
  %2 = load %struct.op* ()** %arrayidx, align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %3 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %2, %struct.op* ()** %3, align 8, !tbaa !84
  %conv1 = trunc i64 %flags to i8
  %4 = getelementptr inbounds i8* %call, i64 36
  store i8 %conv1, i8* %4, align 1, !tbaa !85
  %shr44 = lshr i64 %flags, 8
  %conv2 = trunc i64 %shr44 to i8
  %5 = getelementptr inbounds i8* %call, i64 37
  store i8 %conv2, i8* %5, align 1, !tbaa !86
  %6 = load i64* @PL_hints, align 8, !tbaa !1
  %and = and i64 %6, 1048576
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %op_pmpermflags = getelementptr inbounds i8* %call, i64 96
  %7 = bitcast i8* %op_pmpermflags to i64*
  store i64 1, i64* %7, align 8, !tbaa !87
  %.pre = load i64* @PL_hints, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %8 = phi i64 [ 0, %entry ], [ 1, %if.then ]
  %9 = phi i64 [ %6, %entry ], [ %.pre, %if.then ]
  %and4 = and i64 %9, 4
  %tobool5 = icmp eq i64 %and4, 0
  br i1 %tobool5, label %if.end9, label %if.then6

if.then6:                                         ; preds = %if.end
  %op_pmpermflags7 = getelementptr inbounds i8* %call, i64 96
  %10 = bitcast i8* %op_pmpermflags7 to i64*
  %or8 = or i64 %8, 2048
  store i64 %or8, i64* %10, align 8, !tbaa !87
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then6
  %11 = phi i64 [ %or8, %if.then6 ], [ %8, %if.end ]
  %op_pmflags = getelementptr inbounds i8* %call, i64 88
  %12 = bitcast i8* %op_pmflags to i64*
  store i64 %11, i64* %12, align 8, !tbaa !88
  %cmp = icmp ne i64 %type, 35
  %13 = load %struct.hv** @PL_curstash, align 8
  %tobool12 = icmp ne %struct.hv* %13, null
  %or.cond = and i1 %cmp, %tobool12
  br i1 %or.cond, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.end9
  %sv_any = getelementptr inbounds %struct.hv* %13, i64 0, i32 0
  %14 = load %struct.xpvhv** %sv_any, align 8, !tbaa !26
  %xhv_pmroot = getelementptr inbounds %struct.xpvhv* %14, i64 0, i32 9
  %15 = load %struct.pmop** %xhv_pmroot, align 8, !tbaa !28
  %op_pmnext = getelementptr inbounds i8* %call, i64 72
  %16 = bitcast i8* %op_pmnext to %struct.pmop**
  store %struct.pmop* %15, %struct.pmop** %16, align 8, !tbaa !27
  %17 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  %sv_any14 = getelementptr inbounds %struct.hv* %17, i64 0, i32 0
  %18 = load %struct.xpvhv** %sv_any14, align 8, !tbaa !26
  %xhv_pmroot15 = getelementptr inbounds %struct.xpvhv* %18, i64 0, i32 9
  store %struct.pmop* %0, %struct.pmop** %xhv_pmroot15, align 8, !tbaa !28
  %19 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  %op_pmstash = getelementptr inbounds i8* %call, i64 112
  %20 = bitcast i8* %op_pmstash to %struct.hv**
  store %struct.hv* %19, %struct.hv** %20, align 8, !tbaa !22
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %if.end9
  %21 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool17 = icmp eq i8* %21, null
  br i1 %tobool17, label %cond.false, label %land.lhs.true18

land.lhs.true18:                                  ; preds = %if.end16
  %arrayidx19 = getelementptr inbounds i8* %21, i64 %type
  %22 = load i8* %arrayidx19, align 1, !tbaa !5
  %tobool21 = icmp eq i8 %22, 0
  br i1 %tobool21, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true18
  %23 = bitcast i8* %call to %struct.op*
  tail call void @Perl_op_free(%struct.op* %23)
  %arrayidx22 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %type
  %24 = load i8** %arrayidx22, align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %24) #4
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true18, %if.end16
  %arrayidx23 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %type
  %25 = load %struct.op* (%struct.op*)** %arrayidx23, align 8, !tbaa !6
  %26 = bitcast i8* %call to %struct.op*
  %call24 = tail call %struct.op* %25(%struct.op* %26) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call24, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_invert(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv = sext i32 %call to i64
  %0 = inttoptr i64 %conv to %struct.op*
  %call1 = tail call %struct.op* @Perl_newUNOP(i64 96, i64 128, %struct.op* %0)
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi %struct.op* [ %call1, %if.end ], [ null, %entry ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_scope(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end31, label %if.then

if.then:                                          ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 8
  %tobool1 = icmp eq i8 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %if.then8

lor.lhs.false:                                    ; preds = %if.then
  %1 = load i64* @PL_perldb, align 8, !tbaa !1
  %and3 = and i64 %1, 4
  %tobool4 = icmp eq i64 %and3, 0
  %2 = load i8* @PL_tainting, align 1
  %tobool7 = icmp eq i8 %2, 0
  %or.cond43 = and i1 %tobool4, %tobool7
  br i1 %or.cond43, label %if.else, label %if.then8

if.then8:                                         ; preds = %lor.lhs.false, %if.then
  %call.i = tail call i8* @Perl_safesysmalloc(i64 40) #4
  %3 = bitcast i8* %call.i to %struct.op*
  tail call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 40, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i, i64 32
  %4 = bitcast i8* %op_type.i to i16*
  store i16 177, i16* %4, align 2, !tbaa !12
  %5 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 177), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %6 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %5, %struct.op* ()** %6, align 8, !tbaa !41
  %7 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %7, align 1, !tbaa !14
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %3, %struct.op** %op_next.i, align 8, !tbaa !42
  %8 = getelementptr inbounds i8* %call.i, i64 37
  store i8 0, i8* %8, align 1, !tbaa !11
  %9 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 177), align 8, !tbaa !1
  %and.i = and i64 %9, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %if.then8
  %call4.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %3) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 177), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then8
  %10 = phi i64 [ %9, %if.then8 ], [ %.pre.i, %if.then.i ]
  %and6.i = and i64 %10, 8
  %tobool7.i = icmp eq i64 %and6.i, 0
  br i1 %tobool7.i, label %if.end11.i, label %if.then8.i

if.then8.i:                                       ; preds = %if.end.i
  %call9.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 177, i32 512) #4
  %conv10.i = sext i32 %call9.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %11 = bitcast i8* %op_targ.i to i64*
  store i64 %conv10.i, i64* %11, align 8, !tbaa !13
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then8.i, %if.end.i
  %12 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12.i = icmp eq i8* %12, null
  br i1 %tobool12.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end11.i
  %arrayidx13.i = getelementptr inbounds i8* %12, i64 177
  %13 = load i8* %arrayidx13.i, align 1, !tbaa !5
  %tobool15.i = icmp eq i8 %13, 0
  br i1 %tobool15.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %3) #4
  %14 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 177), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %14) #4
  br label %Perl_newOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end11.i
  %15 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 177), align 8, !tbaa !6
  %call18.i = tail call %struct.op* %15(%struct.op* %3) #4
  br label %Perl_newOP.exit

Perl_newOP.exit:                                  ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call18.i, %cond.false.i ]
  %call9 = tail call i32 (i32, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @prepend_elem to i32 (i32, %struct.op*, %struct.op*, ...)*)(i32 173, %struct.op* %cond.i, %struct.op* %o) #4
  %conv10 = sext i32 %call9 to i64
  %16 = inttoptr i64 %conv10 to %struct.op*
  %op_type = getelementptr inbounds %struct.op* %16, i64 0, i32 4
  store i16 178, i16* %op_type, align 2, !tbaa !12
  %17 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 178), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %16, i64 0, i32 2
  store %struct.op* ()* %17, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  br label %if.end31

if.else:                                          ; preds = %lor.lhs.false
  %op_type11 = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %18 = load i16* %op_type11, align 2, !tbaa !12
  %cmp = icmp eq i16 %18, 173
  br i1 %cmp, label %if.then14, label %if.else27

if.then14:                                        ; preds = %if.else
  store i16 179, i16* %op_type11, align 2, !tbaa !12
  %19 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 179), align 8, !tbaa !6
  %op_ppaddr16 = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %19, %struct.op* ()** %op_ppaddr16, align 8, !tbaa !41
  %20 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %21 = load %struct.op** %20, align 8, !tbaa !45
  %op_type17 = getelementptr inbounds %struct.op* %21, i64 0, i32 4
  %22 = load i16* %op_type17, align 2, !tbaa !12
  %23 = and i16 %22, -2
  %switch = icmp eq i16 %23, 174
  br i1 %switch, label %Perl_op_null.exit, label %if.end31

Perl_op_null.exit:                                ; preds = %if.then14
  %call.i45 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %21) #4
  %24 = load i16* %op_type17, align 2, !tbaa !12
  %conv3.i = zext i16 %24 to i64
  %op_targ.i46 = getelementptr inbounds %struct.op* %21, i64 0, i32 3
  store i64 %conv3.i, i64* %op_targ.i46, align 8, !tbaa !13
  store i16 0, i16* %op_type17, align 2, !tbaa !12
  %25 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i47 = getelementptr inbounds %struct.op* %21, i64 0, i32 2
  store %struct.op* ()* %25, %struct.op* ()** %op_ppaddr.i47, align 8, !tbaa !41
  br label %if.end31

if.else27:                                        ; preds = %if.else
  %call.i49 = tail call i8* @Perl_safesysmalloc(i64 56) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i49, i8 0, i64 56, i32 1, i1 false) #4
  %op_type.i50 = getelementptr inbounds i8* %call.i49, i64 32
  %26 = bitcast i8* %op_type.i50 to i16*
  store i16 179, i16* %26, align 2, !tbaa !89
  %27 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 179), align 8, !tbaa !6
  %op_ppaddr.i51 = getelementptr inbounds i8* %call.i49, i64 16
  %28 = bitcast i8* %op_ppaddr.i51 to %struct.op* ()**
  store %struct.op* ()* %27, %struct.op* ()** %28, align 8, !tbaa !90
  %29 = getelementptr inbounds i8* %call.i49, i64 36
  store i8 4, i8* %29, align 1, !tbaa !91
  %op_first.i = getelementptr inbounds i8* %call.i49, i64 40
  %30 = bitcast i8* %op_first.i to %struct.op**
  store %struct.op* %o, %struct.op** %30, align 8, !tbaa !45
  %op_last.i = getelementptr inbounds i8* %call.i49, i64 48
  %31 = bitcast i8* %op_last.i to %struct.op**
  store %struct.op* %o, %struct.op** %31, align 8, !tbaa !70
  %32 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool30.i = icmp eq i8* %32, null
  br i1 %tobool30.i, label %cond.false.i54, label %land.lhs.true31.i

land.lhs.true31.i:                                ; preds = %if.else27
  %arrayidx32.i = getelementptr inbounds i8* %32, i64 179
  %33 = load i8* %arrayidx32.i, align 1, !tbaa !5
  %tobool34.i = icmp eq i8 %33, 0
  br i1 %tobool34.i, label %cond.false.i54, label %cond.true.i53

cond.true.i53:                                    ; preds = %land.lhs.true31.i
  %34 = bitcast i8* %call.i49 to %struct.op*
  tail call void @Perl_op_free(%struct.op* %34) #4
  %35 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 179), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %35) #4
  br label %if.end31

cond.false.i54:                                   ; preds = %land.lhs.true31.i, %if.else27
  %36 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 179), align 8, !tbaa !6
  %37 = bitcast i8* %call.i49 to %struct.op*
  %call37.i = tail call %struct.op* %36(%struct.op* %37) #4
  br label %if.end31

if.end31:                                         ; preds = %cond.false.i54, %cond.true.i53, %if.then14, %entry, %Perl_newOP.exit, %Perl_op_null.exit
  %o.addr.0 = phi %struct.op* [ %16, %Perl_newOP.exit ], [ %o, %Perl_op_null.exit ], [ null, %entry ], [ %o, %if.then14 ], [ null, %cond.true.i53 ], [ %call37.i, %cond.false.i54 ]
  ret %struct.op* %o.addr.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newLISTOP(i64 %type, i64 %flags, %struct.op* %first, %struct.op* %last) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 56) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 56, i32 1, i1 false)
  %conv = trunc i64 %type to i16
  %op_type = getelementptr inbounds i8* %call, i64 32
  %0 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %0, align 2, !tbaa !89
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %type
  %1 = load %struct.op* ()** %arrayidx, align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %2 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %1, %struct.op* ()** %2, align 8, !tbaa !90
  %tobool = icmp ne %struct.op* %first, null
  %tobool1 = icmp ne %struct.op* %last, null
  %or.cond = or i1 %tobool, %tobool1
  %or = or i64 %flags, 4
  %or.flags = select i1 %or.cond, i64 %or, i64 %flags
  %conv2 = trunc i64 %or.flags to i8
  %3 = getelementptr inbounds i8* %call, i64 36
  store i8 %conv2, i8* %3, align 1, !tbaa !91
  %tobool3 = icmp eq %struct.op* %last, null
  %or.cond38 = and i1 %tobool3, %tobool
  br i1 %or.cond38, label %if.end15, label %if.else

if.else:                                          ; preds = %entry
  %tobool6 = icmp eq %struct.op* %first, null
  %or.cond39 = and i1 %tobool6, %tobool1
  %tobool.not = xor i1 %tobool, true
  %brmerge = or i1 %or.cond39, %tobool.not
  %last.mux = select i1 %or.cond39, %struct.op* %last, %struct.op* %first
  br i1 %brmerge, label %if.end15, label %if.then12

if.then12:                                        ; preds = %if.else
  %op_sibling = getelementptr inbounds %struct.op* %first, i64 0, i32 1
  store %struct.op* %last, %struct.op** %op_sibling, align 8, !tbaa !17
  br label %if.end15

if.end15:                                         ; preds = %if.else, %entry, %if.then12
  %last.addr.0 = phi %struct.op* [ %last, %if.then12 ], [ %first, %entry ], [ %last, %if.else ]
  %first.addr.0 = phi %struct.op* [ %first, %if.then12 ], [ %first, %entry ], [ %last.mux, %if.else ]
  %op_first = getelementptr inbounds i8* %call, i64 40
  %4 = bitcast i8* %op_first to %struct.op**
  store %struct.op* %first.addr.0, %struct.op** %4, align 8, !tbaa !45
  %op_last = getelementptr inbounds i8* %call, i64 48
  %5 = bitcast i8* %op_last to %struct.op**
  store %struct.op* %last.addr.0, %struct.op** %5, align 8, !tbaa !70
  %cmp = icmp eq i64 %type, 141
  br i1 %cmp, label %if.then17, label %if.end29

if.then17:                                        ; preds = %if.end15
  %call.i = tail call i8* @Perl_safesysmalloc(i64 40) #4
  %6 = bitcast i8* %call.i to %struct.op*
  tail call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 40, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i, i64 32
  %7 = bitcast i8* %op_type.i to i16*
  store i16 3, i16* %7, align 2, !tbaa !12
  %8 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 3), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %9 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %8, %struct.op* ()** %9, align 8, !tbaa !41
  %10 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %10, align 1, !tbaa !14
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %6, %struct.op** %op_next.i, align 8, !tbaa !42
  %11 = getelementptr inbounds i8* %call.i, i64 37
  store i8 0, i8* %11, align 1, !tbaa !11
  %12 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 3), align 8, !tbaa !1
  %and.i = and i64 %12, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %if.then17
  %call4.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %6) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 3), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then17
  %13 = phi i64 [ %12, %if.then17 ], [ %.pre.i, %if.then.i ]
  %and6.i = and i64 %13, 8
  %tobool7.i = icmp eq i64 %and6.i, 0
  br i1 %tobool7.i, label %if.end11.i, label %if.then8.i

if.then8.i:                                       ; preds = %if.end.i
  %call9.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 3, i32 512) #4
  %conv10.i = sext i32 %call9.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %14 = bitcast i8* %op_targ.i to i64*
  store i64 %conv10.i, i64* %14, align 8, !tbaa !13
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then8.i, %if.end.i
  %15 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12.i = icmp eq i8* %15, null
  br i1 %tobool12.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end11.i
  %arrayidx13.i = getelementptr inbounds i8* %15, i64 3
  %16 = load i8* %arrayidx13.i, align 1, !tbaa !5
  %tobool15.i = icmp eq i8 %16, 0
  br i1 %tobool15.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %6) #4
  %17 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 3), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %17) #4
  br label %Perl_newOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end11.i
  %18 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 3), align 8, !tbaa !6
  %call18.i = tail call %struct.op* %18(%struct.op* %6) #4
  br label %Perl_newOP.exit

Perl_newOP.exit:                                  ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call18.i, %cond.false.i ]
  %op_sibling19 = getelementptr inbounds %struct.op* %cond.i, i64 0, i32 1
  store %struct.op* %first.addr.0, %struct.op** %op_sibling19, align 8, !tbaa !17
  store %struct.op* %cond.i, %struct.op** %4, align 8, !tbaa !45
  %19 = load i8* %3, align 1, !tbaa !91
  %or23 = or i8 %19, 4
  store i8 %or23, i8* %3, align 1, !tbaa !91
  %tobool25 = icmp eq %struct.op* %last.addr.0, null
  br i1 %tobool25, label %if.then26, label %if.end29

if.then26:                                        ; preds = %Perl_newOP.exit
  store %struct.op* %cond.i, %struct.op** %5, align 8, !tbaa !70
  br label %if.end29

if.end29:                                         ; preds = %Perl_newOP.exit, %if.then26, %if.end15
  %20 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool30 = icmp eq i8* %20, null
  br i1 %tobool30, label %cond.false, label %land.lhs.true31

land.lhs.true31:                                  ; preds = %if.end29
  %arrayidx32 = getelementptr inbounds i8* %20, i64 %type
  %21 = load i8* %arrayidx32, align 1, !tbaa !5
  %tobool34 = icmp eq i8 %21, 0
  br i1 %tobool34, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true31
  %22 = bitcast i8* %call to %struct.op*
  tail call void @Perl_op_free(%struct.op* %22)
  %arrayidx35 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %type
  %23 = load i8** %arrayidx35, align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %23) #4
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true31, %if.end29
  %arrayidx36 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %type
  %24 = load %struct.op* (%struct.op*)** %arrayidx36, align 8, !tbaa !6
  %25 = bitcast i8* %call to %struct.op*
  %call37 = tail call %struct.op* %24(%struct.op* %25) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call37, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind uwtable
define void @Perl_save_hints() #0 {
entry:
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([54 x i8]* @.str27, i64 0, i64 0)) #4
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @Perl_block_start(i32 %full) #0 {
entry:
  %0 = load i64* @PL_savestack_ix, align 8, !tbaa !1
  %conv = trunc i64 %0 to i32
  %1 = load i32* @PL_yynerrs, align 4, !tbaa !92
  %tobool = icmp eq i32 %1, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call = tail call i32 (i32, ...)* bitcast (i32 (...)* @pad_block_start to i32 (i32, ...)*)(i32 %full) #4
  %2 = load i64* @PL_savestack_ix, align 8, !tbaa !1
  %add = add nsw i64 %2, 3
  %3 = load i64* @PL_savestack_max, align 8, !tbaa !1
  %cmp = icmp sgt i64 %add, %3
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  tail call void @Perl_savestack_grow() #4
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %4 = load i64* @PL_hints, align 8, !tbaa !1
  %and = and i64 %4, 131072
  %tobool5 = icmp eq i64 %and, 0
  br i1 %tobool5, label %if.end14, label %if.then6

if.then6:                                         ; preds = %if.end4
  %5 = load %struct.gv** @PL_hintgv, align 8, !tbaa !6
  %sv_any = getelementptr inbounds %struct.gv* %5, i64 0, i32 0
  %6 = load %struct.xpvgv** %sv_any, align 8, !tbaa !60
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %6, i64 0, i32 7
  %7 = load %struct.gp** %xgv_gp, align 8, !tbaa !62
  %gp_hv = getelementptr inbounds %struct.gp* %7, i64 0, i32 5
  %8 = load %struct.hv** %gp_hv, align 8, !tbaa !94
  %9 = bitcast %struct.hv* %8 to i8*
  %10 = load i64* @PL_savestack_ix, align 8, !tbaa !1
  %inc = add nsw i64 %10, 1
  store i64 %inc, i64* @PL_savestack_ix, align 8, !tbaa !1
  %11 = load %union.any** @PL_savestack, align 8, !tbaa !6
  %any_ptr = getelementptr inbounds %union.any* %11, i64 %10, i32 0
  store i8* %9, i8** %any_ptr, align 8, !tbaa !6
  %12 = load %struct.gv** @PL_hintgv, align 8, !tbaa !6
  %sv_any7 = getelementptr inbounds %struct.gv* %12, i64 0, i32 0
  %13 = load %struct.xpvgv** %sv_any7, align 8, !tbaa !60
  %xgv_gp8 = getelementptr inbounds %struct.xpvgv* %13, i64 0, i32 7
  %14 = load %struct.gp** %xgv_gp8, align 8, !tbaa !62
  %gp_hv9 = getelementptr inbounds %struct.gp* %14, i64 0, i32 5
  %15 = load %struct.hv** %gp_hv9, align 8, !tbaa !94
  %call10 = tail call %struct.hv* @Perl_newHVhv(%struct.hv* %15) #4
  %16 = load %struct.gv** @PL_hintgv, align 8, !tbaa !6
  %sv_any11 = getelementptr inbounds %struct.gv* %16, i64 0, i32 0
  %17 = load %struct.xpvgv** %sv_any11, align 8, !tbaa !60
  %xgv_gp12 = getelementptr inbounds %struct.xpvgv* %17, i64 0, i32 7
  %18 = load %struct.gp** %xgv_gp12, align 8, !tbaa !62
  %gp_hv13 = getelementptr inbounds %struct.gp* %18, i64 0, i32 5
  store %struct.hv* %call10, %struct.hv** %gp_hv13, align 8, !tbaa !94
  %.pre = load i64* @PL_hints, align 8, !tbaa !1
  br label %if.end14

if.end14:                                         ; preds = %if.end4, %if.then6
  %19 = phi i64 [ %4, %if.end4 ], [ %.pre, %if.then6 ]
  %20 = load i64* @PL_savestack_ix, align 8, !tbaa !1
  %inc15 = add nsw i64 %20, 1
  store i64 %inc15, i64* @PL_savestack_ix, align 8, !tbaa !1
  %21 = load %union.any** @PL_savestack, align 8, !tbaa !6
  %22 = getelementptr inbounds %union.any* %21, i64 %20, i32 0
  %.c = inttoptr i64 %19 to i8*
  store i8* %.c, i8** %22, align 8, !tbaa !1
  %23 = load i64* @PL_savestack_ix, align 8, !tbaa !1
  %inc17 = add nsw i64 %23, 1
  store i64 %inc17, i64* @PL_savestack_ix, align 8, !tbaa !1
  %24 = getelementptr inbounds %union.any* %21, i64 %23, i32 0
  store i8* inttoptr (i64 27 to i8*), i8** %24, align 8, !tbaa !1
  %25 = load i64* @PL_hints, align 8, !tbaa !1
  %and20 = and i64 %25, -257
  store i64 %and20, i64* @PL_hints, align 8, !tbaa !1
  tail call void @Perl_save_sptr(%struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14)) #4
  %26 = load %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !47
  %magicptr = ptrtoint %struct.sv* %26 to i64
  switch i64 %magicptr, label %if.then28 [
    i64 48, label %if.end30
    i64 24, label %if.end30
    i64 0, label %if.end30
  ]

if.then28:                                        ; preds = %if.end14
  %call29 = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %26) #4
  store %struct.sv* %call29, %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !47
  tail call void @Perl_save_freesv(%struct.sv* %call29) #4
  br label %if.end30

if.end30:                                         ; preds = %if.end14, %if.end14, %if.end14, %if.then28
  tail call void @Perl_save_sptr(%struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 15)) #4
  %27 = load %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 15), align 8, !tbaa !95
  %cmp31 = icmp eq %struct.sv* %27, null
  br i1 %cmp31, label %return, label %if.then33

if.then33:                                        ; preds = %if.end30
  %call34 = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %27) #4
  store %struct.sv* %call34, %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 15), align 8, !tbaa !95
  tail call void @Perl_save_freesv(%struct.sv* %call34) #4
  br label %return

return:                                           ; preds = %if.end30, %if.then33, %entry
  ret i32 %conv
}

declare i32 @pad_block_start(...) #2

declare void @Perl_savestack_grow() #2

declare %struct.hv* @Perl_newHVhv(%struct.hv*) #2

declare void @Perl_save_sptr(%struct.sv**) #2

declare %struct.sv* @Perl_newSVsv(%struct.sv*) #2

declare void @Perl_save_freesv(%struct.sv*) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_block_end(i64 %floor, %struct.op* %seq) #0 {
entry:
  %0 = load i64* @PL_hints, align 8, !tbaa !1
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarseq to i32 (%struct.op*, ...)*)(%struct.op* %seq) #4
  %conv2 = sext i32 %call to i64
  %1 = inttoptr i64 %conv2 to %struct.op*
  %2 = load i32* @PL_yynerrs, align 4, !tbaa !92
  %tobool = icmp eq i32 %2, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %3 = load i64* @PL_savestack_ix, align 8, !tbaa !1
  %cmp = icmp sgt i64 %3, %floor
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  tail call void @Perl_leave_scope(i64 %floor) #4
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %4 = load i64* @PL_hints, align 8, !tbaa !1
  %conv7 = trunc i64 %4 to i8
  store i8 %conv7, i8* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 7), align 1, !tbaa !96
  %conv = and i64 %0, 256
  %tobool8 = icmp eq i64 %conv, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end5
  %or = or i64 %4, 256
  store i64 %or, i64* @PL_hints, align 8, !tbaa !1
  br label %if.end10

if.end10:                                         ; preds = %if.end5, %if.then9
  %call11 = tail call i32 (...)* @pad_leavemy() #4
  br label %return

return:                                           ; preds = %entry, %if.end10
  ret %struct.op* %1
}

declare i32 @scalarseq(...) #2

declare void @Perl_leave_scope(i64) #2

declare i32 @pad_leavemy(...) #2

; Function Attrs: nounwind uwtable
define void @Perl_newPROG(%struct.op* %o) #0 {
entry:
  %0 = load volatile i32* @PL_in_eval, align 4, !tbaa !92
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.op** @PL_eval_root, align 8, !tbaa !6
  %tobool1 = icmp eq %struct.op* %1, null
  br i1 %tobool1, label %if.end, label %if.end53

if.end:                                           ; preds = %if.then
  %2 = load volatile i32* @PL_in_eval, align 4, !tbaa !92
  %and = shl i32 %2, 5
  %3 = and i32 %and, 128
  %conv63 = zext i32 %3 to i64
  %call = tail call %struct.op* @Perl_newUNOP(i64 312, i64 %conv63, %struct.op* %o)
  store %struct.op* %call, %struct.op** @PL_eval_root, align 8, !tbaa !6
  %call4 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %call) #4
  %conv5 = sext i32 %call4 to i64
  %4 = inttoptr i64 %conv5 to %struct.op*
  store %struct.op* %4, %struct.op** @PL_eval_start, align 8, !tbaa !6
  %5 = load %struct.op** @PL_eval_root, align 8, !tbaa !6
  %op_private = getelementptr inbounds %struct.op* %5, i64 0, i32 7
  %6 = load i8* %op_private, align 1, !tbaa !11
  %or = or i8 %6, 64
  store i8 %or, i8* %op_private, align 1, !tbaa !11
  %op_targ = getelementptr inbounds %struct.op* %5, i64 0, i32 3
  store i64 1, i64* %op_targ, align 8, !tbaa !13
  %op_next = getelementptr inbounds %struct.op* %5, i64 0, i32 0
  store %struct.op* null, %struct.op** %op_next, align 8, !tbaa !42
  %7 = load void (%struct.op*)** @PL_peepp, align 8, !tbaa !6
  %8 = load %struct.op** @PL_eval_start, align 8, !tbaa !6
  tail call void %7(%struct.op* %8) #4
  br label %if.end53

if.else:                                          ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %9 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %9, 1
  br i1 %cmp, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.else
  store %struct.av* null, %struct.av** @PL_comppad_name, align 8, !tbaa !6
  store %struct.cv* null, %struct.cv** @PL_compcv, align 8, !tbaa !6
  %10 = bitcast %struct.op* %o to i8*
  tail call void @Perl_safesysfree(i8* %10) #4
  br label %if.end53

if.end11:                                         ; preds = %if.else
  %call12 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarvoid to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %call13 = tail call i32 (i32, ...)* bitcast (i32 (...)* @sawparens to i32 (i32, ...)*)(i32 %call12) #4
  %call14 = tail call i32 (i32, ...)* bitcast (i32 (...)* @scope to i32 (i32, ...)*)(i32 %call13) #4
  %conv15 = sext i32 %call14 to i64
  %11 = inttoptr i64 %conv15 to %struct.op*
  store %struct.op* %11, %struct.op** @PL_main_root, align 8, !tbaa !6
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !6
  %op_next16 = getelementptr inbounds %struct.op* %11, i64 0, i32 0
  %12 = load %struct.op** %op_next16, align 8, !tbaa !42
  %tobool17 = icmp eq %struct.op* %12, null
  br i1 %tobool17, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.end11
  %call19 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %11) #4
  %conv20 = sext i32 %call19 to i64
  %13 = inttoptr i64 %conv20 to %struct.op*
  br label %cond.end

cond.end:                                         ; preds = %if.end11, %cond.false
  %cond21 = phi %struct.op* [ %13, %cond.false ], [ %12, %if.end11 ]
  store %struct.op* %cond21, %struct.op** @PL_main_start, align 8, !tbaa !6
  %14 = load %struct.op** @PL_main_root, align 8, !tbaa !6
  %op_private22 = getelementptr inbounds %struct.op* %14, i64 0, i32 7
  %15 = load i8* %op_private22, align 1, !tbaa !11
  %or24 = or i8 %15, 64
  store i8 %or24, i8* %op_private22, align 1, !tbaa !11
  %op_targ26 = getelementptr inbounds %struct.op* %14, i64 0, i32 3
  store i64 1, i64* %op_targ26, align 8, !tbaa !13
  %op_next27 = getelementptr inbounds %struct.op* %14, i64 0, i32 0
  store %struct.op* null, %struct.op** %op_next27, align 8, !tbaa !42
  %16 = load void (%struct.op*)** @PL_peepp, align 8, !tbaa !6
  %17 = load %struct.op** @PL_main_start, align 8, !tbaa !6
  tail call void %16(%struct.op* %17) #4
  store %struct.cv* null, %struct.cv** @PL_compcv, align 8, !tbaa !6
  %18 = load i64* @PL_perldb, align 8, !tbaa !1
  %and29 = and i64 %18, 8
  %tobool30 = icmp eq i64 %and29, 0
  br i1 %tobool30, label %if.end53, label %if.then31

if.then31:                                        ; preds = %cond.end
  %call32 = tail call %struct.cv* @Perl_get_cv(i8* getelementptr inbounds ([14 x i8]* @.str28, i64 0, i64 0), i64 0) #4
  %tobool33 = icmp eq %struct.cv* %call32, null
  br i1 %tobool33, label %if.end53, label %if.then34

if.then34:                                        ; preds = %if.then31
  %19 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !6
  %20 = load i64** @PL_markstack_ptr, align 8, !tbaa !6
  %incdec.ptr = getelementptr inbounds i64* %20, i64 1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !6
  %21 = load i64** @PL_markstack_max, align 8, !tbaa !6
  %cmp35 = icmp eq i64* %incdec.ptr, %21
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.then34
  tail call void @Perl_markstack_grow() #4
  %.pre = load i64** @PL_markstack_ptr, align 8, !tbaa !6
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %if.then34
  %22 = phi i64* [ %.pre, %if.then37 ], [ %incdec.ptr, %if.then34 ]
  %23 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !6
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %19 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %23 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  store i64 %sub.ptr.div, i64* %22, align 8, !tbaa !1
  %24 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !6
  %sub.ptr.lhs.cast39 = ptrtoint %struct.sv** %24 to i64
  %sub.ptr.sub41 = sub i64 %sub.ptr.lhs.cast39, %sub.ptr.lhs.cast
  %cmp43 = icmp slt i64 %sub.ptr.sub41, 8
  br i1 %cmp43, label %if.then45, label %if.end47

if.then45:                                        ; preds = %if.end38
  %call46 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %19, %struct.sv** %19, i32 1) #4
  br label %if.end47

if.end47:                                         ; preds = %if.then45, %if.end38
  %sp.0 = phi %struct.sv** [ %call46, %if.then45 ], [ %19, %if.end38 ]
  %25 = load %struct.gv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 10), align 8, !tbaa !97
  %26 = bitcast %struct.gv* %25 to %struct.sv*
  %incdec.ptr49 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %26, %struct.sv** %incdec.ptr49, align 8, !tbaa !6
  store %struct.sv** %incdec.ptr49, %struct.sv*** @PL_stack_sp, align 8, !tbaa !6
  %27 = bitcast %struct.cv* %call32 to %struct.sv*
  %call50 = tail call i64 @Perl_call_sv(%struct.sv* %27, i64 2) #4
  br label %if.end53

if.end53:                                         ; preds = %if.then, %if.then31, %cond.end, %if.end47, %if.then10, %if.end
  ret void
}

declare i32 @scope(...) #2

declare i32 @sawparens(...) #2

declare %struct.cv* @Perl_get_cv(i8*, i64) #2

declare void @Perl_markstack_grow() #2

declare %struct.sv** @Perl_stack_grow(%struct.sv**, %struct.sv**, i32) #2

declare i64 @Perl_call_sv(%struct.sv*, i64) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_localize(%struct.op* %o, i64 %lex) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 8
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.else, label %if.end148

if.else:                                          ; preds = %entry
  %1 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %1, i64 0, i32 14
  %2 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp = icmp eq %struct.sv* %2, null
  br i1 %cmp, label %lor.lhs.false13, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %3 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings2 = getelementptr inbounds %struct.cop* %3, i64 0, i32 14
  %4 = load %struct.sv** %cop_warnings2, align 8, !tbaa !47
  %cmp3 = icmp eq %struct.sv* %4, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp3, label %lor.lhs.false13, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %land.lhs.true
  %5 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings6 = getelementptr inbounds %struct.cop* %5, i64 0, i32 14
  %6 = load %struct.sv** %cop_warnings6, align 8, !tbaa !47
  %cmp7 = icmp eq %struct.sv* %6, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp7, label %land.lhs.true21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true5
  %7 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings9 = getelementptr inbounds %struct.cop* %7, i64 0, i32 14
  %8 = load %struct.sv** %cop_warnings9, align 8, !tbaa !47
  %sv_any = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %9 to i8**
  %10 = load i8** %xpv_pv, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8* %10, i64 8
  %11 = load i8* %arrayidx, align 1, !tbaa !5
  %and11 = and i8 %11, 1
  %tobool12 = icmp eq i8 %and11, 0
  br i1 %tobool12, label %lor.lhs.false13, label %land.lhs.true21

lor.lhs.false13:                                  ; preds = %lor.lhs.false, %land.lhs.true, %if.else
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings14 = getelementptr inbounds %struct.cop* %12, i64 0, i32 14
  %13 = load %struct.sv** %cop_warnings14, align 8, !tbaa !47
  %cmp15 = icmp eq %struct.sv* %13, null
  br i1 %cmp15, label %land.lhs.true17, label %if.end148

land.lhs.true17:                                  ; preds = %lor.lhs.false13
  %14 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and19 = and i8 %14, 1
  %tobool20 = icmp eq i8 %and19, 0
  br i1 %tobool20, label %if.end148, label %land.lhs.true21

land.lhs.true21:                                  ; preds = %lor.lhs.false, %land.lhs.true17, %land.lhs.true5
  %15 = load i8** @PL_bufptr, align 8, !tbaa !6
  %16 = load i8** @PL_oldbufptr, align 8, !tbaa !6
  %cmp22 = icmp ugt i8* %15, %16
  br i1 %cmp22, label %land.lhs.true24, label %if.end148

land.lhs.true24:                                  ; preds = %land.lhs.true21
  %arrayidx25 = getelementptr inbounds i8* %15, i64 -1
  %17 = load i8* %arrayidx25, align 1, !tbaa !5
  %cmp27 = icmp eq i8 %17, 44
  br i1 %cmp27, label %while.cond.preheader, label %if.end148

while.cond.preheader:                             ; preds = %land.lhs.true24
  %18 = load i8* %15, align 1, !tbaa !5
  %tobool31232 = icmp eq i8 %18, 0
  br i1 %tobool31232, label %if.end148, label %land.rhs

while.cond:                                       ; preds = %land.rhs
  %19 = load i8* %incdec.ptr, align 1, !tbaa !5
  %tobool31 = icmp eq i8 %19, 0
  br i1 %tobool31, label %if.end148, label %land.rhs

land.rhs:                                         ; preds = %while.cond.preheader, %while.cond
  %20 = phi i8 [ %19, %while.cond ], [ %18, %while.cond.preheader ]
  %s.0233 = phi i8* [ %incdec.ptr, %while.cond ], [ %15, %while.cond.preheader ]
  %conv30 = sext i8 %20 to i32
  %memchr193 = tail call i8* @memchr(i8* getelementptr inbounds ([5 x i8]* @.str29, i64 0, i64 0), i32 %conv30, i64 5)
  %tobool33 = icmp eq i8* %memchr193, null
  %incdec.ptr = getelementptr inbounds i8* %s.0233, i64 1
  br i1 %tobool33, label %land.lhs.true38, label %while.cond

while.body35.loopexit:                            ; preds = %land.rhs121
  %tobool37 = icmp eq i8 %33, 0
  br i1 %tobool37, label %if.end148, label %land.lhs.true38

land.lhs.true38:                                  ; preds = %land.rhs, %while.body35.loopexit
  %21 = phi i8 [ %33, %while.body35.loopexit ], [ %20, %land.rhs ]
  %sigil.0223 = phi i32 [ 1, %while.body35.loopexit ], [ 0, %land.rhs ]
  %s.1222 = phi i8* [ %s.3218, %while.body35.loopexit ], [ %s.0233, %land.rhs ]
  %conv36 = sext i8 %21 to i32
  %memchr = tail call i8* @memchr(i8* getelementptr inbounds ([5 x i8]* @.str30, i64 0, i64 0), i32 %conv36, i64 5)
  %tobool41 = icmp eq i8* %memchr, null
  br i1 %tobool41, label %while.end130, label %land.lhs.true42

land.lhs.true42:                                  ; preds = %land.lhs.true38
  %incdec.ptr43 = getelementptr inbounds i8* %s.1222, i64 1
  %22 = load i8* %incdec.ptr43, align 1, !tbaa !5
  %tobool45 = icmp eq i8 %22, 0
  br i1 %tobool45, label %while.end130, label %land.lhs.true46

land.lhs.true46:                                  ; preds = %land.lhs.true42
  %.off = add i8 %22, -65
  %23 = icmp ult i8 %.off, 26
  %.off202 = add i8 %22, -97
  %24 = icmp ult i8 %.off202, 26
  %or.cond = or i1 %23, %24
  %.off203 = add i8 %22, -48
  %25 = icmp ult i8 %.off203, 10
  %or.cond209 = or i1 %or.cond, %25
  br i1 %or.cond209, label %if.then78, label %lor.lhs.false70

lor.lhs.false70:                                  ; preds = %land.lhs.true46
  %cmp72 = icmp eq i8 %22, 95
  %tobool77 = icmp slt i8 %22, 0
  %or.cond197 = or i1 %cmp72, %tobool77
  br i1 %or.cond197, label %if.then78, label %while.end130

if.then78:                                        ; preds = %land.lhs.true46, %lor.lhs.false70
  %incdec.ptr79 = getelementptr inbounds i8* %s.1222, i64 2
  %26 = load i8* %incdec.ptr79, align 1, !tbaa !5
  %tobool82214 = icmp eq i8 %26, 0
  br i1 %tobool82214, label %if.end148, label %land.rhs83

land.rhs83:                                       ; preds = %if.then78, %while.body115
  %27 = phi i8 [ %31, %while.body115 ], [ %26, %if.then78 ]
  %s.2215 = phi i8* [ %incdec.ptr116, %while.body115 ], [ %incdec.ptr79, %if.then78 ]
  %.off204 = add i8 %27, -65
  %28 = icmp ult i8 %.off204, 26
  %.off205 = add i8 %27, -97
  %29 = icmp ult i8 %.off205, 26
  %or.cond211 = or i1 %28, %29
  %.off206 = add i8 %27, -48
  %30 = icmp ult i8 %.off206, 10
  %or.cond213 = or i1 %or.cond211, %30
  br i1 %or.cond213, label %while.body115, label %lor.lhs.false107

lor.lhs.false107:                                 ; preds = %land.rhs83
  %cmp109 = icmp eq i8 %27, 95
  %tobool113 = icmp slt i8 %27, 0
  %or.cond201 = or i1 %cmp109, %tobool113
  br i1 %or.cond201, label %while.body115, label %while.cond118.preheader

while.cond118.preheader:                          ; preds = %lor.lhs.false107
  %tobool120217 = icmp eq i8 %27, 0
  br i1 %tobool120217, label %if.end148, label %land.rhs121

while.body115:                                    ; preds = %land.rhs83, %lor.lhs.false107
  %incdec.ptr116 = getelementptr inbounds i8* %s.2215, i64 1
  %31 = load i8* %incdec.ptr116, align 1, !tbaa !5
  %tobool82 = icmp eq i8 %31, 0
  br i1 %tobool82, label %if.end148, label %land.rhs83

while.cond118:                                    ; preds = %land.rhs121
  %32 = load i8* %incdec.ptr127, align 1, !tbaa !5
  %tobool120 = icmp eq i8 %32, 0
  br i1 %tobool120, label %if.end148, label %land.rhs121

land.rhs121:                                      ; preds = %while.cond118.preheader, %while.cond118
  %33 = phi i8 [ %32, %while.cond118 ], [ %27, %while.cond118.preheader ]
  %s.3218 = phi i8* [ %incdec.ptr127, %while.cond118 ], [ %s.2215, %while.cond118.preheader ]
  %conv119 = sext i8 %33 to i32
  %memchr192 = tail call i8* @memchr(i8* getelementptr inbounds ([5 x i8]* @.str29, i64 0, i64 0), i32 %conv119, i64 5)
  %tobool124 = icmp eq i8* %memchr192, null
  %incdec.ptr127 = getelementptr inbounds i8* %s.3218, i64 1
  br i1 %tobool124, label %while.body35.loopexit, label %while.cond118

while.end130:                                     ; preds = %land.lhs.true38, %land.lhs.true42, %lor.lhs.false70
  %34 = phi i8 [ %22, %lor.lhs.false70 ], [ 0, %land.lhs.true42 ], [ %21, %land.lhs.true38 ]
  %tobool132 = icmp eq i32 %sigil.0223, 0
  br i1 %tobool132, label %if.end148, label %land.lhs.true133

land.lhs.true133:                                 ; preds = %while.end130
  switch i8 %34, label %if.end148 [
    i8 59, label %if.then141
    i8 61, label %if.then141
  ]

if.then141:                                       ; preds = %land.lhs.true133, %land.lhs.true133
  %tobool142 = icmp eq i64 %lex, 0
  br i1 %tobool142, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.then141
  %35 = load i64* @PL_in_my, align 8, !tbaa !1
  %cmp143 = icmp eq i64 %35, 137
  %cond = select i1 %cmp143, i8* getelementptr inbounds ([4 x i8]* @.str4, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8]* @.str5, i64 0, i64 0)
  br label %cond.end

cond.end:                                         ; preds = %if.then141, %cond.true
  %cond145 = phi i8* [ %cond, %cond.true ], [ getelementptr inbounds ([6 x i8]* @.str21, i64 0, i64 0), %if.then141 ]
  tail call void (i64, i8*, ...)* @Perl_warner(i64 32, i8* getelementptr inbounds ([37 x i8]* @.str31, i64 0, i64 0), i8* %cond145) #4
  br label %if.end148

if.end148:                                        ; preds = %while.cond, %while.body35.loopexit, %while.cond118.preheader, %if.then78, %while.body115, %while.cond118, %while.cond.preheader, %land.lhs.true133, %while.end130, %land.lhs.true17, %entry, %lor.lhs.false13, %land.lhs.true21, %land.lhs.true24, %cond.end
  %tobool149 = icmp eq i64 %lex, 0
  br i1 %tobool149, label %if.else153, label %if.then150

if.then150:                                       ; preds = %if.end148
  %call151 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @my to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  br label %if.end156

if.else153:                                       ; preds = %if.end148
  %call154 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i32, ...)*)(%struct.op* %o, i32 0) #4
  br label %if.end156

if.end156:                                        ; preds = %if.else153, %if.then150
  %o.addr.0.in.in = phi i32 [ %call151, %if.then150 ], [ %call154, %if.else153 ]
  %o.addr.0.in = sext i32 %o.addr.0.in.in to i64
  %o.addr.0 = inttoptr i64 %o.addr.0.in to %struct.op*
  store i64 0, i64* @PL_in_my, align 8, !tbaa !1
  store %struct.hv* null, %struct.hv** @PL_in_my_stash, align 8, !tbaa !6
  ret %struct.op* %o.addr.0
}

declare i32 @my(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_jmaybe(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %0, 141
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([2 x i8]* @.str32, i64 0, i64 0), i64 1, i64 4) #4
  %1 = bitcast %struct.gv* %call to %struct.sv*
  store %struct.sv* %1, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool.i = icmp eq %struct.gv* %call, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then
  %2 = getelementptr inbounds %struct.gv* %call, i64 0, i32 1
  %3 = load i64* %2, align 8, !tbaa !40
  %inc.i = add i64 %3, 1
  store i64 %inc.i, i64* %2, align 8, !tbaa !40
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.then, %land.rhs.i
  %call.i9 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i9, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i9, i64 32
  %4 = bitcast i8* %op_type.i to i16*
  store i16 7, i16* %4, align 2, !tbaa !71
  %5 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 7), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i9, i64 16
  %6 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %5, %struct.op* ()** %6, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i9, i64 40
  %7 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %1, %struct.sv** %7, align 8, !tbaa !18
  %8 = bitcast i8* %call.i9 to %struct.op*
  %op_next.i = bitcast i8* %call.i9 to %struct.op**
  store %struct.op* %8, %struct.op** %op_next.i, align 8, !tbaa !73
  %9 = getelementptr inbounds i8* %call.i9, i64 36
  store i8 0, i8* %9, align 1, !tbaa !74
  %10 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  %and.i = and i64 %10, 4
  %tobool.i10 = icmp eq i64 %and.i, 0
  br i1 %tobool.i10, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %Perl_newGVOP.exit
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %8) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %Perl_newGVOP.exit
  %11 = phi i64 [ %10, %Perl_newGVOP.exit ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %11, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 7, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i9, i64 24
  %12 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %12, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %13 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %13, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %13, i64 7
  %14 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %14, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %8) #4
  %15 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 7), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %15) #4
  br label %Perl_newSVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %16 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 7), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %16(%struct.op* %8) #4
  br label %Perl_newSVOP.exit

Perl_newSVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  %op_type.i11 = getelementptr inbounds %struct.op* %cond.i, i64 0, i32 4
  %17 = load i16* %op_type.i11, align 2, !tbaa !12
  switch i16 %17, label %if.end12.i [
    i16 12, label %if.then.i13
    i16 348, label %land.lhs.true.i16
  ]

if.then.i13:                                      ; preds = %Perl_newSVOP.exit
  store i16 9, i16* %op_type.i11, align 2, !tbaa !12
  %18 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 9), align 8, !tbaa !6
  %op_ppaddr.i12 = getelementptr inbounds %struct.op* %cond.i, i64 0, i32 2
  store %struct.op* ()* %18, %struct.op* ()** %op_ppaddr.i12, align 8, !tbaa !41
  br label %Perl_newSVREF.exit

land.lhs.true.i16:                                ; preds = %Perl_newSVOP.exit
  %op_flags.i = getelementptr inbounds %struct.op* %cond.i, i64 0, i32 6
  %19 = load i8* %op_flags.i, align 1, !tbaa !14
  %and.i14 = and i8 %19, 64
  %tobool.i15 = icmp eq i8 %and.i14, 0
  br i1 %tobool.i15, label %if.then8.i, label %if.end12.i

if.then8.i:                                       ; preds = %land.lhs.true.i16
  %or.i = or i8 %19, 64
  store i8 %or.i, i8* %op_flags.i, align 1, !tbaa !14
  br label %Perl_newSVREF.exit

if.end12.i:                                       ; preds = %land.lhs.true.i16, %Perl_newSVOP.exit
  %call.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %cond.i) #4
  %conv13.i = sext i32 %call.i to i64
  %20 = inttoptr i64 %conv13.i to %struct.op*
  %call14.i = tail call %struct.op* @Perl_newUNOP(i64 15, i64 0, %struct.op* %20) #4
  br label %Perl_newSVREF.exit

Perl_newSVREF.exit:                               ; preds = %if.then.i13, %if.then8.i, %if.end12.i
  %retval.0.i = phi %struct.op* [ %cond.i, %if.then.i13 ], [ %call14.i, %if.end12.i ], [ %cond.i, %if.then8.i ]
  %call4 = tail call i32 (i32, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @prepend_elem to i32 (i32, %struct.op*, %struct.op*, ...)*)(i32 141, %struct.op* %retval.0.i, %struct.op* %o) #4
  %call5 = tail call i32 (i32, i32, i32, ...)* bitcast (i32 (...)* @convert to i32 (i32, i32, i32, ...)*)(i32 140, i32 0, i32 %call4) #4
  %conv6 = sext i32 %call5 to i64
  %21 = inttoptr i64 %conv6 to %struct.op*
  br label %if.end

if.end:                                           ; preds = %Perl_newSVREF.exit, %entry
  %o.addr.0 = phi %struct.op* [ %21, %Perl_newSVREF.exit ], [ %o, %entry ]
  ret %struct.op* %o.addr.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newSVREF(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  switch i16 %0, label %if.end12 [
    i16 12, label %if.then
    i16 348, label %land.lhs.true
  ]

if.then:                                          ; preds = %entry
  store i16 9, i16* %op_type, align 2, !tbaa !12
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 9), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %1, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  br label %return

land.lhs.true:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.then8, label %if.end12

if.then8:                                         ; preds = %land.lhs.true
  %or = or i8 %2, 64
  store i8 %or, i8* %op_flags, align 1, !tbaa !14
  br label %return

if.end12:                                         ; preds = %entry, %land.lhs.true
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv13 = sext i32 %call to i64
  %3 = inttoptr i64 %conv13 to %struct.op*
  %call14 = tail call %struct.op* @Perl_newUNOP(i64 15, i64 0, %struct.op* %3)
  br label %return

return:                                           ; preds = %if.end12, %if.then8, %if.then
  %retval.0 = phi %struct.op* [ %o, %if.then ], [ %call14, %if.end12 ], [ %o, %if.then8 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newGVOP(i64 %type, i64 %flags, %struct.gv* %gv) #0 {
entry:
  %0 = bitcast %struct.gv* %gv to %struct.sv*
  store %struct.sv* %0, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool = icmp eq %struct.gv* %gv, null
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %1 = getelementptr inbounds %struct.gv* %gv, i64 0, i32 1
  %2 = load i64* %1, align 8, !tbaa !40
  %inc = add i64 %2, 1
  store i64 %inc, i64* %1, align 8, !tbaa !40
  br label %land.end

land.end:                                         ; preds = %entry, %land.rhs
  %call = tail call %struct.op* @Perl_newSVOP(i64 %type, i64 %flags, %struct.sv* %0)
  ret %struct.op* %call
}

declare %struct.gv* @Perl_gv_fetchpv(i8*, i64, i64) #2

declare i32 @convert(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_fold_constants(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %conv = zext i16 %0 to i64
  %arrayidx = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %conv
  %1 = load i64* %arrayidx, align 8, !tbaa !1
  %and = and i64 %1, 4
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %.pre = load i64* %arrayidx, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %2 = phi i64 [ %1, %entry ], [ %.pre, %if.then ]
  %and2 = and i64 %2, 8
  %tobool3 = icmp eq i64 %and2, 0
  br i1 %tobool3, label %if.end9, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %op_targ = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !13
  %tobool4 = icmp eq i64 %3, 0
  br i1 %tobool4, label %if.then5, label %if.end9

if.then5:                                         ; preds = %land.lhs.true
  %call6 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 %conv, i32 512) #4
  %conv7 = sext i32 %call6 to i64
  store i64 %conv7, i64* %op_targ, align 8, !tbaa !13
  %.pre202 = load i64* %arrayidx, align 8, !tbaa !1
  br label %if.end9

if.end9:                                          ; preds = %land.lhs.true, %if.end, %if.then5
  %4 = phi i64 [ %2, %land.lhs.true ], [ %2, %if.end ], [ %.pre202, %if.then5 ]
  %and11 = and i64 %4, 32
  %tobool12 = icmp eq i64 %and11, 0
  br i1 %tobool12, label %if.end32, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %if.end9
  %5 = load i64* @PL_hints, align 8, !tbaa !1
  %and14 = and i64 %5, 1
  %tobool15 = icmp eq i64 %and14, 0
  br i1 %tobool15, label %if.end32, label %land.lhs.true16

land.lhs.true16:                                  ; preds = %land.lhs.true13
  %cmp = icmp eq i16 %0, 94
  br i1 %cmp, label %land.lhs.true18, label %if.then28

land.lhs.true18:                                  ; preds = %land.lhs.true16
  %6 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %7 = load %struct.op** %6, align 8, !tbaa !15
  %op_type19 = getelementptr inbounds %struct.op* %7, i64 0, i32 4
  %8 = load i16* %op_type19, align 2, !tbaa !12
  %cmp21 = icmp eq i16 %8, 5
  br i1 %cmp21, label %land.lhs.true23, label %if.then28

land.lhs.true23:                                  ; preds = %land.lhs.true18
  %op_private = getelementptr inbounds %struct.op* %7, i64 0, i32 7
  %9 = load i8* %op_private, align 1, !tbaa !11
  %and26 = and i8 %9, 64
  %tobool27 = icmp eq i8 %and26, 0
  br i1 %tobool27, label %if.then28, label %if.end32

if.then28:                                        ; preds = %land.lhs.true23, %land.lhs.true18, %land.lhs.true16
  %10 = load i16* %op_type, align 2, !tbaa !12
  %inc = add i16 %10, 1
  store i16 %inc, i16* %op_type, align 2, !tbaa !12
  %conv30 = zext i16 %inc to i64
  %arrayidx31 = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %conv30
  %11 = load %struct.op* ()** %arrayidx31, align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %11, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %arrayidx33.phi.trans.insert = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %conv30
  %.pre203 = load i64* %arrayidx33.phi.trans.insert, align 8, !tbaa !1
  br label %if.end32

if.end32:                                         ; preds = %land.lhs.true23, %land.lhs.true13, %if.end9, %if.then28
  %12 = phi i64 [ %4, %land.lhs.true23 ], [ %.pre203, %if.then28 ], [ %4, %land.lhs.true13 ], [ %4, %if.end9 ]
  %type.0 = phi i64 [ %conv, %land.lhs.true23 ], [ %conv30, %if.then28 ], [ %conv, %land.lhs.true13 ], [ %conv, %if.end9 ]
  %and34 = and i64 %12, 2
  %tobool35 = icmp eq i64 %and34, 0
  br i1 %tobool35, label %return, label %if.end37

if.end37:                                         ; preds = %if.end32
  switch i64 %type.0, label %sw.epilog [
    i64 94, label %sw.bb
    i64 115, label %sw.bb43
    i64 120, label %sw.bb43
    i64 121, label %sw.bb43
    i64 122, label %sw.bb43
    i64 123, label %sw.bb43
    i64 84, label %sw.bb43
    i64 85, label %sw.bb43
    i64 86, label %sw.bb43
    i64 87, label %sw.bb43
    i64 90, label %sw.bb43
  ]

sw.bb:                                            ; preds = %if.end37
  %13 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %14 = load %struct.op** %13, align 8, !tbaa !15
  %op_private39 = getelementptr inbounds %struct.op* %14, i64 0, i32 7
  %15 = load i8* %op_private39, align 1, !tbaa !11
  %and41 = and i8 %15, -9
  store i8 %and41, i8* %op_private39, align 1, !tbaa !11
  br label %sw.epilog

sw.bb43:                                          ; preds = %if.end37, %if.end37, %if.end37, %if.end37, %if.end37, %if.end37, %if.end37, %if.end37, %if.end37, %if.end37
  %16 = load i64* @PL_hints, align 8
  %and44 = and i64 %16, 4
  %17 = load i64* @PL_error_count, align 8
  %18 = or i64 %and44, %17
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %if.end50, label %return

sw.epilog:                                        ; preds = %if.end37, %sw.bb
  %.old = load i64* @PL_error_count, align 8, !tbaa !1
  %tobool48.old = icmp eq i64 %.old, 0
  br i1 %tobool48.old, label %if.end50, label %return

if.end50:                                         ; preds = %sw.epilog, %sw.bb43
  %op_next = getelementptr inbounds %struct.op* %o, i64 0, i32 0
  %20 = load %struct.op** %op_next, align 8, !tbaa !42
  %tobool51 = icmp eq %struct.op* %20, null
  br i1 %tobool51, label %cond.false, label %for.cond.preheader

cond.false:                                       ; preds = %if.end50
  %call53 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv54 = sext i32 %call53 to i64
  %21 = inttoptr i64 %conv54 to %struct.op*
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end50, %cond.false
  %curop.0.ph = phi %struct.op* [ %21, %cond.false ], [ %20, %if.end50 ]
  %cmp55200 = icmp eq %struct.op* %curop.0.ph, %o
  br i1 %cmp55200, label %for.end, label %for.body

for.body:                                         ; preds = %for.cond.preheader, %for.cond.backedge
  %curop.0201 = phi %struct.op* [ %curop.0.be, %for.cond.backedge ], [ %curop.0.ph, %for.cond.preheader ]
  %op_type57 = getelementptr inbounds %struct.op* %curop.0201, i64 0, i32 4
  %22 = load i16* %op_type57, align 2, !tbaa !12
  switch i16 %22, label %return [
    i16 5, label %lor.lhs.false
    i16 141, label %for.inc
    i16 2, label %for.inc
    i16 0, label %for.inc
    i16 3, label %for.inc
  ]

lor.lhs.false:                                    ; preds = %for.body
  %op_private61 = getelementptr inbounds %struct.op* %curop.0201, i64 0, i32 7
  %23 = load i8* %op_private61, align 1, !tbaa !11
  %and63 = and i8 %23, 64
  %tobool64 = icmp eq i8 %and63, 0
  br i1 %tobool64, label %for.inc, label %return

for.inc:                                          ; preds = %for.body, %for.body, %for.body, %for.body, %lor.lhs.false
  %op_next87 = getelementptr inbounds %struct.op* %curop.0201, i64 0, i32 0
  %24 = load %struct.op** %op_next87, align 8, !tbaa !42
  %tobool88 = icmp eq %struct.op* %24, null
  br i1 %tobool88, label %cond.false91, label %for.cond.backedge

for.cond.backedge:                                ; preds = %for.inc, %cond.false91
  %curop.0.be = phi %struct.op* [ %25, %cond.false91 ], [ %24, %for.inc ]
  %cmp55 = icmp eq %struct.op* %curop.0.be, %o
  br i1 %cmp55, label %for.end, label %for.body

cond.false91:                                     ; preds = %for.inc
  %call92 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %curop.0201) #4
  %conv93 = sext i32 %call92 to i64
  %25 = inttoptr i64 %conv93 to %struct.op*
  br label %for.cond.backedge

for.end:                                          ; preds = %for.cond.backedge, %for.cond.preheader
  %26 = load %struct.op** %op_next, align 8, !tbaa !42
  %tobool97 = icmp eq %struct.op* %26, null
  br i1 %tobool97, label %cond.false100, label %cond.end103

cond.false100:                                    ; preds = %for.end
  %call101 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv102 = sext i32 %call101 to i64
  %27 = inttoptr i64 %conv102 to %struct.op*
  br label %cond.end103

cond.end103:                                      ; preds = %for.end, %cond.false100
  %cond104 = phi %struct.op* [ %27, %cond.false100 ], [ %26, %for.end ]
  store %struct.op* null, %struct.op** %op_next, align 8, !tbaa !42
  store %struct.op* %cond104, %struct.op** @PL_op, align 8, !tbaa !6
  %28 = load i32 ()** @PL_runops, align 8, !tbaa !6
  %call106 = tail call i32 %28() #4
  %29 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !6
  %incdec.ptr = getelementptr inbounds %struct.sv** %29, i64 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !6
  %30 = load %struct.sv** %29, align 8, !tbaa !6
  %op_targ107 = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %31 = load i64* %op_targ107, align 8, !tbaa !13
  %tobool108 = icmp eq i64 %31, 0
  br i1 %tobool108, label %if.else, label %land.lhs.true109

land.lhs.true109:                                 ; preds = %cond.end103
  %32 = load %struct.sv*** @PL_curpad, align 8, !tbaa !6
  %arrayidx111 = getelementptr inbounds %struct.sv** %32, i64 %31
  %33 = load %struct.sv** %arrayidx111, align 8, !tbaa !6
  %cmp112 = icmp eq %struct.sv* %30, %33
  br i1 %cmp112, label %if.then114, label %if.else

if.then114:                                       ; preds = %land.lhs.true109
  %call116 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_swipe to i32 (i64, i32, ...)*)(i64 %31, i32 0) #4
  br label %if.end126

if.else:                                          ; preds = %cond.end103, %land.lhs.true109
  %sv_flags = getelementptr inbounds %struct.sv* %30, i64 0, i32 2
  %34 = load i64* %sv_flags, align 8, !tbaa !34
  %and117 = and i64 %34, 2048
  %tobool118 = icmp eq i64 %and117, 0
  br i1 %tobool118, label %if.end126, label %if.then119

if.then119:                                       ; preds = %if.else
  store %struct.sv* %30, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool120 = icmp eq %struct.sv* %30, null
  br i1 %tobool120, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.then119
  %sv_refcnt = getelementptr inbounds %struct.sv* %30, i64 0, i32 1
  %35 = load i64* %sv_refcnt, align 8, !tbaa !40
  %inc121 = add i64 %35, 1
  store i64 %inc121, i64* %sv_refcnt, align 8, !tbaa !40
  br label %land.end

land.end:                                         ; preds = %if.then119, %land.rhs
  %and124 = and i64 %34, -2049
  store i64 %and124, i64* %sv_flags, align 8, !tbaa !34
  br label %if.end126

if.end126:                                        ; preds = %if.else, %land.end, %if.then114
  tail call void @Perl_op_free(%struct.op* %o)
  %cmp127 = icmp eq i64 %type.0, 14
  br i1 %cmp127, label %if.then129, label %if.end131

if.then129:                                       ; preds = %if.end126
  store %struct.sv* %30, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool.i = icmp eq %struct.sv* %30, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then129
  %36 = getelementptr inbounds %struct.sv* %30, i64 0, i32 1
  %37 = load i64* %36, align 8, !tbaa !40
  %inc.i = add i64 %37, 1
  store i64 %inc.i, i64* %36, align 8, !tbaa !40
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.then129, %land.rhs.i
  %call.i172 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i172, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i172, i64 32
  %38 = bitcast i8* %op_type.i to i16*
  store i16 7, i16* %38, align 2, !tbaa !71
  %39 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 7), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i172, i64 16
  %40 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %39, %struct.op* ()** %40, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i172, i64 40
  %41 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %30, %struct.sv** %41, align 8, !tbaa !18
  %42 = bitcast i8* %call.i172 to %struct.op*
  %op_next.i = bitcast i8* %call.i172 to %struct.op**
  store %struct.op* %42, %struct.op** %op_next.i, align 8, !tbaa !73
  %43 = getelementptr inbounds i8* %call.i172, i64 36
  store i8 0, i8* %43, align 1, !tbaa !74
  %44 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  %and.i = and i64 %44, 4
  %tobool.i173 = icmp eq i64 %and.i, 0
  br i1 %tobool.i173, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %Perl_newGVOP.exit
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %42) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %Perl_newGVOP.exit
  %45 = phi i64 [ %44, %Perl_newGVOP.exit ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %45, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 7, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i172, i64 24
  %46 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %46, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %47 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %47, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %47, i64 7
  %48 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %48, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %42) #4
  %49 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 7), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %49) #4
  br label %return

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %50 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 7), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %50(%struct.op* %42) #4
  br label %return

if.end131:                                        ; preds = %if.end126
  %call.i = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i174 = getelementptr inbounds i8* %call.i, i64 32
  %51 = bitcast i8* %op_type.i174 to i16*
  store i16 5, i16* %51, align 2, !tbaa !71
  %52 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i175 = getelementptr inbounds i8* %call.i, i64 16
  %53 = bitcast i8* %op_ppaddr.i175 to %struct.op* ()**
  store %struct.op* ()* %52, %struct.op* ()** %53, align 8, !tbaa !72
  %op_sv.i176 = getelementptr inbounds i8* %call.i, i64 40
  %54 = bitcast i8* %op_sv.i176 to %struct.sv**
  store %struct.sv* %30, %struct.sv** %54, align 8, !tbaa !18
  %55 = bitcast i8* %call.i to %struct.op*
  %op_next.i177 = bitcast i8* %call.i to %struct.op**
  store %struct.op* %55, %struct.op** %op_next.i177, align 8, !tbaa !73
  %56 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %56, align 1, !tbaa !74
  %57 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i178 = and i64 %57, 4
  %tobool.i179 = icmp eq i64 %and.i178, 0
  br i1 %tobool.i179, label %if.end.i185, label %if.then.i182

if.then.i182:                                     ; preds = %if.end131
  %call3.i180 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %55) #4
  %.pre.i181 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i185

if.end.i185:                                      ; preds = %if.then.i182, %if.end131
  %58 = phi i64 [ %57, %if.end131 ], [ %.pre.i181, %if.then.i182 ]
  %and5.i183 = and i64 %58, 8
  %tobool6.i184 = icmp eq i64 %and5.i183, 0
  br i1 %tobool6.i184, label %if.end10.i191, label %if.then7.i189

if.then7.i189:                                    ; preds = %if.end.i185
  %call8.i186 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i187 = sext i32 %call8.i186 to i64
  %op_targ.i188 = getelementptr inbounds i8* %call.i, i64 24
  %59 = bitcast i8* %op_targ.i188 to i64*
  store i64 %conv9.i187, i64* %59, align 8, !tbaa !75
  br label %if.end10.i191

if.end10.i191:                                    ; preds = %if.then7.i189, %if.end.i185
  %60 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i190 = icmp eq i8* %60, null
  br i1 %tobool11.i190, label %cond.false.i197, label %land.lhs.true.i194

land.lhs.true.i194:                               ; preds = %if.end10.i191
  %arrayidx12.i192 = getelementptr inbounds i8* %60, i64 5
  %61 = load i8* %arrayidx12.i192, align 1, !tbaa !5
  %tobool14.i193 = icmp eq i8 %61, 0
  br i1 %tobool14.i193, label %cond.false.i197, label %cond.true.i195

cond.true.i195:                                   ; preds = %land.lhs.true.i194
  tail call void @Perl_op_free(%struct.op* %55) #4
  %62 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %62) #4
  br label %return

cond.false.i197:                                  ; preds = %land.lhs.true.i194, %if.end10.i191
  %63 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i196 = tail call %struct.op* %63(%struct.op* %55) #4
  br label %return

return:                                           ; preds = %for.body, %lor.lhs.false, %cond.false.i197, %cond.true.i195, %cond.false.i, %cond.true.i, %if.end32, %sw.bb43, %sw.epilog
  %retval.0 = phi %struct.op* [ %o, %sw.epilog ], [ %o, %sw.bb43 ], [ %o, %if.end32 ], [ null, %cond.true.i ], [ %call17.i, %cond.false.i ], [ null, %cond.true.i195 ], [ %call17.i196, %cond.false.i197 ], [ %o, %lor.lhs.false ], [ %o, %for.body ]
  ret %struct.op* %retval.0
}

declare i32 @pad_swipe(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_gen_constant_list(%struct.op* %o) #0 {
entry:
  %0 = load i64* @PL_tmps_floor, align 8, !tbaa !1
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %1 = load i64* @PL_error_count, align 8, !tbaa !1
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %op_next = getelementptr inbounds %struct.op* %o, i64 0, i32 0
  %2 = load %struct.op** %op_next, align 8, !tbaa !42
  %tobool1 = icmp eq %struct.op* %2, null
  br i1 %tobool1, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.end
  %call3 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv = sext i32 %call3 to i64
  %3 = inttoptr i64 %conv to %struct.op*
  br label %cond.end

cond.end:                                         ; preds = %if.end, %cond.false
  %cond = phi %struct.op* [ %3, %cond.false ], [ %2, %if.end ]
  store %struct.op* %cond, %struct.op** @PL_op, align 8, !tbaa !6
  store %struct.op* null, %struct.op** %op_next, align 8, !tbaa !42
  %4 = load void (%struct.op*)** @PL_peepp, align 8, !tbaa !6
  tail call void %4(%struct.op* %cond) #4
  %call5 = tail call %struct.op* @Perl_pp_pushmark() #4
  %5 = load i32 ()** @PL_runops, align 8, !tbaa !6
  %call6 = tail call i32 %5() #4
  store %struct.op* %cond, %struct.op** @PL_op, align 8, !tbaa !6
  %call7 = tail call %struct.op* @Perl_pp_anonlist() #4
  store i64 %0, i64* @PL_tmps_floor, align 8, !tbaa !1
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  store i16 125, i16* %op_type, align 2, !tbaa !12
  %6 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 125), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %6, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %7 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %7, -25
  %or = or i8 %and, 8
  store i8 %or, i8* %op_flags, align 1, !tbaa !14
  %op_seq = getelementptr inbounds %struct.op* %o, i64 0, i32 5
  store i16 0, i16* %op_seq, align 2, !tbaa !8
  %8 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %9 = load %struct.op** %8, align 8, !tbaa !15
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !6
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !6
  %11 = load %struct.sv** %10, align 8, !tbaa !6
  store %struct.sv* %11, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool13 = icmp eq %struct.sv* %11, null
  br i1 %tobool13, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %cond.end
  %sv_refcnt = getelementptr inbounds %struct.sv* %11, i64 0, i32 1
  %12 = load i64* %sv_refcnt, align 8, !tbaa !40
  %inc = add i64 %12, 1
  store i64 %inc, i64* %sv_refcnt, align 8, !tbaa !40
  br label %land.end

land.end:                                         ; preds = %cond.end, %land.rhs
  %call.i = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i, i64 32
  %13 = bitcast i8* %op_type.i to i16*
  store i16 5, i16* %13, align 2, !tbaa !71
  %14 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %15 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %14, %struct.op* ()** %15, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i, i64 40
  %16 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %11, %struct.sv** %16, align 8, !tbaa !18
  %17 = bitcast i8* %call.i to %struct.op*
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %17, %struct.op** %op_next.i, align 8, !tbaa !73
  %18 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %18, align 1, !tbaa !74
  %19 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i = and i64 %19, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %land.end
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %17) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %land.end
  %20 = phi i64 [ %19, %land.end ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %20, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %21 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %21, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %22 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %22, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %22, i64 5
  %23 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %23, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %17) #4
  %24 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %24) #4
  br label %Perl_newSVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %25 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %25(%struct.op* %17) #4
  br label %Perl_newSVOP.exit

Perl_newSVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  store %struct.op* %cond.i, %struct.op** %8, align 8, !tbaa !15
  tail call void @Perl_op_free(%struct.op* %9)
  %call17 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %call18 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv19 = sext i32 %call18 to i64
  %26 = inttoptr i64 %conv19 to %struct.op*
  br label %return

return:                                           ; preds = %entry, %Perl_newSVOP.exit
  %retval.0 = phi %struct.op* [ %26, %Perl_newSVOP.exit ], [ %o, %entry ]
  ret %struct.op* %retval.0
}

declare %struct.op* @Perl_pp_pushmark() #2

declare %struct.op* @Perl_pp_anonlist() #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_convert(i64 %type, i64 %flags, %struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %0, 141
  br i1 %cmp, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = tail call %struct.op* @Perl_newLISTOP(i64 141, i64 0, %struct.op* %o, %struct.op* null)
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %1, -4
  store i8 %and, i8* %op_flags, align 1, !tbaa !14
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %o.addr.0 = phi %struct.op* [ %call, %if.then ], [ %o, %if.else ]
  %arrayidx = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %type
  %2 = load i64* %arrayidx, align 8, !tbaa !1
  %and4 = and i64 %2, 1
  %tobool5 = icmp eq i64 %and4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %3 = getelementptr inbounds %struct.op* %o.addr.0, i64 1, i32 0
  %4 = load %struct.op** %3, align 8, !tbaa !45
  %op_type.i = getelementptr inbounds %struct.op* %4, i64 0, i32 4
  %5 = load i16* %op_type.i, align 2, !tbaa !12
  %cmp.i = icmp eq i16 %5, 0
  br i1 %cmp.i, label %if.end7, label %if.end.i

if.end.i:                                         ; preds = %if.then6
  %call.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %4) #4
  %6 = load i16* %op_type.i, align 2, !tbaa !12
  %conv3.i = zext i16 %6 to i64
  %op_targ.i = getelementptr inbounds %struct.op* %4, i64 0, i32 3
  store i64 %conv3.i, i64* %op_targ.i, align 8, !tbaa !13
  store i16 0, i16* %op_type.i, align 2, !tbaa !12
  %7 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds %struct.op* %4, i64 0, i32 2
  store %struct.op* ()* %7, %struct.op* ()** %op_ppaddr.i, align 8, !tbaa !41
  br label %if.end7

if.end7:                                          ; preds = %if.end.i, %if.then6, %if.end
  %conv8 = trunc i64 %type to i16
  %op_type9 = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 4
  store i16 %conv8, i16* %op_type9, align 2, !tbaa !12
  %arrayidx10 = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %type
  %8 = load %struct.op* ()** %arrayidx10, align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 2
  store %struct.op* ()* %8, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %op_flags11 = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 6
  %9 = load i8* %op_flags11, align 1, !tbaa !14
  %conv12 = zext i8 %9 to i64
  %or = or i64 %conv12, %flags
  %conv13 = trunc i64 %or to i8
  store i8 %conv13, i8* %op_flags11, align 1, !tbaa !14
  %10 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool14 = icmp eq i8* %10, null
  br i1 %tobool14, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end7
  %arrayidx15 = getelementptr inbounds i8* %10, i64 %type
  %11 = load i8* %arrayidx15, align 1, !tbaa !5
  %tobool17 = icmp eq i8 %11, 0
  br i1 %tobool17, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  tail call void @Perl_op_free(%struct.op* %o.addr.0)
  %arrayidx18 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %type
  %12 = load i8** %arrayidx18, align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %12) #4
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end7
  %arrayidx19 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %type
  %13 = load %struct.op* (%struct.op*)** %arrayidx19, align 8, !tbaa !6
  %call20 = tail call %struct.op* %13(%struct.op* %o.addr.0) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call20, %cond.false ]
  %op_type21 = getelementptr inbounds %struct.op* %cond, i64 0, i32 4
  %14 = load i16* %op_type21, align 2, !tbaa !12
  %conv22 = zext i16 %14 to i32
  %conv23 = trunc i64 %type to i32
  %cmp24 = icmp eq i32 %conv22, %conv23
  br i1 %cmp24, label %if.end27, label %return

if.end27:                                         ; preds = %cond.end
  %call28 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @fold_constants to i32 (%struct.op*, ...)*)(%struct.op* %cond) #4
  %conv29 = sext i32 %call28 to i64
  %15 = inttoptr i64 %conv29 to %struct.op*
  br label %return

return:                                           ; preds = %cond.end, %if.end27
  %retval.0 = phi %struct.op* [ %15, %if.end27 ], [ %cond, %cond.end ]
  ret %struct.op* %retval.0
}

declare i32 @fold_constants(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_append_elem(i64 %type, %struct.op* %first, %struct.op* %last) #0 {
entry:
  %tobool = icmp eq %struct.op* %first, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tobool1 = icmp eq %struct.op* %last, null
  br i1 %tobool1, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %op_type = getelementptr inbounds %struct.op* %first, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %conv = zext i16 %0 to i32
  %conv4 = trunc i64 %type to i32
  %cmp = icmp eq i32 %conv, %conv4
  br i1 %cmp, label %lor.lhs.false, label %if.then10

lor.lhs.false:                                    ; preds = %if.end3
  %cmp6 = icmp ne i64 %type, 141
  %op_flags = getelementptr inbounds %struct.op* %first, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %1, 8
  %tobool9 = icmp eq i8 %and, 0
  %or.cond = or i1 %cmp6, %tobool9
  br i1 %or.cond, label %if.end11, label %if.then10

if.then10:                                        ; preds = %lor.lhs.false, %if.end3
  %call = tail call %struct.op* @Perl_newLISTOP(i64 %type, i64 0, %struct.op* %first, %struct.op* %last)
  br label %return

if.end11:                                         ; preds = %lor.lhs.false
  %and14 = and i8 %1, 4
  %tobool15 = icmp eq i8 %and14, 0
  br i1 %tobool15, label %if.else, label %if.then16

if.then16:                                        ; preds = %if.end11
  %2 = getelementptr inbounds %struct.op* %first, i64 1, i32 1
  %3 = load %struct.op** %2, align 8, !tbaa !70
  %op_sibling = getelementptr inbounds %struct.op* %3, i64 0, i32 1
  store %struct.op* %last, %struct.op** %op_sibling, align 8, !tbaa !17
  br label %if.end20

if.else:                                          ; preds = %if.end11
  %op_flags12 = getelementptr inbounds %struct.op* %first, i64 0, i32 6
  %or = or i8 %1, 4
  store i8 %or, i8* %op_flags12, align 1, !tbaa !14
  %4 = getelementptr inbounds %struct.op* %first, i64 1, i32 0
  store %struct.op* %last, %struct.op** %4, align 8, !tbaa !45
  %.pre37 = getelementptr inbounds %struct.op* %first, i64 1, i32 1
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then16
  %.pre-phi = phi %struct.op** [ %.pre37, %if.else ], [ %2, %if.then16 ]
  store %struct.op* %last, %struct.op** %.pre-phi, align 8, !tbaa !70
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end20, %if.then10
  %retval.0 = phi %struct.op* [ %call, %if.then10 ], [ %first, %if.end20 ], [ %last, %entry ], [ %first, %if.end ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_append_list(i64 %type, %struct.listop* %first, %struct.listop* %last) #0 {
entry:
  %tobool = icmp eq %struct.listop* %first, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.listop* %last to %struct.op*
  br label %return

if.end:                                           ; preds = %entry
  %tobool1 = icmp eq %struct.listop* %last, null
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %1 = bitcast %struct.listop* %first to %struct.op*
  br label %return

if.end3:                                          ; preds = %if.end
  %op_type = getelementptr inbounds %struct.listop* %first, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !89
  %conv = zext i16 %2 to i32
  %conv4 = trunc i64 %type to i32
  %cmp = icmp eq i32 %conv, %conv4
  br i1 %cmp, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end3
  %3 = bitcast %struct.listop* %first to %struct.op*
  %4 = bitcast %struct.listop* %last to %struct.op*
  %call = tail call i32 (i64, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @prepend_elem to i32 (i64, %struct.op*, %struct.op*, ...)*)(i64 %type, %struct.op* %3, %struct.op* %4) #4
  %conv7 = sext i32 %call to i64
  %5 = inttoptr i64 %conv7 to %struct.op*
  br label %return

if.end8:                                          ; preds = %if.end3
  %op_type9 = getelementptr inbounds %struct.listop* %last, i64 0, i32 4
  %6 = load i16* %op_type9, align 2, !tbaa !89
  %cmp12 = icmp eq i16 %6, %2
  br i1 %cmp12, label %if.end17, label %if.then14

if.then14:                                        ; preds = %if.end8
  %7 = bitcast %struct.listop* %first to %struct.op*
  %8 = bitcast %struct.listop* %last to %struct.op*
  %call15 = tail call i32 (i64, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @append_elem to i32 (i64, %struct.op*, %struct.op*, ...)*)(i64 %type, %struct.op* %7, %struct.op* %8) #4
  %conv16 = sext i32 %call15 to i64
  %9 = inttoptr i64 %conv16 to %struct.op*
  br label %return

if.end17:                                         ; preds = %if.end8
  %op_first = getelementptr inbounds %struct.listop* %last, i64 0, i32 8
  %10 = load %struct.op** %op_first, align 8, !tbaa !45
  %op_last = getelementptr inbounds %struct.listop* %first, i64 0, i32 9
  %11 = load %struct.op** %op_last, align 8, !tbaa !70
  %op_sibling = getelementptr inbounds %struct.op* %11, i64 0, i32 1
  store %struct.op* %10, %struct.op** %op_sibling, align 8, !tbaa !17
  %op_last18 = getelementptr inbounds %struct.listop* %last, i64 0, i32 9
  %12 = load %struct.op** %op_last18, align 8, !tbaa !70
  store %struct.op* %12, %struct.op** %op_last, align 8, !tbaa !70
  %op_flags = getelementptr inbounds %struct.listop* %last, i64 0, i32 6
  %13 = load i8* %op_flags, align 1, !tbaa !91
  %and = and i8 %13, 4
  %op_flags21 = getelementptr inbounds %struct.listop* %first, i64 0, i32 6
  %14 = load i8* %op_flags21, align 1, !tbaa !91
  %or = or i8 %14, %and
  store i8 %or, i8* %op_flags21, align 1, !tbaa !91
  %15 = bitcast %struct.listop* %last to i8*
  tail call void @Perl_safesysfree(i8* %15) #4
  %16 = bitcast %struct.listop* %first to %struct.op*
  br label %return

return:                                           ; preds = %if.end17, %if.then14, %if.then6, %if.then2, %if.then
  %retval.0 = phi %struct.op* [ %5, %if.then6 ], [ %9, %if.then14 ], [ %16, %if.end17 ], [ %1, %if.then2 ], [ %0, %if.then ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_prepend_elem(i64 %type, %struct.op* %first, %struct.op* %last) #0 {
entry:
  %tobool = icmp eq %struct.op* %first, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tobool1 = icmp eq %struct.op* %last, null
  br i1 %tobool1, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %op_type = getelementptr inbounds %struct.op* %last, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %conv = zext i16 %0 to i32
  %conv4 = trunc i64 %type to i32
  %cmp = icmp eq i32 %conv, %conv4
  br i1 %cmp, label %if.then6, label %if.end38

if.then6:                                         ; preds = %if.end3
  %cmp7 = icmp eq i64 %type, 141
  br i1 %cmp7, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then6
  %1 = getelementptr inbounds %struct.op* %last, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !45
  %op_sibling = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %3 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %op_sibling10 = getelementptr inbounds %struct.op* %first, i64 0, i32 1
  store %struct.op* %3, %struct.op** %op_sibling10, align 8, !tbaa !17
  store %struct.op* %first, %struct.op** %op_sibling, align 8, !tbaa !17
  %op_flags = getelementptr inbounds %struct.op* %first, i64 0, i32 6
  %4 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %4, 8
  %tobool14 = icmp eq i8 %and, 0
  %op_flags16 = getelementptr inbounds %struct.op* %last, i64 0, i32 6
  %5 = load i8* %op_flags16, align 1, !tbaa !14
  br i1 %tobool14, label %if.then15, label %if.end33

if.then15:                                        ; preds = %if.then9
  %and18 = and i8 %5, -9
  store i8 %and18, i8* %op_flags16, align 1, !tbaa !14
  br label %if.end33

if.else:                                          ; preds = %if.then6
  %op_flags21 = getelementptr inbounds %struct.op* %last, i64 0, i32 6
  %6 = load i8* %op_flags21, align 1, !tbaa !14
  %and23 = and i8 %6, 4
  %tobool24 = icmp eq i8 %and23, 0
  br i1 %tobool24, label %if.then25, label %if.end29

if.then25:                                        ; preds = %if.else
  %7 = getelementptr inbounds %struct.op* %last, i64 1, i32 1
  store %struct.op* %first, %struct.op** %7, align 8, !tbaa !70
  %or = or i8 %6, 4
  store i8 %or, i8* %op_flags21, align 1, !tbaa !14
  br label %if.end29

if.end29:                                         ; preds = %if.else, %if.then25
  %8 = phi i8 [ %6, %if.else ], [ %or, %if.then25 ]
  %9 = getelementptr inbounds %struct.op* %last, i64 1, i32 0
  %10 = load %struct.op** %9, align 8, !tbaa !45
  %op_sibling31 = getelementptr inbounds %struct.op* %first, i64 0, i32 1
  store %struct.op* %10, %struct.op** %op_sibling31, align 8, !tbaa !17
  store %struct.op* %first, %struct.op** %9, align 8, !tbaa !45
  br label %if.end33

if.end33:                                         ; preds = %if.then9, %if.then15, %if.end29
  %11 = phi i8 [ %and18, %if.then15 ], [ %8, %if.end29 ], [ %5, %if.then9 ]
  %op_flags34 = getelementptr inbounds %struct.op* %last, i64 0, i32 6
  %or36 = or i8 %11, 4
  store i8 %or36, i8* %op_flags34, align 1, !tbaa !14
  br label %return

if.end38:                                         ; preds = %if.end3
  %call = tail call %struct.op* @Perl_newLISTOP(i64 %type, i64 0, %struct.op* %first, %struct.op* %last)
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end38, %if.end33
  %retval.0 = phi %struct.op* [ %last, %if.end33 ], [ %call, %if.end38 ], [ %last, %entry ], [ %first, %if.end ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newNULLLIST() #0 {
entry:
  %call.i = tail call i8* @Perl_safesysmalloc(i64 40) #4
  %0 = bitcast i8* %call.i to %struct.op*
  tail call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 40, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i, i64 32
  %1 = bitcast i8* %op_type.i to i16*
  store i16 1, i16* %1, align 2, !tbaa !12
  %2 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 1), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %3 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %2, %struct.op* ()** %3, align 8, !tbaa !41
  %4 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %4, align 1, !tbaa !14
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %0, %struct.op** %op_next.i, align 8, !tbaa !42
  %5 = getelementptr inbounds i8* %call.i, i64 37
  store i8 0, i8* %5, align 1, !tbaa !11
  %6 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 1), align 8, !tbaa !1
  %and.i = and i64 %6, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %call4.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %0) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 1), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %entry
  %7 = phi i64 [ %6, %entry ], [ %.pre.i, %if.then.i ]
  %and6.i = and i64 %7, 8
  %tobool7.i = icmp eq i64 %and6.i, 0
  br i1 %tobool7.i, label %if.end11.i, label %if.then8.i

if.then8.i:                                       ; preds = %if.end.i
  %call9.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 1, i32 512) #4
  %conv10.i = sext i32 %call9.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %8 = bitcast i8* %op_targ.i to i64*
  store i64 %conv10.i, i64* %8, align 8, !tbaa !13
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then8.i, %if.end.i
  %9 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12.i = icmp eq i8* %9, null
  br i1 %tobool12.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end11.i
  %arrayidx13.i = getelementptr inbounds i8* %9, i64 1
  %10 = load i8* %arrayidx13.i, align 1, !tbaa !5
  %tobool15.i = icmp eq i8 %10, 0
  br i1 %tobool15.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %0) #4
  %11 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 1), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %11) #4
  br label %Perl_newOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end11.i
  %12 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 1), align 8, !tbaa !6
  %call18.i = tail call %struct.op* %12(%struct.op* %0) #4
  br label %Perl_newOP.exit

Perl_newOP.exit:                                  ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call18.i, %cond.false.i ]
  ret %struct.op* %cond.i
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_force_list(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %0, 141
  br i1 %cmp, label %if.end.i, label %if.end

if.end:                                           ; preds = %entry, %lor.lhs.false
  %call = tail call %struct.op* @Perl_newLISTOP(i64 141, i64 0, %struct.op* %o, %struct.op* null)
  %op_type.i.phi.trans.insert = getelementptr inbounds %struct.op* %call, i64 0, i32 4
  %.pre = load i16* %op_type.i.phi.trans.insert, align 2, !tbaa !12
  %phitmp = icmp eq i16 %.pre, 0
  br i1 %phitmp, label %Perl_op_null.exit, label %if.end.i

if.end.i:                                         ; preds = %lor.lhs.false, %if.end
  %o.pn = phi %struct.op* [ %call, %if.end ], [ %o, %lor.lhs.false ]
  %op_type.i9 = getelementptr inbounds %struct.op* %o.pn, i64 0, i32 4
  %call.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %o.pn) #4
  %1 = load i16* %op_type.i9, align 2, !tbaa !12
  %conv3.i = zext i16 %1 to i64
  %op_targ.i = getelementptr inbounds %struct.op* %o.pn, i64 0, i32 3
  store i64 %conv3.i, i64* %op_targ.i, align 8, !tbaa !13
  store i16 0, i16* %op_type.i9, align 2, !tbaa !12
  %2 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds %struct.op* %o.pn, i64 0, i32 2
  store %struct.op* ()* %2, %struct.op* ()** %op_ppaddr.i, align 8, !tbaa !41
  br label %Perl_op_null.exit

Perl_op_null.exit:                                ; preds = %if.end, %if.end.i
  %o.addr.08 = phi %struct.op* [ %call, %if.end ], [ %o.pn, %if.end.i ]
  ret %struct.op* %o.addr.08
}

declare i32 @force_list(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pmtrans(%struct.op* %o, %struct.op* %expr, %struct.op* %repl) #0 {
entry:
  %tlen = alloca i64, align 8
  %rlen = alloca i64, align 8
  %ulen = alloca i64, align 8
  %len = alloca i64, align 8
  %len63 = alloca i64, align 8
  %tmpbuf = alloca [14 x i8], align 1
  %range_mark = alloca i8, align 1
  %range_mark139 = alloca i8, align 1
  %op_sv = getelementptr inbounds %struct.op* %expr, i64 1
  %0 = bitcast %struct.op* %op_sv to %struct.sv**
  %1 = load %struct.sv** %0, align 8, !tbaa !18
  %op_sv1 = getelementptr inbounds %struct.op* %repl, i64 1
  %2 = bitcast %struct.op* %op_sv1 to %struct.sv**
  %3 = load %struct.sv** %2, align 8, !tbaa !18
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %4 = load i64* %sv_flags, align 8, !tbaa !34
  %and = and i64 %4, 262144
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %5 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_cur = getelementptr inbounds i8* %5, i64 8
  %6 = bitcast i8* %xpv_cur to i64*
  %7 = load i64* %6, align 8, !tbaa !37
  store i64 %7, i64* %tlen, align 8, !tbaa !1
  %xpv_pv = bitcast i8* %5 to i8**
  %8 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %1, i64* %tlen, i64 2) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %8, %cond.true ], [ %call, %cond.false ]
  %sv_flags3 = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %9 = load i64* %sv_flags3, align 8, !tbaa !34
  %and4 = and i64 %9, 262144
  %cmp5 = icmp eq i64 %and4, 0
  br i1 %cmp5, label %cond.false11, label %cond.true6

cond.true6:                                       ; preds = %cond.end
  %sv_any7 = getelementptr inbounds %struct.sv* %3, i64 0, i32 0
  %10 = load i8** %sv_any7, align 8, !tbaa !36
  %xpv_cur8 = getelementptr inbounds i8* %10, i64 8
  %11 = bitcast i8* %xpv_cur8 to i64*
  %12 = load i64* %11, align 8, !tbaa !37
  store i64 %12, i64* %rlen, align 8, !tbaa !1
  %xpv_pv10 = bitcast i8* %10 to i8**
  %13 = load i8** %xpv_pv10, align 8, !tbaa !39
  br label %cond.end13

cond.false11:                                     ; preds = %cond.end
  %call12 = call i8* @Perl_sv_2pv_flags(%struct.sv* %3, i64* %rlen, i64 2) #4
  br label %cond.end13

cond.end13:                                       ; preds = %cond.false11, %cond.true6
  %cond14 = phi i8* [ %13, %cond.true6 ], [ %call12, %cond.false11 ]
  %14 = load i64* @PL_hints, align 8, !tbaa !1
  %or = or i64 %14, 256
  store i64 %or, i64* @PL_hints, align 8, !tbaa !1
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %15 = load i8* %op_private, align 1, !tbaa !11
  %conv = zext i8 %15 to i32
  %and15 = and i32 %conv, 32
  %and19 = and i32 %conv, 16
  %conv20856 = zext i32 %and19 to i64
  %and23 = and i32 %conv, 8
  %16 = load i64* %sv_flags, align 8, !tbaa !34
  %and26 = and i64 %16, 536870912
  %tobool = icmp eq i64 %and26, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end13
  %or29 = or i8 %15, 1
  store i8 %or29, i8* %op_private, align 1, !tbaa !11
  br label %if.end

if.end:                                           ; preds = %cond.end13, %if.then
  %17 = phi i8 [ %15, %cond.end13 ], [ %or29, %if.then ]
  %18 = load i64* %sv_flags3, align 8, !tbaa !34
  %and32 = and i64 %18, 536870912
  %tobool33 = icmp eq i64 %and32, 0
  br i1 %tobool33, label %if.end39, label %if.then34

if.then34:                                        ; preds = %if.end
  %or37 = or i8 %17, 2
  store i8 %or37, i8* %op_private, align 1, !tbaa !11
  br label %if.end39

if.end39:                                         ; preds = %if.end, %if.then34
  %19 = phi i8 [ %17, %if.end ], [ %or37, %if.then34 ]
  %and42 = and i8 %19, 3
  %tobool43 = icmp eq i8 %and42, 0
  br i1 %tobool43, label %if.end400, label %if.then44

if.then44:                                        ; preds = %if.end39
  %call45 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8]* @.str34, i64 0, i64 0), i64 10) #4
  %20 = load i64* %tlen, align 8, !tbaa !1
  %add.ptr = getelementptr inbounds i8* %cond, i64 %20
  %21 = load i64* %rlen, align 8, !tbaa !1
  %add.ptr46 = getelementptr inbounds i8* %cond14, i64 %21
  %22 = load i8* %op_private, align 1, !tbaa !11
  %conv48 = zext i8 %22 to i32
  %and49 = and i32 %conv48, 1
  %and53 = and i32 %conv48, 2
  %tobool55 = icmp eq i32 %and49, 0
  br i1 %tobool55, label %if.then56, label %if.end59

if.then56:                                        ; preds = %if.then44
  store i64 %20, i64* %len, align 8, !tbaa !1
  %call57 = call i8* @Perl_bytes_to_utf8(i8* %cond, i64* %len) #4
  %23 = load i64* %len, align 8, !tbaa !1
  %add.ptr58 = getelementptr inbounds i8* %call57, i64 %23
  %.pre928 = load i64* %rlen, align 8
  br label %if.end59

if.end59:                                         ; preds = %if.then44, %if.then56
  %24 = phi i64 [ %21, %if.then44 ], [ %.pre928, %if.then56 ]
  %tend.0 = phi i8* [ %add.ptr, %if.then44 ], [ %add.ptr58, %if.then56 ]
  %t.0 = phi i8* [ %cond, %if.then44 ], [ %call57, %if.then56 ]
  %tsave.0 = phi i8* [ null, %if.then44 ], [ %call57, %if.then56 ]
  %tobool60 = icmp eq i32 %and53, 0
  %tobool61 = icmp ne i64 %24, 0
  %or.cond = and i1 %tobool60, %tobool61
  br i1 %or.cond, label %if.then62, label %if.end66

if.then62:                                        ; preds = %if.end59
  store i64 %24, i64* %len63, align 8, !tbaa !1
  %call64 = call i8* @Perl_bytes_to_utf8(i8* %cond14, i64* %len63) #4
  %25 = load i64* %len63, align 8, !tbaa !1
  %add.ptr65 = getelementptr inbounds i8* %call64, i64 %25
  br label %if.end66

if.end66:                                         ; preds = %if.end59, %if.then62
  %rend.0 = phi i8* [ %add.ptr65, %if.then62 ], [ %add.ptr46, %if.end59 ]
  %r.0 = phi i8* [ %call64, %if.then62 ], [ %cond14, %if.end59 ]
  %rsave.0 = phi i8* [ %call64, %if.then62 ], [ null, %if.end59 ]
  %tobool67 = icmp eq i32 %and15, 0
  br i1 %tobool67, label %if.else152, label %if.then68

if.then68:                                        ; preds = %if.end66
  %26 = load i64* %tlen, align 8, !tbaa !1
  %mul69 = shl i64 %26, 4
  %call70 = call i8* @Perl_safesysmalloc(i64 %mul69) #4
  %27 = bitcast i8* %call70 to i64*
  %call71 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0), i64 0) #4
  %cmp72917 = icmp ult i8* %t.0, %tend.0
  br i1 %cmp72917, label %while.body.lr.ph, label %while.end.thread

while.end.thread:                                 ; preds = %if.then68
  call void @qsort(i8* %call70, i64 0, i64 16, i32 (i8*, i8*)* @uvcompare) #4
  br label %while.end.for.end_crit_edge

while.body.lr.ph:                                 ; preds = %if.then68
  %sub.ptr.lhs.cast = ptrtoint i8* %tend.0 to i64
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end96
  %t.1919 = phi i8* [ %t.0, %while.body.lr.ph ], [ %t.2, %if.end96 ]
  %i.0918 = phi i64 [ 0, %while.body.lr.ph ], [ %inc, %if.end96 ]
  %sub.ptr.rhs.cast = ptrtoint i8* %t.1919 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call74 = call i64 @Perl_utf8n_to_uvuni(i8* %t.1919, i64 %sub.ptr.sub, i64* %ulen, i64 0) #4
  %mul75 = shl nsw i64 %i.0918, 1
  %arrayidx = getelementptr inbounds i64* %27, i64 %mul75
  store i64 %call74, i64* %arrayidx, align 8, !tbaa !1
  %28 = load i64* %ulen, align 8, !tbaa !1
  %add.ptr76 = getelementptr inbounds i8* %t.1919, i64 %28
  %cmp77 = icmp ult i8* %add.ptr76, %tend.0
  br i1 %cmp77, label %land.lhs.true79, label %if.else

land.lhs.true79:                                  ; preds = %while.body
  %29 = load i8* %add.ptr76, align 1, !tbaa !5
  %cmp81 = icmp eq i8 %29, -1
  br i1 %cmp81, label %if.then83, label %if.else

if.then83:                                        ; preds = %land.lhs.true79
  %add.ptr76.sum = add i64 %28, 1
  %incdec.ptr = getelementptr inbounds i8* %t.1919, i64 %add.ptr76.sum
  %sub.ptr.rhs.cast85 = ptrtoint i8* %incdec.ptr to i64
  %sub.ptr.sub86 = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast85
  %call87 = call i64 @Perl_utf8n_to_uvuni(i8* %incdec.ptr, i64 %sub.ptr.sub86, i64* %ulen, i64 0) #4
  %add862 = or i64 %mul75, 1
  %arrayidx89 = getelementptr inbounds i64* %27, i64 %add862
  store i64 %call87, i64* %arrayidx89, align 8, !tbaa !1
  %30 = load i64* %ulen, align 8, !tbaa !1
  %incdec.ptr.sum = add i64 %30, %add.ptr76.sum
  %add.ptr90 = getelementptr inbounds i8* %t.1919, i64 %incdec.ptr.sum
  br label %if.end96

if.else:                                          ; preds = %land.lhs.true79, %while.body
  %add94861 = or i64 %mul75, 1
  %arrayidx95 = getelementptr inbounds i64* %27, i64 %add94861
  store i64 %call74, i64* %arrayidx95, align 8, !tbaa !1
  br label %if.end96

if.end96:                                         ; preds = %if.else, %if.then83
  %t.2 = phi i8* [ %add.ptr90, %if.then83 ], [ %add.ptr76, %if.else ]
  %inc = add nsw i64 %i.0918, 1
  %cmp72 = icmp ult i8* %t.2, %tend.0
  br i1 %cmp72, label %while.body, label %while.end

while.end:                                        ; preds = %if.end96
  call void @qsort(i8* %call70, i64 %inc, i64 16, i32 (i8*, i8*)* @uvcompare) #4
  %cmp97913 = icmp sgt i64 %i.0918, -1
  br i1 %cmp97913, label %for.body.lr.ph, label %while.end.for.end_crit_edge

while.end.for.end_crit_edge:                      ; preds = %while.end.thread, %while.end
  %arraydecay132.pre = getelementptr inbounds [14 x i8]* %tmpbuf, i64 0, i64 0
  %sub.ptr.rhs.cast137.pre = ptrtoint [14 x i8]* %tmpbuf to i64
  br label %for.end

for.body.lr.ph:                                   ; preds = %while.end
  %arraydecay = getelementptr inbounds [14 x i8]* %tmpbuf, i64 0, i64 0
  %sub.ptr.rhs.cast108 = ptrtoint [14 x i8]* %tmpbuf to i64
  br label %for.body

for.body:                                         ; preds = %if.end122, %for.body.lr.ph
  %nextmin.0915 = phi i64 [ 0, %for.body.lr.ph ], [ %nextmin.0.add129, %if.end122 ]
  %j.0914 = phi i64 [ 0, %for.body.lr.ph ], [ %inc131, %if.end122 ]
  %mul99 = shl nsw i64 %j.0914, 1
  %arrayidx100 = getelementptr inbounds i64* %27, i64 %mul99
  %31 = load i64* %arrayidx100, align 8, !tbaa !1
  %sub = sub i64 %31, %nextmin.0915
  %cmp101 = icmp sgt i64 %sub, 0
  br i1 %cmp101, label %if.then103, label %if.end122

if.then103:                                       ; preds = %for.body
  %call104 = call i8* @Perl_uvuni_to_utf8(i8* %arraydecay, i64 %nextmin.0915) #4
  %sub.ptr.lhs.cast107 = ptrtoint i8* %call104 to i64
  %sub.ptr.sub109 = sub i64 %sub.ptr.lhs.cast107, %sub.ptr.rhs.cast108
  call void @Perl_sv_catpvn_flags(%struct.sv* %call71, i8* %arraydecay, i64 %sub.ptr.sub109, i64 2) #4
  %cmp110 = icmp sgt i64 %sub, 1
  br i1 %cmp110, label %if.then112, label %if.end122

if.then112:                                       ; preds = %if.then103
  store i8 -1, i8* %range_mark, align 1, !tbaa !5
  %sub114 = add i64 %31, -1
  %call115 = call i8* @Perl_uvuni_to_utf8(i8* %arraydecay, i64 %sub114) #4
  call void @Perl_sv_catpvn_flags(%struct.sv* %call71, i8* %range_mark, i64 1, i64 2) #4
  %sub.ptr.lhs.cast118 = ptrtoint i8* %call115 to i64
  %sub.ptr.sub120 = sub i64 %sub.ptr.lhs.cast118, %sub.ptr.rhs.cast108
  call void @Perl_sv_catpvn_flags(%struct.sv* %call71, i8* %arraydecay, i64 %sub.ptr.sub120, i64 2) #4
  br label %if.end122

if.end122:                                        ; preds = %if.then103, %if.then112, %for.body
  %add124860 = or i64 %mul99, 1
  %arrayidx125 = getelementptr inbounds i64* %27, i64 %add124860
  %32 = load i64* %arrayidx125, align 8, !tbaa !1
  %cmp126 = icmp ult i64 %32, %nextmin.0915
  %add129 = add i64 %32, 1
  %nextmin.0.add129 = select i1 %cmp126, i64 %nextmin.0915, i64 %add129
  %inc131 = add nsw i64 %j.0914, 1
  %exitcond921 = icmp eq i64 %inc131, %inc
  br i1 %exitcond921, label %for.end, label %for.body

for.end:                                          ; preds = %if.end122, %while.end.for.end_crit_edge
  %sub.ptr.rhs.cast137.pre-phi = phi i64 [ %sub.ptr.rhs.cast137.pre, %while.end.for.end_crit_edge ], [ %sub.ptr.rhs.cast108, %if.end122 ]
  %arraydecay132.pre-phi = phi i8* [ %arraydecay132.pre, %while.end.for.end_crit_edge ], [ %arraydecay, %if.end122 ]
  %nextmin.0.lcssa = phi i64 [ 0, %while.end.for.end_crit_edge ], [ %nextmin.0.add129, %if.end122 ]
  %call133 = call i8* @Perl_uvuni_to_utf8(i8* %arraydecay132.pre-phi, i64 %nextmin.0.lcssa) #4
  %sub.ptr.lhs.cast136 = ptrtoint i8* %call133 to i64
  %sub.ptr.sub138 = sub i64 %sub.ptr.lhs.cast136, %sub.ptr.rhs.cast137.pre-phi
  call void @Perl_sv_catpvn_flags(%struct.sv* %call71, i8* %arraydecay132.pre-phi, i64 %sub.ptr.sub138, i64 2) #4
  store i8 -1, i8* %range_mark139, align 1, !tbaa !5
  call void @Perl_sv_catpvn_flags(%struct.sv* %call71, i8* %range_mark139, i64 1, i64 2) #4
  %call141 = call i8* @Perl_uvuni_to_utf8_flags(i8* %arraydecay132.pre-phi, i64 2147483647, i64 8) #4
  %sub.ptr.lhs.cast144 = ptrtoint i8* %call141 to i64
  %sub.ptr.sub146 = sub i64 %sub.ptr.lhs.cast144, %sub.ptr.rhs.cast137.pre-phi
  call void @Perl_sv_catpvn_flags(%struct.sv* %call71, i8* %arraydecay132.pre-phi, i64 %sub.ptr.sub146, i64 2) #4
  %sv_any147 = getelementptr inbounds %struct.sv* %call71, i64 0, i32 0
  %33 = load i8** %sv_any147, align 8, !tbaa !36
  %xpv_pv148 = bitcast i8* %33 to i8**
  %34 = load i8** %xpv_pv148, align 8, !tbaa !39
  %xpv_cur150 = getelementptr inbounds i8* %33, i64 8
  %35 = bitcast i8* %xpv_cur150 to i64*
  %36 = load i64* %35, align 8, !tbaa !37
  store i64 %36, i64* %tlen, align 8, !tbaa !1
  %add.ptr151 = getelementptr inbounds i8* %34, i64 %36
  call void @Perl_safesysfree(i8* %call70) #4
  br label %if.end158

if.else152:                                       ; preds = %if.end66
  %37 = load i64* %rlen, align 8, !tbaa !1
  %tobool153 = icmp ne i64 %37, 0
  %tobool155 = icmp ne i32 %and19, 0
  %or.cond591 = or i1 %tobool153, %tobool155
  br i1 %or.cond591, label %if.end158, label %if.then156

if.then156:                                       ; preds = %if.else152
  %38 = load i64* %tlen, align 8, !tbaa !1
  store i64 %38, i64* %rlen, align 8, !tbaa !1
  br label %if.end158

if.end158:                                        ; preds = %if.else152, %if.then156, %for.end
  %transv.0 = phi %struct.sv* [ %call71, %for.end ], [ null, %if.else152 ], [ null, %if.then156 ]
  %tend.1 = phi i8* [ %add.ptr151, %for.end ], [ %tend.0, %if.else152 ], [ %tend.0, %if.then156 ]
  %rend.1 = phi i8* [ %rend.0, %for.end ], [ %rend.0, %if.else152 ], [ %tend.0, %if.then156 ]
  %r.1 = phi i8* [ %r.0, %for.end ], [ %r.0, %if.else152 ], [ %t.0, %if.then156 ]
  %t.3 = phi i8* [ %34, %for.end ], [ %t.0, %if.else152 ], [ %t.0, %if.then156 ]
  %tobool159 = icmp eq i32 %and23, 0
  br i1 %tobool159, label %if.then160, label %while.cond179.preheader

if.then160:                                       ; preds = %if.end158
  %39 = load i64* %rlen, align 8, !tbaa !1
  %notlhs = icmp eq i64 %39, 0
  %notrhs = icmp eq i32 %and19, 0
  %or.cond592.not = and i1 %notrhs, %notlhs
  %cmp164 = icmp eq i8* %t.3, %r.1
  %or.cond863 = or i1 %or.cond592.not, %cmp164
  br i1 %or.cond863, label %if.then172, label %lor.lhs.false166

lor.lhs.false166:                                 ; preds = %if.then160
  %40 = load i64* %tlen, align 8, !tbaa !1
  %cmp167 = icmp eq i64 %40, %39
  br i1 %cmp167, label %land.lhs.true169, label %while.cond179.preheader

land.lhs.true169:                                 ; preds = %lor.lhs.false166
  %call170 = call i32 @memcmp(i8* %t.3, i8* %r.1, i64 %39) #4
  %tobool171 = icmp eq i32 %call170, 0
  br i1 %tobool171, label %if.then172, label %while.cond179.preheader

if.then172:                                       ; preds = %if.then160, %land.lhs.true169
  %41 = load i8* %op_private, align 1, !tbaa !11
  %or175 = or i8 %41, 4
  store i8 %or175, i8* %op_private, align 1, !tbaa !11
  br label %while.cond179.preheader

while.cond179.preheader:                          ; preds = %lor.lhs.false166, %if.then172, %if.end158, %land.lhs.true169
  %cmp180895 = icmp ult i8* %t.3, %tend.1
  br i1 %cmp180895, label %while.body184.lr.ph, label %while.end355

while.body184.lr.ph:                              ; preds = %while.cond179.preheader
  %sub.ptr.lhs.cast188 = ptrtoint i8* %tend.1 to i64
  %sub.ptr.lhs.cast215 = ptrtoint i8* %rend.1 to i64
  br label %while.body184

while.body184:                                    ; preds = %while.body184.lr.ph, %if.end352
  %cmp182908 = phi i1 [ true, %while.body184.lr.ph ], [ %cmp182, %if.end352 ]
  %t.4907 = phi i8* [ %t.3, %while.body184.lr.ph ], [ %t.5, %if.end352 ]
  %r.2906 = phi i8* [ %r.1, %while.body184.lr.ph ], [ %r.3877, %if.end352 ]
  %final.0905 = phi i64 [ 0, %while.body184.lr.ph ], [ %final.2875, %if.end352 ]
  %havefinal.0904 = phi i64 [ 0, %while.body184.lr.ph ], [ %havefinal.1873, %if.end352 ]
  %max.0902 = phi i64 [ 0, %while.body184.lr.ph ], [ %max.2, %if.end352 ]
  %rlast.0901 = phi i64 [ 0, %while.body184.lr.ph ], [ %rlast.1871, %if.end352 ]
  %rfirst.0900 = phi i64 [ 1, %while.body184.lr.ph ], [ %rfirst.2, %if.end352 ]
  %tlast.0899 = phi i64 [ 0, %while.body184.lr.ph ], [ %tlast.1, %if.end352 ]
  %tfirst.0898 = phi i64 [ 1, %while.body184.lr.ph ], [ %add354, %if.end352 ]
  %grows.0896 = phi i64 [ 0, %while.body184.lr.ph ], [ %grows.2, %if.end352 ]
  br i1 %cmp182908, label %if.then187, label %if.end208

if.then187:                                       ; preds = %while.body184
  %sub.ptr.rhs.cast189 = ptrtoint i8* %t.4907 to i64
  %sub.ptr.sub190 = sub i64 %sub.ptr.lhs.cast188, %sub.ptr.rhs.cast189
  %call191 = call i64 @Perl_utf8n_to_uvuni(i8* %t.4907, i64 %sub.ptr.sub190, i64* %ulen, i64 0) #4
  %42 = load i64* %ulen, align 8, !tbaa !1
  %add.ptr192 = getelementptr inbounds i8* %t.4907, i64 %42
  %cmp193 = icmp ult i8* %add.ptr192, %tend.1
  br i1 %cmp193, label %land.lhs.true195, label %if.end208

land.lhs.true195:                                 ; preds = %if.then187
  %43 = load i8* %add.ptr192, align 1, !tbaa !5
  %cmp197 = icmp eq i8 %43, -1
  br i1 %cmp197, label %if.then199, label %if.end208

if.then199:                                       ; preds = %land.lhs.true195
  %add.ptr192.sum = add i64 %42, 1
  %incdec.ptr200 = getelementptr inbounds i8* %t.4907, i64 %add.ptr192.sum
  %sub.ptr.rhs.cast202 = ptrtoint i8* %incdec.ptr200 to i64
  %sub.ptr.sub203 = sub i64 %sub.ptr.lhs.cast188, %sub.ptr.rhs.cast202
  %call204 = call i64 @Perl_utf8n_to_uvuni(i8* %incdec.ptr200, i64 %sub.ptr.sub203, i64* %ulen, i64 0) #4
  %44 = load i64* %ulen, align 8, !tbaa !1
  %incdec.ptr200.sum = add i64 %44, %add.ptr192.sum
  %add.ptr205 = getelementptr inbounds i8* %t.4907, i64 %incdec.ptr200.sum
  br label %if.end208

if.end208:                                        ; preds = %if.then187, %land.lhs.true195, %if.then199, %while.body184
  %tfirst.1 = phi i64 [ %call191, %if.then199 ], [ %tfirst.0898, %while.body184 ], [ %call191, %land.lhs.true195 ], [ %call191, %if.then187 ]
  %tlast.1 = phi i64 [ %call204, %if.then199 ], [ %tlast.0899, %while.body184 ], [ %call191, %land.lhs.true195 ], [ %call191, %if.then187 ]
  %t.5 = phi i8* [ %add.ptr205, %if.then199 ], [ %t.4907, %while.body184 ], [ %add.ptr192, %land.lhs.true195 ], [ %add.ptr192, %if.then187 ]
  %cmp209 = icmp ugt i64 %rfirst.0900, %rlast.0901
  br i1 %cmp209, label %if.then211, label %if.end241

if.then211:                                       ; preds = %if.end208
  %cmp212 = icmp ult i8* %r.2906, %rend.1
  br i1 %cmp212, label %if.then214, label %if.end241.thread

if.then214:                                       ; preds = %if.then211
  %sub.ptr.rhs.cast216 = ptrtoint i8* %r.2906 to i64
  %sub.ptr.sub217 = sub i64 %sub.ptr.lhs.cast215, %sub.ptr.rhs.cast216
  %call218 = call i64 @Perl_utf8n_to_uvuni(i8* %r.2906, i64 %sub.ptr.sub217, i64* %ulen, i64 0) #4
  %45 = load i64* %ulen, align 8, !tbaa !1
  %add.ptr219 = getelementptr inbounds i8* %r.2906, i64 %45
  %cmp220 = icmp ult i8* %add.ptr219, %rend.1
  br i1 %cmp220, label %land.lhs.true222, label %if.end241

land.lhs.true222:                                 ; preds = %if.then214
  %46 = load i8* %add.ptr219, align 1, !tbaa !5
  %cmp224 = icmp eq i8 %46, -1
  br i1 %cmp224, label %if.then226, label %if.end241

if.then226:                                       ; preds = %land.lhs.true222
  %add.ptr219.sum = add i64 %45, 1
  %incdec.ptr227 = getelementptr inbounds i8* %r.2906, i64 %add.ptr219.sum
  %sub.ptr.rhs.cast229 = ptrtoint i8* %incdec.ptr227 to i64
  %sub.ptr.sub230 = sub i64 %sub.ptr.lhs.cast215, %sub.ptr.rhs.cast229
  %call231 = call i64 @Perl_utf8n_to_uvuni(i8* %incdec.ptr227, i64 %sub.ptr.sub230, i64* %ulen, i64 0) #4
  %47 = load i64* %ulen, align 8, !tbaa !1
  %incdec.ptr227.sum = add i64 %47, %add.ptr219.sum
  %add.ptr232 = getelementptr inbounds i8* %r.2906, i64 %incdec.ptr227.sum
  br label %if.end241

if.end241.thread:                                 ; preds = %if.then211
  %inc236 = add nsw i64 %havefinal.0904, 1
  %tobool237 = icmp eq i64 %havefinal.0904, 0
  %rlast.0.final.0 = select i1 %tobool237, i64 %rlast.0901, i64 %final.0905
  %sub242865 = sub i64 %tlast.1, %tfirst.1
  br label %if.then251

if.end241:                                        ; preds = %if.then214, %land.lhs.true222, %if.then226, %if.end208
  %rfirst.1 = phi i64 [ %call218, %if.then226 ], [ %rfirst.0900, %if.end208 ], [ %call218, %land.lhs.true222 ], [ %call218, %if.then214 ]
  %rlast.1 = phi i64 [ %call231, %if.then226 ], [ %rlast.0901, %if.end208 ], [ %call218, %land.lhs.true222 ], [ %call218, %if.then214 ]
  %r.3 = phi i8* [ %add.ptr232, %if.then226 ], [ %r.2906, %if.end208 ], [ %add.ptr219, %land.lhs.true222 ], [ %add.ptr219, %if.then214 ]
  %sub242 = sub i64 %tlast.1, %tfirst.1
  %sub243 = sub i64 %rlast.1, %rfirst.1
  %cmp244 = icmp sgt i64 %sub242, %sub243
  %sub243.sub242 = select i1 %cmp244, i64 %sub243, i64 %sub242
  %cmp249 = icmp eq i64 %rfirst.1, 4294967295
  br i1 %cmp249, label %if.then251, label %if.else257

if.then251:                                       ; preds = %if.end241.thread, %if.end241
  %sub242879 = phi i64 [ %sub242865, %if.end241.thread ], [ %sub242, %if.end241 ]
  %r.3878 = phi i8* [ %r.2906, %if.end241.thread ], [ %r.3, %if.end241 ]
  %final.2876 = phi i64 [ %rlast.0.final.0, %if.end241.thread ], [ %final.0905, %if.end241 ]
  %havefinal.1874 = phi i64 [ %inc236, %if.end241.thread ], [ %havefinal.0904, %if.end241 ]
  %rlast.1872 = phi i64 [ 4294967295, %if.end241.thread ], [ %rlast.1, %if.end241 ]
  %cmp252 = icmp sgt i64 %sub242879, 0
  br i1 %cmp252, label %if.then254, label %if.else255

if.then254:                                       ; preds = %if.then251
  call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %call45, i8* getelementptr inbounds ([18 x i8]* @.str36, i64 0, i64 0), i64 %tfirst.1, i64 %tlast.1) #4
  br label %if.end352

if.else255:                                       ; preds = %if.then251
  call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %call45, i8* getelementptr inbounds ([13 x i8]* @.str37, i64 0, i64 0), i64 %tfirst.1) #4
  br label %if.end352

if.else257:                                       ; preds = %if.end241
  %cmp258 = icmp sgt i64 %sub243.sub242, 0
  br i1 %cmp258, label %if.then260, label %if.else262

if.then260:                                       ; preds = %if.else257
  %add261 = add i64 %sub243.sub242, %tfirst.1
  call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %call45, i8* getelementptr inbounds ([19 x i8]* @.str38, i64 0, i64 0), i64 %tfirst.1, i64 %add261, i64 %rfirst.1) #4
  br label %if.end263

if.else262:                                       ; preds = %if.else257
  call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %call45, i8* getelementptr inbounds ([14 x i8]* @.str39, i64 0, i64 0), i64 %tfirst.1, i64 %rfirst.1) #4
  br label %if.end263

if.end263:                                        ; preds = %if.else262, %if.then260
  %add264 = add i64 %sub243.sub242, %rfirst.1
  %cmp265 = icmp ugt i64 %add264, %max.0902
  %add264.max.0 = select i1 %cmp265, i64 %add264, i64 %max.0902
  %tobool270 = icmp eq i64 %grows.0896, 0
  br i1 %tobool270, label %if.then271, label %if.end349

if.then271:                                       ; preds = %if.end263
  %cmp272 = icmp ult i64 %tfirst.1, %rfirst.1
  br i1 %cmp272, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then271
  %cmp274 = icmp ult i64 %tfirst.1, 128
  br i1 %cmp274, label %cond.end305, label %cond.false277

cond.false277:                                    ; preds = %land.rhs
  %cmp278 = icmp ult i64 %tfirst.1, 2048
  br i1 %cmp278, label %cond.end305, label %cond.false281

cond.false281:                                    ; preds = %cond.false277
  %cmp282 = icmp ult i64 %tfirst.1, 65536
  br i1 %cmp282, label %cond.end305, label %cond.false285

cond.false285:                                    ; preds = %cond.false281
  %cmp286 = icmp ult i64 %tfirst.1, 2097152
  br i1 %cmp286, label %cond.end305, label %cond.false289

cond.false289:                                    ; preds = %cond.false285
  %cmp290 = icmp ult i64 %tfirst.1, 67108864
  br i1 %cmp290, label %cond.end305, label %cond.false293

cond.false293:                                    ; preds = %cond.false289
  %cmp294 = icmp ult i64 %tfirst.1, 2147483648
  %cond296 = select i1 %cmp294, i32 6, i32 7
  br label %cond.end305

cond.end305:                                      ; preds = %cond.false277, %cond.false285, %cond.false289, %cond.false293, %cond.false281, %land.rhs
  %cond306 = phi i32 [ 1, %land.rhs ], [ 2, %cond.false277 ], [ 3, %cond.false281 ], [ 4, %cond.false285 ], [ %cond296, %cond.false293 ], [ 5, %cond.false289 ]
  %cmp308 = icmp ult i64 %add264, 128
  br i1 %cmp308, label %cond.end344, label %cond.false311

cond.false311:                                    ; preds = %cond.end305
  %cmp313 = icmp ult i64 %add264, 2048
  br i1 %cmp313, label %cond.end344, label %cond.false316

cond.false316:                                    ; preds = %cond.false311
  %cmp318 = icmp ult i64 %add264, 65536
  br i1 %cmp318, label %cond.end344, label %cond.false321

cond.false321:                                    ; preds = %cond.false316
  %cmp323 = icmp ult i64 %add264, 2097152
  br i1 %cmp323, label %cond.end344, label %cond.false326

cond.false326:                                    ; preds = %cond.false321
  %cmp328 = icmp ult i64 %add264, 67108864
  br i1 %cmp328, label %cond.end344, label %cond.false331

cond.false331:                                    ; preds = %cond.false326
  %cmp333 = icmp ult i64 %add264, 2147483648
  %cond335 = select i1 %cmp333, i32 6, i32 7
  br label %cond.end344

cond.end344:                                      ; preds = %cond.false311, %cond.false321, %cond.false326, %cond.false331, %cond.false316, %cond.end305
  %cond345 = phi i32 [ 1, %cond.end305 ], [ 2, %cond.false311 ], [ 3, %cond.false316 ], [ 4, %cond.false321 ], [ %cond335, %cond.false331 ], [ 5, %cond.false326 ]
  %cmp346 = icmp ult i32 %cond306, %cond345
  br label %land.end

land.end:                                         ; preds = %cond.end344, %if.then271
  %48 = phi i1 [ false, %if.then271 ], [ %cmp346, %cond.end344 ]
  %conv348 = zext i1 %48 to i64
  br label %if.end349

if.end349:                                        ; preds = %if.end263, %land.end
  %grows.1 = phi i64 [ %grows.0896, %if.end263 ], [ %conv348, %land.end ]
  %add350 = add i64 %rfirst.1, 1
  %add351 = add i64 %add350, %sub243.sub242
  br label %if.end352

if.end352:                                        ; preds = %if.then254, %if.else255, %if.end349
  %r.3877 = phi i8* [ %r.3878, %if.then254 ], [ %r.3878, %if.else255 ], [ %r.3, %if.end349 ]
  %final.2875 = phi i64 [ %final.2876, %if.then254 ], [ %final.2876, %if.else255 ], [ %final.0905, %if.end349 ]
  %havefinal.1873 = phi i64 [ %havefinal.1874, %if.then254 ], [ %havefinal.1874, %if.else255 ], [ %havefinal.0904, %if.end349 ]
  %rlast.1871 = phi i64 [ %rlast.1872, %if.then254 ], [ %rlast.1872, %if.else255 ], [ %rlast.1, %if.end349 ]
  %grows.2 = phi i64 [ %grows.0896, %if.then254 ], [ %grows.0896, %if.else255 ], [ %grows.1, %if.end349 ]
  %rfirst.2 = phi i64 [ 4294967295, %if.then254 ], [ 4294967295, %if.else255 ], [ %add351, %if.end349 ]
  %diff.1 = phi i64 [ %sub242879, %if.then254 ], [ %sub242879, %if.else255 ], [ %sub243.sub242, %if.end349 ]
  %max.2 = phi i64 [ %max.0902, %if.then254 ], [ %max.0902, %if.else255 ], [ %add264.max.0, %if.end349 ]
  %add353 = add i64 %tfirst.1, 1
  %add354 = add i64 %add353, %diff.1
  %cmp180 = icmp uge i8* %t.5, %tend.1
  %cmp182 = icmp ugt i64 %add354, %tlast.1
  %or.cond864 = and i1 %cmp180, %cmp182
  br i1 %or.cond864, label %while.end355, label %while.body184

while.end355:                                     ; preds = %if.end352, %while.cond179.preheader
  %final.0.lcssa = phi i64 [ 0, %while.cond179.preheader ], [ %final.2875, %if.end352 ]
  %havefinal.0.lcssa = phi i64 [ 0, %while.cond179.preheader ], [ %havefinal.1873, %if.end352 ]
  %max.0.lcssa = phi i64 [ 0, %while.cond179.preheader ], [ %max.2, %if.end352 ]
  %grows.0.lcssa = phi i64 [ 0, %while.cond179.preheader ], [ %grows.2, %if.end352 ]
  %inc356 = add i64 %max.0.lcssa, 1
  %tobool357 = icmp eq i32 %and19, 0
  %inc359 = add i64 %max.0.lcssa, 2
  %conv20856.inc359 = select i1 %tobool357, i64 %conv20856, i64 %inc359
  %inc356.inc359 = select i1 %tobool357, i64 %inc356, i64 %inc359
  %cmp361 = icmp ugt i64 %inc356.inc359, 65535
  br i1 %cmp361, label %if.end370, label %if.else364

if.else364:                                       ; preds = %while.end355
  %cmp365 = icmp ugt i64 %inc356.inc359, 255
  %. = select i1 %cmp365, i64 16, i64 8
  br label %if.end370

if.end370:                                        ; preds = %if.else364, %while.end355
  %bits.0 = phi i64 [ 32, %while.end355 ], [ %., %if.else364 ]
  %op_pv = getelementptr inbounds %struct.op* %o, i64 1
  %49 = bitcast %struct.op* %op_pv to i8**
  %50 = load i8** %49, align 8, !tbaa !20
  call void @Perl_safesysfree(i8* %50) #4
  %call371 = call %struct.sv* @Perl_swash_init(i8* getelementptr inbounds ([5 x i8]* @.str40, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0), %struct.sv* %call45, i64 %bits.0, i64 %inc356) #4
  %51 = bitcast %struct.op* %op_pv to %struct.sv**
  %52 = getelementptr inbounds %struct.op* %op_pv, i64 0, i32 0
  %call371.c = bitcast %struct.sv* %call371 to %struct.op*
  store %struct.op* %call371.c, %struct.op** %52, align 8, !tbaa !18
  call void @Perl_sv_free(%struct.sv* %call45) #4
  %tobool373 = icmp eq %struct.sv* %transv.0, null
  br i1 %tobool373, label %if.end375, label %if.then374

if.then374:                                       ; preds = %if.end370
  call void @Perl_sv_free(%struct.sv* %transv.0) #4
  br label %if.end375

if.end375:                                        ; preds = %if.end370, %if.then374
  %tobool376 = icmp eq i64 %conv20856.inc359, 0
  %tobool378 = icmp ne i64 %havefinal.0.lcssa, 0
  %or.cond593 = and i1 %tobool376, %tobool378
  %53 = load i64* %rlen, align 8
  %tobool380 = icmp ne i64 %53, 0
  %or.cond594 = and i1 %or.cond593, %tobool380
  br i1 %or.cond594, label %if.then381, label %if.end386

if.then381:                                       ; preds = %if.end375
  %54 = load %struct.sv** %51, align 8, !tbaa !18
  %sv_any383 = getelementptr inbounds %struct.sv* %54, i64 0, i32 0
  %55 = load i8** %sv_any383, align 8, !tbaa !36
  %xrv_rv = bitcast i8* %55 to %struct.sv**
  %56 = load %struct.sv** %xrv_rv, align 8, !tbaa !98
  %57 = bitcast %struct.sv* %56 to %struct.hv*
  %call384 = call %struct.sv* @Perl_newSVuv(i64 %final.0.lcssa) #4
  %call385 = call %struct.sv** @Perl_hv_store(%struct.hv* %57, i8* getelementptr inbounds ([6 x i8]* @.str41, i64 0, i64 0), i64 5, %struct.sv* %call384, i64 0) #4
  br label %if.end386

if.end386:                                        ; preds = %if.end375, %if.then381
  %tobool387 = icmp eq i64 %grows.0.lcssa, 0
  br i1 %tobool387, label %if.end393, label %if.then388

if.then388:                                       ; preds = %if.end386
  %58 = load i8* %op_private, align 1, !tbaa !11
  %or391 = or i8 %58, 64
  store i8 %or391, i8* %op_private, align 1, !tbaa !11
  br label %if.end393

if.end393:                                        ; preds = %if.end386, %if.then388
  %tobool394 = icmp eq i8* %tsave.0, null
  br i1 %tobool394, label %if.end396, label %if.then395

if.then395:                                       ; preds = %if.end393
  call void @Perl_safesysfree(i8* %tsave.0) #4
  br label %if.end396

if.end396:                                        ; preds = %if.end393, %if.then395
  %tobool397 = icmp eq i8* %rsave.0, null
  br i1 %tobool397, label %if.end399, label %if.then398

if.then398:                                       ; preds = %if.end396
  call void @Perl_safesysfree(i8* %rsave.0) #4
  br label %if.end399

if.end399:                                        ; preds = %if.end396, %if.then398
  call void @Perl_op_free(%struct.op* %expr)
  call void @Perl_op_free(%struct.op* %repl)
  br label %return

if.end400:                                        ; preds = %if.end39
  %op_pv401 = getelementptr inbounds %struct.op* %o, i64 1
  %59 = bitcast %struct.op* %op_pv401 to i8**
  %60 = load i8** %59, align 8, !tbaa !20
  %61 = bitcast i8* %60 to i16*
  %tobool402 = icmp eq i32 %and15, 0
  br i1 %tobool402, label %if.else498, label %if.then403

if.then403:                                       ; preds = %if.end400
  call void @llvm.memset.p0i8.i64(i8* %60, i8 0, i64 512, i32 1, i1 false)
  %62 = load i64* %tlen, align 8, !tbaa !1
  %cmp405893 = icmp sgt i64 %62, 0
  br i1 %cmp405893, label %for.body407, label %for.cond413.preheader

for.cond413.preheader:                            ; preds = %for.body407, %if.then403
  %tobool423 = icmp eq i32 %and19, 0
  br i1 %tobool423, label %for.body416.us, label %for.body416

for.body416.us:                                   ; preds = %for.cond413.preheader, %for.inc454.us
  %i.2892.us = phi i64 [ %inc455.us, %for.inc454.us ], [ 0, %for.cond413.preheader ]
  %j.1891.us = phi i64 [ %j.2.us, %for.inc454.us ], [ 0, %for.cond413.preheader ]
  %grows.3890.us = phi i64 [ %grows.5.us, %for.inc454.us ], [ 0, %for.cond413.preheader ]
  %arrayidx417.us = getelementptr inbounds i16* %61, i64 %i.2892.us
  %63 = load i16* %arrayidx417.us, align 2, !tbaa !100
  %tobool418.us = icmp eq i16 %63, 0
  br i1 %tobool418.us, label %if.then419.us, label %for.inc454.us

if.then419.us:                                    ; preds = %for.body416.us
  %64 = load i64* %rlen, align 8, !tbaa !1
  %cmp420.us = icmp slt i64 %j.1891.us, %64
  br i1 %cmp420.us, label %if.else438.us, label %if.else426.us

if.else426.us:                                    ; preds = %if.then419.us
  %tobool427.us = icmp eq i64 %64, 0
  br i1 %tobool427.us, label %if.else433.us, label %if.then428.us

if.then428.us:                                    ; preds = %if.else426.us
  %sub429.us = add nsw i64 %j.1891.us, -1
  %arrayidx430.us = getelementptr inbounds i8* %cond14, i64 %sub429.us
  %65 = load i8* %arrayidx430.us, align 1, !tbaa !5
  %conv431.us = zext i8 %65 to i16
  store i16 %conv431.us, i16* %arrayidx417.us, align 2, !tbaa !100
  br label %for.inc454.us

if.else433.us:                                    ; preds = %if.else426.us
  %conv434.us = trunc i64 %i.2892.us to i16
  store i16 %conv434.us, i16* %arrayidx417.us, align 2, !tbaa !100
  br label %for.inc454.us

if.else438.us:                                    ; preds = %if.then419.us
  %cmp439.us = icmp slt i64 %i.2892.us, 128
  %arrayidx442.us = getelementptr inbounds i8* %cond14, i64 %j.1891.us
  %66 = load i8* %arrayidx442.us, align 1, !tbaa !5
  br i1 %cmp439.us, label %land.lhs.true441.us, label %if.end447.us

land.lhs.true441.us:                              ; preds = %if.else438.us
  %cmp444.us = icmp slt i8 %66, 0
  %.grows.3.us = select i1 %cmp444.us, i64 1, i64 %grows.3890.us
  br label %if.end447.us

if.end447.us:                                     ; preds = %if.else438.us, %land.lhs.true441.us
  %grows.4.us = phi i64 [ %.grows.3.us, %land.lhs.true441.us ], [ %grows.3890.us, %if.else438.us ]
  %inc448.us = add nsw i64 %j.1891.us, 1
  %conv450.us = zext i8 %66 to i16
  store i16 %conv450.us, i16* %arrayidx417.us, align 2, !tbaa !100
  br label %for.inc454.us

for.inc454.us:                                    ; preds = %if.end447.us, %if.else433.us, %if.then428.us, %for.body416.us
  %grows.5.us = phi i64 [ %grows.3890.us, %for.body416.us ], [ %grows.3890.us, %if.then428.us ], [ %grows.3890.us, %if.else433.us ], [ %grows.4.us, %if.end447.us ]
  %j.2.us = phi i64 [ %j.1891.us, %for.body416.us ], [ %j.1891.us, %if.then428.us ], [ %j.1891.us, %if.else433.us ], [ %inc448.us, %if.end447.us ]
  %inc455.us = add nsw i64 %i.2892.us, 1
  %exitcond922 = icmp eq i64 %inc455.us, 256
  br i1 %exitcond922, label %for.end456, label %for.body416.us

for.body407:                                      ; preds = %if.then403, %for.body407
  %i.1894 = phi i64 [ %inc411, %for.body407 ], [ 0, %if.then403 ]
  %arrayidx408 = getelementptr inbounds i8* %cond, i64 %i.1894
  %67 = load i8* %arrayidx408, align 1, !tbaa !5
  %idxprom = zext i8 %67 to i64
  %arrayidx409 = getelementptr inbounds i16* %61, i64 %idxprom
  store i16 -1, i16* %arrayidx409, align 2, !tbaa !100
  %inc411 = add nsw i64 %i.1894, 1
  %cmp405 = icmp slt i64 %inc411, %62
  br i1 %cmp405, label %for.body407, label %for.cond413.preheader

for.body416:                                      ; preds = %for.cond413.preheader, %for.inc454
  %i.2892 = phi i64 [ %inc455, %for.inc454 ], [ 0, %for.cond413.preheader ]
  %j.1891 = phi i64 [ %j.2, %for.inc454 ], [ 0, %for.cond413.preheader ]
  %grows.3890 = phi i64 [ %grows.5, %for.inc454 ], [ 0, %for.cond413.preheader ]
  %arrayidx417 = getelementptr inbounds i16* %61, i64 %i.2892
  %68 = load i16* %arrayidx417, align 2, !tbaa !100
  %tobool418 = icmp eq i16 %68, 0
  br i1 %tobool418, label %if.then419, label %for.inc454

if.then419:                                       ; preds = %for.body416
  %69 = load i64* %rlen, align 8, !tbaa !1
  %cmp420 = icmp slt i64 %j.1891, %69
  br i1 %cmp420, label %if.else438, label %if.then424

if.then424:                                       ; preds = %if.then419
  store i16 -2, i16* %arrayidx417, align 2, !tbaa !100
  br label %for.inc454

if.else438:                                       ; preds = %if.then419
  %cmp439 = icmp slt i64 %i.2892, 128
  %arrayidx442 = getelementptr inbounds i8* %cond14, i64 %j.1891
  %70 = load i8* %arrayidx442, align 1, !tbaa !5
  br i1 %cmp439, label %land.lhs.true441, label %if.end447

land.lhs.true441:                                 ; preds = %if.else438
  %cmp444 = icmp slt i8 %70, 0
  %.grows.3 = select i1 %cmp444, i64 1, i64 %grows.3890
  br label %if.end447

if.end447:                                        ; preds = %if.else438, %land.lhs.true441
  %grows.4 = phi i64 [ %.grows.3, %land.lhs.true441 ], [ %grows.3890, %if.else438 ]
  %inc448 = add nsw i64 %j.1891, 1
  %conv450 = zext i8 %70 to i16
  store i16 %conv450, i16* %arrayidx417, align 2, !tbaa !100
  br label %for.inc454

for.inc454:                                       ; preds = %for.body416, %if.then424, %if.end447
  %grows.5 = phi i64 [ %grows.3890, %for.body416 ], [ %grows.3890, %if.then424 ], [ %grows.4, %if.end447 ]
  %j.2 = phi i64 [ %j.1891, %for.body416 ], [ %j.1891, %if.then424 ], [ %inc448, %if.end447 ]
  %inc455 = add nsw i64 %i.2892, 1
  %exitcond = icmp eq i64 %inc455, 256
  br i1 %exitcond, label %for.end456, label %for.body416

for.end456:                                       ; preds = %for.inc454, %for.inc454.us
  %j.1.lcssa = phi i64 [ %j.2.us, %for.inc454.us ], [ %j.2, %for.inc454 ]
  %grows.3.lcssa = phi i64 [ %grows.5.us, %for.inc454.us ], [ %grows.5, %for.inc454 ]
  br i1 %tobool423, label %if.then458, label %if.end583

if.then458:                                       ; preds = %for.end456
  %71 = load i64* %rlen, align 8, !tbaa !1
  %tobool459 = icmp eq i64 %71, 0
  br i1 %tobool459, label %if.then460, label %if.else468

if.then460:                                       ; preds = %if.then458
  %tobool461 = icmp eq i32 %and23, 0
  br i1 %tobool461, label %if.then462, label %if.end480

if.then462:                                       ; preds = %if.then460
  %72 = load i8* %op_private, align 1, !tbaa !11
  %or465 = or i8 %72, 4
  store i8 %or465, i8* %op_private, align 1, !tbaa !11
  br label %if.end480

if.else468:                                       ; preds = %if.then458
  %cmp469 = icmp slt i64 %j.1.lcssa, %71
  br i1 %cmp469, label %if.else473, label %if.then471

if.then471:                                       ; preds = %if.else468
  %sub472 = add i64 %71, -1
  br label %if.end480

if.else473:                                       ; preds = %if.else468
  %add474 = sub i64 257, %j.1.lcssa
  %sub475 = add i64 %add474, %71
  %mul476 = shl i64 %sub475, 1
  %call477 = call i8* @Perl_safesysrealloc(i8* %60, i64 %mul476) #4
  %73 = bitcast i8* %call477 to i16*
  %74 = getelementptr inbounds %struct.op* %op_pv401, i64 0, i32 0
  %call477.c = bitcast i8* %call477 to %struct.op*
  store %struct.op* %call477.c, %struct.op** %74, align 8, !tbaa !20
  %.pre926 = load i64* %rlen, align 8, !tbaa !1
  br label %if.end480

if.end480:                                        ; preds = %if.then460, %if.then471, %if.else473, %if.then462
  %75 = phi i64 [ %71, %if.then471 ], [ %.pre926, %if.else473 ], [ 0, %if.then460 ], [ 0, %if.then462 ]
  %tbl.0 = phi i16* [ %61, %if.then471 ], [ %73, %if.else473 ], [ %61, %if.then460 ], [ %61, %if.then462 ]
  %j.3 = phi i64 [ %sub472, %if.then471 ], [ %j.1.lcssa, %if.else473 ], [ 0, %if.then460 ], [ 0, %if.then462 ]
  %sub481 = sub i64 %75, %j.3
  %conv482 = trunc i64 %sub481 to i16
  %arrayidx483 = getelementptr inbounds i16* %tbl.0, i64 256
  store i16 %conv482, i16* %arrayidx483, align 2, !tbaa !100
  %cmp486888 = icmp sgt i64 %sub481, 0
  br i1 %cmp486888, label %for.body488.preheader, label %if.end583

for.body488.preheader:                            ; preds = %if.end480
  %76 = sub i64 %75, %j.3
  %n.vec = and i64 %76, -2
  %cmp.zero = icmp eq i64 %n.vec, 0
  br i1 %cmp.zero, label %middle.block, label %vector.memcheck

vector.memcheck:                                  ; preds = %for.body488.preheader
  %77 = add i64 %75, 256
  %78 = sub i64 %77, %j.3
  %79 = add i64 %75, -1
  %scevgep936 = getelementptr i16* %tbl.0, i64 %78
  %scevgep = getelementptr i16* %tbl.0, i64 257
  %scevgep939 = getelementptr i8* %cond14, i64 %79
  %scevgep938 = getelementptr i8* %cond14, i64 %j.3
  %scevgep936937 = bitcast i16* %scevgep936 to i8*
  %scevgep935 = bitcast i16* %scevgep to i8*
  %bound1 = icmp ule i8* %scevgep938, %scevgep936937
  %bound0 = icmp ule i8* %scevgep935, %scevgep939
  %memcheck.conflict = and i1 %bound0, %bound1
  br i1 %memcheck.conflict, label %middle.block, label %vector.body

vector.body:                                      ; preds = %vector.memcheck, %vector.body
  %index = phi i64 [ %index.next, %vector.body ], [ 0, %vector.memcheck ]
  %80 = add i64 %index, %j.3
  %81 = getelementptr inbounds i8* %cond14, i64 %80
  %82 = bitcast i8* %81 to <2 x i8>*
  %wide.load = load <2 x i8>* %82, align 1
  %83 = zext <2 x i8> %wide.load to <2 x i16>
  %84 = add i64 %index, 257
  %85 = getelementptr inbounds i16* %tbl.0, i64 %84
  %86 = bitcast i16* %85 to <2 x i16>*
  store <2 x i16> %83, <2 x i16>* %86, align 2
  %index.next = add i64 %index, 2
  %87 = icmp eq i64 %index.next, %n.vec
  br i1 %87, label %middle.block, label %vector.body, !llvm.loop !101

middle.block:                                     ; preds = %vector.body, %vector.memcheck, %for.body488.preheader
  %resume.val = phi i64 [ 0, %for.body488.preheader ], [ 0, %vector.memcheck ], [ %n.vec, %vector.body ]
  %cmp.n = icmp eq i64 %76, %resume.val
  br i1 %cmp.n, label %if.end583, label %for.body488

for.body488:                                      ; preds = %middle.block, %for.body488
  %i.3889 = phi i64 [ %inc495, %for.body488 ], [ %resume.val, %middle.block ]
  %add489 = add nsw i64 %i.3889, %j.3
  %arrayidx490 = getelementptr inbounds i8* %cond14, i64 %add489
  %88 = load i8* %arrayidx490, align 1, !tbaa !5
  %conv491 = zext i8 %88 to i16
  %add492 = add nsw i64 %i.3889, 257
  %arrayidx493 = getelementptr inbounds i16* %tbl.0, i64 %add492
  store i16 %conv491, i16* %arrayidx493, align 2, !tbaa !100
  %inc495 = add nsw i64 %i.3889, 1
  %cmp486 = icmp slt i64 %inc495, %sub481
  br i1 %cmp486, label %for.body488, label %if.end583, !llvm.loop !104

if.else498:                                       ; preds = %if.end400
  %89 = load i64* %rlen, align 8, !tbaa !1
  %tobool499 = icmp ne i64 %89, 0
  %tobool501 = icmp ne i32 %and19, 0
  %or.cond595 = or i1 %tobool499, %tobool501
  br i1 %or.cond595, label %if.else510, label %if.then502

if.then502:                                       ; preds = %if.else498
  %90 = load i64* %tlen, align 8, !tbaa !1
  store i64 %90, i64* %rlen, align 8, !tbaa !1
  %tobool503 = icmp eq i32 %and23, 0
  br i1 %tobool503, label %if.then504, label %if.end524

if.then504:                                       ; preds = %if.then502
  %or507 = or i8 %19, 4
  store i8 %or507, i8* %op_private, align 1, !tbaa !11
  br label %if.end524

if.else510:                                       ; preds = %if.else498
  %tobool511 = icmp eq i32 %and23, 0
  %91 = load i64* %tlen, align 8, !tbaa !1
  %cmp513 = icmp eq i64 %89, %91
  %or.cond931 = and i1 %tobool511, %cmp513
  br i1 %or.cond931, label %land.lhs.true515, label %if.end524

land.lhs.true515:                                 ; preds = %if.else510
  %call516 = call i32 @memcmp(i8* %cond, i8* %cond14, i64 %89) #4
  %tobool517 = icmp eq i32 %call516, 0
  br i1 %tobool517, label %if.then518, label %if.end524

if.then518:                                       ; preds = %land.lhs.true515
  %or521 = or i8 %19, 4
  store i8 %or521, i8* %op_private, align 1, !tbaa !11
  br label %if.end524

if.end524:                                        ; preds = %if.else510, %land.lhs.true515, %if.then502, %if.then518, %if.then504
  %92 = phi i64 [ %89, %land.lhs.true515 ], [ %89, %if.then518 ], [ %90, %if.then502 ], [ %90, %if.then504 ], [ %89, %if.else510 ]
  %93 = phi i64 [ %89, %land.lhs.true515 ], [ %89, %if.then518 ], [ %90, %if.then502 ], [ %90, %if.then504 ], [ %91, %if.else510 ]
  %r.4 = phi i8* [ %cond14, %land.lhs.true515 ], [ %cond14, %if.then518 ], [ %cond, %if.then502 ], [ %cond, %if.then504 ], [ %cond14, %if.else510 ]
  call void @llvm.memset.p0i8.i64(i8* %60, i8 -1, i64 512, i32 2, i1 false)
  %cmp534881 = icmp sgt i64 %93, 0
  br i1 %cmp534881, label %for.body536.lr.ph, label %if.end590

for.body536.lr.ph:                                ; preds = %if.end524
  br i1 %tobool501, label %for.body536.us, label %for.body536

for.body536.us:                                   ; preds = %for.body536.lr.ph, %for.inc579.us
  %i.5884.us = phi i64 [ %inc580.us, %for.inc579.us ], [ 0, %for.body536.lr.ph ]
  %grows.6882.us = phi i64 [ %grows.8.us, %for.inc579.us ], [ 0, %for.body536.lr.ph ]
  %cmp537.us = icmp slt i64 %i.5884.us, %92
  %arrayidx555.us = getelementptr inbounds i8* %cond, i64 %i.5884.us
  %94 = load i8* %arrayidx555.us, align 1, !tbaa !5
  %idxprom556.us = zext i8 %94 to i64
  %arrayidx557.us = getelementptr inbounds i16* %61, i64 %idxprom556.us
  %95 = load i16* %arrayidx557.us, align 2, !tbaa !100
  %cmp559.us = icmp eq i16 %95, -1
  br i1 %cmp537.us, label %if.end554.us, label %if.then541.us

if.then541.us:                                    ; preds = %for.body536.us
  br i1 %cmp559.us, label %if.then548.us, label %for.inc579.us

if.then548.us:                                    ; preds = %if.then541.us
  store i16 -2, i16* %arrayidx557.us, align 2, !tbaa !100
  br label %for.inc579.us

if.end554.us:                                     ; preds = %for.body536.us
  br i1 %cmp559.us, label %if.then561.us, label %for.inc579.us

if.then561.us:                                    ; preds = %if.end554.us
  %cmp564.us = icmp sgt i8 %94, -1
  %arrayidx567.us = getelementptr inbounds i8* %r.4, i64 %i.5884.us
  %96 = load i8* %arrayidx567.us, align 1, !tbaa !5
  br i1 %cmp564.us, label %land.lhs.true566.us, label %if.end572.us

land.lhs.true566.us:                              ; preds = %if.then561.us
  %cmp569.us = icmp slt i8 %96, 0
  %.grows.6.us = select i1 %cmp569.us, i64 1, i64 %grows.6882.us
  br label %if.end572.us

if.end572.us:                                     ; preds = %if.then561.us, %land.lhs.true566.us
  %grows.7.us = phi i64 [ %.grows.6.us, %land.lhs.true566.us ], [ %grows.6882.us, %if.then561.us ]
  %conv574.us = zext i8 %96 to i16
  store i16 %conv574.us, i16* %arrayidx557.us, align 2, !tbaa !100
  br label %for.inc579.us

for.inc579.us:                                    ; preds = %if.end572.us, %if.end554.us, %if.then548.us, %if.then541.us
  %grows.8.us = phi i64 [ %grows.6882.us, %if.then548.us ], [ %grows.6882.us, %if.then541.us ], [ %grows.7.us, %if.end572.us ], [ %grows.6882.us, %if.end554.us ]
  %inc580.us = add nsw i64 %i.5884.us, 1
  %cmp534.us = icmp slt i64 %inc580.us, %93
  br i1 %cmp534.us, label %for.body536.us, label %if.end583

for.body536:                                      ; preds = %for.body536.lr.ph, %for.inc579
  %i.5884 = phi i64 [ %inc580, %for.inc579 ], [ 0, %for.body536.lr.ph ]
  %j.4883 = phi i64 [ %inc581, %for.inc579 ], [ 0, %for.body536.lr.ph ]
  %grows.6882 = phi i64 [ %grows.8, %for.inc579 ], [ 0, %for.body536.lr.ph ]
  %not.cmp537 = icmp sge i64 %j.4883, %92
  %dec = sext i1 %not.cmp537 to i64
  %j.4883.dec = add nsw i64 %j.4883, %dec
  %arrayidx555 = getelementptr inbounds i8* %cond, i64 %i.5884
  %97 = load i8* %arrayidx555, align 1, !tbaa !5
  %idxprom556 = zext i8 %97 to i64
  %arrayidx557 = getelementptr inbounds i16* %61, i64 %idxprom556
  %98 = load i16* %arrayidx557, align 2, !tbaa !100
  %cmp559 = icmp eq i16 %98, -1
  br i1 %cmp559, label %if.then561, label %for.inc579

if.then561:                                       ; preds = %for.body536
  %cmp564 = icmp sgt i8 %97, -1
  %arrayidx567 = getelementptr inbounds i8* %r.4, i64 %j.4883.dec
  %99 = load i8* %arrayidx567, align 1, !tbaa !5
  br i1 %cmp564, label %land.lhs.true566, label %if.end572

land.lhs.true566:                                 ; preds = %if.then561
  %cmp569 = icmp slt i8 %99, 0
  %.grows.6 = select i1 %cmp569, i64 1, i64 %grows.6882
  br label %if.end572

if.end572:                                        ; preds = %if.then561, %land.lhs.true566
  %grows.7 = phi i64 [ %.grows.6, %land.lhs.true566 ], [ %grows.6882, %if.then561 ]
  %conv574 = zext i8 %99 to i16
  store i16 %conv574, i16* %arrayidx557, align 2, !tbaa !100
  br label %for.inc579

for.inc579:                                       ; preds = %for.body536, %if.end572
  %grows.8 = phi i64 [ %grows.7, %if.end572 ], [ %grows.6882, %for.body536 ]
  %inc580 = add nsw i64 %i.5884, 1
  %inc581 = add nsw i64 %j.4883.dec, 1
  %cmp534 = icmp slt i64 %inc580, %93
  br i1 %cmp534, label %for.body536, label %if.end583

if.end583:                                        ; preds = %for.body488, %middle.block, %for.inc579, %for.inc579.us, %if.end480, %for.end456
  %grows.9 = phi i64 [ %grows.3.lcssa, %for.end456 ], [ %grows.3.lcssa, %if.end480 ], [ %grows.8.us, %for.inc579.us ], [ %grows.8, %for.inc579 ], [ %grows.3.lcssa, %middle.block ], [ %grows.3.lcssa, %for.body488 ]
  %tobool584 = icmp eq i64 %grows.9, 0
  br i1 %tobool584, label %if.end590, label %if.then585

if.then585:                                       ; preds = %if.end583
  %100 = load i8* %op_private, align 1, !tbaa !11
  %or588 = or i8 %100, 64
  store i8 %or588, i8* %op_private, align 1, !tbaa !11
  br label %if.end590

if.end590:                                        ; preds = %if.end524, %if.end583, %if.then585
  call void @Perl_op_free(%struct.op* %expr)
  call void @Perl_op_free(%struct.op* %repl)
  br label %return

return:                                           ; preds = %if.end590, %if.end399
  ret %struct.op* %o
}

declare i8* @Perl_sv_2pv_flags(%struct.sv*, i64*, i64) #2

declare i8* @Perl_bytes_to_utf8(i8*, i64*) #2

declare i64 @Perl_utf8n_to_uvuni(i8*, i64, i64*, i64) #2

declare void @qsort(i8*, i64, i64, i32 (i8*, i8*)* nocapture) #2

; Function Attrs: nounwind readonly uwtable
define internal i32 @uvcompare(i8* nocapture readonly %a, i8* nocapture readonly %b) #5 {
entry:
  %0 = bitcast i8* %a to i64*
  %1 = load i64* %0, align 8, !tbaa !1
  %2 = bitcast i8* %b to i64*
  %3 = load i64* %2, align 8, !tbaa !1
  %cmp = icmp ult i64 %1, %3
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp ugt i64 %1, %3
  br i1 %cmp1, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %add.ptr = getelementptr inbounds i8* %a, i64 8
  %4 = bitcast i8* %add.ptr to i64*
  %5 = load i64* %4, align 8, !tbaa !1
  %add = add i64 %3, 1
  %cmp4 = icmp ult i64 %5, %add
  br i1 %cmp4, label %return, label %if.end6

if.end6:                                          ; preds = %if.end3
  %cmp9 = icmp ugt i64 %5, %add
  %. = zext i1 %cmp9 to i32
  br label %return

return:                                           ; preds = %if.end6, %if.end3, %if.end, %entry
  %retval.0 = phi i32 [ -1, %entry ], [ 1, %if.end ], [ -1, %if.end3 ], [ %., %if.end6 ]
  ret i32 %retval.0
}

declare i8* @Perl_uvuni_to_utf8(i8*, i64) #2

declare void @Perl_sv_catpvn_flags(%struct.sv*, i8*, i64, i64) #2

declare i8* @Perl_uvuni_to_utf8_flags(i8*, i64, i64) #2

; Function Attrs: nounwind readonly
declare i32 @memcmp(i8* nocapture, i8* nocapture, i64) #1

declare void @Perl_sv_catpvf(%struct.sv*, i8*, ...) #2

declare %struct.sv* @Perl_swash_init(i8*, i8*, %struct.sv*, i64, i64) #2

declare %struct.sv** @Perl_hv_store(%struct.hv*, i8*, i64, %struct.sv*, i64) #2

declare %struct.sv* @Perl_newSVuv(i64) #2

declare i8* @Perl_safesysrealloc(i8*, i64) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pmruntime(%struct.op* %o, %struct.op* %expr, %struct.op* %repl) #0 {
entry:
  %plen = alloca i64, align 8
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %0, 35
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (%struct.op*, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @pmtrans to i32 (%struct.op*, %struct.op*, %struct.op*, ...)*)(%struct.op* %o, %struct.op* %expr, %struct.op* %repl) #4
  %conv2 = sext i32 %call to i64
  %1 = inttoptr i64 %conv2 to %struct.op*
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64* @PL_hints, align 8, !tbaa !1
  %or = or i64 %2, 256
  store i64 %or, i64* @PL_hints, align 8, !tbaa !1
  %3 = bitcast %struct.op* %o to %struct.pmop*
  %op_type3 = getelementptr inbounds %struct.op* %expr, i64 0, i32 4
  %4 = load i16* %op_type3, align 2, !tbaa !12
  %cmp5 = icmp eq i16 %4, 5
  br i1 %cmp5, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end
  %op_sv = getelementptr inbounds %struct.op* %expr, i64 1
  %5 = bitcast %struct.op* %op_sv to %struct.sv**
  %6 = load %struct.sv** %5, align 8, !tbaa !18
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i64* %sv_flags, align 8, !tbaa !34
  %and = and i64 %7, 262144
  %cmp8 = icmp eq i64 %and, 0
  br i1 %cmp8, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then7
  %sv_any = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_cur = getelementptr inbounds i8* %8, i64 8
  %9 = bitcast i8* %xpv_cur to i64*
  %10 = load i64* %9, align 8, !tbaa !37
  store i64 %10, i64* %plen, align 8, !tbaa !1
  %xpv_pv = bitcast i8* %8 to i8**
  %11 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %cond.end

cond.false:                                       ; preds = %if.then7
  %call11 = call i8* @Perl_sv_2pv_flags(%struct.sv* %6, i64* %plen, i64 2) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %11, %cond.true ], [ %call11, %cond.false ]
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %12 = load i8* %op_flags, align 1, !tbaa !14
  %tobool = icmp slt i8 %12, 0
  br i1 %tobool, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %cond.end
  %13 = load i8* %cond, align 1, !tbaa !5
  %cmp15 = icmp eq i8 %13, 32
  br i1 %cmp15, label %land.lhs.true17, label %if.end36

land.lhs.true17:                                  ; preds = %land.lhs.true
  %arrayidx = getelementptr inbounds i8* %cond, i64 1
  %14 = load i8* %arrayidx, align 1, !tbaa !5
  %cmp19 = icmp eq i8 %14, 0
  br i1 %cmp19, label %if.then21, label %if.end36

if.then21:                                        ; preds = %land.lhs.true17
  call void @Perl_sv_setpvn(%struct.sv* %6, i8* getelementptr inbounds ([4 x i8]* @.str42, i64 0, i64 0), i64 3) #4
  %15 = load i64* %sv_flags, align 8, !tbaa !34
  %and23 = and i64 %15, 262144
  %cmp24 = icmp eq i64 %and23, 0
  br i1 %cmp24, label %cond.false31, label %cond.true26

cond.true26:                                      ; preds = %if.then21
  %sv_any27 = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %16 = load i8** %sv_any27, align 8, !tbaa !36
  %xpv_cur28 = getelementptr inbounds i8* %16, i64 8
  %17 = bitcast i8* %xpv_cur28 to i64*
  %18 = load i64* %17, align 8, !tbaa !37
  store i64 %18, i64* %plen, align 8, !tbaa !1
  %xpv_pv30 = bitcast i8* %16 to i8**
  %19 = load i8** %xpv_pv30, align 8, !tbaa !39
  br label %cond.end33

cond.false31:                                     ; preds = %if.then21
  %call32 = call i8* @Perl_sv_2pv_flags(%struct.sv* %6, i64* %plen, i64 2) #4
  br label %cond.end33

cond.end33:                                       ; preds = %cond.false31, %cond.true26
  %cond34 = phi i8* [ %19, %cond.true26 ], [ %call32, %cond.false31 ]
  %op_pmflags = getelementptr inbounds %struct.op* %o, i64 2, i32 1
  %20 = bitcast %struct.op** %op_pmflags to i64*
  %21 = load i64* %20, align 8, !tbaa !88
  %or35 = or i64 %21, 16
  %or35.c = inttoptr i64 %or35 to %struct.op*
  store %struct.op* %or35.c, %struct.op** %op_pmflags, align 8, !tbaa !88
  br label %if.end36

if.end36:                                         ; preds = %cond.end33, %land.lhs.true17, %land.lhs.true, %cond.end
  %p.0 = phi i8* [ %cond34, %cond.end33 ], [ %cond, %land.lhs.true17 ], [ %cond, %land.lhs.true ], [ %cond, %cond.end ]
  %22 = load i64* %sv_flags, align 8, !tbaa !34
  %and38 = and i64 %22, 536870912
  %tobool39 = icmp eq i64 %and38, 0
  br i1 %tobool39, label %if.end48, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %if.end36
  %23 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %op_private = getelementptr inbounds %struct.cop* %23, i64 0, i32 7
  %24 = load i8* %op_private, align 1, !tbaa !96
  %and42 = and i8 %24, 8
  %tobool43 = icmp eq i8 %and42, 0
  br i1 %tobool43, label %if.then44, label %if.end48

if.then44:                                        ; preds = %land.lhs.true40
  %op_pmdynflags = getelementptr inbounds %struct.op* %o, i64 2, i32 3
  %25 = bitcast i64* %op_pmdynflags to i8*
  %26 = load i8* %25, align 1, !tbaa !105
  %or46 = or i8 %26, 4
  store i8 %or46, i8* %25, align 1, !tbaa !105
  br label %if.end48

if.end48:                                         ; preds = %land.lhs.true40, %if.end36, %if.then44
  %27 = load %struct.regexp* (i8*, i8*, %struct.pmop*)** @PL_regcompp, align 8, !tbaa !6
  %28 = load i64* %plen, align 8, !tbaa !1
  %add.ptr = getelementptr inbounds i8* %p.0, i64 %28
  %call49 = call %struct.regexp* %27(i8* %p.0, i8* %add.ptr, %struct.pmop* %3) #4
  %29 = getelementptr inbounds %struct.op* %o, i64 2, i32 0
  %call49.c = bitcast %struct.regexp* %call49 to %struct.op*
  store %struct.op* %call49.c, %struct.op** %29, align 8, !tbaa !32
  %precomp = getelementptr inbounds %struct.regexp* %call49, i64 0, i32 4
  %30 = load i8** %precomp, align 8, !tbaa !106
  %call51 = call i32 @strcmp(i8* getelementptr inbounds ([4 x i8]* @.str42, i64 0, i64 0), i8* %30) #4
  %tobool52 = icmp eq i32 %call51, 0
  br i1 %tobool52, label %if.then53, label %if.end56

if.then53:                                        ; preds = %if.end48
  %op_pmflags54 = getelementptr inbounds %struct.op* %o, i64 2, i32 1
  %31 = bitcast %struct.op** %op_pmflags54 to i64*
  %32 = load i64* %31, align 8, !tbaa !88
  %or55 = or i64 %32, 32
  %or55.c = inttoptr i64 %or55 to %struct.op*
  store %struct.op* %or55.c, %struct.op** %op_pmflags54, align 8, !tbaa !88
  br label %if.end56

if.end56:                                         ; preds = %if.end48, %if.then53
  call void @Perl_op_free(%struct.op* %expr)
  br label %if.end116

if.else:                                          ; preds = %if.end
  %op_pmflags57 = getelementptr inbounds %struct.op* %o, i64 2, i32 1
  %33 = bitcast %struct.op** %op_pmflags57 to i64*
  %34 = load i64* %33, align 8, !tbaa !88
  %and58 = and i64 %34, 128
  %tobool59 = icmp ne i64 %and58, 0
  %and60 = and i64 %2, 2097152
  %tobool61 = icmp eq i64 %and60, 0
  %or.cond = or i1 %tobool59, %tobool61
  br i1 %or.cond, label %if.then62, label %if.end68

if.then62:                                        ; preds = %if.else
  %35 = lshr i64 %2, 21
  %36 = and i64 %35, 1
  %37 = xor i64 %36, 29
  %call67 = call %struct.op* @Perl_newUNOP(i64 %37, i64 0, %struct.op* %expr)
  br label %if.end68

if.end68:                                         ; preds = %if.else, %if.then62
  %expr.addr.0 = phi %struct.op* [ %call67, %if.then62 ], [ %expr, %if.else ]
  %call69 = call i8* @Perl_safesysmalloc(i64 56) #4
  call void @llvm.memset.p0i8.i64(i8* %call69, i8 0, i64 56, i32 1, i1 false)
  %op_type70 = getelementptr inbounds i8* %call69, i64 32
  %38 = bitcast i8* %op_type70 to i16*
  store i16 30, i16* %38, align 2, !tbaa !108
  %39 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 30), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds i8* %call69, i64 16
  %40 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %39, %struct.op* ()** %40, align 8, !tbaa !110
  %call71 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %expr.addr.0) #4
  %conv72 = sext i32 %call71 to i64
  %41 = inttoptr i64 %conv72 to %struct.op*
  %op_first = getelementptr inbounds i8* %call69, i64 40
  %42 = bitcast i8* %op_first to %struct.op**
  store %struct.op* %41, %struct.op** %42, align 8, !tbaa !111
  %43 = load i64* @PL_hints, align 8, !tbaa !1
  %.tr = trunc i64 %43 to i32
  %44 = lshr i32 %.tr, 14
  %45 = and i32 %44, 128
  %46 = getelementptr inbounds i8* %call69, i64 36
  %47 = load i8* %46, align 1, !tbaa !112
  %conv77 = zext i8 %47 to i32
  %48 = or i32 %conv77, %45
  %or78 = or i32 %48, 4
  %conv79 = trunc i32 %or78 to i8
  store i8 %conv79, i8* %46, align 1, !tbaa !112
  %49 = getelementptr inbounds i8* %call69, i64 37
  store i8 1, i8* %49, align 1, !tbaa !113
  %op_other = getelementptr inbounds i8* %call69, i64 48
  %50 = bitcast i8* %op_other to %struct.op**
  store %struct.op* %o, %struct.op** %50, align 8, !tbaa !114
  %51 = load i64* %33, align 8, !tbaa !88
  %and82 = and i64 %51, 128
  %tobool83 = icmp ne i64 %and82, 0
  %and85 = and i64 %43, 2097152
  %tobool86 = icmp eq i64 %and85, 0
  %or.cond454 = or i1 %tobool83, %tobool86
  %op_next = getelementptr inbounds %struct.op* %expr.addr.0, i64 0, i32 0
  %52 = load %struct.op** %op_next, align 8, !tbaa !42
  %tobool88 = icmp eq %struct.op* %52, null
  br i1 %or.cond454, label %if.then87, label %if.else99

if.then87:                                        ; preds = %if.end68
  br i1 %tobool88, label %cond.false91, label %cond.end94

cond.false91:                                     ; preds = %if.then87
  %call92 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %expr.addr.0) #4
  br label %cond.end94

cond.end94:                                       ; preds = %if.then87, %cond.false91
  %op_next96 = bitcast i8* %call69 to %struct.op**
  store %struct.op* %expr.addr.0, %struct.op** %op_next96, align 8, !tbaa !115
  %53 = bitcast i8* %call69 to %struct.op*
  %54 = getelementptr inbounds %struct.op* %expr.addr.0, i64 1, i32 0
  %55 = load %struct.op** %54, align 8, !tbaa !15
  %op_next98 = getelementptr inbounds %struct.op* %55, i64 0, i32 0
  store %struct.op* %53, %struct.op** %op_next98, align 8, !tbaa !42
  br label %if.end111

if.else99:                                        ; preds = %if.end68
  br i1 %tobool88, label %cond.false104, label %cond.end107

cond.false104:                                    ; preds = %if.else99
  %call105 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %expr.addr.0) #4
  %conv106 = sext i32 %call105 to i64
  %56 = inttoptr i64 %conv106 to %struct.op*
  br label %cond.end107

cond.end107:                                      ; preds = %if.else99, %cond.false104
  %cond108 = phi %struct.op* [ %56, %cond.false104 ], [ %52, %if.else99 ]
  %op_next109 = bitcast i8* %call69 to %struct.op**
  store %struct.op* %cond108, %struct.op** %op_next109, align 8, !tbaa !115
  %57 = bitcast i8* %call69 to %struct.op*
  store %struct.op* %57, %struct.op** %op_next, align 8, !tbaa !42
  br label %if.end111

if.end111:                                        ; preds = %cond.end107, %cond.end94
  %58 = load i16* %op_type, align 2, !tbaa !12
  %conv113 = zext i16 %58 to i32
  %59 = bitcast i8* %call69 to %struct.op*
  %call114 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %59) #4
  %call115 = call i32 (i32, i32, %struct.op*, ...)* bitcast (i32 (...)* @prepend_elem to i32 (i32, i32, %struct.op*, ...)*)(i32 %conv113, i32 %call114, %struct.op* %o) #4
  br label %if.end116

if.end116:                                        ; preds = %if.end111, %if.end56
  %tobool117 = icmp eq %struct.op* %repl, null
  br i1 %tobool117, label %return, label %if.then118

if.then118:                                       ; preds = %if.end116
  %op_pmflags119 = getelementptr inbounds %struct.op* %o, i64 2, i32 1
  %60 = bitcast %struct.op** %op_pmflags119 to i64*
  %61 = load i64* %60, align 8, !tbaa !88
  %and120 = and i64 %61, 1024
  %tobool121 = icmp eq i64 %and120, 0
  br i1 %tobool121, label %if.else128, label %if.then122

if.then122:                                       ; preds = %if.then118
  %62 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line = getelementptr inbounds %struct.cop* %62, i64 0, i32 13
  %63 = load i64* %cop_line, align 8, !tbaa !116
  %64 = load i64* @PL_multi_end, align 8, !tbaa !1
  %cmp123 = icmp ult i64 %63, %64
  br i1 %cmp123, label %if.then125, label %if.end251

if.then125:                                       ; preds = %if.then122
  %65 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line126 = getelementptr inbounds %struct.cop* %65, i64 0, i32 13
  store i64 %64, i64* %cop_line126, align 8, !tbaa !116
  br label %if.end251

if.else128:                                       ; preds = %if.then118
  %op_type129 = getelementptr inbounds %struct.op* %repl, i64 0, i32 4
  %66 = load i16* %op_type129, align 2, !tbaa !12
  %cmp131 = icmp eq i16 %66, 5
  br i1 %cmp131, label %if.then263, label %if.else134

if.else134:                                       ; preds = %if.else128
  %op_next135 = getelementptr inbounds %struct.op* %repl, i64 0, i32 0
  %67 = load %struct.op** %op_next135, align 8, !tbaa !42
  %tobool136 = icmp eq %struct.op* %67, null
  br i1 %tobool136, label %cond.false139, label %for.cond.preheader

cond.false139:                                    ; preds = %if.else134
  %call140 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %repl) #4
  %conv141 = sext i32 %call140 to i64
  %68 = inttoptr i64 %conv141 to %struct.op*
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.else134, %cond.false139
  %curop.0.ph = phi %struct.op* [ %68, %cond.false139 ], [ %67, %if.else134 ]
  %cmp144430 = icmp eq %struct.op* %curop.0.ph, %repl
  br i1 %cmp144430, label %if.then263, label %for.body

for.body:                                         ; preds = %for.cond.preheader, %for.cond.backedge
  %lastop.0433 = phi %struct.op* [ %curop.0432, %for.cond.backedge ], [ null, %for.cond.preheader ]
  %curop.0432 = phi %struct.op* [ %curop.0.be, %for.cond.backedge ], [ %curop.0.ph, %for.cond.preheader ]
  %repl_has_vars.0431 = phi i64 [ %repl_has_vars.1, %for.cond.backedge ], [ 0, %for.cond.preheader ]
  %op_type146 = getelementptr inbounds %struct.op* %curop.0432, i64 0, i32 4
  %69 = load i16* %op_type146, align 2, !tbaa !12
  %idxprom = zext i16 %69 to i64
  %arrayidx147 = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %idxprom
  %70 = load i64* %arrayidx147, align 8, !tbaa !1
  %and148 = and i64 %70, 64
  %tobool149 = icmp eq i64 %and148, 0
  br i1 %tobool149, label %if.end240, label %if.then150

if.then150:                                       ; preds = %for.body
  switch i16 %69, label %if.else228 [
    i16 7, label %if.then155
    i16 17, label %if.end251
    i16 15, label %if.then198
    i16 125, label %if.then198
    i16 134, label %if.then198
    i16 14, label %if.then198
    i16 9, label %if.end240
    i16 10, label %if.end240
    i16 11, label %if.end240
    i16 12, label %if.end240
  ]

if.then155:                                       ; preds = %if.then150
  %op_sv156 = getelementptr inbounds %struct.op* %curop.0432, i64 1
  %71 = bitcast %struct.op* %op_sv156 to %struct.sv**
  %72 = load %struct.sv** %71, align 8, !tbaa !18
  %73 = bitcast %struct.sv* %72 to %struct.gv*
  %sv_any157 = bitcast %struct.sv* %72 to %struct.xpvgv**
  %74 = load %struct.xpvgv** %sv_any157, align 8, !tbaa !60
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %74, i64 0, i32 7
  %75 = load %struct.gp** %xgv_gp, align 8, !tbaa !62
  %gp_egv = getelementptr inbounds %struct.gp* %75, i64 0, i32 6
  %76 = load %struct.gv** %gp_egv, align 8, !tbaa !117
  %tobool158 = icmp eq %struct.gv* %76, null
  %. = select i1 %tobool158, %struct.gv* %73, %struct.gv* %76
  %sv_any166 = getelementptr inbounds %struct.gv* %., i64 0, i32 0
  %77 = load %struct.xpvgv** %sv_any166, align 8, !tbaa !60
  %xgv_name = getelementptr inbounds %struct.xpvgv* %77, i64 0, i32 8
  %78 = load i8** %xgv_name, align 8, !tbaa !118
  %79 = load i8* %78, align 1, !tbaa !5
  %conv167 = sext i8 %79 to i32
  %memchr = call i8* @memchr(i8* getelementptr inbounds ([17 x i8]* @.str43, i64 0, i64 0), i32 %conv167, i64 17)
  %tobool169 = icmp eq i8* %memchr, null
  br i1 %tobool169, label %if.end240, label %if.end251

if.then198:                                       ; preds = %if.then150, %if.then150, %if.then150, %if.then150
  %tobool199 = icmp eq %struct.op* %lastop.0433, null
  br i1 %tobool199, label %if.end240, label %land.lhs.true200

land.lhs.true200:                                 ; preds = %if.then198
  %op_type201 = getelementptr inbounds %struct.op* %lastop.0433, i64 0, i32 4
  %80 = load i16* %op_type201, align 2, !tbaa !12
  %cmp203 = icmp eq i16 %80, 7
  br i1 %cmp203, label %if.end240, label %if.end251

if.else228:                                       ; preds = %if.then150
  %cmp231 = icmp eq i16 %69, 13
  br i1 %cmp231, label %if.end240, label %if.end251

if.end240:                                        ; preds = %if.then150, %if.then150, %if.then150, %if.then150, %if.then155, %land.lhs.true200, %if.then198, %for.body, %if.else228
  %repl_has_vars.1 = phi i64 [ 1, %if.then155 ], [ %repl_has_vars.0431, %land.lhs.true200 ], [ %repl_has_vars.0431, %if.then198 ], [ %repl_has_vars.0431, %if.else228 ], [ %repl_has_vars.0431, %for.body ], [ 1, %if.then150 ], [ 1, %if.then150 ], [ 1, %if.then150 ], [ 1, %if.then150 ]
  %op_next241 = getelementptr inbounds %struct.op* %curop.0432, i64 0, i32 0
  %81 = load %struct.op** %op_next241, align 8, !tbaa !42
  %tobool242 = icmp eq %struct.op* %81, null
  br i1 %tobool242, label %cond.false245, label %for.cond.backedge

for.cond.backedge:                                ; preds = %if.end240, %cond.false245
  %curop.0.be = phi %struct.op* [ %81, %if.end240 ], [ %82, %cond.false245 ]
  %cmp144 = icmp eq %struct.op* %curop.0.be, %repl
  br i1 %cmp144, label %land.lhs.true254, label %for.body

cond.false245:                                    ; preds = %if.end240
  %call246 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %curop.0432) #4
  %conv247 = sext i32 %call246 to i64
  %82 = inttoptr i64 %conv247 to %struct.op*
  br label %for.cond.backedge

if.end251:                                        ; preds = %if.else228, %land.lhs.true200, %if.then155, %if.then150, %if.then122, %if.then125
  %repl_has_vars.2 = phi i64 [ 0, %if.then125 ], [ 0, %if.then122 ], [ %repl_has_vars.0431, %if.else228 ], [ %repl_has_vars.0431, %land.lhs.true200 ], [ 1, %if.then155 ], [ %repl_has_vars.0431, %if.then150 ]
  %curop.1 = phi %struct.op* [ null, %if.then125 ], [ null, %if.then122 ], [ %curop.0432, %if.then150 ], [ %curop.0432, %if.then155 ], [ %curop.0432, %land.lhs.true200 ], [ %curop.0432, %if.else228 ]
  %cmp252 = icmp eq %struct.op* %curop.1, %repl
  br i1 %cmp252, label %land.lhs.true254, label %if.end282

land.lhs.true254:                                 ; preds = %for.cond.backedge, %if.end251
  %repl_has_vars.2452 = phi i64 [ %repl_has_vars.2, %if.end251 ], [ %repl_has_vars.1, %for.cond.backedge ]
  %tobool255 = icmp eq i64 %repl_has_vars.2452, 0
  br i1 %tobool255, label %if.then263, label %land.lhs.true256

land.lhs.true256:                                 ; preds = %land.lhs.true254
  %op_pmregexp257 = getelementptr inbounds %struct.op* %o, i64 2
  %83 = bitcast %struct.op* %op_pmregexp257 to %struct.regexp**
  %84 = load %struct.regexp** %83, align 8, !tbaa !32
  %tobool258 = icmp eq %struct.regexp* %84, null
  br i1 %tobool258, label %if.then277, label %lor.lhs.false259

lor.lhs.false259:                                 ; preds = %land.lhs.true256
  %reganch = getelementptr inbounds %struct.regexp* %84, i64 0, i32 15
  %85 = load i64* %reganch, align 8, !tbaa !119
  %and261 = and i64 %85, 1024
  %tobool262 = icmp eq i64 %and261, 0
  br i1 %tobool262, label %if.then263, label %if.end282

if.then263:                                       ; preds = %for.cond.preheader, %if.else128, %lor.lhs.false259, %land.lhs.true254
  %86 = load i64* %60, align 8, !tbaa !88
  %or265 = or i64 %86, 64
  %or265.c = inttoptr i64 %or265 to %struct.op*
  store %struct.op* %or265.c, %struct.op** %op_pmflags119, align 8, !tbaa !88
  %op_pmpermflags = getelementptr inbounds %struct.op* %o, i64 2, i32 2
  %87 = bitcast %struct.op* ()** %op_pmpermflags to i64*
  %88 = load i64* %87, align 8, !tbaa !87
  %or266 = or i64 %88, 64
  %or266.c = inttoptr i64 %or266 to %struct.op* ()*
  store %struct.op* ()* %or266.c, %struct.op* ()** %op_pmpermflags, align 8, !tbaa !87
  %89 = load i16* %op_type, align 2, !tbaa !12
  %conv268 = zext i16 %89 to i32
  %call269 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %repl) #4
  %call270 = call i32 (i32, i32, %struct.op*, ...)* bitcast (i32 (...)* @prepend_elem to i32 (i32, i32, %struct.op*, ...)*)(i32 %conv268, i32 %call269, %struct.op* %o) #4
  br label %return

if.then277:                                       ; preds = %land.lhs.true256
  %90 = load i64* %60, align 8, !tbaa !88
  %or279 = or i64 %90, 8
  %or279.c = inttoptr i64 %or279 to %struct.op*
  store %struct.op* %or279.c, %struct.op** %op_pmflags119, align 8, !tbaa !88
  %op_pmpermflags280 = getelementptr inbounds %struct.op* %o, i64 2, i32 2
  %91 = bitcast %struct.op* ()** %op_pmpermflags280 to i64*
  %92 = load i64* %91, align 8, !tbaa !87
  %or281 = or i64 %92, 8
  %or281.c = inttoptr i64 %or281 to %struct.op* ()*
  store %struct.op* ()* %or281.c, %struct.op* ()** %op_pmpermflags280, align 8, !tbaa !87
  br label %if.end282

if.end282:                                        ; preds = %lor.lhs.false259, %if.end251, %if.then277
  %call283 = call i8* @Perl_safesysmalloc(i64 56) #4
  call void @llvm.memset.p0i8.i64(i8* %call283, i8 0, i64 56, i32 1, i1 false)
  %op_type284 = getelementptr inbounds i8* %call283, i64 32
  %93 = bitcast i8* %op_type284 to i16*
  store i16 34, i16* %93, align 2, !tbaa !108
  %94 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 34), align 8, !tbaa !6
  %op_ppaddr285 = getelementptr inbounds i8* %call283, i64 16
  %95 = bitcast i8* %op_ppaddr285 to %struct.op* ()**
  store %struct.op* ()* %94, %struct.op* ()** %95, align 8, !tbaa !110
  %call286 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %repl) #4
  %conv287 = sext i32 %call286 to i64
  %96 = inttoptr i64 %conv287 to %struct.op*
  %op_first288 = getelementptr inbounds i8* %call283, i64 40
  %97 = bitcast i8* %op_first288 to %struct.op**
  store %struct.op* %96, %struct.op** %97, align 8, !tbaa !111
  %98 = getelementptr inbounds i8* %call283, i64 36
  %99 = load i8* %98, align 1, !tbaa !112
  %or291 = or i8 %99, 4
  store i8 %or291, i8* %98, align 1, !tbaa !112
  %100 = getelementptr inbounds i8* %call283, i64 37
  store i8 1, i8* %100, align 1, !tbaa !113
  %op_other294 = getelementptr inbounds i8* %call283, i64 48
  %101 = bitcast i8* %op_other294 to %struct.op**
  store %struct.op* %o, %struct.op** %101, align 8, !tbaa !114
  %op_next295 = getelementptr inbounds %struct.op* %repl, i64 0, i32 0
  %102 = load %struct.op** %op_next295, align 8, !tbaa !42
  %tobool296 = icmp eq %struct.op* %102, null
  br i1 %tobool296, label %cond.false299, label %cond.end302

cond.false299:                                    ; preds = %if.end282
  %call300 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %repl) #4
  %conv301 = sext i32 %call300 to i64
  %103 = inttoptr i64 %conv301 to %struct.op*
  br label %cond.end302

cond.end302:                                      ; preds = %if.end282, %cond.false299
  %cond303 = phi %struct.op* [ %103, %cond.false299 ], [ %102, %if.end282 ]
  %op_next304 = bitcast i8* %call283 to %struct.op**
  store %struct.op* %cond303, %struct.op** %op_next304, align 8, !tbaa !115
  %104 = bitcast i8* %call283 to %struct.op*
  store %struct.op* %104, %struct.op** %op_next295, align 8, !tbaa !42
  %call306 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %104) #4
  %conv307 = sext i32 %call306 to i64
  %op_pmreplroot = getelementptr inbounds %struct.op* %o, i64 1, i32 2
  %.c = inttoptr i64 %conv307 to %struct.op* ()*
  store %struct.op* ()* %.c, %struct.op* ()** %op_pmreplroot, align 8, !tbaa !31
  %105 = load %struct.op** %op_next304, align 8, !tbaa !115
  %tobool309 = icmp eq %struct.op* %105, null
  br i1 %tobool309, label %cond.false312, label %cond.end315

cond.false312:                                    ; preds = %cond.end302
  %call313 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %104) #4
  %conv314 = sext i32 %call313 to i64
  %106 = inttoptr i64 %conv314 to %struct.op*
  br label %cond.end315

cond.end315:                                      ; preds = %cond.end302, %cond.false312
  %cond316 = phi %struct.op* [ %106, %cond.false312 ], [ %105, %cond.end302 ]
  %op_pmreplstart = getelementptr inbounds %struct.op* %o, i64 1, i32 3
  %cond316.c = ptrtoint %struct.op* %cond316 to i64
  store i64 %cond316.c, i64* %op_pmreplstart, align 8, !tbaa !120
  store %struct.op* null, %struct.op** %op_next304, align 8, !tbaa !115
  br label %return

return:                                           ; preds = %cond.end315, %if.then263, %if.end116, %if.then
  %retval.0 = phi %struct.op* [ %1, %if.then ], [ %o, %if.end116 ], [ %o, %if.then263 ], [ %o, %cond.end315 ]
  ret %struct.op* %retval.0
}

declare i32 @pmtrans(...) #2

declare void @Perl_sv_setpvn(%struct.sv*, i8*, i64) #2

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8* nocapture, i8* nocapture) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newPADOP(i64 %type, i64 %flags, %struct.sv* %sv) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 48, i32 1, i1 false)
  %conv = trunc i64 %type to i16
  %op_type = getelementptr inbounds i8* %call, i64 32
  %0 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %0, align 2, !tbaa !121
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %type
  %1 = load %struct.op* ()** %arrayidx, align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %2 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %1, %struct.op* ()** %2, align 8, !tbaa !123
  %call1 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 %type, i32 512) #4
  %conv2 = sext i32 %call1 to i64
  %op_padix = getelementptr inbounds i8* %call, i64 40
  %3 = bitcast i8* %op_padix to i64*
  store i64 %conv2, i64* %3, align 8, !tbaa !124
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !6
  %arrayidx4 = getelementptr inbounds %struct.sv** %4, i64 %conv2
  %5 = load %struct.sv** %arrayidx4, align 8, !tbaa !6
  tail call void @Perl_sv_free(%struct.sv* %5) #4
  %6 = load i64* %3, align 8, !tbaa !124
  %7 = load %struct.sv*** @PL_curpad, align 8, !tbaa !6
  %arrayidx6 = getelementptr inbounds %struct.sv** %7, i64 %6
  store %struct.sv* %sv, %struct.sv** %arrayidx6, align 8, !tbaa !6
  %tobool = icmp eq %struct.sv* %sv, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %8 = load i64* %sv_flags, align 8, !tbaa !34
  %or = or i64 %8, 768
  store i64 %or, i64* %sv_flags, align 8, !tbaa !34
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %9 = bitcast i8* %call to %struct.op*
  %op_next = bitcast i8* %call to %struct.op**
  store %struct.op* %9, %struct.op** %op_next, align 8, !tbaa !125
  %conv7 = trunc i64 %flags to i8
  %10 = getelementptr inbounds i8* %call, i64 36
  store i8 %conv7, i8* %10, align 1, !tbaa !126
  %arrayidx8 = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %type
  %11 = load i64* %arrayidx8, align 8, !tbaa !1
  %and = and i64 %11, 4
  %tobool9 = icmp eq i64 %and, 0
  br i1 %tobool9, label %if.end12, label %if.then10

if.then10:                                        ; preds = %if.end
  %call11 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %9) #4
  %.pre = load i64* %arrayidx8, align 8, !tbaa !1
  br label %if.end12

if.end12:                                         ; preds = %if.end, %if.then10
  %12 = phi i64 [ %11, %if.end ], [ %.pre, %if.then10 ]
  %and14 = and i64 %12, 8
  %tobool15 = icmp eq i64 %and14, 0
  br i1 %tobool15, label %if.end19, label %if.then16

if.then16:                                        ; preds = %if.end12
  %call17 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 %type, i32 512) #4
  %conv18 = sext i32 %call17 to i64
  %op_targ = getelementptr inbounds i8* %call, i64 24
  %13 = bitcast i8* %op_targ to i64*
  store i64 %conv18, i64* %13, align 8, !tbaa !127
  br label %if.end19

if.end19:                                         ; preds = %if.end12, %if.then16
  %14 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool20 = icmp eq i8* %14, null
  br i1 %tobool20, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end19
  %arrayidx21 = getelementptr inbounds i8* %14, i64 %type
  %15 = load i8* %arrayidx21, align 1, !tbaa !5
  %tobool23 = icmp eq i8 %15, 0
  br i1 %tobool23, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  tail call void @Perl_op_free(%struct.op* %9)
  %arrayidx24 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %type
  %16 = load i8** %arrayidx24, align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %16) #4
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end19
  %arrayidx25 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %type
  %17 = load %struct.op* (%struct.op*)** %arrayidx25, align 8, !tbaa !6
  %call26 = tail call %struct.op* %17(%struct.op* %9) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call26, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newPVOP(i64 %type, i64 %flags, i8* %pv) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 48, i32 1, i1 false)
  %conv = trunc i64 %type to i16
  %op_type = getelementptr inbounds i8* %call, i64 32
  %0 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %0, align 2, !tbaa !128
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %type
  %1 = load %struct.op* ()** %arrayidx, align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %2 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %1, %struct.op* ()** %2, align 8, !tbaa !129
  %op_pv = getelementptr inbounds i8* %call, i64 40
  %3 = bitcast i8* %op_pv to i8**
  store i8* %pv, i8** %3, align 8, !tbaa !20
  %4 = bitcast i8* %call to %struct.op*
  %op_next = bitcast i8* %call to %struct.op**
  store %struct.op* %4, %struct.op** %op_next, align 8, !tbaa !130
  %conv1 = trunc i64 %flags to i8
  %5 = getelementptr inbounds i8* %call, i64 36
  store i8 %conv1, i8* %5, align 1, !tbaa !131
  %arrayidx2 = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %type
  %6 = load i64* %arrayidx2, align 8, !tbaa !1
  %and = and i64 %6, 4
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call3 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %4) #4
  %.pre = load i64* %arrayidx2, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %7 = phi i64 [ %6, %entry ], [ %.pre, %if.then ]
  %and5 = and i64 %7, 8
  %tobool6 = icmp eq i64 %and5, 0
  br i1 %tobool6, label %if.end10, label %if.then7

if.then7:                                         ; preds = %if.end
  %call8 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 %type, i32 512) #4
  %conv9 = sext i32 %call8 to i64
  %op_targ = getelementptr inbounds i8* %call, i64 24
  %8 = bitcast i8* %op_targ to i64*
  store i64 %conv9, i64* %8, align 8, !tbaa !132
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then7
  %9 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11 = icmp eq i8* %9, null
  br i1 %tobool11, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end10
  %arrayidx12 = getelementptr inbounds i8* %9, i64 %type
  %10 = load i8* %arrayidx12, align 1, !tbaa !5
  %tobool14 = icmp eq i8 %10, 0
  br i1 %tobool14, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  tail call void @Perl_op_free(%struct.op* %4)
  %arrayidx15 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %type
  %11 = load i8** %arrayidx15, align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %11) #4
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end10
  %arrayidx16 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %type
  %12 = load %struct.op* (%struct.op*)** %arrayidx16, align 8, !tbaa !6
  %call17 = tail call %struct.op* %12(%struct.op* %4) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call17, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind uwtable
define void @Perl_package(%struct.op* %o) #0 {
entry:
  %len = alloca i64, align 8
  call void @Perl_save_hptr(%struct.hv** @PL_curstash) #4
  %0 = load %struct.sv** @PL_curstname, align 8, !tbaa !6
  call void @Perl_save_item(%struct.sv* %0) #4
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %1 = bitcast %struct.op* %op_sv to %struct.sv**
  %2 = load %struct.sv** %1, align 8, !tbaa !18
  %sv_flags = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %3 = load i64* %sv_flags, align 8, !tbaa !34
  %and = and i64 %3, 262144
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %sv_any = getelementptr inbounds %struct.sv* %2, i64 0, i32 0
  %4 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_cur = getelementptr inbounds i8* %4, i64 8
  %5 = bitcast i8* %xpv_cur to i64*
  %6 = load i64* %5, align 8, !tbaa !37
  store i64 %6, i64* %len, align 8, !tbaa !1
  %xpv_pv = bitcast i8* %4 to i8**
  %7 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %2, i64* %len, i64 2) #4
  %.pre = load i64* %len, align 8, !tbaa !1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %8 = phi i64 [ %6, %cond.true ], [ %.pre, %cond.false ]
  %cond = phi i8* [ %7, %cond.true ], [ %call, %cond.false ]
  %call2 = call %struct.hv* @Perl_gv_stashpvn(i8* %cond, i64 %8, i64 1) #4
  store %struct.hv* %call2, %struct.hv** @PL_curstash, align 8, !tbaa !6
  %9 = load %struct.sv** @PL_curstname, align 8, !tbaa !6
  %10 = load i64* %len, align 8, !tbaa !1
  call void @Perl_sv_setpvn(%struct.sv* %9, i8* %cond, i64 %10) #4
  call void @Perl_op_free(%struct.op* %o)
  br label %if.end

if.else:                                          ; preds = %entry
  %call3 = call i32 (i8*, ...)* bitcast (i32 (...)* @deprecate to i32 (i8*, ...)*)(i8* getelementptr inbounds ([28 x i8]* @.str44, i64 0, i64 0)) #4
  %11 = load %struct.sv** @PL_curstname, align 8, !tbaa !6
  call void @Perl_sv_setpv(%struct.sv* %11, i8* getelementptr inbounds ([7 x i8]* @.str45, i64 0, i64 0)) #4
  store %struct.hv* null, %struct.hv** @PL_curstash, align 8, !tbaa !6
  br label %if.end

if.end:                                           ; preds = %if.else, %cond.end
  %12 = load i64* @PL_hints, align 8, !tbaa !1
  %or = or i64 %12, 256
  store i64 %or, i64* @PL_hints, align 8, !tbaa !1
  store i64 4294967295, i64* @PL_copline, align 8, !tbaa !1
  store i32 3, i32* @PL_expect, align 4, !tbaa !92
  ret void
}

declare void @Perl_save_hptr(%struct.hv**) #2

declare void @Perl_save_item(%struct.sv*) #2

declare %struct.hv* @Perl_gv_stashpvn(i8*, i64, i64) #2

declare i32 @deprecate(...) #2

declare void @Perl_sv_setpv(%struct.sv*, i8*) #2

; Function Attrs: nounwind uwtable
define void @Perl_utilize(i32 %aver, i64 %floor, %struct.op* %version, %struct.op* %idop, %struct.op* %arg) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %idop, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %0, 5
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([29 x i8]* @.str46, i64 0, i64 0)) #4
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %cmp2 = icmp eq %struct.op* %version, null
  br i1 %cmp2, label %if.end46, label %if.then4

if.then4:                                         ; preds = %if.end
  %op_sv = getelementptr inbounds %struct.op* %version, i64 1
  %1 = bitcast %struct.op* %op_sv to %struct.sv**
  %2 = load %struct.sv** %1, align 8, !tbaa !18
  %cmp5 = icmp eq %struct.op* %arg, null
  br i1 %cmp5, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then4
  %sv_flags = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %3 = load i64* %sv_flags, align 8, !tbaa !34
  %and = and i64 %3, 50331648
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.end46, label %if.else

if.else:                                          ; preds = %land.lhs.true, %if.then4
  %op_type9 = getelementptr inbounds %struct.op* %version, i64 0, i32 4
  %4 = load i16* %op_type9, align 2, !tbaa !12
  %cmp11 = icmp eq i16 %4, 5
  br i1 %cmp11, label %lor.lhs.false, label %if.then16

lor.lhs.false:                                    ; preds = %if.else
  %sv_flags13 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i64* %sv_flags13, align 8, !tbaa !34
  %and14 = and i64 %5, 50331648
  %tobool15 = icmp eq i64 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false, %if.else
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([39 x i8]* @.str47, i64 0, i64 0)) #4
  br label %if.end17

if.end17:                                         ; preds = %lor.lhs.false, %if.then16
  %op_sv18 = getelementptr inbounds %struct.op* %idop, i64 1
  %6 = bitcast %struct.op* %op_sv18 to %struct.sv**
  %7 = load %struct.sv** %6, align 8, !tbaa !18
  %call = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %7) #4
  %call.i = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i, i64 32
  %8 = bitcast i8* %op_type.i to i16*
  store i16 5, i16* %8, align 2, !tbaa !71
  %9 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %10 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %9, %struct.op* ()** %10, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i, i64 40
  %11 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %call, %struct.sv** %11, align 8, !tbaa !18
  %12 = bitcast i8* %call.i to %struct.op*
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %12, %struct.op** %op_next.i, align 8, !tbaa !73
  %13 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %13, align 1, !tbaa !74
  %14 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i = and i64 %14, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %if.end17
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %12) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.end17
  %15 = phi i64 [ %14, %if.end17 ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %15, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %16 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %16, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %17 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %17, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %17, i64 5
  %18 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %18, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %12) #4
  %19 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %19) #4
  br label %Perl_newSVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %20 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %20(%struct.op* %12) #4
  br label %Perl_newSVOP.exit

Perl_newSVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  %call20 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([8 x i8]* @.str48, i64 0, i64 0), i64 7) #4
  %call21 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %call20, i64 5) #4
  %sv_flags22 = getelementptr inbounds %struct.sv* %call20, i64 0, i32 2
  %21 = load i64* %sv_flags22, align 8, !tbaa !34
  %and23 = and i64 %21, 2097152
  %tobool24 = icmp eq i64 %and23, 0
  br i1 %tobool24, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %Perl_newSVOP.exit
  %call25 = tail call i32 @Perl_sv_backoff(%struct.sv* %call20) #4
  %.pre305 = load i64* %sv_flags22, align 8, !tbaa !34
  br label %land.end

land.end:                                         ; preds = %Perl_newSVOP.exit, %land.rhs
  %22 = phi i64 [ %21, %Perl_newSVOP.exit ], [ %.pre305, %land.rhs ]
  %or = or i64 %22, 16842752
  store i64 %or, i64* %sv_flags22, align 8, !tbaa !34
  %sv_any = getelementptr inbounds %struct.sv* %call20, i64 0, i32 0
  %23 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_cur = getelementptr inbounds i8* %23, i64 8
  %24 = bitcast i8* %xpv_cur to i64*
  %25 = load i64* %24, align 8, !tbaa !37
  %tobool29298 = icmp eq i64 %25, 0
  br i1 %tobool29298, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %land.end
  %xpv_pv = bitcast i8* %23 to i8**
  %26 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.body
  %s_PeRlHaSh.0301 = phi i8* [ %26, %while.body.lr.ph ], [ %incdec.ptr, %while.body ]
  %hash_PeRlHaSh.0300 = phi i64 [ 0, %while.body.lr.ph ], [ %xor, %while.body ]
  %i_PeRlHaSh.0299 = phi i64 [ %25, %while.body.lr.ph ], [ %dec, %while.body ]
  %dec = add nsw i64 %i_PeRlHaSh.0299, -1
  %incdec.ptr = getelementptr inbounds i8* %s_PeRlHaSh.0301, i64 1
  %27 = load i8* %s_PeRlHaSh.0301, align 1, !tbaa !5
  %conv30 = zext i8 %27 to i64
  %add = add i64 %conv30, %hash_PeRlHaSh.0300
  %add31 = mul i64 %add, 1025
  %shr = lshr i64 %add31, 6
  %xor = xor i64 %shr, %add31
  %tobool29 = icmp eq i64 %dec, 0
  br i1 %tobool29, label %while.cond.while.end_crit_edge, label %while.body

while.cond.while.end_crit_edge:                   ; preds = %while.body
  %phitmp = mul i64 %xor, 9
  br label %while.end

while.end:                                        ; preds = %while.cond.while.end_crit_edge, %land.end
  %hash_PeRlHaSh.0.lcssa = phi i64 [ %phitmp, %while.cond.while.end_crit_edge ], [ 0, %land.end ]
  %shr34 = lshr i64 %hash_PeRlHaSh.0.lcssa, 11
  %xor35 = xor i64 %shr34, %hash_PeRlHaSh.0.lcssa
  %add37 = mul i64 %xor35, 32769
  %xuv_uv = getelementptr inbounds i8* %23, i64 24
  %28 = bitcast i8* %xuv_uv to i64*
  store i64 %add37, i64* %28, align 8, !tbaa !133
  %call39 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %version) #4
  %call40 = tail call i32 (i32, %struct.op*, i32, ...)* bitcast (i32 (...)* @prepend_elem to i32 (i32, %struct.op*, i32, ...)*)(i32 141, %struct.op* %cond.i, i32 %call39) #4
  %call.i186 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i186, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i187 = getelementptr inbounds i8* %call.i186, i64 32
  %29 = bitcast i8* %op_type.i187 to i16*
  store i16 350, i16* %29, align 2, !tbaa !71
  %30 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 350), align 8, !tbaa !6
  %op_ppaddr.i188 = getelementptr inbounds i8* %call.i186, i64 16
  %31 = bitcast i8* %op_ppaddr.i188 to %struct.op* ()**
  store %struct.op* ()* %30, %struct.op* ()** %31, align 8, !tbaa !72
  %op_sv.i189 = getelementptr inbounds i8* %call.i186, i64 40
  %32 = bitcast i8* %op_sv.i189 to %struct.sv**
  store %struct.sv* %call20, %struct.sv** %32, align 8, !tbaa !18
  %33 = bitcast i8* %call.i186 to %struct.op*
  %op_next.i190 = bitcast i8* %call.i186 to %struct.op**
  store %struct.op* %33, %struct.op** %op_next.i190, align 8, !tbaa !73
  %34 = getelementptr inbounds i8* %call.i186, i64 36
  store i8 0, i8* %34, align 1, !tbaa !74
  %35 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 350), align 8, !tbaa !1
  %and.i191 = and i64 %35, 4
  %tobool.i192 = icmp eq i64 %and.i191, 0
  br i1 %tobool.i192, label %if.end.i198, label %if.then.i195

if.then.i195:                                     ; preds = %while.end
  %call3.i193 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %33) #4
  %.pre.i194 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 350), align 8, !tbaa !1
  br label %if.end.i198

if.end.i198:                                      ; preds = %if.then.i195, %while.end
  %36 = phi i64 [ %35, %while.end ], [ %.pre.i194, %if.then.i195 ]
  %and5.i196 = and i64 %36, 8
  %tobool6.i197 = icmp eq i64 %and5.i196, 0
  br i1 %tobool6.i197, label %if.end10.i204, label %if.then7.i202

if.then7.i202:                                    ; preds = %if.end.i198
  %call8.i199 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 350, i32 512) #4
  %conv9.i200 = sext i32 %call8.i199 to i64
  %op_targ.i201 = getelementptr inbounds i8* %call.i186, i64 24
  %37 = bitcast i8* %op_targ.i201 to i64*
  store i64 %conv9.i200, i64* %37, align 8, !tbaa !75
  br label %if.end10.i204

if.end10.i204:                                    ; preds = %if.then7.i202, %if.end.i198
  %38 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i203 = icmp eq i8* %38, null
  br i1 %tobool11.i203, label %cond.false.i210, label %land.lhs.true.i207

land.lhs.true.i207:                               ; preds = %if.end10.i204
  %arrayidx12.i205 = getelementptr inbounds i8* %38, i64 350
  %39 = load i8* %arrayidx12.i205, align 1, !tbaa !5
  %tobool14.i206 = icmp eq i8 %39, 0
  br i1 %tobool14.i206, label %cond.false.i210, label %cond.true.i208

cond.true.i208:                                   ; preds = %land.lhs.true.i207
  tail call void @Perl_op_free(%struct.op* %33) #4
  %40 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 350), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %40) #4
  br label %Perl_newSVOP.exit212

cond.false.i210:                                  ; preds = %land.lhs.true.i207, %if.end10.i204
  %41 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 350), align 8, !tbaa !6
  %call17.i209 = tail call %struct.op* %41(%struct.op* %33) #4
  br label %Perl_newSVOP.exit212

Perl_newSVOP.exit212:                             ; preds = %cond.true.i208, %cond.false.i210
  %cond.i211 = phi %struct.op* [ null, %cond.true.i208 ], [ %call17.i209, %cond.false.i210 ]
  %call42 = tail call i32 (i32, i32, %struct.op*, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, i32, %struct.op*, ...)*)(i32 141, i32 %call40, %struct.op* %cond.i211) #4
  %call43 = tail call i32 (i32, i32, i32, ...)* bitcast (i32 (...)* @convert to i32 (i32, i32, i32, ...)*)(i32 166, i32 192, i32 %call42) #4
  %conv44 = sext i32 %call43 to i64
  %42 = inttoptr i64 %conv44 to %struct.op*
  br label %if.end46

if.end46:                                         ; preds = %land.lhs.true, %if.end, %Perl_newSVOP.exit212
  %veop.0 = phi %struct.op* [ %42, %Perl_newSVOP.exit212 ], [ null, %if.end ], [ null, %land.lhs.true ]
  %arg.addr.0 = phi %struct.op* [ %arg, %Perl_newSVOP.exit212 ], [ %arg, %if.end ], [ %version, %land.lhs.true ]
  %tobool47 = icmp eq %struct.op* %arg.addr.0, null
  br i1 %tobool47, label %if.else54, label %land.lhs.true48

land.lhs.true48:                                  ; preds = %if.end46
  %op_type49 = getelementptr inbounds %struct.op* %arg.addr.0, i64 0, i32 4
  %43 = load i16* %op_type49, align 2, !tbaa !12
  %cmp51 = icmp eq i16 %43, 1
  br i1 %cmp51, label %if.end126, label %if.else54

if.else54:                                        ; preds = %if.end46, %land.lhs.true48
  %op_sv55 = getelementptr inbounds %struct.op* %idop, i64 1
  %44 = bitcast %struct.op* %op_sv55 to %struct.sv**
  %45 = load %struct.sv** %44, align 8, !tbaa !18
  %sv_flags56 = getelementptr inbounds %struct.sv* %45, i64 0, i32 2
  %46 = load i64* %sv_flags56, align 8, !tbaa !34
  %and57 = and i64 %46, 50331648
  %tobool58 = icmp eq i64 %and57, 0
  br i1 %tobool58, label %if.else60, label %if.end126

if.else60:                                        ; preds = %if.else54
  %call64 = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %45) #4
  %call.i213 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i213, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i214 = getelementptr inbounds i8* %call.i213, i64 32
  %47 = bitcast i8* %op_type.i214 to i16*
  store i16 5, i16* %47, align 2, !tbaa !71
  %48 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i215 = getelementptr inbounds i8* %call.i213, i64 16
  %49 = bitcast i8* %op_ppaddr.i215 to %struct.op* ()**
  store %struct.op* ()* %48, %struct.op* ()** %49, align 8, !tbaa !72
  %op_sv.i216 = getelementptr inbounds i8* %call.i213, i64 40
  %50 = bitcast i8* %op_sv.i216 to %struct.sv**
  store %struct.sv* %call64, %struct.sv** %50, align 8, !tbaa !18
  %51 = bitcast i8* %call.i213 to %struct.op*
  %op_next.i217 = bitcast i8* %call.i213 to %struct.op**
  store %struct.op* %51, %struct.op** %op_next.i217, align 8, !tbaa !73
  %52 = getelementptr inbounds i8* %call.i213, i64 36
  store i8 0, i8* %52, align 1, !tbaa !74
  %53 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i218 = and i64 %53, 4
  %tobool.i219 = icmp eq i64 %and.i218, 0
  br i1 %tobool.i219, label %if.end.i225, label %if.then.i222

if.then.i222:                                     ; preds = %if.else60
  %call3.i220 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %51) #4
  %.pre.i221 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i225

if.end.i225:                                      ; preds = %if.then.i222, %if.else60
  %54 = phi i64 [ %53, %if.else60 ], [ %.pre.i221, %if.then.i222 ]
  %and5.i223 = and i64 %54, 8
  %tobool6.i224 = icmp eq i64 %and5.i223, 0
  br i1 %tobool6.i224, label %if.end10.i231, label %if.then7.i229

if.then7.i229:                                    ; preds = %if.end.i225
  %call8.i226 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i227 = sext i32 %call8.i226 to i64
  %op_targ.i228 = getelementptr inbounds i8* %call.i213, i64 24
  %55 = bitcast i8* %op_targ.i228 to i64*
  store i64 %conv9.i227, i64* %55, align 8, !tbaa !75
  br label %if.end10.i231

if.end10.i231:                                    ; preds = %if.then7.i229, %if.end.i225
  %56 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i230 = icmp eq i8* %56, null
  br i1 %tobool11.i230, label %cond.false.i237, label %land.lhs.true.i234

land.lhs.true.i234:                               ; preds = %if.end10.i231
  %arrayidx12.i232 = getelementptr inbounds i8* %56, i64 5
  %57 = load i8* %arrayidx12.i232, align 1, !tbaa !5
  %tobool14.i233 = icmp eq i8 %57, 0
  br i1 %tobool14.i233, label %cond.false.i237, label %cond.true.i235

cond.true.i235:                                   ; preds = %land.lhs.true.i234
  tail call void @Perl_op_free(%struct.op* %51) #4
  %58 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %58) #4
  br label %Perl_newSVOP.exit239

cond.false.i237:                                  ; preds = %land.lhs.true.i234, %if.end10.i231
  %59 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i236 = tail call %struct.op* %59(%struct.op* %51) #4
  br label %Perl_newSVOP.exit239

Perl_newSVOP.exit239:                             ; preds = %cond.true.i235, %cond.false.i237
  %cond.i238 = phi %struct.op* [ null, %cond.true.i235 ], [ %call17.i236, %cond.false.i237 ]
  %tobool66 = icmp eq i32 %aver, 0
  br i1 %tobool66, label %cond.false, label %cond.true

cond.true:                                        ; preds = %Perl_newSVOP.exit239
  %call67 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([7 x i8]* @.str49, i64 0, i64 0), i64 6) #4
  br label %cond.end

cond.false:                                       ; preds = %Perl_newSVOP.exit239
  %call68 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([9 x i8]* @.str50, i64 0, i64 0), i64 8) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %call67, %cond.true ], [ %call68, %cond.false ]
  %sv_flags69 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %60 = load i64* %sv_flags69, align 8, !tbaa !34
  %and70 = and i64 %60, 255
  %cmp71 = icmp ugt i64 %and70, 4
  br i1 %cmp71, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end
  %call73 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %cond, i64 5) #4
  %.pre = load i64* %sv_flags69, align 8, !tbaa !34
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end
  %61 = phi i64 [ %.pre, %lor.rhs ], [ %60, %cond.end ]
  %and77 = and i64 %61, 2097152
  %tobool78 = icmp eq i64 %and77, 0
  br i1 %tobool78, label %land.end82, label %land.rhs79

land.rhs79:                                       ; preds = %lor.end
  %call80 = tail call i32 @Perl_sv_backoff(%struct.sv* %cond) #4
  %.pre304 = load i64* %sv_flags69, align 8, !tbaa !34
  br label %land.end82

land.end82:                                       ; preds = %lor.end, %land.rhs79
  %62 = phi i64 [ %61, %lor.end ], [ %.pre304, %land.rhs79 ]
  %or85 = or i64 %62, 16842752
  store i64 %or85, i64* %sv_flags69, align 8, !tbaa !34
  %sv_any88 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 0
  %63 = load i8** %sv_any88, align 8, !tbaa !36
  %xpv_cur95 = getelementptr inbounds i8* %63, i64 8
  %64 = bitcast i8* %xpv_cur95 to i64*
  %65 = load i64* %64, align 8, !tbaa !37
  %tobool100294 = icmp eq i64 %65, 0
  br i1 %tobool100294, label %while.end109, label %while.body101.lr.ph

while.body101.lr.ph:                              ; preds = %land.end82
  %xpv_pv89 = bitcast i8* %63 to i8**
  %66 = load i8** %xpv_pv89, align 8, !tbaa !39
  br label %while.body101

while.body101:                                    ; preds = %while.body101.lr.ph, %while.body101
  %hash_PeRlHaSh97.0297 = phi i64 [ 0, %while.body101.lr.ph ], [ %xor108, %while.body101 ]
  %i_PeRlHaSh93.0296 = phi i64 [ %65, %while.body101.lr.ph ], [ %dec99, %while.body101 ]
  %s_PeRlHaSh91.0295 = phi i8* [ %66, %while.body101.lr.ph ], [ %incdec.ptr102, %while.body101 ]
  %dec99 = add nsw i64 %i_PeRlHaSh93.0296, -1
  %incdec.ptr102 = getelementptr inbounds i8* %s_PeRlHaSh91.0295, i64 1
  %67 = load i8* %s_PeRlHaSh91.0295, align 1, !tbaa !5
  %conv103 = zext i8 %67 to i64
  %add104 = add i64 %conv103, %hash_PeRlHaSh97.0297
  %add106 = mul i64 %add104, 1025
  %shr107 = lshr i64 %add106, 6
  %xor108 = xor i64 %shr107, %add106
  %tobool100 = icmp eq i64 %dec99, 0
  br i1 %tobool100, label %while.cond98.while.end109_crit_edge, label %while.body101

while.cond98.while.end109_crit_edge:              ; preds = %while.body101
  %phitmp303 = mul i64 %xor108, 9
  br label %while.end109

while.end109:                                     ; preds = %while.cond98.while.end109_crit_edge, %land.end82
  %hash_PeRlHaSh97.0.lcssa = phi i64 [ %phitmp303, %while.cond98.while.end109_crit_edge ], [ 0, %land.end82 ]
  %shr112 = lshr i64 %hash_PeRlHaSh97.0.lcssa, 11
  %xor113 = xor i64 %shr112, %hash_PeRlHaSh97.0.lcssa
  %add116 = mul i64 %xor113, 32769
  %xuv_uv118 = getelementptr inbounds i8* %63, i64 24
  %68 = bitcast i8* %xuv_uv118 to i64*
  store i64 %add116, i64* %68, align 8, !tbaa !133
  %call119 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %arg.addr.0) #4
  %call120 = tail call i32 (i32, %struct.op*, i32, ...)* bitcast (i32 (...)* @prepend_elem to i32 (i32, %struct.op*, i32, ...)*)(i32 141, %struct.op* %cond.i238, i32 %call119) #4
  %call.i240 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i240, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i241 = getelementptr inbounds i8* %call.i240, i64 32
  %69 = bitcast i8* %op_type.i241 to i16*
  store i16 350, i16* %69, align 2, !tbaa !71
  %70 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 350), align 8, !tbaa !6
  %op_ppaddr.i242 = getelementptr inbounds i8* %call.i240, i64 16
  %71 = bitcast i8* %op_ppaddr.i242 to %struct.op* ()**
  store %struct.op* ()* %70, %struct.op* ()** %71, align 8, !tbaa !72
  %op_sv.i243 = getelementptr inbounds i8* %call.i240, i64 40
  %72 = bitcast i8* %op_sv.i243 to %struct.sv**
  store %struct.sv* %cond, %struct.sv** %72, align 8, !tbaa !18
  %73 = bitcast i8* %call.i240 to %struct.op*
  %op_next.i244 = bitcast i8* %call.i240 to %struct.op**
  store %struct.op* %73, %struct.op** %op_next.i244, align 8, !tbaa !73
  %74 = getelementptr inbounds i8* %call.i240, i64 36
  store i8 0, i8* %74, align 1, !tbaa !74
  %75 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 350), align 8, !tbaa !1
  %and.i245 = and i64 %75, 4
  %tobool.i246 = icmp eq i64 %and.i245, 0
  br i1 %tobool.i246, label %if.end.i252, label %if.then.i249

if.then.i249:                                     ; preds = %while.end109
  %call3.i247 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %73) #4
  %.pre.i248 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 350), align 8, !tbaa !1
  br label %if.end.i252

if.end.i252:                                      ; preds = %if.then.i249, %while.end109
  %76 = phi i64 [ %75, %while.end109 ], [ %.pre.i248, %if.then.i249 ]
  %and5.i250 = and i64 %76, 8
  %tobool6.i251 = icmp eq i64 %and5.i250, 0
  br i1 %tobool6.i251, label %if.end10.i258, label %if.then7.i256

if.then7.i256:                                    ; preds = %if.end.i252
  %call8.i253 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 350, i32 512) #4
  %conv9.i254 = sext i32 %call8.i253 to i64
  %op_targ.i255 = getelementptr inbounds i8* %call.i240, i64 24
  %77 = bitcast i8* %op_targ.i255 to i64*
  store i64 %conv9.i254, i64* %77, align 8, !tbaa !75
  br label %if.end10.i258

if.end10.i258:                                    ; preds = %if.then7.i256, %if.end.i252
  %78 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i257 = icmp eq i8* %78, null
  br i1 %tobool11.i257, label %cond.false.i264, label %land.lhs.true.i261

land.lhs.true.i261:                               ; preds = %if.end10.i258
  %arrayidx12.i259 = getelementptr inbounds i8* %78, i64 350
  %79 = load i8* %arrayidx12.i259, align 1, !tbaa !5
  %tobool14.i260 = icmp eq i8 %79, 0
  br i1 %tobool14.i260, label %cond.false.i264, label %cond.true.i262

cond.true.i262:                                   ; preds = %land.lhs.true.i261
  tail call void @Perl_op_free(%struct.op* %73) #4
  %80 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 350), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %80) #4
  br label %Perl_newSVOP.exit266

cond.false.i264:                                  ; preds = %land.lhs.true.i261, %if.end10.i258
  %81 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 350), align 8, !tbaa !6
  %call17.i263 = tail call %struct.op* %81(%struct.op* %73) #4
  br label %Perl_newSVOP.exit266

Perl_newSVOP.exit266:                             ; preds = %cond.true.i262, %cond.false.i264
  %cond.i265 = phi %struct.op* [ null, %cond.true.i262 ], [ %call17.i263, %cond.false.i264 ]
  %call122 = tail call i32 (i32, i32, %struct.op*, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, i32, %struct.op*, ...)*)(i32 141, i32 %call120, %struct.op* %cond.i265) #4
  %call123 = tail call i32 (i32, i32, i32, ...)* bitcast (i32 (...)* @convert to i32 (i32, i32, i32, ...)*)(i32 166, i32 192, i32 %call122) #4
  %conv124 = sext i32 %call123 to i64
  %82 = inttoptr i64 %conv124 to %struct.op*
  br label %if.end126

if.end126:                                        ; preds = %if.else54, %land.lhs.true48, %Perl_newSVOP.exit266
  %imop.0 = phi %struct.op* [ %82, %Perl_newSVOP.exit266 ], [ %arg.addr.0, %land.lhs.true48 ], [ null, %if.else54 ]
  %call127 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([6 x i8]* @.str51, i64 0, i64 0), i64 5) #4
  %call.i267 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i267, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i268 = getelementptr inbounds i8* %call.i267, i64 32
  %83 = bitcast i8* %op_type.i268 to i16*
  store i16 5, i16* %83, align 2, !tbaa !71
  %84 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i269 = getelementptr inbounds i8* %call.i267, i64 16
  %85 = bitcast i8* %op_ppaddr.i269 to %struct.op* ()**
  store %struct.op* ()* %84, %struct.op* ()** %85, align 8, !tbaa !72
  %op_sv.i270 = getelementptr inbounds i8* %call.i267, i64 40
  %86 = bitcast i8* %op_sv.i270 to %struct.sv**
  store %struct.sv* %call127, %struct.sv** %86, align 8, !tbaa !18
  %87 = bitcast i8* %call.i267 to %struct.op*
  %op_next.i271 = bitcast i8* %call.i267 to %struct.op**
  store %struct.op* %87, %struct.op** %op_next.i271, align 8, !tbaa !73
  %88 = getelementptr inbounds i8* %call.i267, i64 36
  store i8 0, i8* %88, align 1, !tbaa !74
  %89 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i272 = and i64 %89, 4
  %tobool.i273 = icmp eq i64 %and.i272, 0
  br i1 %tobool.i273, label %if.end.i279, label %if.then.i276

if.then.i276:                                     ; preds = %if.end126
  %call3.i274 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %87) #4
  %.pre.i275 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i279

if.end.i279:                                      ; preds = %if.then.i276, %if.end126
  %90 = phi i64 [ %89, %if.end126 ], [ %.pre.i275, %if.then.i276 ]
  %and5.i277 = and i64 %90, 8
  %tobool6.i278 = icmp eq i64 %and5.i277, 0
  br i1 %tobool6.i278, label %if.end10.i285, label %if.then7.i283

if.then7.i283:                                    ; preds = %if.end.i279
  %call8.i280 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i281 = sext i32 %call8.i280 to i64
  %op_targ.i282 = getelementptr inbounds i8* %call.i267, i64 24
  %91 = bitcast i8* %op_targ.i282 to i64*
  store i64 %conv9.i281, i64* %91, align 8, !tbaa !75
  br label %if.end10.i285

if.end10.i285:                                    ; preds = %if.then7.i283, %if.end.i279
  %92 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i284 = icmp eq i8* %92, null
  br i1 %tobool11.i284, label %cond.false.i291, label %land.lhs.true.i288

land.lhs.true.i288:                               ; preds = %if.end10.i285
  %arrayidx12.i286 = getelementptr inbounds i8* %92, i64 5
  %93 = load i8* %arrayidx12.i286, align 1, !tbaa !5
  %tobool14.i287 = icmp eq i8 %93, 0
  br i1 %tobool14.i287, label %cond.false.i291, label %cond.true.i289

cond.true.i289:                                   ; preds = %land.lhs.true.i288
  tail call void @Perl_op_free(%struct.op* %87) #4
  %94 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %94) #4
  br label %Perl_newSVOP.exit293

cond.false.i291:                                  ; preds = %land.lhs.true.i288, %if.end10.i285
  %95 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i290 = tail call %struct.op* %95(%struct.op* %87) #4
  br label %Perl_newSVOP.exit293

Perl_newSVOP.exit293:                             ; preds = %cond.true.i289, %cond.false.i291
  %cond.i292 = phi %struct.op* [ null, %cond.true.i289 ], [ %call17.i290, %cond.false.i291 ]
  %call129 = tail call %struct.op* @Perl_newUNOP(i64 309, i64 0, %struct.op* %idop)
  %call130 = tail call %struct.op* @Perl_newSTATEOP(i64 0, i8* null, %struct.op* %call129)
  %call131 = tail call %struct.op* @Perl_newSTATEOP(i64 0, i8* null, %struct.op* %veop.0)
  %call132 = tail call i32 (i32, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, %struct.op*, ...)*)(i32 173, %struct.op* %call130, %struct.op* %call131) #4
  %call133 = tail call %struct.op* @Perl_newSTATEOP(i64 0, i8* null, %struct.op* %imop.0)
  %call134 = tail call i32 (i32, i32, %struct.op*, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, i32, %struct.op*, ...)*)(i32 173, i32 %call132, %struct.op* %call133) #4
  %conv135 = sext i32 %call134 to i64
  %96 = inttoptr i64 %conv135 to %struct.op*
  %call136 = tail call %struct.cv* @Perl_newATTRSUB(i64 %floor, %struct.op* %cond.i292, %struct.op* null, %struct.op* null, %struct.op* %96)
  %97 = load i64* @PL_hints, align 8, !tbaa !1
  %or137 = or i64 %97, 256
  store i64 %or137, i64* @PL_hints, align 8, !tbaa !1
  store i64 4294967295, i64* @PL_copline, align 8, !tbaa !1
  store i32 3, i32* @PL_expect, align 4, !tbaa !92
  %98 = load i64* @PL_cop_seqmax, align 8, !tbaa !1
  %inc = add i64 %98, 1
  store i64 %inc, i64* @PL_cop_seqmax, align 8, !tbaa !1
  ret void
}

declare signext i8 @Perl_sv_upgrade(%struct.sv*, i64) #2

declare i32 @Perl_sv_backoff(%struct.sv*) #2

; Function Attrs: nounwind uwtable
define %struct.cv* @Perl_newATTRSUB(i64 %floor, %struct.op* %o, %struct.op* %proto, %struct.op* %attrs, %struct.op* %block) #0 {
entry:
  %n_a = alloca i64, align 8
  %tobool = icmp ne %struct.op* %o, null
  br i1 %tobool, label %cond.true, label %cond.end4

cond.true:                                        ; preds = %entry
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %0 = bitcast %struct.op* %op_sv to %struct.sv**
  %1 = load %struct.sv** %0, align 8, !tbaa !18
  store %struct.sv* %1, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i64* %sv_flags, align 8, !tbaa !34
  %and = and i64 %2, 262144
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true1

cond.true1:                                       ; preds = %cond.true
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %3 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_cur = getelementptr inbounds i8* %3, i64 8
  %4 = bitcast i8* %xpv_cur to i64*
  %5 = load i64* %4, align 8, !tbaa !37
  store i64 %5, i64* %n_a, align 8, !tbaa !1
  %xpv_pv = bitcast i8* %3 to i8**
  %6 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %cond.end4

cond.false:                                       ; preds = %cond.true
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %1, i64* %n_a, i64 2) #4
  br label %cond.end4

cond.end4:                                        ; preds = %entry, %cond.true1, %cond.false
  %cond5 = phi i8* [ %6, %cond.true1 ], [ %call, %cond.false ], [ null, %entry ]
  %tobool6 = icmp ne %struct.op* %proto, null
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  %op_sv7 = getelementptr inbounds %struct.op* %proto, i64 1
  %7 = bitcast %struct.op* %op_sv7 to %struct.sv**
  %8 = load %struct.sv** %7, align 8, !tbaa !18
  store %struct.sv* %8, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %sv_flags8 = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %9 = load i64* %sv_flags8, align 8, !tbaa !34
  %and9 = and i64 %9, 262144
  %cmp10 = icmp eq i64 %and9, 0
  br i1 %cmp10, label %cond.false16, label %cond.true11

cond.true11:                                      ; preds = %if.then
  %sv_any12 = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %10 = load i8** %sv_any12, align 8, !tbaa !36
  %xpv_cur13 = getelementptr inbounds i8* %10, i64 8
  %11 = bitcast i8* %xpv_cur13 to i64*
  %12 = load i64* %11, align 8, !tbaa !37
  store i64 %12, i64* %n_a, align 8, !tbaa !1
  %xpv_pv15 = bitcast i8* %10 to i8**
  %13 = load i8** %xpv_pv15, align 8, !tbaa !39
  br label %if.end

cond.false16:                                     ; preds = %if.then
  %call17 = call i8* @Perl_sv_2pv_flags(%struct.sv* %8, i64* %n_a, i64 2) #4
  br label %if.end

if.end:                                           ; preds = %cond.end4, %cond.true11, %cond.false16
  %ps.0 = phi i8* [ %13, %cond.true11 ], [ %call17, %cond.false16 ], [ null, %cond.end4 ]
  %14 = load i64* @PL_perldb, align 8
  %notlhs = icmp ne i8* %cond5, null
  %notrhs = icmp eq i64 %14, 0
  %or.cond.not = or i1 %notrhs, %notlhs
  %and23 = and i64 %14, 512
  %tobool24 = icmp eq i64 %and23, 0
  %or.cond967 = or i1 %or.cond.not, %tobool24
  br i1 %or.cond967, label %if.end57, label %land.lhs.true25

land.lhs.true25:                                  ; preds = %if.end
  %15 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line = getelementptr inbounds %struct.cop* %15, i64 0, i32 13
  %16 = load i64* %cop_line, align 8, !tbaa !116
  %tobool26 = icmp eq i64 %16, 0
  br i1 %tobool26, label %if.end57, label %if.then27

if.then27:                                        ; preds = %land.lhs.true25
  %call28 = call %struct.sv* @Perl_sv_newmortal() #4
  %17 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  %tobool29 = icmp ne %struct.hv* %17, null
  %cond30 = select i1 %tobool29, i8* getelementptr inbounds ([9 x i8]* @.str66, i64 0, i64 0), i8* getelementptr inbounds ([19 x i8]* @.str67, i64 0, i64 0)
  %18 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv = getelementptr inbounds %struct.cop* %18, i64 0, i32 10
  %19 = load %struct.gv** %cop_filegv, align 8, !tbaa !97
  %tobool31 = icmp eq %struct.gv* %19, null
  br i1 %tobool31, label %cond.end51, label %cond.true32

cond.true32:                                      ; preds = %if.then27
  %20 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv33 = getelementptr inbounds %struct.cop* %20, i64 0, i32 10
  %21 = load %struct.gv** %cop_filegv33, align 8, !tbaa !97
  %sv_any34 = getelementptr inbounds %struct.gv* %21, i64 0, i32 0
  %22 = load %struct.xpvgv** %sv_any34, align 8, !tbaa !60
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %22, i64 0, i32 7
  %23 = load %struct.gp** %xgv_gp, align 8, !tbaa !62
  %gp_sv = getelementptr inbounds %struct.gp* %23, i64 0, i32 0
  %24 = load %struct.sv** %gp_sv, align 8, !tbaa !135
  %tobool35 = icmp eq %struct.sv* %24, null
  br i1 %tobool35, label %cond.end51, label %cond.true37

cond.true37:                                      ; preds = %cond.true32
  %25 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %26 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv41 = getelementptr inbounds %struct.cop* %26, i64 0, i32 10
  %27 = load %struct.gv** %cop_filegv41, align 8, !tbaa !97
  %sv_any42 = getelementptr inbounds %struct.gv* %27, i64 0, i32 0
  %28 = load %struct.xpvgv** %sv_any42, align 8, !tbaa !60
  %xgv_gp43 = getelementptr inbounds %struct.xpvgv* %28, i64 0, i32 7
  %29 = load %struct.gp** %xgv_gp43, align 8, !tbaa !62
  %gp_sv44 = getelementptr inbounds %struct.gp* %29, i64 0, i32 0
  %30 = load %struct.sv** %gp_sv44, align 8, !tbaa !135
  %sv_any48 = getelementptr inbounds %struct.sv* %30, i64 0, i32 0
  %31 = load i8** %sv_any48, align 8, !tbaa !36
  %xpv_pv49 = bitcast i8* %31 to i8**
  %32 = load i8** %xpv_pv49, align 8, !tbaa !39
  br label %cond.end51

cond.end51:                                       ; preds = %cond.true32, %if.then27, %cond.true37
  %cond52 = phi i8* [ %32, %cond.true37 ], [ null, %if.then27 ], [ null, %cond.true32 ]
  %33 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line53 = getelementptr inbounds %struct.cop* %33, i64 0, i32 13
  %34 = load i64* %cop_line53, align 8, !tbaa !116
  call void (%struct.sv*, i8*, ...)* @Perl_sv_setpvf(%struct.sv* %call28, i8* getelementptr inbounds ([11 x i8]* @.str65, i64 0, i64 0), i8* %cond30, i8* %cond52, i64 %34) #4
  %sv_any54 = getelementptr inbounds %struct.sv* %call28, i64 0, i32 0
  %35 = load i8** %sv_any54, align 8, !tbaa !36
  %xpv_pv55 = bitcast i8* %35 to i8**
  %36 = load i8** %xpv_pv55, align 8, !tbaa !39
  br label %if.end57

if.end57:                                         ; preds = %land.lhs.true25, %if.end, %cond.end51
  %aname.0 = phi i8* [ %36, %cond.end51 ], [ null, %if.end ], [ null, %land.lhs.true25 ]
  br i1 %notlhs, label %cond.end68, label %cond.false60

cond.false60:                                     ; preds = %if.end57
  %tobool61 = icmp eq i8* %aname.0, null
  br i1 %tobool61, label %cond.false63, label %cond.end68

cond.false63:                                     ; preds = %cond.false60
  %37 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  %tobool64 = icmp ne %struct.hv* %37, null
  %cond65 = select i1 %tobool64, i8* getelementptr inbounds ([9 x i8]* @.str66, i64 0, i64 0), i8* getelementptr inbounds ([19 x i8]* @.str67, i64 0, i64 0)
  br label %cond.end68

cond.end68:                                       ; preds = %cond.false60, %if.end57, %cond.false63
  %cond69 = phi i8* [ %cond65, %cond.false63 ], [ %cond5, %if.end57 ], [ %aname.0, %cond.false60 ]
  %tobool70 = icmp ne %struct.op* %block, null
  br i1 %tobool70, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end68
  %tobool71 = icmp ne %struct.op* %attrs, null
  %phitmp = select i1 %tobool71, i64 2, i64 18
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end68
  %38 = phi i64 [ 2, %cond.end68 ], [ %phitmp, %lor.rhs ]
  %call73 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond69, i64 %38, i64 12) #4
  br i1 %tobool, label %if.then75, label %if.end77

if.then75:                                        ; preds = %lor.end
  %call76 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @save_freeop to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  br label %if.end77

if.end77:                                         ; preds = %if.then75, %lor.end
  br i1 %tobool6, label %if.then79, label %if.end81

if.then79:                                        ; preds = %if.end77
  %call80 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @save_freeop to i32 (%struct.op*, ...)*)(%struct.op* %proto) #4
  br label %if.end81

if.end81:                                         ; preds = %if.then79, %if.end77
  %tobool82 = icmp ne %struct.op* %attrs, null
  br i1 %tobool82, label %if.then83, label %if.end85

if.then83:                                        ; preds = %if.end81
  %call84 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @save_freeop to i32 (%struct.op*, ...)*)(%struct.op* %attrs) #4
  br label %if.end85

if.end85:                                         ; preds = %if.then83, %if.end81
  %sv_flags86 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 2
  %39 = load i64* %sv_flags86, align 8, !tbaa !136
  %and87 = and i64 %39, 255
  switch i64 %and87, label %if.then95 [
    i64 13, label %if.end132
    i64 0, label %if.end127
  ]

if.then95:                                        ; preds = %if.end85
  %and97 = and i64 %39, 262144
  %tobool98 = icmp eq i64 %and97, 0
  br i1 %tobool98, label %land.lhs.true99, label %if.end125

land.lhs.true99:                                  ; preds = %if.then95
  %and101 = and i64 %39, 65536
  %tobool102 = icmp eq i64 %and101, 0
  br i1 %tobool102, label %land.lhs.true107, label %land.lhs.true103

land.lhs.true103:                                 ; preds = %land.lhs.true99
  %sv_any104 = bitcast %struct.gv* %call73 to i8**
  %40 = load i8** %sv_any104, align 8, !tbaa !36
  %xiv_iv = getelementptr inbounds i8* %40, i64 24
  %41 = bitcast i8* %xiv_iv to i64*
  %42 = load i64* %41, align 8, !tbaa !53
  %cmp105 = icmp eq i64 %42, -1
  br i1 %cmp105, label %if.end125, label %land.lhs.true107

land.lhs.true107:                                 ; preds = %land.lhs.true99, %land.lhs.true103
  %43 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %43, i64 0, i32 14
  %44 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp108 = icmp eq %struct.sv* %44, null
  br i1 %cmp108, label %if.then124, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true107
  %45 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings110 = getelementptr inbounds %struct.cop* %45, i64 0, i32 14
  %46 = load %struct.sv** %cop_warnings110, align 8, !tbaa !47
  %cmp111 = icmp eq %struct.sv* %46, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp111, label %if.then124, label %lor.lhs.false113

lor.lhs.false113:                                 ; preds = %lor.lhs.false
  %47 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings114 = getelementptr inbounds %struct.cop* %47, i64 0, i32 14
  %48 = load %struct.sv** %cop_warnings114, align 8, !tbaa !47
  %cmp115 = icmp eq %struct.sv* %48, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp115, label %if.end125, label %land.lhs.true117

land.lhs.true117:                                 ; preds = %lor.lhs.false113
  %49 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings118 = getelementptr inbounds %struct.cop* %49, i64 0, i32 14
  %50 = load %struct.sv** %cop_warnings118, align 8, !tbaa !47
  %sv_any119 = getelementptr inbounds %struct.sv* %50, i64 0, i32 0
  %51 = load i8** %sv_any119, align 8, !tbaa !36
  %xpv_pv120 = bitcast i8* %51 to i8**
  %52 = load i8** %xpv_pv120, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8* %52, i64 8
  %53 = load i8* %arrayidx, align 1, !tbaa !5
  %and122 = and i8 %53, 64
  %tobool123 = icmp eq i8 %and122, 0
  br i1 %tobool123, label %if.end125, label %if.then124

if.then124:                                       ; preds = %land.lhs.true117, %lor.lhs.false, %land.lhs.true107
  call void (i64, i8*, ...)* @Perl_warner(i64 35, i8* getelementptr inbounds ([18 x i8]* @.str68, i64 0, i64 0)) #4
  br label %if.end125

if.end125:                                        ; preds = %land.lhs.true117, %lor.lhs.false113, %if.then95, %if.then124, %land.lhs.true103
  %54 = bitcast %struct.gv* %call73 to %struct.cv*
  %call126 = call i32 (%struct.cv*, i8*, i8*, ...)* bitcast (i32 (...)* @cv_ckproto to i32 (%struct.cv*, i8*, i8*, ...)*)(%struct.cv* %54, i8* null, i8* %ps.0) #4
  br label %if.end127

if.end127:                                        ; preds = %if.end85, %if.end125
  %tobool128 = icmp eq i8* %ps.0, null
  %55 = bitcast %struct.gv* %call73 to %struct.sv*
  br i1 %tobool128, label %if.else130, label %if.then129

if.then129:                                       ; preds = %if.end127
  call void @Perl_sv_setpv(%struct.sv* %55, i8* %ps.0) #4
  br label %if.end131

if.else130:                                       ; preds = %if.end127
  call void @Perl_sv_setiv(%struct.sv* %55, i64 -1) #4
  br label %if.end131

if.end131:                                        ; preds = %if.else130, %if.then129
  %56 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %57 = bitcast %struct.cv* %56 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %57) #4
  store %struct.cv* null, %struct.cv** @PL_compcv, align 8, !tbaa !6
  %58 = load i64* @PL_sub_generation, align 8, !tbaa !1
  %inc = add i64 %58, 1
  store i64 %inc, i64* @PL_sub_generation, align 8, !tbaa !1
  br label %done

if.end132:                                        ; preds = %if.end85
  br i1 %notlhs, label %lor.lhs.false134, label %cond.end142

lor.lhs.false134:                                 ; preds = %if.end132
  %sv_any135 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %59 = load %struct.xpvgv** %sv_any135, align 8, !tbaa !60
  %xgv_gp136 = getelementptr inbounds %struct.xpvgv* %59, i64 0, i32 7
  %60 = load %struct.gp** %xgv_gp136, align 8, !tbaa !62
  %gp_cvgen = getelementptr inbounds %struct.gp* %60, i64 0, i32 8
  %61 = load i64* %gp_cvgen, align 8, !tbaa !137
  %tobool137 = icmp eq i64 %61, 0
  br i1 %tobool137, label %cond.false139, label %cond.end142

cond.false139:                                    ; preds = %lor.lhs.false134
  %gp_cv = getelementptr inbounds %struct.gp* %60, i64 0, i32 7
  %62 = load %struct.cv** %gp_cv, align 8, !tbaa !64
  br label %cond.end142

cond.end142:                                      ; preds = %lor.lhs.false134, %if.end132, %cond.false139
  %cond143 = phi %struct.cv* [ %62, %cond.false139 ], [ null, %lor.lhs.false134 ], [ null, %if.end132 ]
  %tobool146 = icmp ne i8* %ps.0, null
  %or.cond790 = and i1 %tobool70, %tobool146
  br i1 %or.cond790, label %lor.lhs.false147, label %if.end156

lor.lhs.false147:                                 ; preds = %cond.end142
  %63 = load i8* %ps.0, align 1, !tbaa !5
  %tobool149 = icmp ne i8 %63, 0
  %or.cond791 = or i1 %tobool149, %tobool82
  br i1 %or.cond791, label %if.end156, label %if.else153

if.else153:                                       ; preds = %lor.lhs.false147
  %call154 = call i32 (%struct.op*, %struct.cv*, ...)* bitcast (i32 (...)* @op_const_sv to i32 (%struct.op*, %struct.cv*, ...)*)(%struct.op* %block, %struct.cv* null) #4
  %conv155 = sext i32 %call154 to i64
  %64 = inttoptr i64 %conv155 to %struct.sv*
  br label %if.end156

if.end156:                                        ; preds = %cond.end142, %lor.lhs.false147, %if.else153
  %const_sv.0 = phi %struct.sv* [ %64, %if.else153 ], [ null, %lor.lhs.false147 ], [ null, %cond.end142 ]
  %tobool157 = icmp eq %struct.cv* %cond143, null
  br i1 %tobool157, label %if.end267, label %if.then158

if.then158:                                       ; preds = %if.end156
  %sv_any159 = getelementptr inbounds %struct.cv* %cond143, i64 0, i32 0
  %65 = load %struct.xpvcv** %sv_any159, align 8, !tbaa !66
  %xcv_root = getelementptr inbounds %struct.xpvcv* %65, i64 0, i32 9
  %66 = load %struct.op** %xcv_root, align 8, !tbaa !138
  %tobool160 = icmp eq %struct.op* %66, null
  br i1 %tobool160, label %lor.end164, label %if.end174.thread970

lor.end164:                                       ; preds = %if.then158
  %xcv_xsub = getelementptr inbounds %struct.xpvcv* %65, i64 0, i32 10
  %67 = load void (%struct.cv*)** %xcv_xsub, align 8, !tbaa !139
  %tobool163 = icmp eq void (%struct.cv*)* %67, null
  br i1 %tobool163, label %lor.lhs.false168, label %if.end174.thread970

lor.lhs.false168:                                 ; preds = %lor.end164
  %sv_flags169 = getelementptr inbounds %struct.cv* %cond143, i64 0, i32 2
  %68 = load i64* %sv_flags169, align 8, !tbaa !140
  %and170 = and i64 %68, 262144
  %tobool171 = icmp eq i64 %and170, 0
  br i1 %tobool171, label %lor.lhs.false177, label %if.end174.thread972

if.end174.thread972:                              ; preds = %lor.lhs.false168
  %call173973 = call i32 (%struct.cv*, %struct.gv*, i8*, ...)* bitcast (i32 (...)* @cv_ckproto to i32 (%struct.cv*, %struct.gv*, i8*, ...)*)(%struct.cv* %cond143, %struct.gv* %call73, i8* %ps.0) #4
  br label %lor.lhs.false177

if.end174.thread970:                              ; preds = %lor.end164, %if.then158
  %call173971 = call i32 (%struct.cv*, %struct.gv*, i8*, ...)* bitcast (i32 (...)* @cv_ckproto to i32 (%struct.cv*, %struct.gv*, i8*, ...)*)(%struct.cv* %cond143, %struct.gv* %call73, i8* %ps.0) #4
  br label %if.then182

lor.lhs.false177:                                 ; preds = %lor.lhs.false168, %if.end174.thread972
  %sv_any178 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %69 = load %struct.xpvgv** %sv_any178, align 8, !tbaa !60
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %69, i64 0, i32 11
  %70 = load i8* %xgv_flags, align 1, !tbaa !141
  %and180 = and i8 %70, 4
  %tobool181 = icmp eq i8 %and180, 0
  br i1 %tobool181, label %if.end267, label %if.then182

if.then182:                                       ; preds = %if.end174.thread970, %lor.lhs.false177
  %or.cond792 = or i1 %tobool70, %tobool82
  br i1 %or.cond792, label %if.end200, label %if.then186

if.then186:                                       ; preds = %if.then182
  %71 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %sv_any187 = getelementptr inbounds %struct.cv* %71, i64 0, i32 0
  %72 = load %struct.xpvcv** %sv_any187, align 8, !tbaa !66
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %72, i64 0, i32 17
  %73 = load i16* %xcv_flags, align 2, !tbaa !68
  %tobool188 = icmp eq i16 %73, 0
  br i1 %tobool188, label %if.end199, label %if.then189

if.then189:                                       ; preds = %if.then186
  %and193 = and i16 %73, 448
  %74 = load %struct.xpvcv** %sv_any159, align 8, !tbaa !66
  %xcv_flags195 = getelementptr inbounds %struct.xpvcv* %74, i64 0, i32 17
  %75 = load i16* %xcv_flags195, align 2, !tbaa !68
  %or197 = or i16 %75, %and193
  store i16 %or197, i16* %xcv_flags195, align 2, !tbaa !68
  br label %if.end199

if.end199:                                        ; preds = %if.then186, %if.then189
  %76 = bitcast %struct.cv* %71 to %struct.sv*
  call void @Perl_save_freesv(%struct.sv* %76) #4
  br label %done

if.end200:                                        ; preds = %if.then182
  %77 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !6
  %si_type = getelementptr inbounds %struct.stackinfo* %77, i64 0, i32 4
  %78 = load i64* %si_type, align 8, !tbaa !142
  %cmp201 = icmp eq i64 %78, 3
  br i1 %cmp201, label %land.lhs.true203, label %if.end208

land.lhs.true203:                                 ; preds = %if.end200
  %79 = load %struct.op** @PL_sortcop, align 8, !tbaa !6
  %80 = load %struct.xpvcv** %sv_any159, align 8, !tbaa !66
  %xcv_start = getelementptr inbounds %struct.xpvcv* %80, i64 0, i32 8
  %81 = load %struct.op** %xcv_start, align 8, !tbaa !144
  %cmp205 = icmp eq %struct.op* %79, %81
  br i1 %cmp205, label %if.then207, label %if.end208

if.then207:                                       ; preds = %land.lhs.true203
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([41 x i8]* @.str69, i64 0, i64 0), i8* %cond5) #4
  br label %if.end208

if.end208:                                        ; preds = %if.then207, %land.lhs.true203, %if.end200
  br i1 %tobool70, label %if.then210, label %if.end267

if.then210:                                       ; preds = %if.end208
  %82 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings211 = getelementptr inbounds %struct.cop* %82, i64 0, i32 14
  %83 = load %struct.sv** %cop_warnings211, align 8, !tbaa !47
  %cmp212 = icmp eq %struct.sv* %83, null
  br i1 %cmp212, label %lor.lhs.false230, label %land.lhs.true214

land.lhs.true214:                                 ; preds = %if.then210
  %84 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings215 = getelementptr inbounds %struct.cop* %84, i64 0, i32 14
  %85 = load %struct.sv** %cop_warnings215, align 8, !tbaa !47
  %cmp216 = icmp eq %struct.sv* %85, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp216, label %lor.lhs.false230, label %land.lhs.true218

land.lhs.true218:                                 ; preds = %land.lhs.true214
  %86 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings219 = getelementptr inbounds %struct.cop* %86, i64 0, i32 14
  %87 = load %struct.sv** %cop_warnings219, align 8, !tbaa !47
  %cmp220 = icmp eq %struct.sv* %87, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp220, label %if.then250, label %lor.lhs.false222

lor.lhs.false222:                                 ; preds = %land.lhs.true218
  %88 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings223 = getelementptr inbounds %struct.cop* %88, i64 0, i32 14
  %89 = load %struct.sv** %cop_warnings223, align 8, !tbaa !47
  %sv_any224 = getelementptr inbounds %struct.sv* %89, i64 0, i32 0
  %90 = load i8** %sv_any224, align 8, !tbaa !36
  %xpv_pv225 = bitcast i8* %90 to i8**
  %91 = load i8** %xpv_pv225, align 8, !tbaa !39
  %arrayidx226 = getelementptr inbounds i8* %91, i64 4
  %92 = load i8* %arrayidx226, align 1, !tbaa !5
  %and228 = and i8 %92, 64
  %tobool229 = icmp eq i8 %and228, 0
  br i1 %tobool229, label %lor.lhs.false230, label %if.then250

lor.lhs.false230:                                 ; preds = %lor.lhs.false222, %land.lhs.true214, %if.then210
  %93 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings231 = getelementptr inbounds %struct.cop* %93, i64 0, i32 14
  %94 = load %struct.sv** %cop_warnings231, align 8, !tbaa !47
  %cmp232 = icmp eq %struct.sv* %94, null
  br i1 %cmp232, label %land.lhs.true234, label %lor.lhs.false238

land.lhs.true234:                                 ; preds = %lor.lhs.false230
  %95 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and236 = and i8 %95, 1
  %tobool237 = icmp eq i8 %and236, 0
  br i1 %tobool237, label %lor.lhs.false238, label %if.then250

lor.lhs.false238:                                 ; preds = %land.lhs.true234, %lor.lhs.false230
  %96 = load %struct.xpvcv** %sv_any159, align 8, !tbaa !66
  %xcv_flags240 = getelementptr inbounds %struct.xpvcv* %96, i64 0, i32 17
  %97 = load i16* %xcv_flags240, align 2, !tbaa !68
  %and242 = and i16 %97, 512
  %tobool243 = icmp eq i16 %and242, 0
  br i1 %tobool243, label %if.end264, label %land.lhs.true244

land.lhs.true244:                                 ; preds = %lor.lhs.false238
  %tobool245 = icmp eq %struct.sv* %const_sv.0, null
  br i1 %tobool245, label %if.then250, label %Perl_cv_const_sv.exit

Perl_cv_const_sv.exit:                            ; preds = %land.lhs.true244
  %any_ptr.i = getelementptr inbounds %struct.xpvcv* %96, i64 0, i32 11, i32 0
  %98 = load i8** %any_ptr.i, align 8, !tbaa !6
  %99 = bitcast i8* %98 to %struct.sv*
  %call248 = call i64 @Perl_sv_cmp(%struct.sv* %99, %struct.sv* %const_sv.0) #4
  %tobool249 = icmp eq i64 %call248, 0
  br i1 %tobool249, label %if.end264, label %if.then250

if.then250:                                       ; preds = %lor.lhs.false222, %land.lhs.true234, %Perl_cv_const_sv.exit, %land.lhs.true244, %land.lhs.true218
  %100 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line251 = getelementptr inbounds %struct.cop* %100, i64 0, i32 13
  %101 = load i64* %cop_line251, align 8, !tbaa !116
  %102 = load i64* @PL_copline, align 8, !tbaa !1
  %cmp252 = icmp eq i64 %102, 4294967295
  br i1 %cmp252, label %if.end256, label %if.then254

if.then254:                                       ; preds = %if.then250
  %103 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line255 = getelementptr inbounds %struct.cop* %103, i64 0, i32 13
  store i64 %102, i64* %cop_line255, align 8, !tbaa !116
  br label %if.end256

if.end256:                                        ; preds = %if.then250, %if.then254
  %104 = load %struct.xpvcv** %sv_any159, align 8, !tbaa !66
  %xcv_flags258 = getelementptr inbounds %struct.xpvcv* %104, i64 0, i32 17
  %105 = load i16* %xcv_flags258, align 2, !tbaa !68
  %and260 = and i16 %105, 512
  %tobool261 = icmp ne i16 %and260, 0
  %cond262 = select i1 %tobool261, i8* getelementptr inbounds ([33 x i8]* @.str70, i64 0, i64 0), i8* getelementptr inbounds ([24 x i8]* @.str71, i64 0, i64 0)
  call void (i64, i8*, ...)* @Perl_warner(i64 19, i8* %cond262, i8* %cond5) #4
  %106 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line263 = getelementptr inbounds %struct.cop* %106, i64 0, i32 13
  store i64 %101, i64* %cop_line263, align 8, !tbaa !116
  br label %if.end264

if.end264:                                        ; preds = %Perl_cv_const_sv.exit, %lor.lhs.false238, %if.end256
  %107 = bitcast %struct.cv* %cond143 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %107) #4
  br label %if.end267

if.end267:                                        ; preds = %lor.lhs.false177, %if.end156, %if.end264, %if.end208
  %cv.0 = phi %struct.cv* [ null, %if.end264 ], [ %cond143, %if.end208 ], [ %cond143, %lor.lhs.false177 ], [ null, %if.end156 ]
  %tobool268 = icmp eq %struct.sv* %const_sv.0, null
  br i1 %tobool268, label %if.end290, label %if.then269

if.then269:                                       ; preds = %if.end267
  store %struct.sv* %const_sv.0, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %sv_refcnt = getelementptr inbounds %struct.sv* %const_sv.0, i64 0, i32 1
  %108 = load i64* %sv_refcnt, align 8, !tbaa !40
  %inc271 = add i64 %108, 1
  store i64 %inc271, i64* %sv_refcnt, align 8, !tbaa !40
  %tobool273 = icmp eq %struct.cv* %cv.0, null
  br i1 %tobool273, label %if.else283, label %if.then274

if.then274:                                       ; preds = %if.then269
  %109 = bitcast %struct.cv* %cv.0 to %struct.sv*
  call void @Perl_sv_setpv(%struct.sv* %109, i8* getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0)) #4
  %110 = bitcast %struct.sv* %const_sv.0 to i8*
  %sv_any275 = getelementptr inbounds %struct.cv* %cv.0, i64 0, i32 0
  %111 = load %struct.xpvcv** %sv_any275, align 8, !tbaa !66
  %any_ptr = getelementptr inbounds %struct.xpvcv* %111, i64 0, i32 11, i32 0
  store i8* %110, i8** %any_ptr, align 8, !tbaa !6
  %112 = load %struct.xpvcv** %sv_any275, align 8, !tbaa !66
  %xcv_xsub277 = getelementptr inbounds %struct.xpvcv* %112, i64 0, i32 10
  store void (%struct.cv*)* @const_sv_xsub, void (%struct.cv*)** %xcv_xsub277, align 8, !tbaa !139
  %xcv_flags279 = getelementptr inbounds %struct.xpvcv* %112, i64 0, i32 17
  %113 = load i16* %xcv_flags279, align 2, !tbaa !68
  %or281 = or i16 %113, 512
  store i16 %or281, i16* %xcv_flags279, align 2, !tbaa !68
  br label %if.end288

if.else283:                                       ; preds = %if.then269
  %sv_any284 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %114 = load %struct.xpvgv** %sv_any284, align 8, !tbaa !60
  %xgv_gp285 = getelementptr inbounds %struct.xpvgv* %114, i64 0, i32 7
  %115 = load %struct.gp** %xgv_gp285, align 8, !tbaa !62
  %gp_cv286 = getelementptr inbounds %struct.gp* %115, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv286, align 8, !tbaa !64
  %call287 = call %struct.cv* @Perl_newCONSTSUB(%struct.hv* null, i8* %cond5, %struct.sv* %const_sv.0)
  br label %if.end288

if.end288:                                        ; preds = %if.else283, %if.then274
  %cv.1 = phi %struct.cv* [ %cv.0, %if.then274 ], [ %call287, %if.else283 ]
  call void @Perl_op_free(%struct.op* %block)
  %116 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %117 = bitcast %struct.cv* %116 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %117) #4
  store %struct.cv* null, %struct.cv** @PL_compcv, align 8, !tbaa !6
  %118 = load i64* @PL_sub_generation, align 8, !tbaa !1
  %inc289 = add i64 %118, 1
  store i64 %inc289, i64* @PL_sub_generation, align 8, !tbaa !1
  br label %done

if.end290:                                        ; preds = %if.end267
  br i1 %tobool82, label %if.then292, label %if.end340

if.then292:                                       ; preds = %if.end290
  %tobool293 = icmp eq %struct.cv* %cv.0, null
  %or.cond793 = or i1 %tobool293, %tobool70
  br i1 %or.cond793, label %if.else327, label %if.then296

if.then296:                                       ; preds = %if.then292
  %119 = bitcast %struct.cv* %cv.0 to %struct.sv*
  %120 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %sv_any297 = getelementptr inbounds %struct.cv* %120, i64 0, i32 0
  %121 = load %struct.xpvcv** %sv_any297, align 8, !tbaa !66
  %xcv_flags298 = getelementptr inbounds %struct.xpvcv* %121, i64 0, i32 17
  %122 = load i16* %xcv_flags298, align 2, !tbaa !68
  %and300 = and i16 %122, 448
  %sv_any301 = getelementptr inbounds %struct.cv* %cv.0, i64 0, i32 0
  %123 = load %struct.xpvcv** %sv_any301, align 8, !tbaa !66
  %xcv_flags302 = getelementptr inbounds %struct.xpvcv* %123, i64 0, i32 17
  %124 = load i16* %xcv_flags302, align 2, !tbaa !68
  %or304 = or i16 %124, %and300
  store i16 %or304, i16* %xcv_flags302, align 2, !tbaa !68
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %123, i64 0, i32 12
  %125 = load %struct.gv** %xcv_gv, align 8, !tbaa !145
  %tobool307 = icmp eq %struct.gv* %125, null
  br i1 %tobool307, label %if.else318, label %land.lhs.true308

land.lhs.true308:                                 ; preds = %if.then296
  %sv_any311 = getelementptr inbounds %struct.gv* %125, i64 0, i32 0
  %126 = load %struct.xpvgv** %sv_any311, align 8, !tbaa !60
  %xgv_stash = getelementptr inbounds %struct.xpvgv* %126, i64 0, i32 10
  %127 = load %struct.hv** %xgv_stash, align 8, !tbaa !146
  %tobool312 = icmp eq %struct.hv* %127, null
  br i1 %tobool312, label %if.else318, label %if.end338

if.else318:                                       ; preds = %land.lhs.true308, %if.then296
  %xcv_stash = getelementptr inbounds %struct.xpvcv* %123, i64 0, i32 7
  %128 = load %struct.hv** %xcv_stash, align 8, !tbaa !147
  %tobool320 = icmp eq %struct.hv* %128, null
  %129 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  %. = select i1 %tobool320, %struct.hv* %129, %struct.hv* %128
  br label %if.end338

if.else327:                                       ; preds = %if.then292
  %130 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %131 = bitcast %struct.cv* %130 to %struct.sv*
  br i1 %notlhs, label %land.lhs.true329, label %if.else336

land.lhs.true329:                                 ; preds = %if.else327
  %sv_any330 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %132 = load %struct.xpvgv** %sv_any330, align 8, !tbaa !60
  %xgv_stash331 = getelementptr inbounds %struct.xpvgv* %132, i64 0, i32 10
  %133 = load %struct.hv** %xgv_stash331, align 8, !tbaa !146
  %tobool332 = icmp eq %struct.hv* %133, null
  br i1 %tobool332, label %if.else336, label %if.end338

if.else336:                                       ; preds = %land.lhs.true329, %if.else327
  %134 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  br label %if.end338

if.end338:                                        ; preds = %if.else318, %land.lhs.true329, %land.lhs.true308, %if.else336
  %rcv.0 = phi %struct.sv* [ %131, %if.else336 ], [ %119, %land.lhs.true308 ], [ %131, %land.lhs.true329 ], [ %119, %if.else318 ]
  %stash.0 = phi %struct.hv* [ %134, %if.else336 ], [ %127, %land.lhs.true308 ], [ %133, %land.lhs.true329 ], [ %., %if.else318 ]
  %call339 = call i32 (%struct.hv*, %struct.sv*, %struct.op*, i32, ...)* bitcast (i32 (...)* @apply_attrs to i32 (%struct.hv*, %struct.sv*, %struct.op*, i32, ...)*)(%struct.hv* %stash.0, %struct.sv* %rcv.0, %struct.op* %attrs, i32 0) #4
  br label %if.end340

if.end340:                                        ; preds = %if.end338, %if.end290
  %tobool341 = icmp eq %struct.cv* %cv.0, null
  br i1 %tobool341, label %if.else382, label %if.then342

if.then342:                                       ; preds = %if.end340
  br i1 %tobool70, label %if.end345, label %if.then344

if.then344:                                       ; preds = %if.then342
  %135 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %136 = bitcast %struct.cv* %135 to %struct.sv*
  call void @Perl_save_freesv(%struct.sv* %136) #4
  br label %done

if.end345:                                        ; preds = %if.then342
  call void @Perl_cv_undef(%struct.cv* %cv.0)
  %137 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %sv_any346 = getelementptr inbounds %struct.cv* %137, i64 0, i32 0
  %138 = load %struct.xpvcv** %sv_any346, align 8, !tbaa !66
  %xcv_flags347 = getelementptr inbounds %struct.xpvcv* %138, i64 0, i32 17
  %139 = load i16* %xcv_flags347, align 2, !tbaa !68
  %sv_any348 = getelementptr inbounds %struct.cv* %cv.0, i64 0, i32 0
  %140 = load %struct.xpvcv** %sv_any348, align 8, !tbaa !66
  %xcv_flags349 = getelementptr inbounds %struct.xpvcv* %140, i64 0, i32 17
  store i16 %139, i16* %xcv_flags349, align 2, !tbaa !68
  %and353 = and i16 %139, 1024
  %tobool354 = icmp eq i16 %and353, 0
  br i1 %tobool354, label %if.then355, label %if.end357

if.then355:                                       ; preds = %if.end345
  %xcv_outside = getelementptr inbounds %struct.xpvcv* %140, i64 0, i32 16
  %141 = load %struct.cv** %xcv_outside, align 8, !tbaa !148
  %142 = bitcast %struct.cv* %141 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %142) #4
  %.pre977 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %sv_any358.phi.trans.insert = getelementptr inbounds %struct.cv* %.pre977, i64 0, i32 0
  %.pre978 = load %struct.xpvcv** %sv_any358.phi.trans.insert, align 8, !tbaa !66
  %.pre979 = load %struct.xpvcv** %sv_any348, align 8, !tbaa !66
  br label %if.end357

if.end357:                                        ; preds = %if.end345, %if.then355
  %143 = phi %struct.xpvcv* [ %140, %if.end345 ], [ %.pre979, %if.then355 ]
  %144 = phi %struct.xpvcv* [ %138, %if.end345 ], [ %.pre978, %if.then355 ]
  %xcv_outside359 = getelementptr inbounds %struct.xpvcv* %144, i64 0, i32 16
  %145 = load %struct.cv** %xcv_outside359, align 8, !tbaa !148
  %xcv_outside361 = getelementptr inbounds %struct.xpvcv* %143, i64 0, i32 16
  store %struct.cv* %145, %struct.cv** %xcv_outside361, align 8, !tbaa !148
  %146 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %sv_any362 = getelementptr inbounds %struct.cv* %146, i64 0, i32 0
  %147 = load %struct.xpvcv** %sv_any362, align 8, !tbaa !66
  %xcv_outside_seq = getelementptr inbounds %struct.xpvcv* %147, i64 0, i32 18
  %148 = load i64* %xcv_outside_seq, align 8, !tbaa !149
  %xcv_outside_seq364 = getelementptr inbounds %struct.xpvcv* %143, i64 0, i32 18
  store i64 %148, i64* %xcv_outside_seq364, align 8, !tbaa !149
  %xcv_outside366 = getelementptr inbounds %struct.xpvcv* %147, i64 0, i32 16
  store %struct.cv* null, %struct.cv** %xcv_outside366, align 8, !tbaa !148
  %149 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %sv_any367 = getelementptr inbounds %struct.cv* %149, i64 0, i32 0
  %150 = load %struct.xpvcv** %sv_any367, align 8, !tbaa !66
  %xcv_padlist = getelementptr inbounds %struct.xpvcv* %150, i64 0, i32 15
  %151 = load %struct.av** %xcv_padlist, align 8, !tbaa !150
  %xcv_padlist369 = getelementptr inbounds %struct.xpvcv* %143, i64 0, i32 15
  store %struct.av* %151, %struct.av** %xcv_padlist369, align 8, !tbaa !150
  %152 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %sv_any370 = getelementptr inbounds %struct.cv* %152, i64 0, i32 0
  %153 = load %struct.xpvcv** %sv_any370, align 8, !tbaa !66
  %xcv_padlist371 = getelementptr inbounds %struct.xpvcv* %153, i64 0, i32 15
  store %struct.av* null, %struct.av** %xcv_padlist371, align 8, !tbaa !150
  %154 = load %struct.av** %xcv_padlist369, align 8, !tbaa !150
  %155 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %call374 = call i32 (%struct.av*, %struct.cv*, %struct.cv*, ...)* bitcast (i32 (...)* @pad_fixup_inner_anons to i32 (%struct.av*, %struct.cv*, %struct.cv*, ...)*)(%struct.av* %154, %struct.cv* %155, %struct.cv* %cv.0) #4
  %156 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %157 = bitcast %struct.cv* %156 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %157) #4
  %158 = load i64* @PL_perldb, align 8, !tbaa !1
  %and377 = and i64 %158, 8
  %tobool378 = icmp eq i64 %and377, 0
  br i1 %tobool378, label %if.end393, label %if.then379

if.then379:                                       ; preds = %if.end357
  %159 = load i64* @PL_sub_generation, align 8, !tbaa !1
  %inc380 = add i64 %159, 1
  store i64 %inc380, i64* @PL_sub_generation, align 8, !tbaa !1
  br label %if.end393

if.else382:                                       ; preds = %if.end340
  %160 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  br i1 %notlhs, label %if.then384, label %if.end393

if.then384:                                       ; preds = %if.else382
  %sv_any385 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %161 = load %struct.xpvgv** %sv_any385, align 8, !tbaa !60
  %xgv_gp386 = getelementptr inbounds %struct.xpvgv* %161, i64 0, i32 7
  %162 = load %struct.gp** %xgv_gp386, align 8, !tbaa !62
  %gp_cv387 = getelementptr inbounds %struct.gp* %162, i64 0, i32 7
  store %struct.cv* %160, %struct.cv** %gp_cv387, align 8, !tbaa !64
  %gp_cvgen390 = getelementptr inbounds %struct.gp* %162, i64 0, i32 8
  store i64 0, i64* %gp_cvgen390, align 8, !tbaa !137
  %163 = load i64* @PL_sub_generation, align 8, !tbaa !1
  %inc391 = add i64 %163, 1
  store i64 %inc391, i64* @PL_sub_generation, align 8, !tbaa !1
  br label %if.end393

if.end393:                                        ; preds = %if.end357, %if.else382, %if.then384, %if.then379
  %cv.2 = phi %struct.cv* [ %cv.0, %if.then379 ], [ %cv.0, %if.end357 ], [ %160, %if.then384 ], [ %160, %if.else382 ]
  %sv_any394 = getelementptr inbounds %struct.cv* %cv.2, i64 0, i32 0
  %164 = load %struct.xpvcv** %sv_any394, align 8, !tbaa !66
  %xcv_gv395 = getelementptr inbounds %struct.xpvcv* %164, i64 0, i32 12
  store %struct.gv* %call73, %struct.gv** %xcv_gv395, align 8, !tbaa !145
  %165 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv396 = getelementptr inbounds %struct.cop* %165, i64 0, i32 10
  %166 = load %struct.gv** %cop_filegv396, align 8, !tbaa !97
  %tobool397 = icmp eq %struct.gv* %166, null
  br i1 %tobool397, label %cond.end419, label %cond.true398

cond.true398:                                     ; preds = %if.end393
  %167 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv399 = getelementptr inbounds %struct.cop* %167, i64 0, i32 10
  %168 = load %struct.gv** %cop_filegv399, align 8, !tbaa !97
  %sv_any400 = getelementptr inbounds %struct.gv* %168, i64 0, i32 0
  %169 = load %struct.xpvgv** %sv_any400, align 8, !tbaa !60
  %xgv_gp401 = getelementptr inbounds %struct.xpvgv* %169, i64 0, i32 7
  %170 = load %struct.gp** %xgv_gp401, align 8, !tbaa !62
  %gp_sv402 = getelementptr inbounds %struct.gp* %170, i64 0, i32 0
  %171 = load %struct.sv** %gp_sv402, align 8, !tbaa !135
  %tobool403 = icmp eq %struct.sv* %171, null
  br i1 %tobool403, label %cond.end419, label %cond.true405

cond.true405:                                     ; preds = %cond.true398
  %172 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %173 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv409 = getelementptr inbounds %struct.cop* %173, i64 0, i32 10
  %174 = load %struct.gv** %cop_filegv409, align 8, !tbaa !97
  %sv_any410 = getelementptr inbounds %struct.gv* %174, i64 0, i32 0
  %175 = load %struct.xpvgv** %sv_any410, align 8, !tbaa !60
  %xgv_gp411 = getelementptr inbounds %struct.xpvgv* %175, i64 0, i32 7
  %176 = load %struct.gp** %xgv_gp411, align 8, !tbaa !62
  %gp_sv412 = getelementptr inbounds %struct.gp* %176, i64 0, i32 0
  %177 = load %struct.sv** %gp_sv412, align 8, !tbaa !135
  %sv_any416 = getelementptr inbounds %struct.sv* %177, i64 0, i32 0
  %178 = load i8** %sv_any416, align 8, !tbaa !36
  %xpv_pv417 = bitcast i8* %178 to i8**
  %179 = load i8** %xpv_pv417, align 8, !tbaa !39
  br label %cond.end419

cond.end419:                                      ; preds = %cond.true398, %if.end393, %cond.true405
  %cond420 = phi i8* [ %179, %cond.true405 ], [ null, %if.end393 ], [ null, %cond.true398 ]
  %180 = load %struct.xpvcv** %sv_any394, align 8, !tbaa !66
  %xcv_file = getelementptr inbounds %struct.xpvcv* %180, i64 0, i32 13
  store i8* %cond420, i8** %xcv_file, align 8, !tbaa !151
  %181 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  %xcv_stash423 = getelementptr inbounds %struct.xpvcv* %180, i64 0, i32 7
  store %struct.hv* %181, %struct.hv** %xcv_stash423, align 8, !tbaa !147
  br i1 %tobool146, label %if.then425, label %if.end426

if.then425:                                       ; preds = %cond.end419
  %182 = bitcast %struct.cv* %cv.2 to %struct.sv*
  call void @Perl_sv_setpv(%struct.sv* %182, i8* %ps.0) #4
  br label %if.end426

if.end426:                                        ; preds = %if.then425, %cond.end419
  %183 = load i64* @PL_error_count, align 8, !tbaa !1
  %tobool427 = icmp eq i64 %183, 0
  br i1 %tobool427, label %if.end453, label %if.then428

if.then428:                                       ; preds = %if.end426
  call void @Perl_op_free(%struct.op* %block)
  br i1 %notlhs, label %if.then430, label %done

if.then430:                                       ; preds = %if.then428
  %call431 = call i8* @strrchr(i8* %cond5, i32 58) #4
  %tobool432 = icmp eq i8* %call431, null
  %add.ptr = getelementptr inbounds i8* %call431, i64 1
  %cond436 = select i1 %tobool432, i8* %cond5, i8* %add.ptr
  %call437 = call i32 @strcmp(i8* %cond436, i8* getelementptr inbounds ([6 x i8]* @.str51, i64 0, i64 0)) #4
  %tobool438 = icmp eq i32 %call437, 0
  br i1 %tobool438, label %if.then439, label %done

if.then439:                                       ; preds = %if.then430
  %184 = load volatile i32* @PL_in_eval, align 4, !tbaa !92
  %and440 = and i32 %184, 4
  %tobool441 = icmp eq i32 %and440, 0
  br i1 %tobool441, label %if.else443, label %if.then442

if.then442:                                       ; preds = %if.then439
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([49 x i8]* @.str72, i64 0, i64 0)) #4
  br label %done

if.else443:                                       ; preds = %if.then439
  %185 = load %struct.gv** @PL_errgv, align 8, !tbaa !6
  %sv_any444 = getelementptr inbounds %struct.gv* %185, i64 0, i32 0
  %186 = load %struct.xpvgv** %sv_any444, align 8, !tbaa !60
  %xgv_gp445 = getelementptr inbounds %struct.xpvgv* %186, i64 0, i32 7
  %187 = load %struct.gp** %xgv_gp445, align 8, !tbaa !62
  %gp_sv446 = getelementptr inbounds %struct.gp* %187, i64 0, i32 0
  %188 = load %struct.sv** %gp_sv446, align 8, !tbaa !135
  call void @Perl_sv_catpv(%struct.sv* %188, i8* getelementptr inbounds ([49 x i8]* @.str72, i64 0, i64 0)) #4
  %189 = load %struct.gv** @PL_errgv, align 8, !tbaa !6
  %sv_any447 = getelementptr inbounds %struct.gv* %189, i64 0, i32 0
  %190 = load %struct.xpvgv** %sv_any447, align 8, !tbaa !60
  %xgv_gp448 = getelementptr inbounds %struct.xpvgv* %190, i64 0, i32 7
  %191 = load %struct.gp** %xgv_gp448, align 8, !tbaa !62
  %gp_sv449 = getelementptr inbounds %struct.gp* %191, i64 0, i32 0
  %192 = load %struct.sv** %gp_sv449, align 8, !tbaa !135
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([3 x i8]* @.str63, i64 0, i64 0), %struct.sv* %192) #4
  br label %done

if.end453:                                        ; preds = %if.end426
  %tobool454 = icmp eq %struct.op* %block, null
  br i1 %tobool454, label %done, label %if.end456

if.end456:                                        ; preds = %if.end453
  %193 = load %struct.xpvcv** %sv_any394, align 8, !tbaa !66
  %xcv_flags458 = getelementptr inbounds %struct.xpvcv* %193, i64 0, i32 17
  %194 = load i16* %xcv_flags458, align 2, !tbaa !68
  %and460 = and i16 %194, 256
  %tobool461 = icmp eq i16 %and460, 0
  br i1 %tobool461, label %if.else469, label %if.then462

if.then462:                                       ; preds = %if.end456
  %call463 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarseq to i32 (%struct.op*, ...)*)(%struct.op* %block) #4
  %call464 = call i32 (i32, i32, ...)* bitcast (i32 (...)* @mod to i32 (i32, i32, ...)*)(i32 %call463, i32 168) #4
  %conv465 = sext i32 %call464 to i64
  %195 = inttoptr i64 %conv465 to %struct.op*
  %call466 = call %struct.op* @Perl_newUNOP(i64 168, i64 0, %struct.op* %195)
  %196 = load %struct.xpvcv** %sv_any394, align 8, !tbaa !66
  %xcv_root468 = getelementptr inbounds %struct.xpvcv* %196, i64 0, i32 9
  store %struct.op* %call466, %struct.op** %xcv_root468, align 8, !tbaa !138
  br label %if.end481

if.else469:                                       ; preds = %if.end456
  %op_type = getelementptr inbounds %struct.op* %block, i64 0, i32 4
  %197 = load i16* %op_type, align 2, !tbaa !12
  %cmp471 = icmp eq i16 %197, 1
  br i1 %cmp471, label %if.then473, label %if.end475

if.then473:                                       ; preds = %if.else469
  call void @Perl_op_free(%struct.op* %block)
  %call474 = call %struct.op* @Perl_newSTATEOP(i64 0, i8* null, %struct.op* null)
  br label %if.end475

if.end475:                                        ; preds = %if.then473, %if.else469
  %block.addr.1 = phi %struct.op* [ %call474, %if.then473 ], [ %block, %if.else469 ]
  %call476 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarseq to i32 (%struct.op*, ...)*)(%struct.op* %block.addr.1) #4
  %conv477 = sext i32 %call476 to i64
  %198 = inttoptr i64 %conv477 to %struct.op*
  %call478 = call %struct.op* @Perl_newUNOP(i64 167, i64 0, %struct.op* %198)
  %199 = load %struct.xpvcv** %sv_any394, align 8, !tbaa !66
  %xcv_root480 = getelementptr inbounds %struct.xpvcv* %199, i64 0, i32 9
  store %struct.op* %call478, %struct.op** %xcv_root480, align 8, !tbaa !138
  br label %if.end481

if.end481:                                        ; preds = %if.end475, %if.then462
  %200 = phi %struct.op* [ %call466, %if.then462 ], [ %call478, %if.end475 ]
  %201 = phi %struct.xpvcv* [ %196, %if.then462 ], [ %199, %if.end475 ]
  %block.addr.2 = phi %struct.op* [ %block, %if.then462 ], [ %block.addr.1, %if.end475 ]
  %op_private = getelementptr inbounds %struct.op* %200, i64 0, i32 7
  %202 = load i8* %op_private, align 1, !tbaa !11
  %or485 = or i8 %202, 64
  store i8 %or485, i8* %op_private, align 1, !tbaa !11
  %op_targ = getelementptr inbounds %struct.op* %200, i64 0, i32 3
  store i64 1, i64* %op_targ, align 8, !tbaa !13
  %op_next = getelementptr inbounds %struct.op* %200, i64 0, i32 0
  %203 = load %struct.op** %op_next, align 8, !tbaa !42
  %tobool491 = icmp eq %struct.op* %203, null
  br i1 %tobool491, label %cond.false496, label %cond.end501

cond.false496:                                    ; preds = %if.end481
  %call499 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %200) #4
  %conv500 = sext i32 %call499 to i64
  %204 = inttoptr i64 %conv500 to %struct.op*
  %.pre = load %struct.xpvcv** %sv_any394, align 8, !tbaa !66
  %xcv_root506.phi.trans.insert = getelementptr inbounds %struct.xpvcv* %.pre, i64 0, i32 9
  %.pre975 = load %struct.op** %xcv_root506.phi.trans.insert, align 8, !tbaa !138
  br label %cond.end501

cond.end501:                                      ; preds = %if.end481, %cond.false496
  %205 = phi %struct.op* [ %.pre975, %cond.false496 ], [ %200, %if.end481 ]
  %206 = phi %struct.xpvcv* [ %.pre, %cond.false496 ], [ %201, %if.end481 ]
  %cond502 = phi %struct.op* [ %204, %cond.false496 ], [ %203, %if.end481 ]
  %xcv_start504 = getelementptr inbounds %struct.xpvcv* %206, i64 0, i32 8
  store %struct.op* %cond502, %struct.op** %xcv_start504, align 8, !tbaa !144
  %op_next507 = getelementptr inbounds %struct.op* %205, i64 0, i32 0
  store %struct.op* null, %struct.op** %op_next507, align 8, !tbaa !42
  %207 = load void (%struct.op*)** @PL_peepp, align 8, !tbaa !6
  call void %207(%struct.op* %cond502) #4
  %208 = load %struct.xpvcv** %sv_any394, align 8, !tbaa !66
  %xcv_flags511 = getelementptr inbounds %struct.xpvcv* %208, i64 0, i32 17
  %209 = load i16* %xcv_flags511, align 2, !tbaa !68
  %and513 = and i16 %209, 1
  %cond515 = zext i16 %and513 to i32
  %call516 = call i32 (i32, ...)* bitcast (i32 (...)* @pad_tidy to i32 (i32, ...)*)(i32 %cond515) #4
  %210 = load %struct.xpvcv** %sv_any394, align 8, !tbaa !66
  %xcv_flags518 = getelementptr inbounds %struct.xpvcv* %210, i64 0, i32 17
  %211 = load i16* %xcv_flags518, align 2, !tbaa !68
  %and520 = and i16 %211, 1
  %tobool521 = icmp ne i16 %and520, 0
  %or.cond798 = and i1 %tobool521, %tobool146
  br i1 %or.cond798, label %land.lhs.true524, label %if.end536

land.lhs.true524:                                 ; preds = %cond.end501
  %212 = load i8* %ps.0, align 1, !tbaa !5
  %tobool525 = icmp eq i8 %212, 0
  br i1 %tobool525, label %land.lhs.true526, label %if.end536

land.lhs.true526:                                 ; preds = %land.lhs.true524
  %call527 = call i32 (%struct.op*, %struct.cv*, ...)* bitcast (i32 (...)* @op_const_sv to i32 (%struct.op*, %struct.cv*, ...)*)(%struct.op* %block.addr.2, %struct.cv* %cv.2) #4
  %tobool528 = icmp eq i32 %call527, 0
  br i1 %tobool528, label %if.end536, label %if.then529

if.then529:                                       ; preds = %land.lhs.true526
  %213 = load %struct.xpvcv** %sv_any394, align 8, !tbaa !66
  %xcv_flags531 = getelementptr inbounds %struct.xpvcv* %213, i64 0, i32 17
  %214 = load i16* %xcv_flags531, align 2, !tbaa !68
  %or533 = or i16 %214, 512
  store i16 %or533, i16* %xcv_flags531, align 2, !tbaa !68
  br label %if.end536

if.end536:                                        ; preds = %land.lhs.true526, %land.lhs.true524, %if.then529, %cond.end501
  %tobool539 = icmp ne i8* %aname.0, null
  %or.cond794 = or i1 %notlhs, %tobool539
  br i1 %or.cond794, label %if.then540, label %done

if.then540:                                       ; preds = %if.end536
  %cond546 = select i1 %notlhs, i8* %cond5, i8* %aname.0
  %215 = load i64* @PL_perldb, align 8, !tbaa !1
  %and549 = and i64 %215, 16
  %tobool550 = icmp eq i64 %and549, 0
  br i1 %tobool550, label %if.end641, label %land.lhs.true551

land.lhs.true551:                                 ; preds = %if.then540
  %216 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  %217 = load %struct.hv** @PL_debstash, align 8, !tbaa !6
  %cmp552 = icmp eq %struct.hv* %216, %217
  br i1 %cmp552, label %if.end641, label %if.then554

if.then554:                                       ; preds = %land.lhs.true551
  %call556 = call %struct.sv* @Perl_newSV(i64 0) #4
  %call557 = call %struct.sv* @Perl_sv_newmortal() #4
  %call558 = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([14 x i8]* @.str28, i64 0, i64 0), i64 2, i64 11) #4
  %218 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv559 = getelementptr inbounds %struct.cop* %218, i64 0, i32 10
  %219 = load %struct.gv** %cop_filegv559, align 8, !tbaa !97
  %tobool560 = icmp eq %struct.gv* %219, null
  br i1 %tobool560, label %cond.end582, label %cond.true561

cond.true561:                                     ; preds = %if.then554
  %220 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv562 = getelementptr inbounds %struct.cop* %220, i64 0, i32 10
  %221 = load %struct.gv** %cop_filegv562, align 8, !tbaa !97
  %sv_any563 = getelementptr inbounds %struct.gv* %221, i64 0, i32 0
  %222 = load %struct.xpvgv** %sv_any563, align 8, !tbaa !60
  %xgv_gp564 = getelementptr inbounds %struct.xpvgv* %222, i64 0, i32 7
  %223 = load %struct.gp** %xgv_gp564, align 8, !tbaa !62
  %gp_sv565 = getelementptr inbounds %struct.gp* %223, i64 0, i32 0
  %224 = load %struct.sv** %gp_sv565, align 8, !tbaa !135
  %tobool566 = icmp eq %struct.sv* %224, null
  br i1 %tobool566, label %cond.end582, label %cond.true568

cond.true568:                                     ; preds = %cond.true561
  %225 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %226 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv572 = getelementptr inbounds %struct.cop* %226, i64 0, i32 10
  %227 = load %struct.gv** %cop_filegv572, align 8, !tbaa !97
  %sv_any573 = getelementptr inbounds %struct.gv* %227, i64 0, i32 0
  %228 = load %struct.xpvgv** %sv_any573, align 8, !tbaa !60
  %xgv_gp574 = getelementptr inbounds %struct.xpvgv* %228, i64 0, i32 7
  %229 = load %struct.gp** %xgv_gp574, align 8, !tbaa !62
  %gp_sv575 = getelementptr inbounds %struct.gp* %229, i64 0, i32 0
  %230 = load %struct.sv** %gp_sv575, align 8, !tbaa !135
  %sv_any579 = getelementptr inbounds %struct.sv* %230, i64 0, i32 0
  %231 = load i8** %sv_any579, align 8, !tbaa !36
  %xpv_pv580 = bitcast i8* %231 to i8**
  %232 = load i8** %xpv_pv580, align 8, !tbaa !39
  br label %cond.end582

cond.end582:                                      ; preds = %cond.true561, %if.then554, %cond.true568
  %cond583 = phi i8* [ %232, %cond.true568 ], [ null, %if.then554 ], [ null, %cond.true561 ]
  %233 = load i64* @PL_subline, align 8, !tbaa !1
  %234 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line584 = getelementptr inbounds %struct.cop* %234, i64 0, i32 13
  %235 = load i64* %cop_line584, align 8, !tbaa !116
  call void (%struct.sv*, i8*, ...)* @Perl_sv_setpvf(%struct.sv* %call556, i8* getelementptr inbounds ([11 x i8]* @.str73, i64 0, i64 0), i8* %cond583, i64 %233, i64 %235) #4
  call void @Perl_gv_efullname4(%struct.sv* %call557, %struct.gv* %call73, i8* null, i8 signext 1) #4
  %236 = load %struct.gv** @PL_DBsub, align 8, !tbaa !6
  %sv_any585 = getelementptr inbounds %struct.gv* %236, i64 0, i32 0
  %237 = load %struct.xpvgv** %sv_any585, align 8, !tbaa !60
  %xgv_gp586 = getelementptr inbounds %struct.xpvgv* %237, i64 0, i32 7
  %238 = load %struct.gp** %xgv_gp586, align 8, !tbaa !62
  %gp_hv = getelementptr inbounds %struct.gp* %238, i64 0, i32 5
  %239 = load %struct.hv** %gp_hv, align 8, !tbaa !94
  %sv_any587 = getelementptr inbounds %struct.sv* %call557, i64 0, i32 0
  %240 = load i8** %sv_any587, align 8, !tbaa !36
  %xpv_pv588 = bitcast i8* %240 to i8**
  %241 = load i8** %xpv_pv588, align 8, !tbaa !39
  %xpv_cur590 = getelementptr inbounds i8* %240, i64 8
  %242 = bitcast i8* %xpv_cur590 to i64*
  %243 = load i64* %242, align 8, !tbaa !37
  %call591 = call %struct.sv** @Perl_hv_store(%struct.hv* %239, i8* %241, i64 %243, %struct.sv* %call556, i64 0) #4
  %sv_any592 = getelementptr inbounds %struct.gv* %call558, i64 0, i32 0
  %244 = load %struct.xpvgv** %sv_any592, align 8, !tbaa !60
  %xgv_gp593 = getelementptr inbounds %struct.xpvgv* %244, i64 0, i32 7
  %245 = load %struct.gp** %xgv_gp593, align 8, !tbaa !62
  %gp_hv594 = getelementptr inbounds %struct.gp* %245, i64 0, i32 5
  %246 = load %struct.hv** %gp_hv594, align 8, !tbaa !94
  %tobool595 = icmp eq %struct.hv* %246, null
  br i1 %tobool595, label %cond.false600, label %cond.end605

cond.false600:                                    ; preds = %cond.end582
  %call601 = call %struct.gv* @Perl_gv_HVadd(%struct.gv* %call558) #4
  %sv_any602 = getelementptr inbounds %struct.gv* %call601, i64 0, i32 0
  %247 = load %struct.xpvgv** %sv_any602, align 8, !tbaa !60
  %xgv_gp603 = getelementptr inbounds %struct.xpvgv* %247, i64 0, i32 7
  %248 = load %struct.gp** %xgv_gp603, align 8, !tbaa !62
  %gp_hv604 = getelementptr inbounds %struct.gp* %248, i64 0, i32 5
  %249 = load %struct.hv** %gp_hv604, align 8, !tbaa !94
  br label %cond.end605

cond.end605:                                      ; preds = %cond.end582, %cond.false600
  %cond606 = phi %struct.hv* [ %249, %cond.false600 ], [ %246, %cond.end582 ]
  %sv_any607 = getelementptr inbounds %struct.hv* %cond606, i64 0, i32 0
  %250 = load %struct.xpvhv** %sv_any607, align 8, !tbaa !26
  %xhv_fill = getelementptr inbounds %struct.xpvhv* %250, i64 0, i32 1
  %251 = load i64* %xhv_fill, align 8, !tbaa !152
  %cmp608 = icmp eq i64 %251, 0
  br i1 %cmp608, label %if.end641, label %land.lhs.true610

land.lhs.true610:                                 ; preds = %cond.end605
  %252 = load i8** %sv_any587, align 8, !tbaa !36
  %xpv_pv612 = bitcast i8* %252 to i8**
  %253 = load i8** %xpv_pv612, align 8, !tbaa !39
  %xpv_cur614 = getelementptr inbounds i8* %252, i64 8
  %254 = bitcast i8* %xpv_cur614 to i64*
  %255 = load i64* %254, align 8, !tbaa !37
  %call615 = call signext i8 @Perl_hv_exists(%struct.hv* %cond606, i8* %253, i64 %255) #4
  %tobool617 = icmp eq i8 %call615, 0
  br i1 %tobool617, label %if.end641, label %land.lhs.true618

land.lhs.true618:                                 ; preds = %land.lhs.true610
  %256 = load %struct.xpvgv** %sv_any592, align 8, !tbaa !60
  %xgv_gp620 = getelementptr inbounds %struct.xpvgv* %256, i64 0, i32 7
  %257 = load %struct.gp** %xgv_gp620, align 8, !tbaa !62
  %gp_cv621 = getelementptr inbounds %struct.gp* %257, i64 0, i32 7
  %258 = load %struct.cv** %gp_cv621, align 8, !tbaa !64
  %tobool622 = icmp eq %struct.cv* %258, null
  br i1 %tobool622, label %if.end641, label %if.then623

if.then623:                                       ; preds = %land.lhs.true618
  %259 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !6
  %260 = load i64** @PL_markstack_ptr, align 8, !tbaa !6
  %incdec.ptr = getelementptr inbounds i64* %260, i64 1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !6
  %261 = load i64** @PL_markstack_max, align 8, !tbaa !6
  %cmp624 = icmp eq i64* %incdec.ptr, %261
  br i1 %cmp624, label %if.then626, label %if.end627

if.then626:                                       ; preds = %if.then623
  call void @Perl_markstack_grow() #4
  %.pre976 = load i64** @PL_markstack_ptr, align 8, !tbaa !6
  br label %if.end627

if.end627:                                        ; preds = %if.then626, %if.then623
  %262 = phi i64* [ %.pre976, %if.then626 ], [ %incdec.ptr, %if.then623 ]
  %263 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !6
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %259 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %263 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  store i64 %sub.ptr.div, i64* %262, align 8, !tbaa !1
  %264 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !6
  %sub.ptr.lhs.cast628 = ptrtoint %struct.sv** %264 to i64
  %sub.ptr.sub630 = sub i64 %sub.ptr.lhs.cast628, %sub.ptr.lhs.cast
  %cmp632 = icmp slt i64 %sub.ptr.sub630, 8
  br i1 %cmp632, label %if.then634, label %if.end636

if.then634:                                       ; preds = %if.end627
  %call635 = call %struct.sv** @Perl_stack_grow(%struct.sv** %259, %struct.sv** %259, i32 1) #4
  br label %if.end636

if.end636:                                        ; preds = %if.then634, %if.end627
  %sp.0 = phi %struct.sv** [ %call635, %if.then634 ], [ %259, %if.end627 ]
  %incdec.ptr638 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %call557, %struct.sv** %incdec.ptr638, align 8, !tbaa !6
  store %struct.sv** %incdec.ptr638, %struct.sv*** @PL_stack_sp, align 8, !tbaa !6
  %265 = bitcast %struct.cv* %258 to %struct.sv*
  %call639 = call i64 @Perl_call_sv(%struct.sv* %265, i64 2) #4
  br label %if.end641

if.end641:                                        ; preds = %land.lhs.true618, %land.lhs.true610, %cond.end605, %land.lhs.true551, %if.then540, %if.end636
  %call642 = call i8* @strrchr(i8* %cond546, i32 58) #4
  %tobool643 = icmp eq i8* %call642, null
  %incdec.ptr645 = getelementptr inbounds i8* %call642, i64 1
  %s541.0 = select i1 %tobool643, i8* %cond546, i8* %incdec.ptr645
  %266 = load i8* %s541.0, align 1, !tbaa !5
  switch i8 %266, label %done [
    i8 66, label %if.end664
    i8 69, label %if.end664
    i8 67, label %if.end664
    i8 73, label %if.end664
  ]

if.end664:                                        ; preds = %if.end641, %if.end641, %if.end641, %if.end641
  %call665 = call i32 @strcmp(i8* %s541.0, i8* getelementptr inbounds ([6 x i8]* @.str51, i64 0, i64 0)) #4
  %tobool666 = icmp eq i32 %call665, 0
  br i1 %tobool666, label %if.then667, label %if.else678

if.then667:                                       ; preds = %if.end664
  %267 = load i64* @PL_scopestack_ix, align 8, !tbaa !1
  call void @Perl_push_scope() #4
  call void @Perl_save_sptr(%struct.sv** bitcast (%struct.gv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 10) to %struct.sv**)) #4
  call void @Perl_save_I32(i64* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 13)) #4
  %268 = load %struct.av** @PL_beginav, align 8, !tbaa !6
  %tobool669 = icmp eq %struct.av* %268, null
  br i1 %tobool669, label %if.then670, label %if.end672

if.then670:                                       ; preds = %if.then667
  %call671 = call %struct.av* @Perl_newAV() #4
  store %struct.av* %call671, %struct.av** @PL_beginav, align 8, !tbaa !6
  br label %if.end672

if.end672:                                        ; preds = %if.then667, %if.then670
  %269 = phi %struct.av* [ %268, %if.then667 ], [ %call671, %if.then670 ]
  %270 = bitcast %struct.cv* %cv.2 to %struct.sv*
  call void @Perl_av_push(%struct.av* %269, %struct.sv* %270) #4
  %sv_any673 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %271 = load %struct.xpvgv** %sv_any673, align 8, !tbaa !60
  %xgv_gp674 = getelementptr inbounds %struct.xpvgv* %271, i64 0, i32 7
  %272 = load %struct.gp** %xgv_gp674, align 8, !tbaa !62
  %gp_cv675 = getelementptr inbounds %struct.gp* %272, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv675, align 8, !tbaa !64
  %273 = load %struct.av** @PL_beginav, align 8, !tbaa !6
  call void @Perl_call_list(i64 %267, %struct.av* %273) #4
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !6
  %274 = load i64* @PL_hints, align 8, !tbaa !1
  %conv677 = trunc i64 %274 to i8
  store i8 %conv677, i8* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 7), align 1, !tbaa !96
  call void @Perl_pop_scope() #4
  br label %done

if.else678:                                       ; preds = %if.end664
  %call679 = call i32 @strcmp(i8* %s541.0, i8* getelementptr inbounds ([4 x i8]* @.str74, i64 0, i64 0)) #4
  %tobool680 = icmp ne i32 %call679, 0
  %275 = load i64* @PL_error_count, align 8
  %tobool682 = icmp ne i64 %275, 0
  %or.cond795 = or i1 %tobool680, %tobool682
  br i1 %or.cond795, label %if.else692, label %if.then683

if.then683:                                       ; preds = %if.else678
  %276 = load %struct.av** @PL_endav, align 8, !tbaa !6
  %tobool684 = icmp eq %struct.av* %276, null
  br i1 %tobool684, label %if.then685, label %if.end687

if.then685:                                       ; preds = %if.then683
  %call686 = call %struct.av* @Perl_newAV() #4
  store %struct.av* %call686, %struct.av** @PL_endav, align 8, !tbaa !6
  br label %if.end687

if.end687:                                        ; preds = %if.then683, %if.then685
  %277 = phi %struct.av* [ %276, %if.then683 ], [ %call686, %if.then685 ]
  call void @Perl_av_unshift(%struct.av* %277, i64 1) #4
  %278 = load %struct.av** @PL_endav, align 8, !tbaa !6
  %279 = bitcast %struct.cv* %cv.2 to %struct.sv*
  %call688 = call %struct.sv** @Perl_av_store(%struct.av* %278, i64 0, %struct.sv* %279) #4
  %sv_any689 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %280 = load %struct.xpvgv** %sv_any689, align 8, !tbaa !60
  %xgv_gp690 = getelementptr inbounds %struct.xpvgv* %280, i64 0, i32 7
  %281 = load %struct.gp** %xgv_gp690, align 8, !tbaa !62
  %gp_cv691 = getelementptr inbounds %struct.gp* %281, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv691, align 8, !tbaa !64
  br label %done

if.else692:                                       ; preds = %if.else678
  %call693 = call i32 @strcmp(i8* %s541.0, i8* getelementptr inbounds ([6 x i8]* @.str75, i64 0, i64 0)) #4
  %tobool694 = icmp ne i32 %call693, 0
  %or.cond796 = or i1 %tobool694, %tobool682
  br i1 %or.cond796, label %if.else737, label %if.then697

if.then697:                                       ; preds = %if.else692
  %282 = load %struct.av** @PL_checkav, align 8, !tbaa !6
  %tobool698 = icmp eq %struct.av* %282, null
  br i1 %tobool698, label %if.then699, label %if.end701

if.then699:                                       ; preds = %if.then697
  %call700 = call %struct.av* @Perl_newAV() #4
  store %struct.av* %call700, %struct.av** @PL_checkav, align 8, !tbaa !6
  br label %if.end701

if.end701:                                        ; preds = %if.then697, %if.then699
  %283 = load %struct.op** @PL_main_start, align 8, !tbaa !6
  %tobool702 = icmp eq %struct.op* %283, null
  br i1 %tobool702, label %if.end732, label %land.lhs.true703

land.lhs.true703:                                 ; preds = %if.end701
  %284 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings704 = getelementptr inbounds %struct.cop* %284, i64 0, i32 14
  %285 = load %struct.sv** %cop_warnings704, align 8, !tbaa !47
  %cmp705 = icmp eq %struct.sv* %285, null
  br i1 %cmp705, label %lor.lhs.false723, label %land.lhs.true707

land.lhs.true707:                                 ; preds = %land.lhs.true703
  %286 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings708 = getelementptr inbounds %struct.cop* %286, i64 0, i32 14
  %287 = load %struct.sv** %cop_warnings708, align 8, !tbaa !47
  %cmp709 = icmp eq %struct.sv* %287, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp709, label %lor.lhs.false723, label %land.lhs.true711

land.lhs.true711:                                 ; preds = %land.lhs.true707
  %288 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings712 = getelementptr inbounds %struct.cop* %288, i64 0, i32 14
  %289 = load %struct.sv** %cop_warnings712, align 8, !tbaa !47
  %cmp713 = icmp eq %struct.sv* %289, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp713, label %if.then731, label %lor.lhs.false715

lor.lhs.false715:                                 ; preds = %land.lhs.true711
  %290 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings716 = getelementptr inbounds %struct.cop* %290, i64 0, i32 14
  %291 = load %struct.sv** %cop_warnings716, align 8, !tbaa !47
  %sv_any717 = getelementptr inbounds %struct.sv* %291, i64 0, i32 0
  %292 = load i8** %sv_any717, align 8, !tbaa !36
  %xpv_pv718 = bitcast i8* %292 to i8**
  %293 = load i8** %xpv_pv718, align 8, !tbaa !39
  %arrayidx719 = getelementptr inbounds i8* %293, i64 11
  %294 = load i8* %arrayidx719, align 1, !tbaa !5
  %and721 = and i8 %294, 4
  %tobool722 = icmp eq i8 %and721, 0
  br i1 %tobool722, label %lor.lhs.false723, label %if.then731

lor.lhs.false723:                                 ; preds = %lor.lhs.false715, %land.lhs.true707, %land.lhs.true703
  %295 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings724 = getelementptr inbounds %struct.cop* %295, i64 0, i32 14
  %296 = load %struct.sv** %cop_warnings724, align 8, !tbaa !47
  %cmp725 = icmp eq %struct.sv* %296, null
  br i1 %cmp725, label %land.lhs.true727, label %if.end732

land.lhs.true727:                                 ; preds = %lor.lhs.false723
  %297 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and729 = and i8 %297, 1
  %tobool730 = icmp eq i8 %and729, 0
  br i1 %tobool730, label %if.end732, label %if.then731

if.then731:                                       ; preds = %lor.lhs.false715, %land.lhs.true727, %land.lhs.true711
  call void (i64, i8*, ...)* @Perl_warner(i64 45, i8* getelementptr inbounds ([28 x i8]* @.str76, i64 0, i64 0)) #4
  br label %if.end732

if.end732:                                        ; preds = %land.lhs.true727, %if.end701, %if.then731, %lor.lhs.false723
  %298 = load %struct.av** @PL_checkav, align 8, !tbaa !6
  call void @Perl_av_unshift(%struct.av* %298, i64 1) #4
  %299 = load %struct.av** @PL_checkav, align 8, !tbaa !6
  %300 = bitcast %struct.cv* %cv.2 to %struct.sv*
  %call733 = call %struct.sv** @Perl_av_store(%struct.av* %299, i64 0, %struct.sv* %300) #4
  %sv_any734 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %301 = load %struct.xpvgv** %sv_any734, align 8, !tbaa !60
  %xgv_gp735 = getelementptr inbounds %struct.xpvgv* %301, i64 0, i32 7
  %302 = load %struct.gp** %xgv_gp735, align 8, !tbaa !62
  %gp_cv736 = getelementptr inbounds %struct.gp* %302, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv736, align 8, !tbaa !64
  br label %done

if.else737:                                       ; preds = %if.else692
  %call738 = call i32 @strcmp(i8* %s541.0, i8* getelementptr inbounds ([5 x i8]* @.str77, i64 0, i64 0)) #4
  %tobool739 = icmp ne i32 %call738, 0
  %or.cond797 = or i1 %tobool739, %tobool682
  br i1 %or.cond797, label %done, label %if.then742

if.then742:                                       ; preds = %if.else737
  %303 = load %struct.av** @PL_initav, align 8, !tbaa !6
  %tobool743 = icmp eq %struct.av* %303, null
  br i1 %tobool743, label %if.then744, label %if.end746

if.then744:                                       ; preds = %if.then742
  %call745 = call %struct.av* @Perl_newAV() #4
  store %struct.av* %call745, %struct.av** @PL_initav, align 8, !tbaa !6
  br label %if.end746

if.end746:                                        ; preds = %if.then742, %if.then744
  %304 = load %struct.op** @PL_main_start, align 8, !tbaa !6
  %tobool747 = icmp eq %struct.op* %304, null
  br i1 %tobool747, label %if.end777, label %land.lhs.true748

land.lhs.true748:                                 ; preds = %if.end746
  %305 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings749 = getelementptr inbounds %struct.cop* %305, i64 0, i32 14
  %306 = load %struct.sv** %cop_warnings749, align 8, !tbaa !47
  %cmp750 = icmp eq %struct.sv* %306, null
  br i1 %cmp750, label %lor.lhs.false768, label %land.lhs.true752

land.lhs.true752:                                 ; preds = %land.lhs.true748
  %307 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings753 = getelementptr inbounds %struct.cop* %307, i64 0, i32 14
  %308 = load %struct.sv** %cop_warnings753, align 8, !tbaa !47
  %cmp754 = icmp eq %struct.sv* %308, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp754, label %lor.lhs.false768, label %land.lhs.true756

land.lhs.true756:                                 ; preds = %land.lhs.true752
  %309 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings757 = getelementptr inbounds %struct.cop* %309, i64 0, i32 14
  %310 = load %struct.sv** %cop_warnings757, align 8, !tbaa !47
  %cmp758 = icmp eq %struct.sv* %310, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp758, label %if.then776, label %lor.lhs.false760

lor.lhs.false760:                                 ; preds = %land.lhs.true756
  %311 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings761 = getelementptr inbounds %struct.cop* %311, i64 0, i32 14
  %312 = load %struct.sv** %cop_warnings761, align 8, !tbaa !47
  %sv_any762 = getelementptr inbounds %struct.sv* %312, i64 0, i32 0
  %313 = load i8** %sv_any762, align 8, !tbaa !36
  %xpv_pv763 = bitcast i8* %313 to i8**
  %314 = load i8** %xpv_pv763, align 8, !tbaa !39
  %arrayidx764 = getelementptr inbounds i8* %314, i64 11
  %315 = load i8* %arrayidx764, align 1, !tbaa !5
  %and766 = and i8 %315, 4
  %tobool767 = icmp eq i8 %and766, 0
  br i1 %tobool767, label %lor.lhs.false768, label %if.then776

lor.lhs.false768:                                 ; preds = %lor.lhs.false760, %land.lhs.true752, %land.lhs.true748
  %316 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings769 = getelementptr inbounds %struct.cop* %316, i64 0, i32 14
  %317 = load %struct.sv** %cop_warnings769, align 8, !tbaa !47
  %cmp770 = icmp eq %struct.sv* %317, null
  br i1 %cmp770, label %land.lhs.true772, label %if.end777

land.lhs.true772:                                 ; preds = %lor.lhs.false768
  %318 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and774 = and i8 %318, 1
  %tobool775 = icmp eq i8 %and774, 0
  br i1 %tobool775, label %if.end777, label %if.then776

if.then776:                                       ; preds = %lor.lhs.false760, %land.lhs.true772, %land.lhs.true756
  call void (i64, i8*, ...)* @Perl_warner(i64 45, i8* getelementptr inbounds ([27 x i8]* @.str78, i64 0, i64 0)) #4
  br label %if.end777

if.end777:                                        ; preds = %land.lhs.true772, %if.end746, %if.then776, %lor.lhs.false768
  %319 = load %struct.av** @PL_initav, align 8, !tbaa !6
  %320 = bitcast %struct.cv* %cv.2 to %struct.sv*
  call void @Perl_av_push(%struct.av* %319, %struct.sv* %320) #4
  %sv_any778 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %321 = load %struct.xpvgv** %sv_any778, align 8, !tbaa !60
  %xgv_gp779 = getelementptr inbounds %struct.xpvgv* %321, i64 0, i32 7
  %322 = load %struct.gp** %xgv_gp779, align 8, !tbaa !62
  %gp_cv780 = getelementptr inbounds %struct.gp* %322, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv780, align 8, !tbaa !64
  br label %done

done:                                             ; preds = %if.then428, %if.else443, %if.then442, %if.then430, %if.end641, %if.end453, %if.end536, %if.end687, %if.else737, %if.end777, %if.end732, %if.end672, %if.then344, %if.end288, %if.end199, %if.end131
  %cv.3 = phi %struct.cv* [ null, %if.end131 ], [ %cv.1, %if.end288 ], [ %cv.2, %if.else737 ], [ %cv.2, %if.end777 ], [ %cv.2, %if.end732 ], [ %cv.2, %if.end687 ], [ %cv.2, %if.end672 ], [ %cv.2, %if.end536 ], [ %cv.2, %if.end453 ], [ %cv.0, %if.then344 ], [ %cond143, %if.end199 ], [ %cv.2, %if.end641 ], [ %cv.2, %if.then430 ], [ %cv.2, %if.then442 ], [ %cv.2, %if.else443 ], [ %cv.2, %if.then428 ]
  store i64 4294967295, i64* @PL_copline, align 8, !tbaa !1
  %323 = load i64* @PL_savestack_ix, align 8, !tbaa !1
  %cmp786 = icmp sgt i64 %323, %floor
  br i1 %cmp786, label %if.then788, label %if.end789

if.then788:                                       ; preds = %done
  call void @Perl_leave_scope(i64 %floor) #4
  br label %if.end789

if.end789:                                        ; preds = %if.then788, %done
  ret %struct.cv* %cv.3
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newSTATEOP(i64 %flags, i8* %label, %struct.op* %o) #0 {
entry:
  %call = tail call i32 (...)* @intro_my() #4
  %conv = sext i32 %call to i64
  %call1 = tail call i8* @Perl_safesysmalloc(i64 104) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call1, i8 0, i64 104, i32 1, i1 false)
  %0 = load i64* @PL_perldb, align 8, !tbaa !1
  %and = and i64 %0, 2
  %tobool2 = icmp eq i64 %and, 0
  br i1 %tobool2, label %if.else, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %entry
  %1 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line = getelementptr inbounds %struct.cop* %1, i64 0, i32 13
  %2 = load i64* %cop_line, align 8, !tbaa !116
  %tobool4 = icmp eq i64 %2, 0
  br i1 %tobool4, label %if.else, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %land.lhs.true3
  %3 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  %4 = load %struct.hv** @PL_debstash, align 8, !tbaa !6
  %cmp = icmp eq %struct.hv* %3, %4
  br i1 %cmp, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true5
  %op_type = getelementptr inbounds i8* %call1, i64 32
  %5 = bitcast i8* %op_type to i16*
  store i16 175, i16* %5, align 2, !tbaa !153
  %6 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 175), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds i8* %call1, i64 16
  %7 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %6, %struct.op* ()** %7, align 8, !tbaa !154
  br label %if.end

if.else:                                          ; preds = %land.lhs.true5, %land.lhs.true3, %entry
  %op_type7 = getelementptr inbounds i8* %call1, i64 32
  %8 = bitcast i8* %op_type7 to i16*
  store i16 174, i16* %8, align 2, !tbaa !153
  %9 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 174), align 8, !tbaa !6
  %op_ppaddr8 = getelementptr inbounds i8* %call1, i64 16
  %10 = bitcast i8* %op_ppaddr8 to %struct.op* ()**
  store %struct.op* ()* %9, %struct.op* ()** %10, align 8, !tbaa !154
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %conv9 = trunc i64 %flags to i8
  %11 = getelementptr inbounds i8* %call1, i64 36
  store i8 %conv9, i8* %11, align 1, !tbaa !155
  %12 = load i64* @PL_hints, align 8, !tbaa !1
  %conv11 = trunc i64 %12 to i8
  %13 = getelementptr inbounds i8* %call1, i64 37
  store i8 %conv11, i8* %13, align 1, !tbaa !96
  store i8 %conv11, i8* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 7), align 1, !tbaa !96
  %14 = bitcast i8* %call1 to %struct.op*
  %op_next = bitcast i8* %call1 to %struct.op**
  store %struct.op* %14, %struct.op** %op_next, align 8, !tbaa !156
  %tobool13 = icmp eq i8* %label, null
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  %cop_label = getelementptr inbounds i8* %call1, i64 40
  %15 = bitcast i8* %cop_label to i8**
  store i8* %label, i8** %15, align 8, !tbaa !157
  %or = or i64 %12, 256
  store i64 %or, i64* @PL_hints, align 8, !tbaa !1
  br label %if.end15

if.end15:                                         ; preds = %if.end, %if.then14
  %cop_seq = getelementptr inbounds i8* %call1, i64 64
  %16 = bitcast i8* %cop_seq to i64*
  store i64 %conv, i64* %16, align 8, !tbaa !158
  %17 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_arybase = getelementptr inbounds %struct.cop* %17, i64 0, i32 12
  %18 = load i64* %cop_arybase, align 8, !tbaa !55
  %cop_arybase16 = getelementptr inbounds i8* %call1, i64 72
  %19 = bitcast i8* %cop_arybase16 to i64*
  store i64 %18, i64* %19, align 8, !tbaa !55
  %20 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %20, i64 0, i32 14
  %21 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp17 = icmp eq %struct.sv* %21, null
  br i1 %cmp17, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end15
  %22 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings19 = getelementptr inbounds %struct.cop* %22, i64 0, i32 14
  %23 = load %struct.sv** %cop_warnings19, align 8, !tbaa !47
  %cmp20 = icmp eq %struct.sv* %23, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp20, label %if.then26, label %lor.lhs.false22

lor.lhs.false22:                                  ; preds = %lor.lhs.false
  %24 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings23 = getelementptr inbounds %struct.cop* %24, i64 0, i32 14
  %25 = load %struct.sv** %cop_warnings23, align 8, !tbaa !47
  %cmp24 = icmp eq %struct.sv* %25, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp24, label %if.then26, label %if.else29

if.then26:                                        ; preds = %lor.lhs.false22, %lor.lhs.false, %if.end15
  %26 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings27 = getelementptr inbounds %struct.cop* %26, i64 0, i32 14
  %27 = load %struct.sv** %cop_warnings27, align 8, !tbaa !47
  %cop_warnings28 = getelementptr inbounds i8* %call1, i64 88
  %28 = bitcast i8* %cop_warnings28 to %struct.sv**
  store %struct.sv* %27, %struct.sv** %28, align 8, !tbaa !47
  br label %if.end33

if.else29:                                        ; preds = %lor.lhs.false22
  %29 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings30 = getelementptr inbounds %struct.cop* %29, i64 0, i32 14
  %30 = load %struct.sv** %cop_warnings30, align 8, !tbaa !47
  %call31 = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %30) #4
  %cop_warnings32 = getelementptr inbounds i8* %call1, i64 88
  %31 = bitcast i8* %cop_warnings32 to %struct.sv**
  store %struct.sv* %call31, %struct.sv** %31, align 8, !tbaa !47
  br label %if.end33

if.end33:                                         ; preds = %if.else29, %if.then26
  %32 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_io = getelementptr inbounds %struct.cop* %32, i64 0, i32 15
  %33 = load %struct.sv** %cop_io, align 8, !tbaa !95
  %cmp34 = icmp eq %struct.sv* %33, null
  %34 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_io37 = getelementptr inbounds %struct.cop* %34, i64 0, i32 15
  %35 = load %struct.sv** %cop_io37, align 8, !tbaa !95
  br i1 %cmp34, label %if.then36, label %if.else39

if.then36:                                        ; preds = %if.end33
  %cop_io38 = getelementptr inbounds i8* %call1, i64 96
  %36 = bitcast i8* %cop_io38 to %struct.sv**
  store %struct.sv* %35, %struct.sv** %36, align 8, !tbaa !95
  br label %if.end43

if.else39:                                        ; preds = %if.end33
  %call41 = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %35) #4
  %cop_io42 = getelementptr inbounds i8* %call1, i64 96
  %37 = bitcast i8* %cop_io42 to %struct.sv**
  store %struct.sv* %call41, %struct.sv** %37, align 8, !tbaa !95
  br label %if.end43

if.end43:                                         ; preds = %if.else39, %if.then36
  %38 = load i64* @PL_copline, align 8, !tbaa !1
  %cmp44 = icmp eq i64 %38, 4294967295
  br i1 %cmp44, label %if.then46, label %if.else49

if.then46:                                        ; preds = %if.end43
  %39 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line47 = getelementptr inbounds %struct.cop* %39, i64 0, i32 13
  %40 = load i64* %cop_line47, align 8, !tbaa !116
  %cop_line48 = getelementptr inbounds i8* %call1, i64 80
  %41 = bitcast i8* %cop_line48 to i64*
  store i64 %40, i64* %41, align 8, !tbaa !116
  br label %if.end51

if.else49:                                        ; preds = %if.end43
  %cop_line50 = getelementptr inbounds i8* %call1, i64 80
  %42 = bitcast i8* %cop_line50 to i64*
  store i64 %38, i64* %42, align 8, !tbaa !116
  store i64 4294967295, i64* @PL_copline, align 8, !tbaa !1
  br label %if.end51

if.end51:                                         ; preds = %if.else49, %if.then46
  %43 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv = getelementptr inbounds %struct.cop* %43, i64 0, i32 10
  %44 = load %struct.gv** %cop_filegv, align 8, !tbaa !97
  %45 = bitcast %struct.gv* %44 to %struct.sv*
  store %struct.sv* %45, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool52 = icmp eq %struct.gv* %44, null
  br i1 %tobool52, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end51
  %46 = getelementptr inbounds %struct.gv* %44, i64 0, i32 1
  %47 = load i64* %46, align 8, !tbaa !40
  %inc = add i64 %47, 1
  store i64 %inc, i64* %46, align 8, !tbaa !40
  br label %land.end

land.end:                                         ; preds = %if.end51, %land.rhs
  %cop_filegv54 = getelementptr inbounds i8* %call1, i64 56
  %48 = bitcast i8* %cop_filegv54 to %struct.gv**
  store %struct.gv* %44, %struct.gv** %48, align 8, !tbaa !97
  %49 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  %cop_stash = getelementptr inbounds i8* %call1, i64 48
  %50 = bitcast i8* %cop_stash to %struct.hv**
  store %struct.hv* %49, %struct.hv** %50, align 8, !tbaa !159
  %51 = load i64* @PL_perldb, align 8, !tbaa !1
  %and57 = and i64 %51, 2
  %tobool58 = icmp eq i64 %and57, 0
  br i1 %tobool58, label %if.end84, label %land.lhs.true59

land.lhs.true59:                                  ; preds = %land.end
  %52 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  %53 = load %struct.hv** @PL_debstash, align 8, !tbaa !6
  %cmp60 = icmp eq %struct.hv* %52, %53
  br i1 %cmp60, label %if.end84, label %if.then62

if.then62:                                        ; preds = %land.lhs.true59
  %54 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv63 = getelementptr inbounds %struct.cop* %54, i64 0, i32 10
  %55 = load %struct.gv** %cop_filegv63, align 8, !tbaa !97
  %tobool64 = icmp eq %struct.gv* %55, null
  br i1 %tobool64, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.then62
  %56 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv65 = getelementptr inbounds %struct.cop* %56, i64 0, i32 10
  %57 = load %struct.gv** %cop_filegv65, align 8, !tbaa !97
  %sv_any = getelementptr inbounds %struct.gv* %57, i64 0, i32 0
  %58 = load %struct.xpvgv** %sv_any, align 8, !tbaa !60
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %58, i64 0, i32 7
  %59 = load %struct.gp** %xgv_gp, align 8, !tbaa !62
  %gp_av = getelementptr inbounds %struct.gp* %59, i64 0, i32 4
  %60 = load %struct.av** %gp_av, align 8, !tbaa !160
  br label %cond.end

cond.end:                                         ; preds = %if.then62, %cond.true
  %cond = phi %struct.av* [ %60, %cond.true ], [ null, %if.then62 ]
  %cop_line66 = getelementptr inbounds i8* %call1, i64 80
  %61 = bitcast i8* %cop_line66 to i64*
  %62 = load i64* %61, align 8, !tbaa !116
  %call67 = tail call %struct.sv** @Perl_av_fetch(%struct.av* %cond, i64 %62, i64 0) #4
  %tobool68 = icmp eq %struct.sv** %call67, null
  br i1 %tobool68, label %if.end84, label %land.lhs.true69

land.lhs.true69:                                  ; preds = %cond.end
  %63 = load %struct.sv** %call67, align 8, !tbaa !6
  %cmp70 = icmp eq %struct.sv* %63, @PL_sv_undef
  br i1 %cmp70, label %if.end84, label %if.then72

if.then72:                                        ; preds = %land.lhs.true69
  %sv_flags = getelementptr inbounds %struct.sv* %63, i64 0, i32 2
  %64 = load i64* %sv_flags, align 8, !tbaa !34
  %and73 = and i64 %64, 2097152
  %tobool74 = icmp eq i64 %and73, 0
  br i1 %tobool74, label %land.end78, label %land.rhs75

land.rhs75:                                       ; preds = %if.then72
  %call76 = tail call i32 @Perl_sv_backoff(%struct.sv* %63) #4
  %.pre = load %struct.sv** %call67, align 8, !tbaa !6
  %sv_flags80.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre117 = load i64* %sv_flags80.phi.trans.insert, align 8, !tbaa !34
  br label %land.end78

land.end78:                                       ; preds = %if.then72, %land.rhs75
  %65 = phi i64 [ %64, %if.then72 ], [ %.pre117, %land.rhs75 ]
  %66 = phi %struct.sv* [ %63, %if.then72 ], [ %.pre, %land.rhs75 ]
  %sv_flags80 = getelementptr inbounds %struct.sv* %66, i64 0, i32 2
  %or81 = or i64 %65, 16842752
  store i64 %or81, i64* %sv_flags80, align 8, !tbaa !34
  %67 = ptrtoint i8* %call1 to i64
  %sv_any82 = getelementptr inbounds %struct.sv* %66, i64 0, i32 0
  %68 = load i8** %sv_any82, align 8, !tbaa !36
  %xiv_iv = getelementptr inbounds i8* %68, i64 24
  %69 = bitcast i8* %xiv_iv to i64*
  store i64 %67, i64* %69, align 8, !tbaa !53
  br label %if.end84

if.end84:                                         ; preds = %land.lhs.true69, %cond.end, %land.lhs.true59, %land.end, %land.end78
  %call85 = tail call i32 (i32, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @prepend_elem to i32 (i32, %struct.op*, %struct.op*, ...)*)(i32 173, %struct.op* %14, %struct.op* %o) #4
  %conv86 = sext i32 %call85 to i64
  %70 = inttoptr i64 %conv86 to %struct.op*
  ret %struct.op* %70
}

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #4

; Function Attrs: nounwind uwtable
define void @Perl_vload_module(i64 %flags, %struct.sv* %name, %struct.sv* %ver, [1 x %struct.__va_list_tag]* nocapture %args) #0 {
entry:
  %call.i = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i, i64 32
  %0 = bitcast i8* %op_type.i to i16*
  store i16 5, i16* %0, align 2, !tbaa !71
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %2 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %1, %struct.op* ()** %2, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i, i64 40
  %3 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %name, %struct.sv** %3, align 8, !tbaa !18
  %4 = bitcast i8* %call.i to %struct.op*
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %4, %struct.op** %op_next.i, align 8, !tbaa !73
  %5 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %5, align 1, !tbaa !74
  %6 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i = and i64 %6, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %4) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %entry
  %7 = phi i64 [ %6, %entry ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %7, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %8 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %8, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %9 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %9, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %9, i64 5
  %10 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %10, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %4) #4
  %11 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %11) #4
  br label %Perl_newSVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %12 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %12(%struct.op* %4) #4
  br label %Perl_newSVOP.exit

Perl_newSVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  %op_private = getelementptr inbounds %struct.op* %cond.i, i64 0, i32 7
  %13 = load i8* %op_private, align 1, !tbaa !11
  %or = or i8 %13, 64
  store i8 %or, i8* %op_private, align 1, !tbaa !11
  %tobool = icmp eq %struct.sv* %ver, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %Perl_newSVOP.exit
  %call.i55 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i55, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i56 = getelementptr inbounds i8* %call.i55, i64 32
  %14 = bitcast i8* %op_type.i56 to i16*
  store i16 5, i16* %14, align 2, !tbaa !71
  %15 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i57 = getelementptr inbounds i8* %call.i55, i64 16
  %16 = bitcast i8* %op_ppaddr.i57 to %struct.op* ()**
  store %struct.op* ()* %15, %struct.op* ()** %16, align 8, !tbaa !72
  %op_sv.i58 = getelementptr inbounds i8* %call.i55, i64 40
  %17 = bitcast i8* %op_sv.i58 to %struct.sv**
  store %struct.sv* %ver, %struct.sv** %17, align 8, !tbaa !18
  %18 = bitcast i8* %call.i55 to %struct.op*
  %op_next.i59 = bitcast i8* %call.i55 to %struct.op**
  store %struct.op* %18, %struct.op** %op_next.i59, align 8, !tbaa !73
  %19 = getelementptr inbounds i8* %call.i55, i64 36
  store i8 0, i8* %19, align 1, !tbaa !74
  %20 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i60 = and i64 %20, 4
  %tobool.i61 = icmp eq i64 %and.i60, 0
  br i1 %tobool.i61, label %if.end.i67, label %if.then.i64

if.then.i64:                                      ; preds = %if.then
  %call3.i62 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %18) #4
  %.pre.i63 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i67

if.end.i67:                                       ; preds = %if.then.i64, %if.then
  %21 = phi i64 [ %20, %if.then ], [ %.pre.i63, %if.then.i64 ]
  %and5.i65 = and i64 %21, 8
  %tobool6.i66 = icmp eq i64 %and5.i65, 0
  br i1 %tobool6.i66, label %if.end10.i73, label %if.then7.i71

if.then7.i71:                                     ; preds = %if.end.i67
  %call8.i68 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i69 = sext i32 %call8.i68 to i64
  %op_targ.i70 = getelementptr inbounds i8* %call.i55, i64 24
  %22 = bitcast i8* %op_targ.i70 to i64*
  store i64 %conv9.i69, i64* %22, align 8, !tbaa !75
  br label %if.end10.i73

if.end10.i73:                                     ; preds = %if.then7.i71, %if.end.i67
  %23 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i72 = icmp eq i8* %23, null
  br i1 %tobool11.i72, label %cond.false.i79, label %land.lhs.true.i76

land.lhs.true.i76:                                ; preds = %if.end10.i73
  %arrayidx12.i74 = getelementptr inbounds i8* %23, i64 5
  %24 = load i8* %arrayidx12.i74, align 1, !tbaa !5
  %tobool14.i75 = icmp eq i8 %24, 0
  br i1 %tobool14.i75, label %cond.false.i79, label %cond.true.i77

cond.true.i77:                                    ; preds = %land.lhs.true.i76
  tail call void @Perl_op_free(%struct.op* %18) #4
  %25 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %25) #4
  br label %if.end

cond.false.i79:                                   ; preds = %land.lhs.true.i76, %if.end10.i73
  %26 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i78 = tail call %struct.op* %26(%struct.op* %18) #4
  br label %if.end

if.end:                                           ; preds = %cond.false.i79, %cond.true.i77, %Perl_newSVOP.exit
  %veop.0 = phi %struct.op* [ null, %Perl_newSVOP.exit ], [ null, %cond.true.i77 ], [ %call17.i78, %cond.false.i79 ]
  %and = and i64 %flags, 2
  %tobool3 = icmp eq i64 %and, 0
  br i1 %tobool3, label %if.else8, label %if.then4

if.then4:                                         ; preds = %if.end
  %call.i.i = tail call i8* @Perl_safesysmalloc(i64 40) #4
  %27 = bitcast i8* %call.i.i to %struct.op*
  tail call void @llvm.memset.p0i8.i64(i8* %call.i.i, i8 0, i64 40, i32 1, i1 false) #4
  %op_type.i.i = getelementptr inbounds i8* %call.i.i, i64 32
  %28 = bitcast i8* %op_type.i.i to i16*
  store i16 1, i16* %28, align 2, !tbaa !12
  %29 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 1), align 8, !tbaa !6
  %op_ppaddr.i.i = getelementptr inbounds i8* %call.i.i, i64 16
  %30 = bitcast i8* %op_ppaddr.i.i to %struct.op* ()**
  store %struct.op* ()* %29, %struct.op* ()** %30, align 8, !tbaa !41
  %31 = getelementptr inbounds i8* %call.i.i, i64 36
  store i8 0, i8* %31, align 1, !tbaa !14
  %op_next.i.i = bitcast i8* %call.i.i to %struct.op**
  store %struct.op* %27, %struct.op** %op_next.i.i, align 8, !tbaa !42
  %32 = getelementptr inbounds i8* %call.i.i, i64 37
  store i8 0, i8* %32, align 1, !tbaa !11
  %33 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 1), align 8, !tbaa !1
  %and.i.i = and i64 %33, 4
  %tobool.i.i = icmp eq i64 %and.i.i, 0
  br i1 %tobool.i.i, label %if.end.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then4
  %call4.i.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %27) #4
  %.pre.i.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 1), align 8, !tbaa !1
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i.i, %if.then4
  %34 = phi i64 [ %33, %if.then4 ], [ %.pre.i.i, %if.then.i.i ]
  %and6.i.i = and i64 %34, 8
  %tobool7.i.i = icmp eq i64 %and6.i.i, 0
  br i1 %tobool7.i.i, label %if.end11.i.i, label %if.then8.i.i

if.then8.i.i:                                     ; preds = %if.end.i.i
  %call9.i.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 1, i32 512) #4
  %conv10.i.i = sext i32 %call9.i.i to i64
  %op_targ.i.i = getelementptr inbounds i8* %call.i.i, i64 24
  %35 = bitcast i8* %op_targ.i.i to i64*
  store i64 %conv10.i.i, i64* %35, align 8, !tbaa !13
  br label %if.end11.i.i

if.end11.i.i:                                     ; preds = %if.then8.i.i, %if.end.i.i
  %36 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12.i.i = icmp eq i8* %36, null
  br i1 %tobool12.i.i, label %cond.false.i.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.end11.i.i
  %arrayidx13.i.i = getelementptr inbounds i8* %36, i64 1
  %37 = load i8* %arrayidx13.i.i, align 1, !tbaa !5
  %tobool15.i.i = icmp eq i8 %37, 0
  br i1 %tobool15.i.i, label %cond.false.i.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %land.lhs.true.i.i
  tail call void @Perl_op_free(%struct.op* %27) #4
  %38 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 1), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %38) #4
  br label %Perl_newNULLLIST.exit

cond.false.i.i:                                   ; preds = %land.lhs.true.i.i, %if.end11.i.i
  %39 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 1), align 8, !tbaa !6
  %call18.i.i = tail call %struct.op* %39(%struct.op* %27) #4
  br label %Perl_newNULLLIST.exit

Perl_newNULLLIST.exit:                            ; preds = %cond.true.i.i, %cond.false.i.i
  %cond.i.i = phi %struct.op* [ null, %cond.true.i.i ], [ %call18.i.i, %cond.false.i.i ]
  %call6 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @sawparens to i32 (%struct.op*, ...)*)(%struct.op* %cond.i.i) #4
  %conv7 = sext i32 %call6 to i64
  %40 = inttoptr i64 %conv7 to %struct.op*
  br label %if.end42

if.else8:                                         ; preds = %if.end
  %and9 = and i64 %flags, 4
  %tobool10 = icmp eq i64 %and9, 0
  %gp_offset_p14 = getelementptr inbounds [1 x %struct.__va_list_tag]* %args, i64 0, i64 0, i32 0
  %gp_offset15 = load i32* %gp_offset_p14, align 4
  %fits_in_gp16 = icmp ult i32 %gp_offset15, 41
  br i1 %tobool10, label %if.else12, label %if.then11

if.then11:                                        ; preds = %if.else8
  br i1 %fits_in_gp16, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %if.then11
  %41 = getelementptr inbounds [1 x %struct.__va_list_tag]* %args, i64 0, i64 0, i32 3
  %reg_save_area = load i8** %41, align 8
  %42 = sext i32 %gp_offset15 to i64
  %43 = getelementptr i8* %reg_save_area, i64 %42
  %44 = add i32 %gp_offset15, 8
  store i32 %44, i32* %gp_offset_p14, align 4
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %if.then11
  %overflow_arg_area_p = getelementptr inbounds [1 x %struct.__va_list_tag]* %args, i64 0, i64 0, i32 2
  %overflow_arg_area = load i8** %overflow_arg_area_p, align 8
  %overflow_arg_area.next = getelementptr i8* %overflow_arg_area, i64 8
  store i8* %overflow_arg_area.next, i8** %overflow_arg_area_p, align 8
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %vaarg.addr.in = phi i8* [ %43, %vaarg.in_reg ], [ %overflow_arg_area, %vaarg.in_mem ]
  %vaarg.addr = bitcast i8* %vaarg.addr.in to %struct.op**
  %45 = load %struct.op** %vaarg.addr, align 8
  br label %if.end42

if.else12:                                        ; preds = %if.else8
  br i1 %fits_in_gp16, label %vaarg.in_reg17, label %vaarg.in_mem19

vaarg.in_reg17:                                   ; preds = %if.else12
  %46 = getelementptr inbounds [1 x %struct.__va_list_tag]* %args, i64 0, i64 0, i32 3
  %reg_save_area18 = load i8** %46, align 8
  %47 = sext i32 %gp_offset15 to i64
  %48 = getelementptr i8* %reg_save_area18, i64 %47
  %49 = add i32 %gp_offset15, 8
  store i32 %49, i32* %gp_offset_p14, align 4
  br label %while.cond.preheader

vaarg.in_mem19:                                   ; preds = %if.else12
  %overflow_arg_area_p20 = getelementptr inbounds [1 x %struct.__va_list_tag]* %args, i64 0, i64 0, i32 2
  %overflow_arg_area21 = load i8** %overflow_arg_area_p20, align 8
  %overflow_arg_area.next22 = getelementptr i8* %overflow_arg_area21, i64 8
  store i8* %overflow_arg_area.next22, i8** %overflow_arg_area_p20, align 8
  br label %while.cond.preheader

while.cond.preheader:                             ; preds = %vaarg.in_mem19, %vaarg.in_reg17
  %sv.0.in.in.ph = phi i8* [ %48, %vaarg.in_reg17 ], [ %overflow_arg_area21, %vaarg.in_mem19 ]
  %sv.0.in109 = bitcast i8* %sv.0.in.in.ph to %struct.sv**
  %sv.0110 = load %struct.sv** %sv.0.in109, align 8
  %tobool25111 = icmp eq %struct.sv* %sv.0110, null
  br i1 %tobool25111, label %if.end42, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %while.cond.preheader
  %50 = getelementptr inbounds [1 x %struct.__va_list_tag]* %args, i64 0, i64 0, i32 3
  %overflow_arg_area_p36 = getelementptr inbounds [1 x %struct.__va_list_tag]* %args, i64 0, i64 0, i32 2
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.cond.backedge
  %sv.0113 = phi %struct.sv* [ %sv.0110, %while.body.lr.ph ], [ %sv.0, %while.cond.backedge ]
  %imop.0112 = phi %struct.op* [ null, %while.body.lr.ph ], [ %64, %while.cond.backedge ]
  %call.i82 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i82, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i83 = getelementptr inbounds i8* %call.i82, i64 32
  %51 = bitcast i8* %op_type.i83 to i16*
  store i16 5, i16* %51, align 2, !tbaa !71
  %52 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i84 = getelementptr inbounds i8* %call.i82, i64 16
  %53 = bitcast i8* %op_ppaddr.i84 to %struct.op* ()**
  store %struct.op* ()* %52, %struct.op* ()** %53, align 8, !tbaa !72
  %op_sv.i85 = getelementptr inbounds i8* %call.i82, i64 40
  %54 = bitcast i8* %op_sv.i85 to %struct.sv**
  store %struct.sv* %sv.0113, %struct.sv** %54, align 8, !tbaa !18
  %55 = bitcast i8* %call.i82 to %struct.op*
  %op_next.i86 = bitcast i8* %call.i82 to %struct.op**
  store %struct.op* %55, %struct.op** %op_next.i86, align 8, !tbaa !73
  %56 = getelementptr inbounds i8* %call.i82, i64 36
  store i8 0, i8* %56, align 1, !tbaa !74
  %57 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i87 = and i64 %57, 4
  %tobool.i88 = icmp eq i64 %and.i87, 0
  br i1 %tobool.i88, label %if.end.i94, label %if.then.i91

if.then.i91:                                      ; preds = %while.body
  %call3.i89 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %55) #4
  %.pre.i90 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i94

if.end.i94:                                       ; preds = %if.then.i91, %while.body
  %58 = phi i64 [ %57, %while.body ], [ %.pre.i90, %if.then.i91 ]
  %and5.i92 = and i64 %58, 8
  %tobool6.i93 = icmp eq i64 %and5.i92, 0
  br i1 %tobool6.i93, label %if.end10.i100, label %if.then7.i98

if.then7.i98:                                     ; preds = %if.end.i94
  %call8.i95 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i96 = sext i32 %call8.i95 to i64
  %op_targ.i97 = getelementptr inbounds i8* %call.i82, i64 24
  %59 = bitcast i8* %op_targ.i97 to i64*
  store i64 %conv9.i96, i64* %59, align 8, !tbaa !75
  br label %if.end10.i100

if.end10.i100:                                    ; preds = %if.then7.i98, %if.end.i94
  %60 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i99 = icmp eq i8* %60, null
  br i1 %tobool11.i99, label %cond.false.i106, label %land.lhs.true.i103

land.lhs.true.i103:                               ; preds = %if.end10.i100
  %arrayidx12.i101 = getelementptr inbounds i8* %60, i64 5
  %61 = load i8* %arrayidx12.i101, align 1, !tbaa !5
  %tobool14.i102 = icmp eq i8 %61, 0
  br i1 %tobool14.i102, label %cond.false.i106, label %cond.true.i104

cond.true.i104:                                   ; preds = %land.lhs.true.i103
  tail call void @Perl_op_free(%struct.op* %55) #4
  %62 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %62) #4
  br label %Perl_newSVOP.exit108

cond.false.i106:                                  ; preds = %land.lhs.true.i103, %if.end10.i100
  %63 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i105 = tail call %struct.op* %63(%struct.op* %55) #4
  br label %Perl_newSVOP.exit108

Perl_newSVOP.exit108:                             ; preds = %cond.true.i104, %cond.false.i106
  %cond.i107 = phi %struct.op* [ null, %cond.true.i104 ], [ %call17.i105, %cond.false.i106 ]
  %call27 = tail call i32 (i32, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, %struct.op*, ...)*)(i32 141, %struct.op* %imop.0112, %struct.op* %cond.i107) #4
  %conv28 = sext i32 %call27 to i64
  %64 = inttoptr i64 %conv28 to %struct.op*
  %gp_offset31 = load i32* %gp_offset_p14, align 4
  %fits_in_gp32 = icmp ult i32 %gp_offset31, 41
  br i1 %fits_in_gp32, label %vaarg.in_reg33, label %vaarg.in_mem35

vaarg.in_reg33:                                   ; preds = %Perl_newSVOP.exit108
  %reg_save_area34 = load i8** %50, align 8
  %65 = sext i32 %gp_offset31 to i64
  %66 = getelementptr i8* %reg_save_area34, i64 %65
  %67 = add i32 %gp_offset31, 8
  store i32 %67, i32* %gp_offset_p14, align 4
  br label %while.cond.backedge

vaarg.in_mem35:                                   ; preds = %Perl_newSVOP.exit108
  %overflow_arg_area37 = load i8** %overflow_arg_area_p36, align 8
  %overflow_arg_area.next38 = getelementptr i8* %overflow_arg_area37, i64 8
  store i8* %overflow_arg_area.next38, i8** %overflow_arg_area_p36, align 8
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %vaarg.in_mem35, %vaarg.in_reg33
  %sv.0.in.in.be = phi i8* [ %66, %vaarg.in_reg33 ], [ %overflow_arg_area37, %vaarg.in_mem35 ]
  %sv.0.in = bitcast i8* %sv.0.in.in.be to %struct.sv**
  %sv.0 = load %struct.sv** %sv.0.in, align 8
  %tobool25 = icmp eq %struct.sv* %sv.0, null
  br i1 %tobool25, label %if.end42, label %while.body

if.end42:                                         ; preds = %while.cond.backedge, %while.cond.preheader, %vaarg.end, %Perl_newNULLLIST.exit
  %imop.1 = phi %struct.op* [ %40, %Perl_newNULLLIST.exit ], [ %45, %vaarg.end ], [ null, %while.cond.preheader ], [ %64, %while.cond.backedge ]
  %68 = load i64* @PL_copline, align 8, !tbaa !1
  %69 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %70 = load i32* @PL_expect, align 4, !tbaa !92
  %and43 = and i64 %flags, 1
  %71 = xor i64 %and43, 1
  %lnot.ext = trunc i64 %71 to i32
  %call45 = tail call i64 @Perl_start_subparse(i64 0, i64 0) #4
  %call46 = tail call i32 (i32, i64, %struct.op*, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @utilize to i32 (i32, i64, %struct.op*, %struct.op*, %struct.op*, ...)*)(i32 %lnot.ext, i64 %call45, %struct.op* %veop.0, %struct.op* %cond.i, %struct.op* %imop.1) #4
  store i32 %70, i32* @PL_expect, align 4, !tbaa !92
  store i64 %68, i64* @PL_copline, align 8, !tbaa !1
  store volatile %struct.cop* %69, %struct.cop** @PL_curcop, align 8, !tbaa !6
  ret void
}

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #4

declare i32 @utilize(...) #2

declare i64 @Perl_start_subparse(i64, i64) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_dofile(%struct.op* %term) #0 {
entry:
  %call = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([3 x i8]* @.str52, i64 0, i64 0), i64 0, i64 12) #4
  %tobool = icmp eq %struct.gv* %call, null
  br i1 %tobool, label %if.then, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %sv_any = getelementptr inbounds %struct.gv* %call, i64 0, i32 0
  %0 = load %struct.xpvgv** %sv_any, align 8, !tbaa !60
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %0, i64 0, i32 7
  %1 = load %struct.gp** %xgv_gp, align 8, !tbaa !62
  %gp_cvgen = getelementptr inbounds %struct.gp* %1, i64 0, i32 8
  %2 = load i64* %gp_cvgen, align 8, !tbaa !137
  %tobool1 = icmp eq i64 %2, 0
  br i1 %tobool1, label %cond.false, label %if.then

cond.false:                                       ; preds = %land.lhs.true
  %gp_cv = getelementptr inbounds %struct.gp* %1, i64 0, i32 7
  %3 = load %struct.cv** %gp_cv, align 8, !tbaa !64
  %tobool4 = icmp eq %struct.cv* %3, null
  br i1 %tobool4, label %if.then, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %cond.false
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %0, i64 0, i32 11
  %4 = load i8* %xgv_flags, align 1, !tbaa !141
  %tobool7 = icmp slt i8 %4, 0
  br i1 %tobool7, label %if.end, label %if.then

if.then:                                          ; preds = %cond.false, %land.lhs.true, %entry, %land.lhs.true5
  %call8 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([17 x i8]* @.str53, i64 0, i64 0), i64 0, i64 12) #4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true5
  %gv.0 = phi %struct.gv* [ %call8, %if.then ], [ %call, %land.lhs.true5 ]
  %tobool9 = icmp eq %struct.gv* %gv.0, null
  br i1 %tobool9, label %if.else, label %land.lhs.true10

land.lhs.true10:                                  ; preds = %if.end
  %sv_any11 = getelementptr inbounds %struct.gv* %gv.0, i64 0, i32 0
  %5 = load %struct.xpvgv** %sv_any11, align 8, !tbaa !60
  %xgv_gp12 = getelementptr inbounds %struct.xpvgv* %5, i64 0, i32 7
  %6 = load %struct.gp** %xgv_gp12, align 8, !tbaa !62
  %gp_cvgen13 = getelementptr inbounds %struct.gp* %6, i64 0, i32 8
  %7 = load i64* %gp_cvgen13, align 8, !tbaa !137
  %tobool14 = icmp eq i64 %7, 0
  br i1 %tobool14, label %cond.false16, label %if.else

cond.false16:                                     ; preds = %land.lhs.true10
  %gp_cv19 = getelementptr inbounds %struct.gp* %6, i64 0, i32 7
  %8 = load %struct.cv** %gp_cv19, align 8, !tbaa !64
  %tobool20 = icmp eq %struct.cv* %8, null
  br i1 %tobool20, label %if.else, label %land.lhs.true21

land.lhs.true21:                                  ; preds = %cond.false16
  %xgv_flags23 = getelementptr inbounds %struct.xpvgv* %5, i64 0, i32 11
  %9 = load i8* %xgv_flags23, align 1, !tbaa !141
  %tobool26 = icmp slt i8 %9, 0
  br i1 %tobool26, label %Perl_newGVOP.exit, label %if.else

Perl_newGVOP.exit:                                ; preds = %land.lhs.true21
  %10 = bitcast %struct.gv* %gv.0 to %struct.sv*
  store %struct.sv* %10, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %11 = getelementptr inbounds %struct.gv* %gv.0, i64 0, i32 1
  %12 = load i64* %11, align 8, !tbaa !40
  %inc.i = add i64 %12, 1
  store i64 %inc.i, i64* %11, align 8, !tbaa !40
  %call.i48 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i48, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i48, i64 32
  %13 = bitcast i8* %op_type.i to i16*
  store i16 7, i16* %13, align 2, !tbaa !71
  %14 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 7), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i48, i64 16
  %15 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %14, %struct.op* ()** %15, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i48, i64 40
  %16 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %10, %struct.sv** %16, align 8, !tbaa !18
  %17 = bitcast i8* %call.i48 to %struct.op*
  %op_next.i = bitcast i8* %call.i48 to %struct.op**
  store %struct.op* %17, %struct.op** %op_next.i, align 8, !tbaa !73
  %18 = getelementptr inbounds i8* %call.i48, i64 36
  store i8 0, i8* %18, align 1, !tbaa !74
  %19 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  %and.i = and i64 %19, 4
  %tobool.i49 = icmp eq i64 %and.i, 0
  br i1 %tobool.i49, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %Perl_newGVOP.exit
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %17) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %Perl_newGVOP.exit
  %20 = phi i64 [ %19, %Perl_newGVOP.exit ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %20, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 7, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i48, i64 24
  %21 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %21, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %22 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %22, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %22, i64 7
  %23 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %23, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %17) #4
  %24 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 7), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %24) #4
  br label %Perl_newSVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %25 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 7), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %25(%struct.op* %17) #4
  br label %Perl_newSVOP.exit

Perl_newSVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  %call29 = tail call %struct.op* @Perl_newUNOP(i64 17, i64 0, %struct.op* %cond.i)
  %call30 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %call29) #4
  %call31 = tail call i32 (i32, %struct.op*, i32, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, i32, ...)*)(i32 141, %struct.op* %term, i32 %call30) #4
  %conv32 = sext i32 %call31 to i64
  %26 = inttoptr i64 %conv32 to %struct.op*
  %call33 = tail call %struct.op* @Perl_newUNOP(i64 166, i64 64, %struct.op* %26)
  %call34 = tail call %struct.op* @Perl_ck_subr(%struct.op* %call33)
  br label %if.end38

if.else:                                          ; preds = %cond.false16, %land.lhs.true10, %if.end, %land.lhs.true21
  %call35 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %term) #4
  %conv36 = sext i32 %call35 to i64
  %27 = inttoptr i64 %conv36 to %struct.op*
  %call37 = tail call %struct.op* @Perl_newUNOP(i64 310, i64 0, %struct.op* %27)
  br label %if.end38

if.end38:                                         ; preds = %if.else, %Perl_newSVOP.exit
  %doop.0 = phi %struct.op* [ %call37, %if.else ], [ %call34, %Perl_newSVOP.exit ]
  ret %struct.op* %doop.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_subr(%struct.op* %o) #0 {
entry:
  %0 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %1 = load %struct.op** %0, align 8, !tbaa !15
  %op_sibling = getelementptr inbounds %struct.op* %1, i64 0, i32 1
  %2 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %tobool = icmp eq %struct.op* %2, null
  %.o = select i1 %tobool, %struct.op* %1, %struct.op* %o
  %3 = getelementptr inbounds %struct.op* %.o, i64 1, i32 0
  %4 = load %struct.op** %3, align 8, !tbaa !15
  %op_sibling3 = getelementptr inbounds %struct.op* %4, i64 0, i32 1
  %5 = load %struct.op** %op_sibling3, align 8, !tbaa !17
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %6 = load i8* %op_private, align 1, !tbaa !11
  %or = or i8 %6, 32
  store i8 %or, i8* %op_private, align 1, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.cond, %entry
  %cvop.0 = phi %struct.op* [ %5, %entry ], [ %7, %for.cond ]
  %op_sibling5 = getelementptr inbounds %struct.op* %cvop.0, i64 0, i32 1
  %7 = load %struct.op** %op_sibling5, align 8, !tbaa !17
  %tobool6 = icmp eq %struct.op* %7, null
  br i1 %tobool6, label %for.end, label %for.cond

for.end:                                          ; preds = %for.cond
  %op_type = getelementptr inbounds %struct.op* %cvop.0, i64 0, i32 4
  %8 = load i16* %op_type, align 2, !tbaa !12
  switch i16 %8, label %if.end106 [
    i16 17, label %Perl_op_null.exit
    i16 165, label %if.then72
    i16 350, label %if.then72
  ]

Perl_op_null.exit:                                ; preds = %for.end
  %op_private10 = getelementptr inbounds %struct.op* %cvop.0, i64 0, i32 7
  %9 = load i8* %op_private10, align 1, !tbaa !11
  %and = and i8 %9, 8
  %or14 = or i8 %or, %and
  store i8 %or14, i8* %op_private, align 1, !tbaa !11
  %call.i = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %cvop.0) #4
  %10 = load i16* %op_type, align 2, !tbaa !12
  %conv3.i = zext i16 %10 to i64
  %op_targ.i = getelementptr inbounds %struct.op* %cvop.0, i64 0, i32 3
  store i64 %conv3.i, i64* %op_targ.i, align 8, !tbaa !13
  store i16 0, i16* %op_type, align 2, !tbaa !12
  %11 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds %struct.op* %cvop.0, i64 0, i32 2
  store %struct.op* ()* %11, %struct.op* ()** %op_ppaddr.i, align 8, !tbaa !41
  %12 = getelementptr inbounds %struct.op* %cvop.0, i64 1, i32 0
  %13 = load %struct.op** %12, align 8, !tbaa !15
  %14 = getelementptr inbounds %struct.op* %13, i64 0, i32 4
  %15 = load i16* %14, align 2, !tbaa !71
  %cmp19 = icmp eq i16 %15, 7
  br i1 %cmp19, label %land.lhs.true, label %if.end106

land.lhs.true:                                    ; preds = %Perl_op_null.exit
  %16 = load i8* %op_private, align 1, !tbaa !11
  %and23 = and i8 %16, 8
  %tobool24 = icmp eq i8 %and23, 0
  br i1 %tobool24, label %if.then25, label %if.end106

if.then25:                                        ; preds = %land.lhs.true
  %op_sv = getelementptr inbounds %struct.op* %13, i64 1
  %17 = bitcast %struct.op* %op_sv to %struct.sv**
  %18 = load %struct.sv** %17, align 8, !tbaa !18
  %19 = bitcast %struct.sv* %18 to %struct.gv*
  %sv_any = bitcast %struct.sv* %18 to %struct.xpvgv**
  %20 = load %struct.xpvgv** %sv_any, align 8, !tbaa !60
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %20, i64 0, i32 7
  %21 = load %struct.gp** %xgv_gp, align 8, !tbaa !62
  %gp_cvgen = getelementptr inbounds %struct.gp* %21, i64 0, i32 8
  %22 = load i64* %gp_cvgen, align 8, !tbaa !137
  %tobool26 = icmp eq i64 %22, 0
  br i1 %tobool26, label %cond.end31, label %if.then34

cond.end31:                                       ; preds = %if.then25
  %gp_cv = getelementptr inbounds %struct.gp* %21, i64 0, i32 7
  %23 = load %struct.cv** %gp_cv, align 8, !tbaa !64
  %tobool33 = icmp eq %struct.cv* %23, null
  br i1 %tobool33, label %if.then34, label %if.else

if.then34:                                        ; preds = %if.then25, %cond.end31
  %24 = getelementptr inbounds %struct.op* %13, i64 0, i32 7
  %25 = load i8* %24, align 1, !tbaa !33
  %or37 = or i8 %25, 32
  store i8 %or37, i8* %24, align 1, !tbaa !33
  br label %if.end106

if.else:                                          ; preds = %cond.end31
  %sv_flags = getelementptr inbounds %struct.cv* %23, i64 0, i32 2
  %26 = load i64* %sv_flags, align 8, !tbaa !140
  %and39 = and i64 %26, 262144
  %tobool40 = icmp eq i64 %and39, 0
  br i1 %tobool40, label %if.end106, label %if.then41

if.then41:                                        ; preds = %if.else
  %sv_any42 = getelementptr inbounds %struct.cv* %23, i64 0, i32 0
  %27 = load %struct.xpvcv** %sv_any42, align 8, !tbaa !66
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %27, i64 0, i32 17
  %28 = load i16* %xcv_flags, align 2, !tbaa !68
  %and44 = and i16 %28, 4
  %tobool45 = icmp eq i16 %and44, 0
  br i1 %tobool45, label %cond.false47, label %cond.true55

cond.false47:                                     ; preds = %if.then41
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %27, i64 0, i32 12
  %29 = load %struct.gv** %xcv_gv, align 8, !tbaa !145
  br label %cond.true55

cond.true55:                                      ; preds = %cond.false47, %if.then41
  %cond50 = phi %struct.gv* [ %29, %cond.false47 ], [ %19, %if.then41 ]
  %xpv_pv = getelementptr inbounds %struct.xpvcv* %27, i64 0, i32 0
  %30 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %if.end106

if.then72:                                        ; preds = %for.end, %for.end
  %op_type73 = getelementptr inbounds %struct.op* %5, i64 0, i32 4
  %31 = load i16* %op_type73, align 2, !tbaa !12
  switch i16 %31, label %if.end106 [
    i16 5, label %if.then77
    i16 141, label %if.then87
  ]

if.then77:                                        ; preds = %if.then72
  %op_private78 = getelementptr inbounds %struct.op* %5, i64 0, i32 7
  %32 = load i8* %op_private78, align 1, !tbaa !11
  %and80 = and i8 %32, -9
  store i8 %and80, i8* %op_private78, align 1, !tbaa !11
  br label %if.end106

if.then87:                                        ; preds = %if.then72
  %33 = getelementptr inbounds %struct.op* %5, i64 1, i32 0
  %34 = load %struct.op** %33, align 8, !tbaa !15
  %op_sibling90 = getelementptr inbounds %struct.op* %34, i64 0, i32 1
  %35 = load %struct.op** %op_sibling90, align 8, !tbaa !17
  %tobool91 = icmp eq %struct.op* %35, null
  br i1 %tobool91, label %if.end106, label %land.lhs.true92

land.lhs.true92:                                  ; preds = %if.then87
  %op_type93 = getelementptr inbounds %struct.op* %35, i64 0, i32 4
  %36 = load i16* %op_type93, align 2, !tbaa !12
  %cmp95 = icmp eq i16 %36, 5
  br i1 %cmp95, label %if.then97, label %if.end106

if.then97:                                        ; preds = %land.lhs.true92
  %op_private98 = getelementptr inbounds %struct.op* %35, i64 0, i32 7
  %37 = load i8* %op_private98, align 1, !tbaa !11
  %and100 = and i8 %37, -9
  store i8 %and100, i8* %op_private98, align 1, !tbaa !11
  br label %if.end106

if.end106:                                        ; preds = %if.then72, %for.end, %cond.true55, %if.else, %land.lhs.true, %if.then87, %if.then97, %land.lhs.true92, %if.then77, %Perl_op_null.exit, %if.then34
  %namegv.0 = phi %struct.gv* [ null, %land.lhs.true ], [ null, %if.else ], [ null, %if.then34 ], [ null, %Perl_op_null.exit ], [ null, %if.then77 ], [ null, %if.then97 ], [ null, %land.lhs.true92 ], [ null, %if.then87 ], [ %cond50, %cond.true55 ], [ null, %for.end ], [ null, %if.then72 ]
  %cv.0 = phi %struct.cv* [ null, %land.lhs.true ], [ %23, %if.else ], [ null, %if.then34 ], [ null, %Perl_op_null.exit ], [ null, %if.then77 ], [ null, %if.then97 ], [ null, %land.lhs.true92 ], [ null, %if.then87 ], [ %23, %cond.true55 ], [ null, %for.end ], [ null, %if.then72 ]
  %proto.0 = phi i8* [ null, %land.lhs.true ], [ null, %if.else ], [ null, %if.then34 ], [ null, %Perl_op_null.exit ], [ null, %if.then77 ], [ null, %if.then97 ], [ null, %land.lhs.true92 ], [ null, %if.then87 ], [ %30, %cond.true55 ], [ null, %for.end ], [ null, %if.then72 ]
  %38 = load i64* @PL_hints, align 8, !tbaa !1
  %and107 = and i64 %38, 2
  %39 = load i8* %op_private, align 1, !tbaa !11
  %conv109 = zext i8 %39 to i64
  %or110 = or i64 %conv109, %and107
  %conv111 = trunc i64 %or110 to i8
  store i8 %conv111, i8* %op_private, align 1, !tbaa !11
  %40 = load i64* @PL_perldb, align 8, !tbaa !1
  %and114 = and i64 %40, 1
  %tobool115 = icmp eq i64 %and114, 0
  br i1 %tobool115, label %while.cond.preheader, label %land.lhs.true116

land.lhs.true116:                                 ; preds = %if.end106
  %41 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  %42 = load %struct.hv** @PL_debstash, align 8, !tbaa !6
  %cmp117 = icmp eq %struct.hv* %41, %42
  br i1 %cmp117, label %while.cond.preheader, label %if.then119

if.then119:                                       ; preds = %land.lhs.true116
  %or122 = or i8 %conv111, 16
  store i8 %or122, i8* %op_private, align 1, !tbaa !11
  br label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.then119, %if.end106, %land.lhs.true116
  %cmp125620 = icmp eq %struct.op* %5, %cvop.0
  %tobool127602610621 = icmp ne i8* %proto.0, null
  br i1 %cmp125620, label %while.end377, label %while.body.lr.ph.lr.ph

while.body.lr.ph.lr.ph:                           ; preds = %while.cond.preheader, %if.end374
  %tobool127602610658 = phi i1 [ %tobool127602610, %if.end374 ], [ %tobool127602610621, %while.cond.preheader ]
  %prev.0.ph652 = phi %struct.op* [ %o2.6, %if.end374 ], [ %4, %while.cond.preheader ]
  %o2.0.ph645 = phi %struct.op* [ %84, %if.end374 ], [ %5, %while.cond.preheader ]
  %proto.1.ph644 = phi i8* [ %proto.6, %if.end374 ], [ %proto.0, %while.cond.preheader ]
  %optional.0.ph643 = phi i32 [ %optional.0.ph548578, %if.end374 ], [ 0, %while.cond.preheader ]
  %arg.0.ph636 = phi i64 [ %arg.5, %if.end374 ], [ 0, %while.cond.preheader ]
  %e.0.ph629 = phi i8* [ %e.5, %if.end374 ], [ null, %while.cond.preheader ]
  %contextclass.0.ph622 = phi i64 [ %contextclass.5, %if.end374 ], [ 0, %while.cond.preheader ]
  br label %while.body.lr.ph.while.body.lr.ph.split_crit_edge

while.body.lr.ph.while.body.lr.ph.split_crit_edge: ; preds = %sw.bb133, %while.body.lr.ph.lr.ph
  %tobool127602613 = phi i1 [ %tobool127602610658, %while.body.lr.ph.lr.ph ], [ true, %sw.bb133 ]
  %proto.1.ph549612 = phi i8* [ %proto.1.ph644, %while.body.lr.ph.lr.ph ], [ %incdec.ptr, %sw.bb133 ]
  %optional.0.ph548611 = phi i32 [ %optional.0.ph643, %while.body.lr.ph.lr.ph ], [ 1, %sw.bb133 ]
  br label %while.body

while.body:                                       ; preds = %sw.bb367, %while.body.lr.ph.while.body.lr.ph.split_crit_edge
  %tobool127604 = phi i1 [ %tobool127602613, %while.body.lr.ph.while.body.lr.ph.split_crit_edge ], [ true, %sw.bb367 ]
  %proto.1603 = phi i8* [ %proto.1.ph549612, %while.body.lr.ph.while.body.lr.ph.split_crit_edge ], [ %incdec.ptr368, %sw.bb367 ]
  br i1 %tobool127604, label %if.then128, label %if.else372

if.then128:                                       ; preds = %while.body
  %43 = load i8* %proto.1603, align 1, !tbaa !5
  %conv129 = sext i8 %43 to i32
  switch i32 %conv129, label %oops [
    i32 0, label %sw.bb
    i32 59, label %sw.bb133
    i32 36, label %sw.bb134
    i32 37, label %sw.bb137
    i32 64, label %sw.bb137
    i32 38, label %sw.bb140
    i32 42, label %sw.bb159
    i32 32, label %sw.bb367
    i32 92, label %sw.bb231
  ]

sw.bb:                                            ; preds = %if.then128
  %call130 = call i32 (%struct.gv*, ...)* bitcast (i32 (...)* @gv_ename to i32 (%struct.gv*, ...)*)(%struct.gv* %namegv.0) #4
  %call131 = call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @too_many_arguments to i32 (%struct.op*, i32, ...)*)(%struct.op* %o, i32 %call130) #4
  %conv132 = sext i32 %call131 to i64
  %44 = inttoptr i64 %conv132 to %struct.op*
  br label %return

sw.bb133:                                         ; preds = %if.then128
  %incdec.ptr = getelementptr inbounds i8* %proto.1603, i64 1
  br label %while.body.lr.ph.while.body.lr.ph.split_crit_edge

sw.bb134:                                         ; preds = %if.then128
  %incdec.ptr135 = getelementptr inbounds i8* %proto.1603, i64 1
  %inc = add nsw i64 %arg.0.ph636, 1
  %call136 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %o2.0.ph645) #4
  br label %if.end374

sw.bb137:                                         ; preds = %if.then128, %if.then128
  %call138 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %o2.0.ph645) #4
  %inc139 = add nsw i64 %arg.0.ph636, 1
  br label %if.end374

sw.bb140:                                         ; preds = %if.then128
  %incdec.ptr141 = getelementptr inbounds i8* %proto.1603, i64 1
  %inc142 = add nsw i64 %arg.0.ph636, 1
  %op_type143 = getelementptr inbounds %struct.op* %o2.0.ph645, i64 0, i32 4
  %45 = load i16* %op_type143, align 2, !tbaa !12
  switch i16 %45, label %if.then152 [
    i16 20, label %if.end374
    i16 43, label %if.end374
  ]

if.then152:                                       ; preds = %sw.bb140
  %cmp153 = icmp eq i64 %arg.0.ph636, 0
  %cond155 = select i1 %cmp153, i8* getelementptr inbounds ([16 x i8]* @.str127, i64 0, i64 0), i8* getelementptr inbounds ([7 x i8]* @.str128, i64 0, i64 0)
  %call156 = call i32 (%struct.gv*, ...)* bitcast (i32 (...)* @gv_ename to i32 (%struct.gv*, ...)*)(%struct.gv* %namegv.0) #4
  %call157 = call i32 (i64, i8*, i32, %struct.op*, ...)* bitcast (i32 (...)* @bad_type to i32 (i64, i8*, i32, %struct.op*, ...)*)(i64 %inc142, i8* %cond155, i32 %call156, %struct.op* %o2.0.ph645) #4
  br label %if.end374

sw.bb159:                                         ; preds = %if.then128
  %incdec.ptr160 = getelementptr inbounds i8* %proto.1603, i64 1
  %inc161 = add nsw i64 %arg.0.ph636, 1
  %op_type162 = getelementptr inbounds %struct.op* %o2.0.ph645, i64 0, i32 4
  %46 = load i16* %op_type162, align 2, !tbaa !12
  switch i16 %46, label %if.end228 [
    i16 14, label %wrapref
    i16 5, label %if.then172
    i16 166, label %if.then182
  ]

if.then172:                                       ; preds = %sw.bb159
  %op_private173 = getelementptr inbounds %struct.op* %o2.0.ph645, i64 0, i32 7
  %47 = load i8* %op_private173, align 1, !tbaa !11
  %and175 = and i8 %47, -9
  store i8 %and175, i8* %op_private173, align 1, !tbaa !11
  br label %if.end228

if.then182:                                       ; preds = %sw.bb159
  %48 = getelementptr inbounds %struct.op* %o2.0.ph645, i64 1, i32 0
  %49 = load %struct.op** %48, align 8, !tbaa !15
  %tobool184 = icmp eq %struct.op* %49, null
  br i1 %tobool184, label %if.end228, label %land.lhs.true185

land.lhs.true185:                                 ; preds = %if.then182
  %op_type186 = getelementptr inbounds %struct.op* %49, i64 0, i32 4
  %50 = load i16* %op_type186, align 2, !tbaa !12
  %cmp188 = icmp eq i16 %50, 0
  br i1 %cmp188, label %if.then190, label %if.end228

if.then190:                                       ; preds = %land.lhs.true185
  %51 = getelementptr inbounds %struct.op* %49, i64 1, i32 0
  %52 = load %struct.op** %51, align 8, !tbaa !15
  %tobool192 = icmp eq %struct.op* %52, null
  br i1 %tobool192, label %if.end228, label %for.cond194

for.cond194:                                      ; preds = %if.then190, %for.cond194
  %gvop.0 = phi %struct.op* [ %53, %for.cond194 ], [ %52, %if.then190 ]
  %op_sibling195 = getelementptr inbounds %struct.op* %gvop.0, i64 0, i32 1
  %53 = load %struct.op** %op_sibling195, align 8, !tbaa !17
  %tobool196 = icmp eq %struct.op* %53, null
  br i1 %tobool196, label %land.lhs.true202, label %for.cond194

land.lhs.true202:                                 ; preds = %for.cond194
  %op_private203 = getelementptr inbounds %struct.op* %gvop.0, i64 0, i32 7
  %54 = load i8* %op_private203, align 1, !tbaa !11
  %tobool206 = icmp slt i8 %54, 0
  br i1 %tobool206, label %land.lhs.true207, label %if.end228

land.lhs.true207:                                 ; preds = %land.lhs.true202
  %55 = getelementptr inbounds %struct.op* %gvop.0, i64 1, i32 0
  %56 = load %struct.op** %55, align 8, !tbaa !15
  %tobool209 = icmp eq %struct.op* %56, null
  br i1 %tobool209, label %if.end228, label %land.lhs.true210

land.lhs.true210:                                 ; preds = %land.lhs.true207
  %op_type211 = getelementptr inbounds %struct.op* %56, i64 0, i32 4
  %57 = load i16* %op_type211, align 2, !tbaa !12
  %cmp213 = icmp eq i16 %57, 7
  br i1 %cmp213, label %if.then215, label %if.end228

if.then215:                                       ; preds = %land.lhs.true210
  %op_sv217 = getelementptr inbounds %struct.op* %56, i64 1
  %58 = bitcast %struct.op* %op_sv217 to %struct.sv**
  %59 = load %struct.sv** %58, align 8, !tbaa !18
  %60 = bitcast %struct.sv* %59 to %struct.gv*
  %op_sibling218 = getelementptr inbounds %struct.op* %o2.0.ph645, i64 0, i32 1
  %61 = load %struct.op** %op_sibling218, align 8, !tbaa !17
  %call219 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0), i64 0) #4
  call void @Perl_op_free(%struct.op* %o2.0.ph645)
  call void @Perl_gv_fullname4(%struct.sv* %call219, %struct.gv* %60, i8* getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0), i8 signext 0) #4
  %call.i539 = call i8* @Perl_safesysmalloc(i64 48) #4
  call void @llvm.memset.p0i8.i64(i8* %call.i539, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i540 = getelementptr inbounds i8* %call.i539, i64 32
  %62 = bitcast i8* %op_type.i540 to i16*
  store i16 5, i16* %62, align 2, !tbaa !71
  %63 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i541 = getelementptr inbounds i8* %call.i539, i64 16
  %64 = bitcast i8* %op_ppaddr.i541 to %struct.op* ()**
  store %struct.op* ()* %63, %struct.op* ()** %64, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i539, i64 40
  %65 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %call219, %struct.sv** %65, align 8, !tbaa !18
  %66 = bitcast i8* %call.i539 to %struct.op*
  %op_next.i = bitcast i8* %call.i539 to %struct.op**
  store %struct.op* %66, %struct.op** %op_next.i, align 8, !tbaa !73
  %67 = getelementptr inbounds i8* %call.i539, i64 36
  store i8 0, i8* %67, align 1, !tbaa !74
  %68 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i = and i64 %68, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i542, label %if.then.i

if.then.i:                                        ; preds = %if.then215
  %call3.i = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %66) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i542

if.end.i542:                                      ; preds = %if.then.i, %if.then215
  %69 = phi i64 [ %68, %if.then215 ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %69, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i542
  %call8.i = call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i543 = getelementptr inbounds i8* %call.i539, i64 24
  %70 = bitcast i8* %op_targ.i543 to i64*
  store i64 %conv9.i, i64* %70, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i542
  %71 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %71, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %71, i64 5
  %72 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %72, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  call void @Perl_op_free(%struct.op* %66) #4
  %73 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %73) #4
  br label %Perl_newSVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %74 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i = call %struct.op* %74(%struct.op* %66) #4
  br label %Perl_newSVOP.exit

Perl_newSVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  %op_sibling221 = getelementptr inbounds %struct.op* %prev.0.ph652, i64 0, i32 1
  store %struct.op* %cond.i, %struct.op** %op_sibling221, align 8, !tbaa !17
  %op_sibling222 = getelementptr inbounds %struct.op* %cond.i, i64 0, i32 1
  store %struct.op* %61, %struct.op** %op_sibling222, align 8, !tbaa !17
  br label %if.end228

if.end228:                                        ; preds = %sw.bb159, %land.lhs.true207, %if.then190, %if.then182, %if.then172, %land.lhs.true185, %land.lhs.true202, %land.lhs.true210, %Perl_newSVOP.exit
  %o2.1 = phi %struct.op* [ %o2.0.ph645, %if.then172 ], [ %cond.i, %Perl_newSVOP.exit ], [ %o2.0.ph645, %land.lhs.true210 ], [ %o2.0.ph645, %land.lhs.true207 ], [ %o2.0.ph645, %land.lhs.true202 ], [ %o2.0.ph645, %if.then190 ], [ %o2.0.ph645, %land.lhs.true185 ], [ %o2.0.ph645, %if.then182 ], [ %o2.0.ph645, %sw.bb159 ]
  %call229 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %o2.1) #4
  br label %if.end374

sw.bb231:                                         ; preds = %if.then128
  %incdec.ptr232 = getelementptr inbounds i8* %proto.1603, i64 1
  %inc233 = add nsw i64 %arg.0.ph636, 1
  br label %again.preheader

again.preheader:                                  ; preds = %sw.bb231, %sw.epilog
  %prev.0.ph653 = phi %struct.op* [ %prev.0.ph654, %sw.epilog ], [ %prev.0.ph652, %sw.bb231 ]
  %optional.0.ph548580 = phi i32 [ %optional.0.ph548581, %sw.epilog ], [ %optional.0.ph548611, %sw.bb231 ]
  %contextclass.1.ph = phi i64 [ %contextclass.3, %sw.epilog ], [ %contextclass.0.ph622, %sw.bb231 ]
  %e.1.ph = phi i8* [ %e.3, %sw.epilog ], [ %e.0.ph629, %sw.bb231 ]
  %arg.1.ph = phi i64 [ %arg.3, %sw.epilog ], [ %inc233, %sw.bb231 ]
  %proto.2.ph = phi i8* [ %proto.4, %sw.epilog ], [ %incdec.ptr232, %sw.bb231 ]
  %o2.2.ph = phi %struct.op* [ %o2.4, %sw.epilog ], [ %o2.0.ph645, %sw.bb231 ]
  br label %again

again:                                            ; preds = %again.preheader, %if.then240
  %contextclass.1 = phi i64 [ %inc237, %if.then240 ], [ %contextclass.1.ph, %again.preheader ]
  %e.1 = phi i8* [ %call241, %if.then240 ], [ %e.1.ph, %again.preheader ]
  %proto.2 = phi i8* [ %incdec.ptr234, %if.then240 ], [ %proto.2.ph, %again.preheader ]
  %incdec.ptr234 = getelementptr inbounds i8* %proto.2, i64 1
  %75 = load i8* %proto.2, align 1, !tbaa !5
  %conv235 = sext i8 %75 to i32
  switch i32 %conv235, label %oops [
    i32 91, label %sw.bb236
    i32 93, label %sw.bb250
    i32 42, label %sw.bb264
    i32 38, label %sw.bb276
    i32 36, label %sw.bb288
    i32 64, label %sw.bb320
    i32 37, label %sw.bb337
  ]

sw.bb236:                                         ; preds = %again
  %inc237 = add nsw i64 %contextclass.1, 1
  %cmp238 = icmp eq i64 %contextclass.1, 0
  br i1 %cmp238, label %if.then240, label %oops

if.then240:                                       ; preds = %sw.bb236
  %call241 = call i8* @strchr(i8* %incdec.ptr234, i32 93) #4
  %tobool242 = icmp eq i8* %call241, null
  %cmp244 = icmp eq i8* %call241, %incdec.ptr234
  %or.cond538 = or i1 %tobool242, %cmp244
  br i1 %or.cond538, label %oops, label %again

sw.bb250:                                         ; preds = %again
  %tobool251 = icmp eq i64 %contextclass.1, 0
  br i1 %tobool251, label %oops, label %if.then252

if.then252:                                       ; preds = %sw.bb250
  %76 = load i8* %incdec.ptr234, align 1, !tbaa !5
  store i8 0, i8* %incdec.ptr234, align 1, !tbaa !5
  br label %while.cond253

while.cond253:                                    ; preds = %while.cond253, %if.then252
  %p.0 = phi i8* [ %incdec.ptr234, %if.then252 ], [ %incdec.ptr254, %while.cond253 ]
  %incdec.ptr254 = getelementptr inbounds i8* %p.0, i64 -1
  %77 = load i8* %incdec.ptr254, align 1, !tbaa !5
  %cmp256 = icmp eq i8 %77, 91
  br i1 %cmp256, label %while.end, label %while.cond253

while.end:                                        ; preds = %while.cond253
  %call259 = call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([10 x i8]* @.str129, i64 0, i64 0), i8* %incdec.ptr254) #4
  %call260 = call i32 (%struct.gv*, ...)* bitcast (i32 (...)* @gv_ename to i32 (%struct.gv*, ...)*)(%struct.gv* %namegv.0) #4
  %call261 = call i32 (i64, i8*, i32, %struct.op*, ...)* bitcast (i32 (...)* @bad_type to i32 (i64, i8*, i32, %struct.op*, ...)*)(i64 %arg.1.ph, i8* %call259, i32 %call260, %struct.op* %o2.2.ph) #4
  store i8 %76, i8* %incdec.ptr234, align 1, !tbaa !5
  br label %sw.epilog

sw.bb264:                                         ; preds = %again
  %op_type265 = getelementptr inbounds %struct.op* %o2.2.ph, i64 0, i32 4
  %78 = load i16* %op_type265, align 2, !tbaa !12
  %cmp267 = icmp eq i16 %78, 14
  br i1 %cmp267, label %wrapref, label %if.end270

if.end270:                                        ; preds = %sw.bb264
  %tobool271 = icmp eq i64 %contextclass.1, 0
  br i1 %tobool271, label %if.then272, label %sw.epilog

if.then272:                                       ; preds = %if.end270
  %call273 = call i32 (%struct.gv*, ...)* bitcast (i32 (...)* @gv_ename to i32 (%struct.gv*, ...)*)(%struct.gv* %namegv.0) #4
  %call274 = call i32 (i64, i8*, i32, %struct.op*, ...)* bitcast (i32 (...)* @bad_type to i32 (i64, i8*, i32, %struct.op*, ...)*)(i64 %arg.1.ph, i8* getelementptr inbounds ([7 x i8]* @.str130, i64 0, i64 0), i32 %call273, %struct.op* %o2.2.ph) #4
  br label %sw.epilog

sw.bb276:                                         ; preds = %again
  %op_type277 = getelementptr inbounds %struct.op* %o2.2.ph, i64 0, i32 4
  %79 = load i16* %op_type277, align 2, !tbaa !12
  %cmp279 = icmp eq i16 %79, 166
  br i1 %cmp279, label %wrapref, label %if.end282

if.end282:                                        ; preds = %sw.bb276
  %tobool283 = icmp eq i64 %contextclass.1, 0
  br i1 %tobool283, label %if.then284, label %sw.epilog

if.then284:                                       ; preds = %if.end282
  %call285 = call i32 (%struct.gv*, ...)* bitcast (i32 (...)* @gv_ename to i32 (%struct.gv*, ...)*)(%struct.gv* %namegv.0) #4
  %call286 = call i32 (i64, i8*, i32, %struct.op*, ...)* bitcast (i32 (...)* @bad_type to i32 (i64, i8*, i32, %struct.op*, ...)*)(i64 %arg.1.ph, i8* getelementptr inbounds ([17 x i8]* @.str131, i64 0, i64 0), i32 %call285, %struct.op* %o2.2.ph) #4
  br label %sw.epilog

sw.bb288:                                         ; preds = %again
  %op_type289 = getelementptr inbounds %struct.op* %o2.2.ph, i64 0, i32 4
  %80 = load i16* %op_type289, align 2, !tbaa !12
  switch i16 %80, label %if.end314 [
    i16 15, label %wrapref
    i16 9, label %wrapref
    i16 135, label %wrapref
    i16 127, label %wrapref
    i16 348, label %wrapref
  ]

if.end314:                                        ; preds = %sw.bb288
  %tobool315 = icmp eq i64 %contextclass.1, 0
  br i1 %tobool315, label %if.then316, label %sw.epilog

if.then316:                                       ; preds = %if.end314
  %call317 = call i32 (%struct.gv*, ...)* bitcast (i32 (...)* @gv_ename to i32 (%struct.gv*, ...)*)(%struct.gv* %namegv.0) #4
  %call318 = call i32 (i64, i8*, i32, %struct.op*, ...)* bitcast (i32 (...)* @bad_type to i32 (i64, i8*, i32, %struct.op*, ...)*)(i64 %arg.1.ph, i8* getelementptr inbounds ([7 x i8]* @.str132, i64 0, i64 0), i32 %call317, %struct.op* %o2.2.ph) #4
  br label %sw.epilog

sw.bb320:                                         ; preds = %again
  %op_type321 = getelementptr inbounds %struct.op* %o2.2.ph, i64 0, i32 4
  %81 = load i16* %op_type321, align 2, !tbaa !12
  switch i16 %81, label %if.end331 [
    i16 125, label %wrapref
    i16 10, label %wrapref
  ]

if.end331:                                        ; preds = %sw.bb320
  %tobool332 = icmp eq i64 %contextclass.1, 0
  br i1 %tobool332, label %if.then333, label %sw.epilog

if.then333:                                       ; preds = %if.end331
  %call334 = call i32 (%struct.gv*, ...)* bitcast (i32 (...)* @gv_ename to i32 (%struct.gv*, ...)*)(%struct.gv* %namegv.0) #4
  %call335 = call i32 (i64, i8*, i32, %struct.op*, ...)* bitcast (i32 (...)* @bad_type to i32 (i64, i8*, i32, %struct.op*, ...)*)(i64 %arg.1.ph, i8* getelementptr inbounds ([6 x i8]* @.str99, i64 0, i64 0), i32 %call334, %struct.op* %o2.2.ph) #4
  br label %sw.epilog

sw.bb337:                                         ; preds = %again
  %op_type338 = getelementptr inbounds %struct.op* %o2.2.ph, i64 0, i32 4
  %82 = load i16* %op_type338, align 2, !tbaa !12
  switch i16 %82, label %if.end348 [
    i16 134, label %wrapref
    i16 11, label %wrapref
  ]

if.end348:                                        ; preds = %sw.bb337
  %tobool349 = icmp eq i64 %contextclass.1, 0
  br i1 %tobool349, label %if.then350, label %sw.epilog

if.then350:                                       ; preds = %if.end348
  %call351 = call i32 (%struct.gv*, ...)* bitcast (i32 (...)* @gv_ename to i32 (%struct.gv*, ...)*)(%struct.gv* %namegv.0) #4
  %call352 = call i32 (i64, i8*, i32, %struct.op*, ...)* bitcast (i32 (...)* @bad_type to i32 (i64, i8*, i32, %struct.op*, ...)*)(i64 %arg.1.ph, i8* getelementptr inbounds ([5 x i8]* @.str101, i64 0, i64 0), i32 %call351, %struct.op* %o2.2.ph) #4
  br label %sw.epilog

wrapref:                                          ; preds = %sw.bb337, %sw.bb337, %sw.bb320, %sw.bb320, %sw.bb288, %sw.bb288, %sw.bb288, %sw.bb288, %sw.bb288, %sw.bb159, %sw.bb276, %sw.bb264
  %prev.0.ph655 = phi %struct.op* [ %prev.0.ph653, %sw.bb337 ], [ %prev.0.ph653, %sw.bb320 ], [ %prev.0.ph653, %sw.bb288 ], [ %prev.0.ph653, %sw.bb276 ], [ %prev.0.ph653, %sw.bb264 ], [ %prev.0.ph652, %sw.bb159 ], [ %prev.0.ph653, %sw.bb288 ], [ %prev.0.ph653, %sw.bb288 ], [ %prev.0.ph653, %sw.bb288 ], [ %prev.0.ph653, %sw.bb288 ], [ %prev.0.ph653, %sw.bb320 ], [ %prev.0.ph653, %sw.bb337 ]
  %optional.0.ph548582 = phi i32 [ %optional.0.ph548580, %sw.bb337 ], [ %optional.0.ph548580, %sw.bb320 ], [ %optional.0.ph548580, %sw.bb288 ], [ %optional.0.ph548580, %sw.bb276 ], [ %optional.0.ph548580, %sw.bb264 ], [ %optional.0.ph548611, %sw.bb159 ], [ %optional.0.ph548580, %sw.bb288 ], [ %optional.0.ph548580, %sw.bb288 ], [ %optional.0.ph548580, %sw.bb288 ], [ %optional.0.ph548580, %sw.bb288 ], [ %optional.0.ph548580, %sw.bb320 ], [ %optional.0.ph548580, %sw.bb337 ]
  %contextclass.2 = phi i64 [ %contextclass.1, %sw.bb337 ], [ %contextclass.1, %sw.bb320 ], [ %contextclass.1, %sw.bb288 ], [ %contextclass.1, %sw.bb276 ], [ %contextclass.1, %sw.bb264 ], [ %contextclass.0.ph622, %sw.bb159 ], [ %contextclass.1, %sw.bb288 ], [ %contextclass.1, %sw.bb288 ], [ %contextclass.1, %sw.bb288 ], [ %contextclass.1, %sw.bb288 ], [ %contextclass.1, %sw.bb320 ], [ %contextclass.1, %sw.bb337 ]
  %e.2 = phi i8* [ %e.1, %sw.bb337 ], [ %e.1, %sw.bb320 ], [ %e.1, %sw.bb288 ], [ %e.1, %sw.bb276 ], [ %e.1, %sw.bb264 ], [ %e.0.ph629, %sw.bb159 ], [ %e.1, %sw.bb288 ], [ %e.1, %sw.bb288 ], [ %e.1, %sw.bb288 ], [ %e.1, %sw.bb288 ], [ %e.1, %sw.bb320 ], [ %e.1, %sw.bb337 ]
  %arg.2 = phi i64 [ %arg.1.ph, %sw.bb337 ], [ %arg.1.ph, %sw.bb320 ], [ %arg.1.ph, %sw.bb288 ], [ %arg.1.ph, %sw.bb276 ], [ %arg.1.ph, %sw.bb264 ], [ %inc161, %sw.bb159 ], [ %arg.1.ph, %sw.bb288 ], [ %arg.1.ph, %sw.bb288 ], [ %arg.1.ph, %sw.bb288 ], [ %arg.1.ph, %sw.bb288 ], [ %arg.1.ph, %sw.bb320 ], [ %arg.1.ph, %sw.bb337 ]
  %proto.3 = phi i8* [ %incdec.ptr234, %sw.bb337 ], [ %incdec.ptr234, %sw.bb320 ], [ %incdec.ptr234, %sw.bb288 ], [ %incdec.ptr234, %sw.bb276 ], [ %incdec.ptr234, %sw.bb264 ], [ %incdec.ptr160, %sw.bb159 ], [ %incdec.ptr234, %sw.bb288 ], [ %incdec.ptr234, %sw.bb288 ], [ %incdec.ptr234, %sw.bb288 ], [ %incdec.ptr234, %sw.bb288 ], [ %incdec.ptr234, %sw.bb320 ], [ %incdec.ptr234, %sw.bb337 ]
  %o2.3 = phi %struct.op* [ %o2.2.ph, %sw.bb337 ], [ %o2.2.ph, %sw.bb320 ], [ %o2.2.ph, %sw.bb288 ], [ %o2.2.ph, %sw.bb276 ], [ %o2.2.ph, %sw.bb264 ], [ %o2.0.ph645, %sw.bb159 ], [ %o2.2.ph, %sw.bb288 ], [ %o2.2.ph, %sw.bb288 ], [ %o2.2.ph, %sw.bb288 ], [ %o2.2.ph, %sw.bb288 ], [ %o2.2.ph, %sw.bb320 ], [ %o2.2.ph, %sw.bb337 ]
  %op_sibling354 = getelementptr inbounds %struct.op* %o2.3, i64 0, i32 1
  %83 = load %struct.op** %op_sibling354, align 8, !tbaa !17
  store %struct.op* null, %struct.op** %op_sibling354, align 8, !tbaa !17
  %call356 = call %struct.op* @Perl_newUNOP(i64 20, i64 0, %struct.op* %o2.3)
  %op_sibling357 = getelementptr inbounds %struct.op* %call356, i64 0, i32 1
  store %struct.op* %83, %struct.op** %op_sibling357, align 8, !tbaa !17
  %op_sibling358 = getelementptr inbounds %struct.op* %prev.0.ph655, i64 0, i32 1
  store %struct.op* %call356, %struct.op** %op_sibling358, align 8, !tbaa !17
  %tobool359 = icmp ne i64 %contextclass.2, 0
  %tobool361 = icmp ne i8* %e.2, null
  %or.cond = and i1 %tobool359, %tobool361
  %add.ptr = getelementptr inbounds i8* %e.2, i64 1
  %add.ptr.proto.3 = select i1 %or.cond, i8* %add.ptr, i8* %proto.3
  %.contextclass.2 = select i1 %or.cond, i64 0, i64 %contextclass.2
  br label %sw.epilog

sw.epilog:                                        ; preds = %wrapref, %if.end270, %if.end282, %if.end314, %if.end331, %if.end348, %if.then350, %if.then333, %if.then316, %if.then284, %if.then272, %while.end
  %prev.0.ph654 = phi %struct.op* [ %prev.0.ph653, %if.end348 ], [ %prev.0.ph653, %if.then350 ], [ %prev.0.ph653, %if.end331 ], [ %prev.0.ph653, %if.then333 ], [ %prev.0.ph653, %if.end314 ], [ %prev.0.ph653, %if.then316 ], [ %prev.0.ph653, %if.end282 ], [ %prev.0.ph653, %if.then284 ], [ %prev.0.ph653, %if.end270 ], [ %prev.0.ph653, %if.then272 ], [ %prev.0.ph653, %while.end ], [ %prev.0.ph655, %wrapref ]
  %optional.0.ph548581 = phi i32 [ %optional.0.ph548580, %if.end348 ], [ %optional.0.ph548580, %if.then350 ], [ %optional.0.ph548580, %if.end331 ], [ %optional.0.ph548580, %if.then333 ], [ %optional.0.ph548580, %if.end314 ], [ %optional.0.ph548580, %if.then316 ], [ %optional.0.ph548580, %if.end282 ], [ %optional.0.ph548580, %if.then284 ], [ %optional.0.ph548580, %if.end270 ], [ %optional.0.ph548580, %if.then272 ], [ %optional.0.ph548580, %while.end ], [ %optional.0.ph548582, %wrapref ]
  %contextclass.3 = phi i64 [ %contextclass.1, %if.end348 ], [ 0, %if.then350 ], [ %contextclass.1, %if.end331 ], [ 0, %if.then333 ], [ %contextclass.1, %if.end314 ], [ 0, %if.then316 ], [ %contextclass.1, %if.end282 ], [ 0, %if.then284 ], [ %contextclass.1, %if.end270 ], [ 0, %if.then272 ], [ 0, %while.end ], [ %.contextclass.2, %wrapref ]
  %e.3 = phi i8* [ %e.1, %if.end348 ], [ %e.1, %if.then350 ], [ %e.1, %if.end331 ], [ %e.1, %if.then333 ], [ %e.1, %if.end314 ], [ %e.1, %if.then316 ], [ %e.1, %if.end282 ], [ %e.1, %if.then284 ], [ %e.1, %if.end270 ], [ %e.1, %if.then272 ], [ %e.1, %while.end ], [ %e.2, %wrapref ]
  %arg.3 = phi i64 [ %arg.1.ph, %if.end348 ], [ %arg.1.ph, %if.then350 ], [ %arg.1.ph, %if.end331 ], [ %arg.1.ph, %if.then333 ], [ %arg.1.ph, %if.end314 ], [ %arg.1.ph, %if.then316 ], [ %arg.1.ph, %if.end282 ], [ %arg.1.ph, %if.then284 ], [ %arg.1.ph, %if.end270 ], [ %arg.1.ph, %if.then272 ], [ %arg.1.ph, %while.end ], [ %arg.2, %wrapref ]
  %proto.4 = phi i8* [ %incdec.ptr234, %if.end348 ], [ %incdec.ptr234, %if.then350 ], [ %incdec.ptr234, %if.end331 ], [ %incdec.ptr234, %if.then333 ], [ %incdec.ptr234, %if.end314 ], [ %incdec.ptr234, %if.then316 ], [ %incdec.ptr234, %if.end282 ], [ %incdec.ptr234, %if.then284 ], [ %incdec.ptr234, %if.end270 ], [ %incdec.ptr234, %if.then272 ], [ %incdec.ptr234, %while.end ], [ %add.ptr.proto.3, %wrapref ]
  %o2.4 = phi %struct.op* [ %o2.2.ph, %if.end348 ], [ %o2.2.ph, %if.then350 ], [ %o2.2.ph, %if.end331 ], [ %o2.2.ph, %if.then333 ], [ %o2.2.ph, %if.end314 ], [ %o2.2.ph, %if.then316 ], [ %o2.2.ph, %if.end282 ], [ %o2.2.ph, %if.then284 ], [ %o2.2.ph, %if.end270 ], [ %o2.2.ph, %if.then272 ], [ %o2.2.ph, %while.end ], [ %call356, %wrapref ]
  %tobool364 = icmp eq i64 %contextclass.3, 0
  br i1 %tobool364, label %if.end374, label %again.preheader

sw.bb367:                                         ; preds = %if.then128
  %incdec.ptr368 = getelementptr inbounds i8* %proto.1603, i64 1
  br label %while.body

oops:                                             ; preds = %if.then240, %again, %sw.bb236, %if.then128, %sw.bb250
  %optional.0.ph548579 = phi i32 [ %optional.0.ph548580, %sw.bb250 ], [ %optional.0.ph548611, %if.then128 ], [ %optional.0.ph548580, %sw.bb236 ], [ %optional.0.ph548580, %again ], [ %optional.0.ph548580, %if.then240 ]
  %contextclass.4 = phi i64 [ 0, %sw.bb250 ], [ %contextclass.0.ph622, %if.then128 ], [ %inc237, %if.then240 ], [ %contextclass.1, %again ], [ %inc237, %sw.bb236 ]
  %e.4 = phi i8* [ %e.1, %sw.bb250 ], [ %e.0.ph629, %if.then128 ], [ %call241, %if.then240 ], [ %e.1, %again ], [ %e.1, %sw.bb236 ]
  %arg.4 = phi i64 [ %arg.1.ph, %sw.bb250 ], [ %arg.0.ph636, %if.then128 ], [ %arg.1.ph, %sw.bb236 ], [ %arg.1.ph, %again ], [ %arg.1.ph, %if.then240 ]
  %proto.5 = phi i8* [ %incdec.ptr234, %sw.bb250 ], [ %proto.1603, %if.then128 ], [ %incdec.ptr234, %sw.bb236 ], [ %incdec.ptr234, %again ], [ %incdec.ptr234, %if.then240 ]
  %o2.5 = phi %struct.op* [ %o2.2.ph, %sw.bb250 ], [ %o2.0.ph645, %if.then128 ], [ %o2.2.ph, %sw.bb236 ], [ %o2.2.ph, %again ], [ %o2.2.ph, %if.then240 ]
  %call370 = call i32 (%struct.gv*, ...)* bitcast (i32 (...)* @gv_ename to i32 (%struct.gv*, ...)*)(%struct.gv* %namegv.0) #4
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str133, i64 0, i64 0), i32 %call370, %struct.cv* %cv.0) #4
  br label %if.end374

if.else372:                                       ; preds = %while.body
  %call373 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %o2.0.ph645) #4
  br label %if.end374

if.end374:                                        ; preds = %sw.bb140, %sw.bb140, %sw.epilog, %sw.bb134, %sw.bb137, %if.end228, %oops, %if.then152, %if.else372
  %optional.0.ph548578 = phi i32 [ %optional.0.ph548579, %oops ], [ %optional.0.ph548581, %sw.epilog ], [ %optional.0.ph548611, %if.end228 ], [ %optional.0.ph548611, %if.then152 ], [ %optional.0.ph548611, %sw.bb140 ], [ %optional.0.ph548611, %sw.bb137 ], [ %optional.0.ph548611, %sw.bb134 ], [ %optional.0.ph548611, %if.else372 ], [ %optional.0.ph548611, %sw.bb140 ]
  %contextclass.5 = phi i64 [ %contextclass.4, %oops ], [ 0, %sw.epilog ], [ %contextclass.0.ph622, %if.end228 ], [ %contextclass.0.ph622, %if.then152 ], [ %contextclass.0.ph622, %sw.bb140 ], [ %contextclass.0.ph622, %sw.bb137 ], [ %contextclass.0.ph622, %sw.bb134 ], [ %contextclass.0.ph622, %if.else372 ], [ %contextclass.0.ph622, %sw.bb140 ]
  %e.5 = phi i8* [ %e.4, %oops ], [ %e.3, %sw.epilog ], [ %e.0.ph629, %if.end228 ], [ %e.0.ph629, %if.then152 ], [ %e.0.ph629, %sw.bb140 ], [ %e.0.ph629, %sw.bb137 ], [ %e.0.ph629, %sw.bb134 ], [ %e.0.ph629, %if.else372 ], [ %e.0.ph629, %sw.bb140 ]
  %arg.5 = phi i64 [ %arg.4, %oops ], [ %arg.3, %sw.epilog ], [ %inc161, %if.end228 ], [ %inc142, %if.then152 ], [ %inc142, %sw.bb140 ], [ %inc139, %sw.bb137 ], [ %inc, %sw.bb134 ], [ %arg.0.ph636, %if.else372 ], [ %inc142, %sw.bb140 ]
  %proto.6 = phi i8* [ %proto.5, %oops ], [ %proto.4, %sw.epilog ], [ %incdec.ptr160, %if.end228 ], [ %incdec.ptr141, %if.then152 ], [ %incdec.ptr141, %sw.bb140 ], [ %proto.1603, %sw.bb137 ], [ %incdec.ptr135, %sw.bb134 ], [ null, %if.else372 ], [ %incdec.ptr141, %sw.bb140 ]
  %o2.6 = phi %struct.op* [ %o2.5, %oops ], [ %o2.4, %sw.epilog ], [ %o2.1, %if.end228 ], [ %o2.0.ph645, %if.then152 ], [ %o2.0.ph645, %sw.bb140 ], [ %o2.0.ph645, %sw.bb137 ], [ %o2.0.ph645, %sw.bb134 ], [ %o2.0.ph645, %if.else372 ], [ %o2.0.ph645, %sw.bb140 ]
  %call375 = call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i32, ...)*)(%struct.op* %o2.6, i32 166) #4
  %op_sibling376 = getelementptr inbounds %struct.op* %o2.6, i64 0, i32 1
  %84 = load %struct.op** %op_sibling376, align 8, !tbaa !17
  %cmp125 = icmp eq %struct.op* %84, %cvop.0
  %tobool127602610 = icmp ne i8* %proto.6, null
  br i1 %cmp125, label %while.end377, label %while.body.lr.ph.lr.ph

while.end377:                                     ; preds = %if.end374, %while.cond.preheader
  %optional.0.ph548.lcssa577 = phi i32 [ 0, %while.cond.preheader ], [ %optional.0.ph548578, %if.end374 ]
  %tobool127.lcssa = phi i1 [ %tobool127602610621, %while.cond.preheader ], [ %tobool127602610, %if.end374 ]
  %proto.1.lcssa = phi i8* [ %proto.0, %while.cond.preheader ], [ %proto.6, %if.end374 ]
  %tobool127.not = xor i1 %tobool127.lcssa, true
  %tobool380 = icmp ne i32 %optional.0.ph548.lcssa577, 0
  %or.cond401 = or i1 %tobool380, %tobool127.not
  br i1 %or.cond401, label %return, label %land.lhs.true381

land.lhs.true381:                                 ; preds = %while.end377
  %85 = load i8* %proto.1.lcssa, align 1, !tbaa !5
  switch i8 %85, label %if.then396 [
    i8 0, label %return
    i8 64, label %return
    i8 37, label %return
    i8 59, label %return
  ]

if.then396:                                       ; preds = %land.lhs.true381
  %call397 = call i32 (%struct.gv*, ...)* bitcast (i32 (...)* @gv_ename to i32 (%struct.gv*, ...)*)(%struct.gv* %namegv.0) #4
  %call398 = call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @too_few_arguments to i32 (%struct.op*, i32, ...)*)(%struct.op* %o, i32 %call397) #4
  %conv399 = sext i32 %call398 to i64
  %86 = inttoptr i64 %conv399 to %struct.op*
  br label %return

return:                                           ; preds = %while.end377, %land.lhs.true381, %land.lhs.true381, %land.lhs.true381, %land.lhs.true381, %if.then396, %sw.bb
  %retval.0 = phi %struct.op* [ %44, %sw.bb ], [ %86, %if.then396 ], [ %o, %land.lhs.true381 ], [ %o, %land.lhs.true381 ], [ %o, %land.lhs.true381 ], [ %o, %land.lhs.true381 ], [ %o, %while.end377 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newSLICEOP(i64 %flags, %struct.op* %subscript, %struct.op* %listval) #0 {
entry:
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @force_list to i32 (%struct.op*, ...)*)(%struct.op* %subscript) #4
  %call1 = tail call i32 (i32, ...)* bitcast (i32 (...)* @list to i32 (i32, ...)*)(i32 %call) #4
  %conv = sext i32 %call1 to i64
  %0 = inttoptr i64 %conv to %struct.op*
  %call2 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @force_list to i32 (%struct.op*, ...)*)(%struct.op* %listval) #4
  %call3 = tail call i32 (i32, ...)* bitcast (i32 (...)* @list to i32 (i32, ...)*)(i32 %call2) #4
  %conv4 = sext i32 %call3 to i64
  %1 = inttoptr i64 %conv4 to %struct.op*
  %call5 = tail call %struct.op* @Perl_newBINOP(i64 142, i64 %flags, %struct.op* %0, %struct.op* %1)
  ret %struct.op* %call5
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newASSIGNOP(i64 %flags, %struct.op* %left, i64 %optype, %struct.op* %right) #0 {
entry:
  %first.addr.i = alloca %struct.op*, align 8
  %other.addr.i = alloca %struct.op*, align 8
  %tobool = icmp eq i64 %optype, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %optype.off = add i64 %optype, -163
  %0 = icmp ult i64 %optype.off, 2
  %call = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %left) #4
  %call3 = call i32 (i32, i64, ...)* bitcast (i32 (...)* @mod to i32 (i32, i64, ...)*)(i32 %call, i64 %optype) #4
  %conv = sext i32 %call3 to i64
  %1 = inttoptr i64 %conv to %struct.op*
  %call4 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %right) #4
  %conv5 = sext i32 %call4 to i64
  %2 = inttoptr i64 %conv5 to %struct.op*
  br i1 %0, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %call6 = call %struct.op* @Perl_newUNOP(i64 36, i64 0, %struct.op* %2)
  %3 = bitcast %struct.op** %first.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %3) #4
  %4 = bitcast %struct.op** %other.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %4) #4
  store %struct.op* %1, %struct.op** %first.addr.i, align 8, !tbaa !6
  store %struct.op* %call6, %struct.op** %other.addr.i, align 8, !tbaa !6
  %call.i = call i32 (i64, i64, %struct.op**, %struct.op**, ...)* bitcast (i32 (...)* @new_logop to i32 (i64, i64, %struct.op**, %struct.op**, ...)*)(i64 %optype, i64 0, %struct.op** %first.addr.i, %struct.op** %other.addr.i) #4
  %conv.i = sext i32 %call.i to i64
  %5 = inttoptr i64 %conv.i to %struct.op*
  call void @llvm.lifetime.end(i64 8, i8* %3) #4
  call void @llvm.lifetime.end(i64 8, i8* %4) #4
  br label %return

if.else:                                          ; preds = %if.then
  %call13 = call %struct.op* @Perl_newBINOP(i64 %optype, i64 64, %struct.op* %1, %struct.op* %2)
  br label %return

if.end:                                           ; preds = %entry
  %call14 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list_assignment to i32 (%struct.op*, ...)*)(%struct.op* %left) #4
  %tobool15 = icmp eq i32 %call14, 0
  br i1 %tobool15, label %if.end296, label %if.then16

if.then16:                                        ; preds = %if.end
  store i64 0, i64* @PL_modcount, align 8, !tbaa !1
  store %struct.op* %right, %struct.op** @PL_eval_start, align 8, !tbaa !6
  %call17 = call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i32, ...)*)(%struct.op* %left, i32 37) #4
  %conv18 = sext i32 %call17 to i64
  %6 = inttoptr i64 %conv18 to %struct.op*
  %7 = load %struct.op** @PL_eval_start, align 8, !tbaa !6
  %tobool19 = icmp eq %struct.op* %7, null
  br i1 %tobool19, label %if.else21, label %if.then20

if.then20:                                        ; preds = %if.then16
  store %struct.op* null, %struct.op** @PL_eval_start, align 8, !tbaa !6
  %op_type = getelementptr inbounds %struct.op* %6, i64 0, i32 4
  %8 = load i16* %op_type, align 2, !tbaa !12
  %9 = and i16 %8, -2
  %switch = icmp eq i16 %9, 10
  br i1 %switch, label %land.lhs.true, label %if.end42

if.else21:                                        ; preds = %if.then16
  call void @Perl_op_free(%struct.op* %6)
  call void @Perl_op_free(%struct.op* %right)
  br label %return

land.lhs.true:                                    ; preds = %if.then20
  %op_type31 = getelementptr inbounds %struct.op* %right, i64 0, i32 4
  %10 = load i16* %op_type31, align 2, !tbaa !12
  %cmp33 = icmp eq i16 %10, 1
  br i1 %cmp33, label %land.lhs.true35, label %if.end42

land.lhs.true35:                                  ; preds = %land.lhs.true
  %op_private = getelementptr inbounds %struct.op* %6, i64 0, i32 7
  %11 = load i8* %op_private, align 1, !tbaa !11
  %tobool37 = icmp slt i8 %11, 0
  br i1 %tobool37, label %if.then38, label %if.end42

if.then38:                                        ; preds = %land.lhs.true35
  call void @Perl_op_free(%struct.op* %right)
  %op_flags = getelementptr inbounds %struct.op* %6, i64 0, i32 6
  %12 = load i8* %op_flags, align 1, !tbaa !14
  %and40 = and i8 %12, 111
  store i8 %and40, i8* %op_flags, align 1, !tbaa !14
  br label %return

if.end42:                                         ; preds = %if.then20, %land.lhs.true35, %land.lhs.true
  %call43 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @force_list to i32 (%struct.op*, ...)*)(%struct.op* %6) #4
  %call44 = call i32 (i32, ...)* bitcast (i32 (...)* @list to i32 (i32, ...)*)(i32 %call43) #4
  %conv45 = sext i32 %call44 to i64
  %13 = inttoptr i64 %conv45 to %struct.op*
  %call46 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @force_list to i32 (%struct.op*, ...)*)(%struct.op* %right) #4
  %call47 = call i32 (i32, ...)* bitcast (i32 (...)* @list to i32 (i32, ...)*)(i32 %call46) #4
  %conv48 = sext i32 %call47 to i64
  %14 = inttoptr i64 %conv48 to %struct.op*
  %call49 = call %struct.op* @Perl_newBINOP(i64 37, i64 %flags, %struct.op* %14, %struct.op* %13)
  %shr421 = lshr i64 %flags, 8
  %conv50 = trunc i64 %shr421 to i8
  %op_private51 = getelementptr inbounds %struct.op* %call49, i64 0, i32 7
  store i8 %conv50, i8* %op_private51, align 1, !tbaa !11
  %15 = inttoptr i64 %conv45 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop* %15, i64 0, i32 8
  %curop.0428 = load %struct.op** %op_first, align 8
  %tobool52429 = icmp eq %struct.op* %curop.0428, null
  br i1 %tobool52429, label %for.end, label %for.body

for.body:                                         ; preds = %if.end42, %for.inc
  %curop.0430 = phi %struct.op* [ %curop.0, %for.inc ], [ %curop.0428, %if.end42 ]
  %op_type53 = getelementptr inbounds %struct.op* %curop.0430, i64 0, i32 4
  %16 = load i16* %op_type53, align 2, !tbaa !12
  %cmp55 = icmp eq i16 %16, 134
  br i1 %cmp55, label %land.lhs.true57, label %for.inc

land.lhs.true57:                                  ; preds = %for.body
  %17 = getelementptr inbounds %struct.op* %curop.0430, i64 1, i32 0
  %18 = load %struct.op** %17, align 8, !tbaa !15
  %op_type59 = getelementptr inbounds %struct.op* %18, i64 0, i32 4
  %19 = load i16* %op_type59, align 2, !tbaa !12
  %cmp61 = icmp eq i16 %19, 7
  br i1 %cmp61, label %for.inc, label %if.then63

if.then63:                                        ; preds = %land.lhs.true57
  %or66 = or i8 %conv50, 32
  store i8 %or66, i8* %op_private51, align 1, !tbaa !11
  br label %for.end

for.inc:                                          ; preds = %land.lhs.true57, %for.body
  %op_sibling = getelementptr inbounds %struct.op* %curop.0430, i64 0, i32 1
  %curop.0 = load %struct.op** %op_sibling, align 8
  %tobool52 = icmp eq %struct.op* %curop.0, null
  br i1 %tobool52, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %if.end42, %if.then63
  %op_private69 = getelementptr inbounds %struct.op* %6, i64 0, i32 7
  %20 = load i8* %op_private69, align 1, !tbaa !11
  %tobool72 = icmp slt i8 %20, 0
  br i1 %tobool72, label %if.end222, label %if.then73

if.then73:                                        ; preds = %for.end
  %21 = load i32* @PL_generation, align 4, !tbaa !92
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* @PL_generation, align 4, !tbaa !92
  %op_next = getelementptr inbounds %struct.op* %call49, i64 0, i32 0
  %22 = load %struct.op** %op_next, align 8, !tbaa !42
  %tobool74 = icmp eq %struct.op* %22, null
  br i1 %tobool74, label %cond.false, label %for.cond78.preheader

cond.false:                                       ; preds = %if.then73
  %call76 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %call49) #4
  %conv77 = sext i32 %call76 to i64
  %23 = inttoptr i64 %conv77 to %struct.op*
  br label %for.cond78.preheader

for.cond78.preheader:                             ; preds = %if.then73, %cond.false
  %curop.1.ph = phi %struct.op* [ %23, %cond.false ], [ %22, %if.then73 ]
  %cmp79424 = icmp eq %struct.op* %curop.1.ph, %call49
  br i1 %cmp79424, label %if.end222, label %for.body81

for.body81:                                       ; preds = %for.cond78.preheader, %for.cond78.backedge
  %lastop.0426 = phi %struct.op* [ %curop.1425, %for.cond78.backedge ], [ %call49, %for.cond78.preheader ]
  %curop.1425 = phi %struct.op* [ %curop.1.be, %for.cond78.backedge ], [ %curop.1.ph, %for.cond78.preheader ]
  %op_type82 = getelementptr inbounds %struct.op* %curop.1425, i64 0, i32 4
  %24 = load i16* %op_type82, align 2, !tbaa !12
  %idxprom = zext i16 %24 to i64
  %arrayidx = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %idxprom
  %25 = load i64* %arrayidx, align 8, !tbaa !1
  %and83 = and i64 %25, 64
  %tobool84 = icmp eq i64 %and83, 0
  br i1 %tobool84, label %if.end202, label %if.then85

if.then85:                                        ; preds = %for.body81
  switch i16 %24, label %if.then216 [
    i16 7, label %if.then90
    i16 9, label %if.then122
    i16 10, label %if.then122
    i16 11, label %if.then122
    i16 12, label %if.then122
    i16 13, label %if.then177
    i16 15, label %if.then165
    i16 125, label %if.then165
    i16 134, label %if.then165
    i16 14, label %if.then165
  ]

if.then90:                                        ; preds = %if.then85
  %op_sv = getelementptr inbounds %struct.op* %curop.1425, i64 1
  %26 = bitcast %struct.op* %op_sv to %struct.sv**
  %27 = load %struct.sv** %26, align 8, !tbaa !18
  %28 = bitcast %struct.sv* %27 to %struct.gv*
  %29 = load %struct.gv** @PL_defgv, align 8, !tbaa !6
  %cmp91 = icmp eq %struct.gv* %28, %29
  br i1 %cmp91, label %if.then216, label %lor.lhs.false93

lor.lhs.false93:                                  ; preds = %if.then90
  %sv_any = bitcast %struct.sv* %27 to %struct.xpvgv**
  %30 = load %struct.xpvgv** %sv_any, align 8, !tbaa !60
  %31 = getelementptr inbounds %struct.xpvgv* %30, i64 0, i32 1
  %32 = load i64* %31, align 8, !tbaa !37
  %conv94 = trunc i64 %32 to i32
  %33 = load i32* @PL_generation, align 4, !tbaa !92
  %cmp95 = icmp eq i32 %conv94, %33
  br i1 %cmp95, label %if.then216, label %if.end98

if.end98:                                         ; preds = %lor.lhs.false93
  %conv99 = sext i32 %33 to i64
  store i64 %conv99, i64* %31, align 8, !tbaa !37
  br label %if.end202

if.then122:                                       ; preds = %if.then85, %if.then85, %if.then85, %if.then85
  %34 = load %struct.av** @PL_comppad_name, align 8
  %op_targ = getelementptr inbounds %struct.op* %curop.1425, i64 0, i32 3
  %35 = load i64* %op_targ, align 8, !tbaa !13
  %sv_any123 = getelementptr inbounds %struct.av* %34, i64 0, i32 0
  %36 = load %struct.xpvav** %sv_any123, align 8, !tbaa !161
  %xav_array = getelementptr inbounds %struct.xpvav* %36, i64 0, i32 0
  %37 = load i8** %xav_array, align 8, !tbaa !163
  %38 = bitcast i8* %37 to %struct.sv**
  %arrayidx124 = getelementptr inbounds %struct.sv** %38, i64 %35
  %39 = load %struct.sv** %arrayidx124, align 8, !tbaa !6
  %sv_any125 = getelementptr inbounds %struct.sv* %39, i64 0, i32 0
  %40 = load i8** %sv_any125, align 8, !tbaa !36
  %xpv_cur126 = getelementptr inbounds i8* %40, i64 8
  %41 = bitcast i8* %xpv_cur126 to i64*
  %42 = load i64* %41, align 8, !tbaa !37
  %conv127 = trunc i64 %42 to i32
  %43 = load i32* @PL_generation, align 4, !tbaa !92
  %cmp128 = icmp eq i32 %conv127, %43
  br i1 %cmp128, label %if.then216, label %if.end131

if.end131:                                        ; preds = %if.then122
  %conv132 = sext i32 %43 to i64
  store i64 %conv132, i64* %41, align 8, !tbaa !37
  br label %if.end202

if.then165:                                       ; preds = %if.then85, %if.then85, %if.then85, %if.then85
  %op_type166 = getelementptr inbounds %struct.op* %lastop.0426, i64 0, i32 4
  %44 = load i16* %op_type166, align 2, !tbaa !12
  %cmp168 = icmp eq i16 %44, 7
  br i1 %cmp168, label %if.end202, label %if.then216

if.then177:                                       ; preds = %if.then85
  %op_pmreplroot = getelementptr inbounds %struct.op* %curop.1425, i64 1, i32 2
  %45 = load %struct.op* ()** %op_pmreplroot, align 8
  %tobool178 = icmp eq %struct.op* ()* %45, null
  br i1 %tobool178, label %if.end202, label %if.then179

if.then179:                                       ; preds = %if.then177
  %46 = bitcast %struct.op* ()* %45 to %struct.gv*
  %47 = load %struct.gv** @PL_defgv, align 8, !tbaa !6
  %cmp182 = icmp eq %struct.gv* %46, %47
  br i1 %cmp182, label %if.then216, label %lor.lhs.false184

lor.lhs.false184:                                 ; preds = %if.then179
  %sv_any185 = bitcast %struct.op* ()* %45 to %struct.xpvgv**
  %48 = load %struct.xpvgv** %sv_any185, align 8, !tbaa !60
  %49 = getelementptr inbounds %struct.xpvgv* %48, i64 0, i32 1
  %50 = load i64* %49, align 8, !tbaa !37
  %conv187 = trunc i64 %50 to i32
  %51 = load i32* @PL_generation, align 4, !tbaa !92
  %cmp188 = icmp eq i32 %conv187, %51
  br i1 %cmp188, label %if.then216, label %if.end191

if.end191:                                        ; preds = %lor.lhs.false184
  %conv192 = sext i32 %51 to i64
  store i64 %conv192, i64* %49, align 8, !tbaa !37
  br label %if.end202

if.end202:                                        ; preds = %if.then165, %if.then177, %for.body81, %if.end98, %if.end191, %if.end131
  %op_next204 = getelementptr inbounds %struct.op* %curop.1425, i64 0, i32 0
  %52 = load %struct.op** %op_next204, align 8, !tbaa !42
  %tobool205 = icmp eq %struct.op* %52, null
  br i1 %tobool205, label %cond.false208, label %for.cond78.backedge

for.cond78.backedge:                              ; preds = %if.end202, %cond.false208
  %curop.1.be = phi %struct.op* [ %53, %cond.false208 ], [ %52, %if.end202 ]
  %cmp79 = icmp eq %struct.op* %curop.1.be, %call49
  br i1 %cmp79, label %if.end222, label %for.body81

cond.false208:                                    ; preds = %if.end202
  %call209 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %curop.1425) #4
  %conv210 = sext i32 %call209 to i64
  %53 = inttoptr i64 %conv210 to %struct.op*
  br label %for.cond78.backedge

if.then216:                                       ; preds = %lor.lhs.false93, %if.then90, %if.then122, %lor.lhs.false184, %if.then179, %if.then165, %if.then85
  %54 = load i8* %op_private51, align 1, !tbaa !11
  %or219 = or i8 %54, 64
  store i8 %or219, i8* %op_private51, align 1, !tbaa !11
  br label %if.end222

if.end222:                                        ; preds = %for.cond78.backedge, %for.cond78.preheader, %if.then216, %for.end
  %tobool223 = icmp eq %struct.op* %right, null
  br i1 %tobool223, label %return, label %land.lhs.true224

land.lhs.true224:                                 ; preds = %if.end222
  %op_type225 = getelementptr inbounds %struct.op* %right, i64 0, i32 4
  %55 = load i16* %op_type225, align 2, !tbaa !12
  %cmp227 = icmp eq i16 %55, 139
  br i1 %cmp227, label %if.then229, label %return

if.then229:                                       ; preds = %land.lhs.true224
  %56 = getelementptr inbounds %struct.op* %right, i64 1, i32 0
  %57 = load %struct.op** %56, align 8, !tbaa !45
  %tobool231 = icmp eq %struct.op* %57, null
  br i1 %tobool231, label %return, label %land.lhs.true232

land.lhs.true232:                                 ; preds = %if.then229
  %op_type233 = getelementptr inbounds %struct.op* %57, i64 0, i32 4
  %58 = load i16* %op_type233, align 2, !tbaa !12
  %cmp235 = icmp eq i16 %58, 13
  br i1 %cmp235, label %if.then237, label %return

if.then237:                                       ; preds = %land.lhs.true232
  %59 = load i16* %op_type, align 2, !tbaa !12
  %cmp240 = icmp eq i16 %59, 125
  br i1 %cmp240, label %land.lhs.true242, label %if.else276

land.lhs.true242:                                 ; preds = %if.then237
  %60 = load i8* %op_private69, align 1, !tbaa !11
  %tobool246 = icmp slt i8 %60, 0
  br i1 %tobool246, label %if.else276, label %land.lhs.true247

land.lhs.true247:                                 ; preds = %land.lhs.true242
  %61 = load i8* %op_private51, align 1, !tbaa !11
  %and250 = and i8 %61, 64
  %tobool251 = icmp eq i8 %and250, 0
  br i1 %tobool251, label %if.then252, label %if.else276

if.then252:                                       ; preds = %land.lhs.true247
  %62 = inttoptr i64 %conv18 to %struct.unop*
  %op_first253 = getelementptr inbounds %struct.unop* %62, i64 0, i32 8
  %63 = load %struct.op** %op_first253, align 8, !tbaa !15
  %op_type254 = getelementptr inbounds %struct.op* %63, i64 0, i32 4
  %64 = load i16* %op_type254, align 2, !tbaa !12
  %cmp256 = icmp eq i16 %64, 7
  br i1 %cmp256, label %land.lhs.true258, label %return

land.lhs.true258:                                 ; preds = %if.then252
  %op_pmreplroot259 = getelementptr inbounds %struct.op* %57, i64 1, i32 2
  %65 = load %struct.op* ()** %op_pmreplroot259, align 8
  %tobool260 = icmp eq %struct.op* ()* %65, null
  br i1 %tobool260, label %if.then261, label %return

if.then261:                                       ; preds = %land.lhs.true258
  %op_sv262 = getelementptr inbounds %struct.op* %63, i64 1
  %66 = bitcast %struct.op* %op_sv262 to %struct.sv**
  %67 = load %struct.sv** %66, align 8, !tbaa !18
  %.c = bitcast %struct.sv* %67 to %struct.op* ()*
  store %struct.op* ()* %.c, %struct.op* ()** %op_pmreplroot259, align 8, !tbaa !31
  %68 = getelementptr inbounds %struct.op* %op_sv262, i64 0, i32 0
  store %struct.op* null, %struct.op** %68, align 8, !tbaa !18
  %op_pmflags = getelementptr inbounds %struct.op* %57, i64 2, i32 1
  %69 = bitcast %struct.op** %op_pmflags to i64*
  %70 = load i64* %69, align 8, !tbaa !88
  %or265 = or i64 %70, 2
  %or265.c = inttoptr i64 %or265 to %struct.op*
  store %struct.op* %or265.c, %struct.op** %op_pmflags, align 8, !tbaa !88
  %71 = getelementptr inbounds %struct.op* %call49, i64 1, i32 0
  %72 = load %struct.op** %71, align 8, !tbaa !15
  %73 = getelementptr inbounds %struct.op* %72, i64 1, i32 0
  %74 = load %struct.op** %73, align 8, !tbaa !15
  %op_sibling268 = getelementptr inbounds %struct.op* %74, i64 0, i32 1
  store %struct.op* null, %struct.op** %op_sibling268, align 8, !tbaa !17
  %op_next269 = getelementptr inbounds %struct.op* %74, i64 0, i32 0
  %75 = load %struct.op** %op_next269, align 8, !tbaa !42
  %op_next270 = getelementptr inbounds %struct.op* %right, i64 0, i32 0
  store %struct.op* %75, %struct.op** %op_next270, align 8, !tbaa !42
  call void @Perl_op_free(%struct.op* %call49)
  %op_flags271 = getelementptr inbounds %struct.op* %right, i64 0, i32 6
  %76 = load i8* %op_flags271, align 1, !tbaa !14
  %and273 = and i8 %76, -4
  store i8 %and273, i8* %op_flags271, align 1, !tbaa !14
  br label %return

if.else276:                                       ; preds = %land.lhs.true247, %land.lhs.true242, %if.then237
  %77 = load i64* @PL_modcount, align 8, !tbaa !1
  %cmp277 = icmp slt i64 %77, 1073741823
  br i1 %cmp277, label %land.lhs.true279, label %return

land.lhs.true279:                                 ; preds = %if.else276
  %78 = getelementptr inbounds %struct.op* %right, i64 1, i32 1
  %79 = load %struct.op** %78, align 8, !tbaa !70
  %op_type280 = getelementptr inbounds %struct.op* %79, i64 0, i32 4
  %80 = load i16* %op_type280, align 2, !tbaa !12
  %cmp282 = icmp eq i16 %80, 5
  br i1 %cmp282, label %if.then284, label %return

if.then284:                                       ; preds = %land.lhs.true279
  %op_sv286 = getelementptr inbounds %struct.op* %79, i64 1
  %81 = bitcast %struct.op* %op_sv286 to %struct.sv**
  %82 = load %struct.sv** %81, align 8, !tbaa !18
  %sv_any287 = getelementptr inbounds %struct.sv* %82, i64 0, i32 0
  %83 = load i8** %sv_any287, align 8, !tbaa !36
  %xiv_iv = getelementptr inbounds i8* %83, i64 24
  %84 = bitcast i8* %xiv_iv to i64*
  %85 = load i64* %84, align 8, !tbaa !53
  %cmp288 = icmp eq i64 %85, 0
  br i1 %cmp288, label %if.then290, label %return

if.then290:                                       ; preds = %if.then284
  %add = add nsw i64 %77, 1
  call void @Perl_sv_setiv(%struct.sv* %82, i64 %add) #4
  br label %return

if.end296:                                        ; preds = %if.end
  %tobool297 = icmp eq %struct.op* %right, null
  br i1 %tobool297, label %if.then298, label %if.end300

if.then298:                                       ; preds = %if.end296
  %call.i422 = call i8* @Perl_safesysmalloc(i64 40) #4
  %86 = bitcast i8* %call.i422 to %struct.op*
  call void @llvm.memset.p0i8.i64(i8* %call.i422, i8 0, i64 40, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i422, i64 32
  %87 = bitcast i8* %op_type.i to i16*
  store i16 43, i16* %87, align 2, !tbaa !12
  %88 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 43), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i422, i64 16
  %89 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %88, %struct.op* ()** %89, align 8, !tbaa !41
  %90 = getelementptr inbounds i8* %call.i422, i64 36
  store i8 0, i8* %90, align 1, !tbaa !14
  %op_next.i = bitcast i8* %call.i422 to %struct.op**
  store %struct.op* %86, %struct.op** %op_next.i, align 8, !tbaa !42
  %91 = getelementptr inbounds i8* %call.i422, i64 37
  store i8 0, i8* %91, align 1, !tbaa !11
  %92 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 43), align 8, !tbaa !1
  %and.i = and i64 %92, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %if.then298
  %call4.i = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %86) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 43), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then298
  %93 = phi i64 [ %92, %if.then298 ], [ %.pre.i, %if.then.i ]
  %and6.i = and i64 %93, 8
  %tobool7.i = icmp eq i64 %and6.i, 0
  br i1 %tobool7.i, label %if.end11.i, label %if.then8.i

if.then8.i:                                       ; preds = %if.end.i
  %call9.i = call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 43, i32 512) #4
  %conv10.i = sext i32 %call9.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i422, i64 24
  %94 = bitcast i8* %op_targ.i to i64*
  store i64 %conv10.i, i64* %94, align 8, !tbaa !13
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then8.i, %if.end.i
  %95 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12.i = icmp eq i8* %95, null
  br i1 %tobool12.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end11.i
  %arrayidx13.i = getelementptr inbounds i8* %95, i64 43
  %96 = load i8* %arrayidx13.i, align 1, !tbaa !5
  %tobool15.i = icmp eq i8 %96, 0
  br i1 %tobool15.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  call void @Perl_op_free(%struct.op* %86) #4
  %97 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 43), align 8, !tbaa !6
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %97) #4
  br label %if.end300

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end11.i
  %98 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 43), align 8, !tbaa !6
  %call18.i = call %struct.op* %98(%struct.op* %86) #4
  br label %if.end300

if.end300:                                        ; preds = %cond.false.i, %cond.true.i, %if.end296
  %right.addr.0 = phi %struct.op* [ %right, %if.end296 ], [ null, %cond.true.i ], [ %call18.i, %cond.false.i ]
  %op_type301 = getelementptr inbounds %struct.op* %right.addr.0, i64 0, i32 4
  %99 = load i16* %op_type301, align 2, !tbaa !12
  %cmp303 = icmp eq i16 %99, 26
  br i1 %cmp303, label %if.then305, label %if.else316

if.then305:                                       ; preds = %if.end300
  %op_flags306 = getelementptr inbounds %struct.op* %right.addr.0, i64 0, i32 6
  %100 = load i8* %op_flags306, align 1, !tbaa !14
  %or308 = or i8 %100, 64
  store i8 %or308, i8* %op_flags306, align 1, !tbaa !14
  %call310 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %left) #4
  %call311 = call i32 (i32, i32, ...)* bitcast (i32 (...)* @mod to i32 (i32, i32, ...)*)(i32 %call310, i32 36) #4
  %conv312 = sext i32 %call311 to i64
  %101 = inttoptr i64 %conv312 to %struct.op*
  %call313 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %right.addr.0) #4
  %conv314 = sext i32 %call313 to i64
  %102 = inttoptr i64 %conv314 to %struct.op*
  %call315 = call %struct.op* @Perl_newBINOP(i64 0, i64 %flags, %struct.op* %101, %struct.op* %102)
  br label %return

if.else316:                                       ; preds = %if.end300
  store %struct.op* %right.addr.0, %struct.op** @PL_eval_start, align 8, !tbaa !6
  %call317 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %right.addr.0) #4
  %conv318 = sext i32 %call317 to i64
  %103 = inttoptr i64 %conv318 to %struct.op*
  %call319 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %left) #4
  %call320 = call i32 (i32, i32, ...)* bitcast (i32 (...)* @mod to i32 (i32, i32, ...)*)(i32 %call319, i32 36) #4
  %conv321 = sext i32 %call320 to i64
  %104 = inttoptr i64 %conv321 to %struct.op*
  %call322 = call %struct.op* @Perl_newBINOP(i64 36, i64 %flags, %struct.op* %103, %struct.op* %104)
  %105 = load %struct.op** @PL_eval_start, align 8, !tbaa !6
  %tobool323 = icmp eq %struct.op* %105, null
  br i1 %tobool323, label %if.else325, label %if.then324

if.then324:                                       ; preds = %if.else316
  store %struct.op* null, %struct.op** @PL_eval_start, align 8, !tbaa !6
  br label %return

if.else325:                                       ; preds = %if.else316
  call void @Perl_op_free(%struct.op* %call322)
  br label %return

return:                                           ; preds = %land.lhs.true224, %if.then252, %if.then284, %if.then290, %land.lhs.true279, %if.else276, %land.lhs.true232, %if.end222, %if.then229, %land.lhs.true258, %if.then324, %if.else325, %if.then305, %if.then261, %if.then38, %if.else21, %if.else, %if.then2
  %retval.0 = phi %struct.op* [ %5, %if.then2 ], [ %call13, %if.else ], [ %6, %if.then38 ], [ %right, %if.then261 ], [ null, %if.else21 ], [ %call315, %if.then305 ], [ %call322, %if.then324 ], [ null, %if.else325 ], [ %call49, %land.lhs.true258 ], [ %call49, %if.then229 ], [ %call49, %if.end222 ], [ %call49, %land.lhs.true232 ], [ %call49, %if.else276 ], [ %call49, %land.lhs.true279 ], [ %call49, %if.then290 ], [ %call49, %if.then284 ], [ %call49, %if.then252 ], [ %call49, %land.lhs.true224 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newLOGOP(i64 %type, i64 %flags, %struct.op* %first, %struct.op* %other) #0 {
entry:
  %first.addr = alloca %struct.op*, align 8
  %other.addr = alloca %struct.op*, align 8
  store %struct.op* %first, %struct.op** %first.addr, align 8, !tbaa !6
  store %struct.op* %other, %struct.op** %other.addr, align 8, !tbaa !6
  %call = call i32 (i64, i64, %struct.op**, %struct.op**, ...)* bitcast (i32 (...)* @new_logop to i32 (i64, i64, %struct.op**, %struct.op**, ...)*)(i64 %type, i64 %flags, %struct.op** %first.addr, %struct.op** %other.addr) #4
  %conv = sext i32 %call to i64
  %0 = inttoptr i64 %conv to %struct.op*
  ret %struct.op* %0
}

declare i32 @list_assignment(...) #2

declare void @Perl_sv_setiv(%struct.sv*, i64) #2

declare i32 @intro_my(...) #2

declare i32 @new_logop(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newCONDOP(i64 %flags, %struct.op* %first, %struct.op* %trueop, %struct.op* %falseop) #0 {
entry:
  %first.addr.i155 = alloca %struct.op*, align 8
  %other.addr.i156 = alloca %struct.op*, align 8
  %first.addr.i = alloca %struct.op*, align 8
  %other.addr.i = alloca %struct.op*, align 8
  %tobool = icmp eq %struct.op* %falseop, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.op** %first.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #4
  %1 = bitcast %struct.op** %other.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #4
  store %struct.op* %first, %struct.op** %first.addr.i, align 8, !tbaa !6
  store %struct.op* %trueop, %struct.op** %other.addr.i, align 8, !tbaa !6
  %call.i = call i32 (i64, i64, %struct.op**, %struct.op**, ...)* bitcast (i32 (...)* @new_logop to i32 (i64, i64, %struct.op**, %struct.op**, ...)*)(i64 159, i64 0, %struct.op** %first.addr.i, %struct.op** %other.addr.i) #4
  %conv.i = sext i32 %call.i to i64
  %2 = inttoptr i64 %conv.i to %struct.op*
  call void @llvm.lifetime.end(i64 8, i8* %0) #4
  call void @llvm.lifetime.end(i64 8, i8* %1) #4
  br label %return

if.end:                                           ; preds = %entry
  %tobool1 = icmp eq %struct.op* %trueop, null
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %3 = bitcast %struct.op** %first.addr.i155 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %3) #4
  %4 = bitcast %struct.op** %other.addr.i156 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %4) #4
  store %struct.op* %first, %struct.op** %first.addr.i155, align 8, !tbaa !6
  store %struct.op* %falseop, %struct.op** %other.addr.i156, align 8, !tbaa !6
  %call.i157 = call i32 (i64, i64, %struct.op**, %struct.op**, ...)* bitcast (i32 (...)* @new_logop to i32 (i64, i64, %struct.op**, %struct.op**, ...)*)(i64 160, i64 0, %struct.op** %first.addr.i155, %struct.op** %other.addr.i156) #4
  %conv.i158 = sext i32 %call.i157 to i64
  %5 = inttoptr i64 %conv.i158 to %struct.op*
  call void @llvm.lifetime.end(i64 8, i8* %3) #4
  call void @llvm.lifetime.end(i64 8, i8* %4) #4
  br label %return

if.end4:                                          ; preds = %if.end
  %call5 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarboolean to i32 (%struct.op*, ...)*)(%struct.op* %first) #4
  %op_type = getelementptr inbounds %struct.op* %first, i64 0, i32 4
  %6 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %6, 5
  br i1 %cmp, label %if.then7, label %if.end61

if.then7:                                         ; preds = %if.end4
  %op_private = getelementptr inbounds %struct.op* %first, i64 0, i32 7
  %7 = load i8* %op_private, align 1, !tbaa !11
  %8 = and i8 %7, 72
  %9 = icmp eq i8 %8, 72
  br i1 %9, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.then7
  %call15 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @no_bareword_allowed to i32 (%struct.op*, ...)*)(%struct.op* %first) #4
  br label %if.end16

if.end16:                                         ; preds = %if.then7, %if.then14
  %op_sv = getelementptr inbounds %struct.op* %first, i64 1
  %10 = bitcast %struct.op* %op_sv to %struct.sv**
  %11 = load %struct.sv** %10, align 8, !tbaa !18
  %tobool17 = icmp eq %struct.sv* %11, null
  br i1 %tobool17, label %if.else, label %cond.false

cond.false:                                       ; preds = %if.end16
  %sv_flags = getelementptr inbounds %struct.sv* %11, i64 0, i32 2
  %12 = load i64* %sv_flags, align 8, !tbaa !34
  %and19 = and i64 %12, 262144
  %tobool20 = icmp eq i64 %and19, 0
  br i1 %tobool20, label %cond.false35, label %cond.true21

cond.true21:                                      ; preds = %cond.false
  %sv_any = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %13 = load i8** %sv_any, align 8, !tbaa !36
  %14 = bitcast i8* %13 to %struct.xpv*
  store %struct.xpv* %14, %struct.xpv** @PL_Xpv, align 8, !tbaa !6
  %tobool23 = icmp eq i8* %13, null
  br i1 %tobool23, label %if.else, label %land.lhs.true24

land.lhs.true24:                                  ; preds = %cond.true21
  %xpv_cur = getelementptr inbounds i8* %13, i64 8
  %15 = bitcast i8* %xpv_cur to i64*
  %16 = load i64* %15, align 8, !tbaa !37
  %cmp25 = icmp ugt i64 %16, 1
  br i1 %cmp25, label %if.then60, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true24
  %tobool28 = icmp eq i64 %16, 0
  br i1 %tobool28, label %if.else, label %land.lhs.true29

land.lhs.true29:                                  ; preds = %lor.lhs.false
  %xpv_pv = bitcast i8* %13 to i8**
  %17 = load i8** %xpv_pv, align 8, !tbaa !39
  %18 = load i8* %17, align 1, !tbaa !5
  %cmp31 = icmp eq i8 %18, 48
  br i1 %cmp31, label %if.else, label %if.then60

cond.false35:                                     ; preds = %cond.false
  %and38 = and i64 %12, 65536
  %tobool39 = icmp eq i64 %and38, 0
  br i1 %tobool39, label %cond.false45, label %cond.true40

cond.true40:                                      ; preds = %cond.false35
  %sv_any42 = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %19 = load i8** %sv_any42, align 8, !tbaa !36
  %xiv_iv = getelementptr inbounds i8* %19, i64 24
  %20 = bitcast i8* %xiv_iv to i64*
  %21 = load i64* %20, align 8, !tbaa !53
  %cmp43 = icmp eq i64 %21, 0
  br i1 %cmp43, label %if.else, label %if.then60

cond.false45:                                     ; preds = %cond.false35
  %and48 = and i64 %12, 131072
  %tobool49 = icmp eq i64 %and48, 0
  br i1 %tobool49, label %cond.false55, label %cond.true50

cond.true50:                                      ; preds = %cond.false45
  %sv_any52 = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %22 = load i8** %sv_any52, align 8, !tbaa !36
  %xnv_nv = getelementptr inbounds i8* %22, i64 32
  %23 = bitcast i8* %xnv_nv to double*
  %24 = load double* %23, align 8, !tbaa !51
  %cmp53 = fcmp une double %24, 0.000000e+00
  br i1 %cmp53, label %if.then60, label %if.else

cond.false55:                                     ; preds = %cond.false45
  %call57 = call signext i8 @Perl_sv_2bool(%struct.sv* %11) #4
  %tobool59 = icmp eq i8 %call57, 0
  br i1 %tobool59, label %if.else, label %if.then60

if.then60:                                        ; preds = %land.lhs.true29, %cond.true40, %cond.false55, %land.lhs.true24, %cond.true50
  call void @Perl_op_free(%struct.op* %first)
  call void @Perl_op_free(%struct.op* %falseop)
  br label %return

if.else:                                          ; preds = %land.lhs.true29, %lor.lhs.false, %cond.true21, %cond.true40, %cond.false55, %if.end16, %cond.true50
  call void @Perl_op_free(%struct.op* %first)
  call void @Perl_op_free(%struct.op* %trueop)
  br label %return

if.end61:                                         ; preds = %if.end4
  %call62 = call i8* @Perl_safesysmalloc(i64 56) #4
  call void @llvm.memset.p0i8.i64(i8* %call62, i8 0, i64 56, i32 1, i1 false)
  %op_type63 = getelementptr inbounds i8* %call62, i64 32
  %25 = bitcast i8* %op_type63 to i16*
  store i16 162, i16* %25, align 2, !tbaa !108
  %26 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 162), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds i8* %call62, i64 16
  %27 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %26, %struct.op* ()** %27, align 8, !tbaa !110
  %op_first = getelementptr inbounds i8* %call62, i64 40
  %28 = bitcast i8* %op_first to %struct.op**
  store %struct.op* %first, %struct.op** %28, align 8, !tbaa !111
  %or = or i64 %flags, 4
  %conv64 = trunc i64 %or to i8
  %29 = getelementptr inbounds i8* %call62, i64 36
  store i8 %conv64, i8* %29, align 1, !tbaa !112
  %shr154 = lshr i64 %flags, 8
  %or65 = or i64 %shr154, 1
  %conv66 = trunc i64 %or65 to i8
  %30 = getelementptr inbounds i8* %call62, i64 37
  store i8 %conv66, i8* %30, align 1, !tbaa !113
  %op_next = getelementptr inbounds %struct.op* %trueop, i64 0, i32 0
  %31 = load %struct.op** %op_next, align 8, !tbaa !42
  %tobool68 = icmp eq %struct.op* %31, null
  br i1 %tobool68, label %cond.false71, label %cond.end

cond.false71:                                     ; preds = %if.end61
  %call72 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %trueop) #4
  %conv73 = sext i32 %call72 to i64
  %32 = inttoptr i64 %conv73 to %struct.op*
  br label %cond.end

cond.end:                                         ; preds = %if.end61, %cond.false71
  %cond = phi %struct.op* [ %32, %cond.false71 ], [ %31, %if.end61 ]
  %op_other = getelementptr inbounds i8* %call62, i64 48
  %33 = bitcast i8* %op_other to %struct.op**
  store %struct.op* %cond, %struct.op** %33, align 8, !tbaa !114
  %op_next74 = getelementptr inbounds %struct.op* %falseop, i64 0, i32 0
  %34 = load %struct.op** %op_next74, align 8, !tbaa !42
  %tobool75 = icmp eq %struct.op* %34, null
  br i1 %tobool75, label %cond.false78, label %cond.end81

cond.false78:                                     ; preds = %cond.end
  %call79 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %falseop) #4
  %conv80 = sext i32 %call79 to i64
  %35 = inttoptr i64 %conv80 to %struct.op*
  br label %cond.end81

cond.end81:                                       ; preds = %cond.end, %cond.false78
  %cond82 = phi %struct.op* [ %35, %cond.false78 ], [ %34, %cond.end ]
  %op_next83 = bitcast i8* %call62 to %struct.op**
  store %struct.op* %cond82, %struct.op** %op_next83, align 8, !tbaa !115
  %36 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool84 = icmp eq i8* %36, null
  br i1 %tobool84, label %cond.false89, label %land.lhs.true85

land.lhs.true85:                                  ; preds = %cond.end81
  %arrayidx = getelementptr inbounds i8* %36, i64 162
  %37 = load i8* %arrayidx, align 1, !tbaa !5
  %tobool87 = icmp eq i8 %37, 0
  br i1 %tobool87, label %cond.false89, label %cond.true88

cond.true88:                                      ; preds = %land.lhs.true85
  %38 = bitcast i8* %call62 to %struct.op*
  call void @Perl_op_free(%struct.op* %38)
  %39 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 162), align 8, !tbaa !6
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %39) #4
  br label %cond.end91

cond.false89:                                     ; preds = %land.lhs.true85, %cond.end81
  %40 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 162), align 8, !tbaa !6
  %41 = bitcast i8* %call62 to %struct.op*
  %call90 = call %struct.op* %40(%struct.op* %41) #4
  br label %cond.end91

cond.end91:                                       ; preds = %cond.false89, %cond.true88
  %op_next93 = getelementptr inbounds %struct.op* %first, i64 0, i32 0
  %42 = load %struct.op** %op_next93, align 8, !tbaa !42
  %tobool94 = icmp eq %struct.op* %42, null
  br i1 %tobool94, label %cond.false97, label %cond.end100

cond.false97:                                     ; preds = %cond.end91
  %call98 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %first) #4
  %conv99 = sext i32 %call98 to i64
  %43 = inttoptr i64 %conv99 to %struct.op*
  br label %cond.end100

cond.end100:                                      ; preds = %cond.end91, %cond.false97
  %cond101 = phi %struct.op* [ %43, %cond.false97 ], [ %42, %cond.end91 ]
  %44 = bitcast i8* %call62 to %struct.op*
  store %struct.op* %44, %struct.op** %op_next93, align 8, !tbaa !42
  %op_sibling = getelementptr inbounds %struct.op* %first, i64 0, i32 1
  store %struct.op* %trueop, %struct.op** %op_sibling, align 8, !tbaa !17
  %op_sibling103 = getelementptr inbounds %struct.op* %trueop, i64 0, i32 1
  store %struct.op* %falseop, %struct.op** %op_sibling103, align 8, !tbaa !17
  %call104 = call %struct.op* @Perl_newUNOP(i64 0, i64 0, %struct.op* %44)
  store %struct.op* %call104, %struct.op** %op_next74, align 8, !tbaa !42
  store %struct.op* %call104, %struct.op** %op_next, align 8, !tbaa !42
  %op_next107 = getelementptr inbounds %struct.op* %call104, i64 0, i32 0
  store %struct.op* %cond101, %struct.op** %op_next107, align 8, !tbaa !42
  br label %return

return:                                           ; preds = %cond.end100, %if.else, %if.then60, %if.then2, %if.then
  %retval.0 = phi %struct.op* [ %trueop, %if.then60 ], [ %falseop, %if.else ], [ %call104, %cond.end100 ], [ %5, %if.then2 ], [ %2, %if.then ]
  ret %struct.op* %retval.0
}

declare i32 @scalarboolean(...) #2

declare signext i8 @Perl_sv_2bool(%struct.sv*) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newRANGE(i64 %flags, %struct.op* %left, %struct.op* %right) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 56) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 56, i32 1, i1 false)
  %op_type = getelementptr inbounds i8* %call, i64 32
  %0 = bitcast i8* %op_type to i16*
  store i16 156, i16* %0, align 2, !tbaa !108
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 156), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %2 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %1, %struct.op* ()** %2, align 8, !tbaa !110
  %op_first = getelementptr inbounds i8* %call, i64 40
  %3 = bitcast i8* %op_first to %struct.op**
  store %struct.op* %left, %struct.op** %3, align 8, !tbaa !111
  %4 = getelementptr inbounds i8* %call, i64 36
  store i8 4, i8* %4, align 1, !tbaa !112
  %op_next = getelementptr inbounds %struct.op* %left, i64 0, i32 0
  %5 = load %struct.op** %op_next, align 8, !tbaa !42
  %tobool = icmp eq %struct.op* %5, null
  br i1 %tobool, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  %call2 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %left) #4
  %conv = sext i32 %call2 to i64
  %6 = inttoptr i64 %conv to %struct.op*
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.false
  %cond = phi %struct.op* [ %6, %cond.false ], [ %5, %entry ]
  %op_next3 = getelementptr inbounds %struct.op* %right, i64 0, i32 0
  %7 = load %struct.op** %op_next3, align 8, !tbaa !42
  %tobool4 = icmp eq %struct.op* %7, null
  br i1 %tobool4, label %cond.false7, label %cond.end10

cond.false7:                                      ; preds = %cond.end
  %call8 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %right) #4
  %conv9 = sext i32 %call8 to i64
  %8 = inttoptr i64 %conv9 to %struct.op*
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end, %cond.false7
  %cond11 = phi %struct.op* [ %8, %cond.false7 ], [ %7, %cond.end ]
  %op_other = getelementptr inbounds i8* %call, i64 48
  %9 = bitcast i8* %op_other to %struct.op**
  store %struct.op* %cond11, %struct.op** %9, align 8, !tbaa !114
  %shr84 = lshr i64 %flags, 8
  %or = or i64 %shr84, 1
  %conv12 = trunc i64 %or to i8
  %10 = getelementptr inbounds i8* %call, i64 37
  store i8 %conv12, i8* %10, align 1, !tbaa !113
  %op_sibling = getelementptr inbounds %struct.op* %left, i64 0, i32 1
  store %struct.op* %right, %struct.op** %op_sibling, align 8, !tbaa !17
  %11 = bitcast i8* %call to %struct.op*
  %op_next13 = bitcast i8* %call to %struct.op**
  store %struct.op* %11, %struct.op** %op_next13, align 8, !tbaa !115
  %call14 = tail call %struct.op* @Perl_newUNOP(i64 157, i64 %flags, %struct.op* %11)
  %call15 = tail call %struct.op* @Perl_newUNOP(i64 158, i64 0, %struct.op* %call14)
  %call16 = tail call %struct.op* @Perl_newUNOP(i64 0, i64 0, %struct.op* %call15)
  %call17 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %call15) #4
  store %struct.op* %cond, %struct.op** %op_next13, align 8, !tbaa !115
  store %struct.op* %call14, %struct.op** %op_next, align 8, !tbaa !42
  store %struct.op* %call15, %struct.op** %op_next3, align 8, !tbaa !42
  %call21 = tail call i32 (i32, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i32, i32, ...)*)(i32 156, i32 1024) #4
  %conv22 = sext i32 %call21 to i64
  %op_targ = getelementptr inbounds i8* %call, i64 24
  %12 = bitcast i8* %op_targ to i64*
  store i64 %conv22, i64* %12, align 8, !tbaa !165
  %13 = load %struct.sv*** @PL_curpad, align 8, !tbaa !6
  %arrayidx = getelementptr inbounds %struct.sv** %13, i64 %conv22
  %14 = load %struct.sv** %arrayidx, align 8, !tbaa !6
  %call24 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %14, i64 6) #4
  %call25 = tail call i32 (i32, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i32, i32, ...)*)(i32 156, i32 1024) #4
  %conv26 = sext i32 %call25 to i64
  %op_targ27 = getelementptr inbounds %struct.op* %call14, i64 0, i32 3
  store i64 %conv26, i64* %op_targ27, align 8, !tbaa !13
  %15 = load %struct.sv*** @PL_curpad, align 8, !tbaa !6
  %arrayidx29 = getelementptr inbounds %struct.sv** %15, i64 %conv26
  %16 = load %struct.sv** %arrayidx29, align 8, !tbaa !6
  %call30 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %16, i64 6) #4
  %op_type31 = getelementptr inbounds %struct.op* %left, i64 0, i32 4
  %17 = load i16* %op_type31, align 2, !tbaa !12
  %cmp = icmp eq i16 %17, 5
  %conv35 = select i1 %cmp, i8 64, i8 0
  %op_private36 = getelementptr inbounds %struct.op* %call14, i64 0, i32 7
  store i8 %conv35, i8* %op_private36, align 1, !tbaa !11
  %op_type37 = getelementptr inbounds %struct.op* %right, i64 0, i32 4
  %18 = load i16* %op_type37, align 2, !tbaa !12
  %cmp39 = icmp eq i16 %18, 5
  %conv42 = select i1 %cmp39, i8 64, i8 0
  %op_private43 = getelementptr inbounds %struct.op* %call15, i64 0, i32 7
  store i8 %conv42, i8* %op_private43, align 1, !tbaa !11
  %op_next44 = getelementptr inbounds %struct.op* %call14, i64 0, i32 0
  store %struct.op* %call16, %struct.op** %op_next44, align 8, !tbaa !42
  %19 = load i8* %op_private36, align 1, !tbaa !11
  %tobool46 = icmp eq i8 %19, 0
  %cmp39.not = xor i1 %cmp39, true
  %brmerge = or i1 %tobool46, %cmp39.not
  br i1 %brmerge, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  %call49 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %call16) #4
  br label %if.end

if.end:                                           ; preds = %cond.end10, %if.then
  ret %struct.op* %call16
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newLOOPOP(i64 %flags, i64 %debuggable, %struct.op* %expr, %struct.op* %block) #0 {
entry:
  %expr.addr = alloca %struct.op*, align 8
  %listop = alloca %struct.op*, align 8
  store %struct.op* %expr, %struct.op** %expr.addr, align 8, !tbaa !6
  %tobool = icmp ne %struct.op* %block, null
  br i1 %tobool, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %block, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %tobool1 = icmp slt i8 %0, 0
  br i1 %tobool1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %op_type = getelementptr inbounds %struct.op* %block, i64 0, i32 4
  %1 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %1, 166
  %cmp6 = icmp eq i16 %1, 0
  %.cmp6 = or i1 %cmp, %cmp6
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %2 = phi i1 [ false, %entry ], [ %.cmp6, %land.rhs ], [ false, %land.lhs.true ]
  %tobool8 = icmp eq %struct.op* %expr, null
  br i1 %tobool8, label %if.end140, label %if.then

if.then:                                          ; preds = %land.end
  br i1 %2, label %land.lhs.true10, label %if.end

land.lhs.true10:                                  ; preds = %if.then
  %op_type11 = getelementptr inbounds %struct.op* %expr, i64 0, i32 4
  %3 = load i16* %op_type11, align 2, !tbaa !12
  %cmp13 = icmp eq i16 %3, 5
  br i1 %cmp13, label %land.lhs.true15, label %if.end

land.lhs.true15:                                  ; preds = %land.lhs.true10
  %op_sv = getelementptr inbounds %struct.op* %expr, i64 1
  %4 = bitcast %struct.op* %op_sv to %struct.sv**
  %5 = load %struct.sv** %4, align 8, !tbaa !18
  %tobool16 = icmp eq %struct.sv* %5, null
  br i1 %tobool16, label %return, label %cond.false

cond.false:                                       ; preds = %land.lhs.true15
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i64* %sv_flags, align 8, !tbaa !34
  %and18 = and i64 %6, 262144
  %tobool19 = icmp eq i64 %and18, 0
  br i1 %tobool19, label %cond.false34, label %cond.true20

cond.true20:                                      ; preds = %cond.false
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %7 = load i8** %sv_any, align 8, !tbaa !36
  %8 = bitcast i8* %7 to %struct.xpv*
  store %struct.xpv* %8, %struct.xpv** @PL_Xpv, align 8, !tbaa !6
  %tobool22 = icmp eq i8* %7, null
  br i1 %tobool22, label %return, label %land.lhs.true23

land.lhs.true23:                                  ; preds = %cond.true20
  %xpv_cur = getelementptr inbounds i8* %7, i64 8
  %9 = bitcast i8* %xpv_cur to i64*
  %10 = load i64* %9, align 8, !tbaa !37
  %cmp24 = icmp ugt i64 %10, 1
  br i1 %cmp24, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true23
  %tobool27 = icmp eq i64 %10, 0
  br i1 %tobool27, label %return, label %land.lhs.true28

land.lhs.true28:                                  ; preds = %lor.lhs.false
  %xpv_pv = bitcast i8* %7 to i8**
  %11 = load i8** %xpv_pv, align 8, !tbaa !39
  %12 = load i8* %11, align 1, !tbaa !5
  %cmp30 = icmp eq i8 %12, 48
  br i1 %cmp30, label %return, label %if.end

cond.false34:                                     ; preds = %cond.false
  %and37 = and i64 %6, 65536
  %tobool38 = icmp eq i64 %and37, 0
  br i1 %tobool38, label %cond.false44, label %cond.true39

cond.true39:                                      ; preds = %cond.false34
  %sv_any41 = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %13 = load i8** %sv_any41, align 8, !tbaa !36
  %xiv_iv = getelementptr inbounds i8* %13, i64 24
  %14 = bitcast i8* %xiv_iv to i64*
  %15 = load i64* %14, align 8, !tbaa !53
  %cmp42 = icmp eq i64 %15, 0
  br i1 %cmp42, label %return, label %if.end

cond.false44:                                     ; preds = %cond.false34
  %and47 = and i64 %6, 131072
  %tobool48 = icmp eq i64 %and47, 0
  br i1 %tobool48, label %cond.false54, label %cond.true49

cond.true49:                                      ; preds = %cond.false44
  %sv_any51 = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %16 = load i8** %sv_any51, align 8, !tbaa !36
  %xnv_nv = getelementptr inbounds i8* %16, i64 32
  %17 = bitcast i8* %xnv_nv to double*
  %18 = load double* %17, align 8, !tbaa !51
  %cmp52 = fcmp une double %18, 0.000000e+00
  br i1 %cmp52, label %if.end, label %return

cond.false54:                                     ; preds = %cond.false44
  %call = call signext i8 @Perl_sv_2bool(%struct.sv* %5) #4
  %tobool57 = icmp eq i8 %call, 0
  br i1 %tobool57, label %return, label %cond.false54.if.end_crit_edge

cond.false54.if.end_crit_edge:                    ; preds = %cond.false54
  %.pre238 = load %struct.op** %expr.addr, align 8, !tbaa !6
  br label %if.end

if.end:                                           ; preds = %cond.false54.if.end_crit_edge, %land.lhs.true28, %cond.true39, %land.lhs.true23, %cond.true49, %land.lhs.true10, %if.then
  %19 = phi %struct.op* [ %.pre238, %cond.false54.if.end_crit_edge ], [ %expr, %land.lhs.true28 ], [ %expr, %cond.true39 ], [ %expr, %land.lhs.true23 ], [ %expr, %cond.true49 ], [ %expr, %land.lhs.true10 ], [ %expr, %if.then ]
  %op_type59 = getelementptr inbounds %struct.op* %19, i64 0, i32 4
  %20 = load i16* %op_type59, align 2, !tbaa !12
  switch i16 %20, label %if.else [
    i16 26, label %if.then76
    i16 25, label %if.then76
    i16 0, label %land.lhs.true73
  ]

land.lhs.true73:                                  ; preds = %if.end
  %op_targ = getelementptr inbounds %struct.op* %19, i64 0, i32 3
  %21 = load i64* %op_targ, align 8, !tbaa !13
  %cmp74 = icmp eq i64 %21, 25
  br i1 %cmp74, label %if.then76, label %if.else

if.then76:                                        ; preds = %if.end, %if.end, %land.lhs.true73
  %call77 = call i32 (...)* @newDEFSVOP() #4
  %conv78 = sext i32 %call77 to i64
  %22 = inttoptr i64 %conv78 to %struct.op*
  %23 = load %struct.op** %expr.addr, align 8, !tbaa !6
  %call79 = call %struct.op* @Perl_newASSIGNOP(i64 0, %struct.op* %22, i64 0, %struct.op* %23)
  %call80 = call %struct.op* @Perl_newUNOP(i64 42, i64 0, %struct.op* %call79)
  store %struct.op* %call80, %struct.op** %expr.addr, align 8, !tbaa !6
  br label %if.end140

if.else:                                          ; preds = %if.end, %land.lhs.true73
  %op_flags81 = getelementptr inbounds %struct.op* %19, i64 0, i32 6
  %24 = load i8* %op_flags81, align 1, !tbaa !14
  %and83 = and i8 %24, 4
  %tobool84 = icmp eq i8 %and83, 0
  br i1 %tobool84, label %if.end140, label %if.then85

if.then85:                                        ; preds = %if.else
  %25 = getelementptr inbounds %struct.op* %19, i64 1, i32 0
  %26 = load %struct.op** %25, align 8, !tbaa !15
  %tobool86 = icmp eq %struct.op* %26, null
  br i1 %tobool86, label %cond.end, label %cond.true87

cond.true87:                                      ; preds = %if.then85
  %op_sibling = getelementptr inbounds %struct.op* %26, i64 0, i32 1
  %27 = load %struct.op** %op_sibling, align 8, !tbaa !17
  br label %cond.end

cond.end:                                         ; preds = %if.then85, %cond.true87
  %cond = phi %struct.op* [ %27, %cond.true87 ], [ null, %if.then85 ]
  %conv90 = zext i16 %20 to i32
  switch i32 %conv90, label %if.end140 [
    i32 0, label %sw.bb
    i32 36, label %sw.bb111
  ]

sw.bb:                                            ; preds = %cond.end
  %tobool91 = icmp eq %struct.op* %cond, null
  br i1 %tobool91, label %if.end140, label %land.lhs.true92

land.lhs.true92:                                  ; preds = %sw.bb
  %op_type93 = getelementptr inbounds %struct.op* %cond, i64 0, i32 4
  %28 = load i16* %op_type93, align 2, !tbaa !12
  %cmp95 = icmp eq i16 %28, 26
  br i1 %cmp95, label %land.lhs.true97, label %if.end140

land.lhs.true97:                                  ; preds = %land.lhs.true92
  %op_flags98 = getelementptr inbounds %struct.op* %cond, i64 0, i32 6
  %29 = load i8* %op_flags98, align 1, !tbaa !14
  %and100 = and i8 %29, 64
  %tobool101 = icmp eq i8 %and100, 0
  br i1 %tobool101, label %if.end140, label %land.lhs.true102

land.lhs.true102:                                 ; preds = %land.lhs.true97
  %op_flags103 = getelementptr inbounds %struct.op* %26, i64 0, i32 6
  %30 = load i8* %op_flags103, align 1, !tbaa !14
  %and105 = and i8 %30, 3
  %cmp106 = icmp eq i8 %and105, 2
  br i1 %cmp106, label %if.then108, label %if.end140

if.then108:                                       ; preds = %land.lhs.true102
  %call109 = call %struct.op* @Perl_newUNOP(i64 42, i64 0, %struct.op* %19)
  store %struct.op* %call109, %struct.op** %expr.addr, align 8, !tbaa !6
  br label %if.end140

sw.bb111:                                         ; preds = %cond.end
  %op_type112 = getelementptr inbounds %struct.op* %26, i64 0, i32 4
  %31 = load i16* %op_type112, align 2, !tbaa !12
  switch i16 %31, label %if.end140 [
    i16 276, label %if.then135
    i16 25, label %if.then135
    i16 0, label %land.lhs.true126
    i16 129, label %if.then135
  ]

land.lhs.true126:                                 ; preds = %sw.bb111
  %op_targ127 = getelementptr inbounds %struct.op* %26, i64 0, i32 3
  %32 = load i64* %op_targ127, align 8, !tbaa !13
  %cmp128 = icmp eq i64 %32, 25
  br i1 %cmp128, label %if.then135, label %if.end140

if.then135:                                       ; preds = %sw.bb111, %sw.bb111, %sw.bb111, %land.lhs.true126
  %call136 = call %struct.op* @Perl_newUNOP(i64 42, i64 0, %struct.op* %19)
  store %struct.op* %call136, %struct.op** %expr.addr, align 8, !tbaa !6
  br label %if.end140

if.end140:                                        ; preds = %sw.bb111, %land.lhs.true126, %land.lhs.true97, %sw.bb, %if.else, %land.end, %if.then76, %cond.end, %if.then108, %land.lhs.true102, %land.lhs.true92, %if.then135
  br i1 %tobool, label %if.end144, label %if.then142

if.then142:                                       ; preds = %if.end140
  %call.i = call i8* @Perl_safesysmalloc(i64 40) #4
  %33 = bitcast i8* %call.i to %struct.op*
  call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 40, i32 1, i1 false)
  %34 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %35 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %34, %struct.op* ()** %35, align 8, !tbaa !41
  %36 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %36, align 1, !tbaa !14
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %33, %struct.op** %op_next.i, align 8, !tbaa !42
  %37 = getelementptr inbounds i8* %call.i, i64 37
  store i8 0, i8* %37, align 1, !tbaa !11
  %38 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 0), align 8, !tbaa !1
  %and.i = and i64 %38, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %if.then142
  %call4.i = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %33) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 0), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then142
  %39 = phi i64 [ %38, %if.then142 ], [ %.pre.i, %if.then.i ]
  %and6.i = and i64 %39, 8
  %tobool7.i = icmp eq i64 %and6.i, 0
  br i1 %tobool7.i, label %if.end11.i, label %if.then8.i

if.then8.i:                                       ; preds = %if.end.i
  %call9.i = call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 0, i32 512) #4
  %conv10.i = sext i32 %call9.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %40 = bitcast i8* %op_targ.i to i64*
  store i64 %conv10.i, i64* %40, align 8, !tbaa !13
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then8.i, %if.end.i
  %41 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12.i = icmp eq i8* %41, null
  br i1 %tobool12.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end11.i
  %42 = load i8* %41, align 1, !tbaa !5
  %tobool15.i = icmp eq i8 %42, 0
  br i1 %tobool15.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  call void @Perl_op_free(%struct.op* %33) #4
  %43 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 0), align 8, !tbaa !6
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %43) #4
  br label %if.end144

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end11.i
  %44 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 0), align 8, !tbaa !6
  %call18.i = call %struct.op* %44(%struct.op* %33) #4
  br label %if.end144

if.end144:                                        ; preds = %cond.false.i, %cond.true.i, %if.end140
  %block.addr.0 = phi %struct.op* [ %block, %if.end140 ], [ null, %cond.true.i ], [ %call18.i, %cond.false.i ]
  %call.i210 = call i8* @Perl_safesysmalloc(i64 40) #4
  %45 = bitcast i8* %call.i210 to %struct.op*
  call void @llvm.memset.p0i8.i64(i8* %call.i210, i8 0, i64 40, i32 1, i1 false) #4
  %op_type.i211 = getelementptr inbounds i8* %call.i210, i64 32
  %46 = bitcast i8* %op_type.i211 to i16*
  store i16 176, i16* %46, align 2, !tbaa !12
  %47 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 176), align 8, !tbaa !6
  %op_ppaddr.i212 = getelementptr inbounds i8* %call.i210, i64 16
  %48 = bitcast i8* %op_ppaddr.i212 to %struct.op* ()**
  store %struct.op* ()* %47, %struct.op* ()** %48, align 8, !tbaa !41
  %49 = getelementptr inbounds i8* %call.i210, i64 36
  store i8 0, i8* %49, align 1, !tbaa !14
  %op_next.i213 = bitcast i8* %call.i210 to %struct.op**
  store %struct.op* %45, %struct.op** %op_next.i213, align 8, !tbaa !42
  %50 = getelementptr inbounds i8* %call.i210, i64 37
  store i8 0, i8* %50, align 1, !tbaa !11
  %51 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 176), align 8, !tbaa !1
  %and.i214 = and i64 %51, 4
  %tobool.i215 = icmp eq i64 %and.i214, 0
  br i1 %tobool.i215, label %if.end.i221, label %if.then.i218

if.then.i218:                                     ; preds = %if.end144
  %call4.i216 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %45) #4
  %.pre.i217 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 176), align 8, !tbaa !1
  br label %if.end.i221

if.end.i221:                                      ; preds = %if.then.i218, %if.end144
  %52 = phi i64 [ %51, %if.end144 ], [ %.pre.i217, %if.then.i218 ]
  %and6.i219 = and i64 %52, 8
  %tobool7.i220 = icmp eq i64 %and6.i219, 0
  br i1 %tobool7.i220, label %if.end11.i227, label %if.then8.i225

if.then8.i225:                                    ; preds = %if.end.i221
  %call9.i222 = call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 176, i32 512) #4
  %conv10.i223 = sext i32 %call9.i222 to i64
  %op_targ.i224 = getelementptr inbounds i8* %call.i210, i64 24
  %53 = bitcast i8* %op_targ.i224 to i64*
  store i64 %conv10.i223, i64* %53, align 8, !tbaa !13
  br label %if.end11.i227

if.end11.i227:                                    ; preds = %if.then8.i225, %if.end.i221
  %54 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12.i226 = icmp eq i8* %54, null
  br i1 %tobool12.i226, label %cond.false.i232, label %land.lhs.true.i229

land.lhs.true.i229:                               ; preds = %if.end11.i227
  %arrayidx13.i = getelementptr inbounds i8* %54, i64 176
  %55 = load i8* %arrayidx13.i, align 1, !tbaa !5
  %tobool15.i228 = icmp eq i8 %55, 0
  br i1 %tobool15.i228, label %cond.false.i232, label %cond.true.i230

cond.true.i230:                                   ; preds = %land.lhs.true.i229
  call void @Perl_op_free(%struct.op* %45) #4
  %56 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 176), align 8, !tbaa !6
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %56) #4
  br label %Perl_newOP.exit234

cond.false.i232:                                  ; preds = %land.lhs.true.i229, %if.end11.i227
  %57 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 176), align 8, !tbaa !6
  %call18.i231 = call %struct.op* %57(%struct.op* %45) #4
  br label %Perl_newOP.exit234

Perl_newOP.exit234:                               ; preds = %cond.true.i230, %cond.false.i232
  %cond.i233 = phi %struct.op* [ null, %cond.true.i230 ], [ %call18.i231, %cond.false.i232 ]
  %call146 = call i32 (i32, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, %struct.op*, ...)*)(i32 173, %struct.op* %block.addr.0, %struct.op* %cond.i233) #4
  %conv147 = sext i32 %call146 to i64
  %58 = inttoptr i64 %conv147 to %struct.op*
  store %struct.op* %58, %struct.op** %listop, align 8, !tbaa !6
  %call148 = call i32 (i32, i32, %struct.op**, %struct.op**, ...)* bitcast (i32 (...)* @new_logop to i32 (i32, i32, %struct.op**, %struct.op**, ...)*)(i32 159, i32 0, %struct.op** %expr.addr, %struct.op** %listop) #4
  %conv149 = sext i32 %call148 to i64
  %59 = inttoptr i64 %conv149 to %struct.op*
  %60 = load %struct.op** %listop, align 8, !tbaa !6
  %tobool150 = icmp eq %struct.op* %60, null
  br i1 %tobool150, label %if.end161, label %if.then151

if.then151:                                       ; preds = %Perl_newOP.exit234
  %op_next = getelementptr inbounds %struct.op* %59, i64 0, i32 0
  %61 = load %struct.op** %op_next, align 8, !tbaa !42
  %tobool152 = icmp eq %struct.op* %61, null
  br i1 %tobool152, label %cond.false155, label %cond.end158

cond.false155:                                    ; preds = %if.then151
  %call156 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %59) #4
  %conv157 = sext i32 %call156 to i64
  %62 = inttoptr i64 %conv157 to %struct.op*
  %.pre237 = load %struct.op** %listop, align 8, !tbaa !6
  br label %cond.end158

cond.end158:                                      ; preds = %if.then151, %cond.false155
  %63 = phi %struct.op* [ %.pre237, %cond.false155 ], [ %60, %if.then151 ]
  %cond159 = phi %struct.op* [ %62, %cond.false155 ], [ %61, %if.then151 ]
  %64 = getelementptr inbounds %struct.op* %63, i64 1, i32 1
  %65 = load %struct.op** %64, align 8, !tbaa !70
  %op_next160 = getelementptr inbounds %struct.op* %65, i64 0, i32 0
  store %struct.op* %cond159, %struct.op** %op_next160, align 8, !tbaa !42
  %.pre = load %struct.op** %listop, align 8
  br label %if.end161

if.end161:                                        ; preds = %Perl_newOP.exit234, %cond.end158
  %66 = phi %struct.op* [ null, %Perl_newOP.exit234 ], [ %.pre, %cond.end158 ]
  %.not = xor i1 %2, true
  %cmp164 = icmp eq %struct.op* %59, %66
  %or.cond = or i1 %cmp164, %.not
  br i1 %or.cond, label %if.end169, label %if.then166

if.then166:                                       ; preds = %if.end161
  %67 = inttoptr i64 %conv149 to %struct.unop*
  %op_first167 = getelementptr inbounds %struct.unop* %67, i64 0, i32 8
  %68 = load %struct.op** %op_first167, align 8, !tbaa !15
  %69 = getelementptr inbounds %struct.op* %68, i64 1, i32 1
  %70 = load %struct.op** %69, align 8, !tbaa !114
  %op_next168 = getelementptr inbounds %struct.op* %59, i64 0, i32 0
  store %struct.op* %70, %struct.op** %op_next168, align 8, !tbaa !42
  %.pre236 = load %struct.op** %listop, align 8, !tbaa !6
  br label %if.end169

if.end169:                                        ; preds = %if.end161, %if.then166
  %71 = phi %struct.op* [ %66, %if.end161 ], [ %.pre236, %if.then166 ]
  %cmp170 = icmp eq %struct.op* %59, %71
  br i1 %cmp170, label %if.then172, label %if.end174

if.then172:                                       ; preds = %if.end169
  %call173 = call %struct.op* @Perl_newUNOP(i64 0, i64 0, %struct.op* %59)
  br label %if.end174

if.end174:                                        ; preds = %if.then172, %if.end169
  %o.0 = phi %struct.op* [ %call173, %if.then172 ], [ %59, %if.end169 ]
  %op_flags175 = getelementptr inbounds %struct.op* %o.0, i64 0, i32 6
  %72 = load i8* %op_flags175, align 1, !tbaa !14
  %conv176 = zext i8 %72 to i64
  %or = or i64 %conv176, %flags
  %conv177 = trunc i64 %or to i8
  store i8 %conv177, i8* %op_flags175, align 1, !tbaa !14
  %call178 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scope to i32 (%struct.op*, ...)*)(%struct.op* %o.0) #4
  %conv179 = sext i32 %call178 to i64
  %73 = inttoptr i64 %conv179 to %struct.op*
  %op_flags180 = getelementptr inbounds %struct.op* %73, i64 0, i32 6
  %74 = load i8* %op_flags180, align 1, !tbaa !14
  %or182 = or i8 %74, -128
  store i8 %or182, i8* %op_flags180, align 1, !tbaa !14
  br label %return

return:                                           ; preds = %cond.true49, %land.lhs.true15, %cond.false54, %cond.true39, %cond.true20, %lor.lhs.false, %land.lhs.true28, %if.end174
  %retval.0 = phi %struct.op* [ %73, %if.end174 ], [ %block, %land.lhs.true28 ], [ %block, %lor.lhs.false ], [ %block, %cond.true20 ], [ %block, %cond.true39 ], [ %block, %cond.false54 ], [ %block, %land.lhs.true15 ], [ %block, %cond.true49 ]
  ret %struct.op* %retval.0
}

declare i32 @newDEFSVOP(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newWHILEOP(i64 %flags, i64 %debuggable, %struct.loop* %loop, i64 %whileline, %struct.op* %expr, %struct.op* %block, %struct.op* %cont) #0 {
entry:
  %expr.addr = alloca %struct.op*, align 8
  %listop = alloca %struct.op*, align 8
  store %struct.op* %expr, %struct.op** %expr.addr, align 8, !tbaa !6
  %tobool = icmp eq %struct.op* %expr, null
  br i1 %tobool, label %if.end72, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %expr, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  switch i16 %0, label %land.lhs.true18 [
    i16 26, label %if.then
    i16 25, label %if.then
    i16 0, label %land.lhs.true11
  ]

land.lhs.true11:                                  ; preds = %land.lhs.true
  %op_targ = getelementptr inbounds %struct.op* %expr, i64 0, i32 3
  %1 = load i64* %op_targ, align 8, !tbaa !13
  %cmp12 = icmp eq i64 %1, 25
  br i1 %cmp12, label %if.then, label %land.lhs.true18

if.then:                                          ; preds = %land.lhs.true, %land.lhs.true, %land.lhs.true11
  %call = call i32 (...)* @newDEFSVOP() #4
  %conv14 = sext i32 %call to i64
  %2 = inttoptr i64 %conv14 to %struct.op*
  %3 = load %struct.op** %expr.addr, align 8, !tbaa !6
  %call15 = call %struct.op* @Perl_newASSIGNOP(i64 0, %struct.op* %2, i64 0, %struct.op* %3)
  %call16 = call %struct.op* @Perl_newUNOP(i64 42, i64 0, %struct.op* %call15)
  store %struct.op* %call16, %struct.op** %expr.addr, align 8, !tbaa !6
  br label %if.end72

land.lhs.true18:                                  ; preds = %land.lhs.true11, %land.lhs.true
  %op_flags = getelementptr inbounds %struct.op* %expr, i64 0, i32 6
  %4 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %4, 4
  %tobool20 = icmp eq i8 %and, 0
  br i1 %tobool20, label %if.end72, label %if.then21

if.then21:                                        ; preds = %land.lhs.true18
  %5 = getelementptr inbounds %struct.op* %expr, i64 1, i32 0
  %6 = load %struct.op** %5, align 8, !tbaa !15
  %tobool22 = icmp eq %struct.op* %6, null
  br i1 %tobool22, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.then21
  %op_sibling = getelementptr inbounds %struct.op* %6, i64 0, i32 1
  %7 = load %struct.op** %op_sibling, align 8, !tbaa !17
  br label %cond.end

cond.end:                                         ; preds = %if.then21, %cond.true
  %cond = phi %struct.op* [ %7, %cond.true ], [ null, %if.then21 ]
  %conv24 = zext i16 %0 to i32
  switch i32 %conv24, label %if.end72 [
    i32 0, label %sw.bb
    i32 36, label %sw.bb44
  ]

sw.bb:                                            ; preds = %cond.end
  %tobool25 = icmp eq %struct.op* %cond, null
  br i1 %tobool25, label %if.end72, label %land.lhs.true26

land.lhs.true26:                                  ; preds = %sw.bb
  %op_type27 = getelementptr inbounds %struct.op* %cond, i64 0, i32 4
  %8 = load i16* %op_type27, align 2, !tbaa !12
  %cmp29 = icmp eq i16 %8, 26
  br i1 %cmp29, label %land.lhs.true31, label %if.end72

land.lhs.true31:                                  ; preds = %land.lhs.true26
  %op_flags32 = getelementptr inbounds %struct.op* %cond, i64 0, i32 6
  %9 = load i8* %op_flags32, align 1, !tbaa !14
  %and34 = and i8 %9, 64
  %tobool35 = icmp eq i8 %and34, 0
  br i1 %tobool35, label %if.end72, label %land.lhs.true36

land.lhs.true36:                                  ; preds = %land.lhs.true31
  %op_flags37 = getelementptr inbounds %struct.op* %6, i64 0, i32 6
  %10 = load i8* %op_flags37, align 1, !tbaa !14
  %and39 = and i8 %10, 3
  %cmp40 = icmp eq i8 %and39, 2
  br i1 %cmp40, label %if.then42, label %if.end72

if.then42:                                        ; preds = %land.lhs.true36
  %call43 = call %struct.op* @Perl_newUNOP(i64 42, i64 0, %struct.op* %expr)
  store %struct.op* %call43, %struct.op** %expr.addr, align 8, !tbaa !6
  br label %if.end72

sw.bb44:                                          ; preds = %cond.end
  %op_type45 = getelementptr inbounds %struct.op* %6, i64 0, i32 4
  %11 = load i16* %op_type45, align 2, !tbaa !12
  switch i16 %11, label %if.end72 [
    i16 276, label %if.then68
    i16 25, label %if.then68
    i16 0, label %land.lhs.true59
    i16 129, label %if.then68
  ]

land.lhs.true59:                                  ; preds = %sw.bb44
  %op_targ60 = getelementptr inbounds %struct.op* %6, i64 0, i32 3
  %12 = load i64* %op_targ60, align 8, !tbaa !13
  %cmp61 = icmp eq i64 %12, 25
  br i1 %cmp61, label %if.then68, label %if.end72

if.then68:                                        ; preds = %sw.bb44, %sw.bb44, %sw.bb44, %land.lhs.true59
  %call69 = call %struct.op* @Perl_newUNOP(i64 42, i64 0, %struct.op* %expr)
  store %struct.op* %call69, %struct.op** %expr.addr, align 8, !tbaa !6
  br label %if.end72

if.end72:                                         ; preds = %sw.bb44, %land.lhs.true59, %entry, %land.lhs.true31, %sw.bb, %land.lhs.true18, %if.then68, %land.lhs.true26, %land.lhs.true36, %if.then42, %cond.end, %if.then
  %tobool73 = icmp eq %struct.op* %block, null
  br i1 %tobool73, label %if.then74, label %if.else76

if.then74:                                        ; preds = %if.end72
  %call.i = call i8* @Perl_safesysmalloc(i64 40) #4
  %13 = bitcast i8* %call.i to %struct.op*
  call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 40, i32 1, i1 false)
  %14 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %15 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %14, %struct.op* ()** %15, align 8, !tbaa !41
  %16 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %16, align 1, !tbaa !14
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %13, %struct.op** %op_next.i, align 8, !tbaa !42
  %17 = getelementptr inbounds i8* %call.i, i64 37
  store i8 0, i8* %17, align 1, !tbaa !11
  %18 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 0), align 8, !tbaa !1
  %and.i = and i64 %18, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %if.then74
  %call4.i = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %13) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 0), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then74
  %19 = phi i64 [ %18, %if.then74 ], [ %.pre.i, %if.then.i ]
  %and6.i = and i64 %19, 8
  %tobool7.i = icmp eq i64 %and6.i, 0
  br i1 %tobool7.i, label %if.end11.i, label %if.then8.i

if.then8.i:                                       ; preds = %if.end.i
  %call9.i = call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 0, i32 512) #4
  %conv10.i = sext i32 %call9.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %20 = bitcast i8* %op_targ.i to i64*
  store i64 %conv10.i, i64* %20, align 8, !tbaa !13
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then8.i, %if.end.i
  %21 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12.i = icmp eq i8* %21, null
  br i1 %tobool12.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end11.i
  %22 = load i8* %21, align 1, !tbaa !5
  %tobool15.i = icmp eq i8 %22, 0
  br i1 %tobool15.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  call void @Perl_op_free(%struct.op* %13) #4
  %23 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 0), align 8, !tbaa !6
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %23) #4
  br label %if.end82

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end11.i
  %24 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 0), align 8, !tbaa !6
  %call18.i = call %struct.op* %24(%struct.op* %13) #4
  br label %if.end82

if.else76:                                        ; preds = %if.end72
  %tobool77 = icmp eq %struct.op* %cont, null
  br i1 %tobool77, label %if.end93, label %if.end82.thread299

if.end82.thread299:                               ; preds = %if.else76
  %call79 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scope to i32 (%struct.op*, ...)*)(%struct.op* %block) #4
  %conv80 = sext i32 %call79 to i64
  %25 = inttoptr i64 %conv80 to %struct.op*
  br label %if.then84

if.end82:                                         ; preds = %cond.false.i, %cond.true.i
  %block.addr.0 = phi %struct.op* [ null, %cond.true.i ], [ %call18.i, %cond.false.i ]
  %tobool83 = icmp eq %struct.op* %cont, null
  br i1 %tobool83, label %if.end93, label %if.then84

if.then84:                                        ; preds = %if.end82.thread299, %if.end82
  %block.addr.0301 = phi %struct.op* [ %25, %if.end82.thread299 ], [ %block.addr.0, %if.end82 ]
  %op_next = getelementptr inbounds %struct.op* %cont, i64 0, i32 0
  %26 = load %struct.op** %op_next, align 8, !tbaa !42
  %tobool85 = icmp eq %struct.op* %26, null
  br i1 %tobool85, label %cond.false88, label %if.end93

cond.false88:                                     ; preds = %if.then84
  %call89 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %cont) #4
  %conv90 = sext i32 %call89 to i64
  %27 = inttoptr i64 %conv90 to %struct.op*
  br label %if.end93

if.end93:                                         ; preds = %if.else76, %cond.false88, %if.then84, %if.end82
  %block.addr.0298 = phi %struct.op* [ %block.addr.0, %if.end82 ], [ %block.addr.0301, %cond.false88 ], [ %block.addr.0301, %if.then84 ], [ %block, %if.else76 ]
  %next.0 = phi %struct.op* [ null, %if.end82 ], [ %27, %cond.false88 ], [ %26, %if.then84 ], [ null, %if.else76 ]
  %28 = load %struct.op** %expr.addr, align 8, !tbaa !6
  %tobool94 = icmp eq %struct.op* %28, null
  br i1 %tobool94, label %if.end102, label %if.then95

if.then95:                                        ; preds = %if.end93
  %call.i270 = call i8* @Perl_safesysmalloc(i64 40) #4
  %29 = bitcast i8* %call.i270 to %struct.op*
  call void @llvm.memset.p0i8.i64(i8* %call.i270, i8 0, i64 40, i32 1, i1 false) #4
  %op_type.i271 = getelementptr inbounds i8* %call.i270, i64 32
  %30 = bitcast i8* %op_type.i271 to i16*
  store i16 176, i16* %30, align 2, !tbaa !12
  %31 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 176), align 8, !tbaa !6
  %op_ppaddr.i272 = getelementptr inbounds i8* %call.i270, i64 16
  %32 = bitcast i8* %op_ppaddr.i272 to %struct.op* ()**
  store %struct.op* ()* %31, %struct.op* ()** %32, align 8, !tbaa !41
  %33 = getelementptr inbounds i8* %call.i270, i64 36
  store i8 0, i8* %33, align 1, !tbaa !14
  %op_next.i273 = bitcast i8* %call.i270 to %struct.op**
  store %struct.op* %29, %struct.op** %op_next.i273, align 8, !tbaa !42
  %34 = getelementptr inbounds i8* %call.i270, i64 37
  store i8 0, i8* %34, align 1, !tbaa !11
  %35 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 176), align 8, !tbaa !1
  %and.i274 = and i64 %35, 4
  %tobool.i275 = icmp eq i64 %and.i274, 0
  br i1 %tobool.i275, label %if.end.i281, label %if.then.i278

if.then.i278:                                     ; preds = %if.then95
  %call4.i276 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %29) #4
  %.pre.i277 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 176), align 8, !tbaa !1
  br label %if.end.i281

if.end.i281:                                      ; preds = %if.then.i278, %if.then95
  %36 = phi i64 [ %35, %if.then95 ], [ %.pre.i277, %if.then.i278 ]
  %and6.i279 = and i64 %36, 8
  %tobool7.i280 = icmp eq i64 %and6.i279, 0
  br i1 %tobool7.i280, label %if.end11.i287, label %if.then8.i285

if.then8.i285:                                    ; preds = %if.end.i281
  %call9.i282 = call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 176, i32 512) #4
  %conv10.i283 = sext i32 %call9.i282 to i64
  %op_targ.i284 = getelementptr inbounds i8* %call.i270, i64 24
  %37 = bitcast i8* %op_targ.i284 to i64*
  store i64 %conv10.i283, i64* %37, align 8, !tbaa !13
  br label %if.end11.i287

if.end11.i287:                                    ; preds = %if.then8.i285, %if.end.i281
  %38 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12.i286 = icmp eq i8* %38, null
  br i1 %tobool12.i286, label %cond.false.i292, label %land.lhs.true.i289

land.lhs.true.i289:                               ; preds = %if.end11.i287
  %arrayidx13.i = getelementptr inbounds i8* %38, i64 176
  %39 = load i8* %arrayidx13.i, align 1, !tbaa !5
  %tobool15.i288 = icmp eq i8 %39, 0
  br i1 %tobool15.i288, label %cond.false.i292, label %cond.true.i290

cond.true.i290:                                   ; preds = %land.lhs.true.i289
  call void @Perl_op_free(%struct.op* %29) #4
  %40 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 176), align 8, !tbaa !6
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %40) #4
  br label %Perl_newOP.exit294

cond.false.i292:                                  ; preds = %land.lhs.true.i289, %if.end11.i287
  %41 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 176), align 8, !tbaa !6
  %call18.i291 = call %struct.op* %41(%struct.op* %29) #4
  br label %Perl_newOP.exit294

Perl_newOP.exit294:                               ; preds = %cond.true.i290, %cond.false.i292
  %cond.i293 = phi %struct.op* [ null, %cond.true.i290 ], [ %call18.i291, %cond.false.i292 ]
  %tobool97 = icmp eq %struct.op* %next.0, null
  %call96.next.0 = select i1 %tobool97, %struct.op* %cond.i293, %struct.op* %next.0
  %call100 = call i32 (i32, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, %struct.op*, ...)*)(i32 173, %struct.op* %cont, %struct.op* %cond.i293) #4
  %conv101 = sext i32 %call100 to i64
  %42 = inttoptr i64 %conv101 to %struct.op*
  br label %if.end102

if.end102:                                        ; preds = %if.end93, %Perl_newOP.exit294
  %next.2 = phi %struct.op* [ %call96.next.0, %Perl_newOP.exit294 ], [ %next.0, %if.end93 ]
  %cont.addr.0 = phi %struct.op* [ %42, %Perl_newOP.exit294 ], [ %cont, %if.end93 ]
  %43 = bitcast %struct.op* %block.addr.0298 to %struct.listop*
  %44 = bitcast %struct.op* %cont.addr.0 to %struct.listop*
  %call103 = call i32 (i32, %struct.listop*, %struct.listop*, ...)* bitcast (i32 (...)* @append_list to i32 (i32, %struct.listop*, %struct.listop*, ...)*)(i32 173, %struct.listop* %43, %struct.listop* %44) #4
  %conv104 = sext i32 %call103 to i64
  %45 = inttoptr i64 %conv104 to %struct.op*
  store %struct.op* %45, %struct.op** %listop, align 8, !tbaa !6
  %op_next105 = getelementptr inbounds %struct.op* %45, i64 0, i32 0
  %46 = load %struct.op** %op_next105, align 8, !tbaa !42
  %tobool106 = icmp eq %struct.op* %46, null
  br i1 %tobool106, label %cond.false109, label %cond.end112

cond.false109:                                    ; preds = %if.end102
  %call110 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %45) #4
  %conv111 = sext i32 %call110 to i64
  %47 = inttoptr i64 %conv111 to %struct.op*
  br label %cond.end112

cond.end112:                                      ; preds = %if.end102, %cond.false109
  %cond113 = phi %struct.op* [ %47, %cond.false109 ], [ %46, %if.end102 ]
  %48 = load %struct.op** %expr.addr, align 8, !tbaa !6
  %tobool114 = icmp eq %struct.op* %48, null
  br i1 %tobool114, label %if.else194, label %if.then115

if.then115:                                       ; preds = %cond.end112
  store i64 %whileline, i64* @PL_copline, align 8, !tbaa !1
  %49 = load %struct.op** %listop, align 8, !tbaa !6
  %call116 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %49) #4
  %call117 = call i32 (i32, i32, %struct.op**, %struct.op**, ...)* bitcast (i32 (...)* @new_logop to i32 (i32, i32, %struct.op**, %struct.op**, ...)*)(i32 159, i32 0, %struct.op** %expr.addr, %struct.op** %listop) #4
  %conv118 = sext i32 %call117 to i64
  %50 = inttoptr i64 %conv118 to %struct.op*
  %51 = load %struct.op** %expr.addr, align 8, !tbaa !6
  %cmp119 = icmp eq %struct.op* %50, %51
  br i1 %cmp119, label %land.lhs.true121, label %if.end174

land.lhs.true121:                                 ; preds = %if.then115
  %op_type122 = getelementptr inbounds %struct.op* %50, i64 0, i32 4
  %52 = load i16* %op_type122, align 2, !tbaa !12
  %cmp124 = icmp eq i16 %52, 5
  br i1 %cmp124, label %land.lhs.true126, label %if.end174

land.lhs.true126:                                 ; preds = %land.lhs.true121
  %53 = inttoptr i64 %conv118 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop* %53, i64 0, i32 8
  %54 = load %struct.sv** %op_sv, align 8, !tbaa !18
  %tobool127 = icmp eq %struct.sv* %54, null
  br i1 %tobool127, label %if.then173, label %cond.false129

cond.false129:                                    ; preds = %land.lhs.true126
  %sv_flags = getelementptr inbounds %struct.sv* %54, i64 0, i32 2
  %55 = load i64* %sv_flags, align 8, !tbaa !34
  %and131 = and i64 %55, 262144
  %tobool132 = icmp eq i64 %and131, 0
  br i1 %tobool132, label %cond.false148, label %cond.true133

cond.true133:                                     ; preds = %cond.false129
  %sv_any = getelementptr inbounds %struct.sv* %54, i64 0, i32 0
  %56 = load i8** %sv_any, align 8, !tbaa !36
  %57 = bitcast i8* %56 to %struct.xpv*
  store %struct.xpv* %57, %struct.xpv** @PL_Xpv, align 8, !tbaa !6
  %tobool135 = icmp eq i8* %56, null
  br i1 %tobool135, label %if.then173, label %land.lhs.true136

land.lhs.true136:                                 ; preds = %cond.true133
  %xpv_cur = getelementptr inbounds i8* %56, i64 8
  %58 = bitcast i8* %xpv_cur to i64*
  %59 = load i64* %58, align 8, !tbaa !37
  %cmp137 = icmp ugt i64 %59, 1
  br i1 %cmp137, label %if.end174, label %lor.lhs.false139

lor.lhs.false139:                                 ; preds = %land.lhs.true136
  %tobool141 = icmp eq i64 %59, 0
  br i1 %tobool141, label %if.then173, label %land.lhs.true142

land.lhs.true142:                                 ; preds = %lor.lhs.false139
  %xpv_pv = bitcast i8* %56 to i8**
  %60 = load i8** %xpv_pv, align 8, !tbaa !39
  %61 = load i8* %60, align 1, !tbaa !5
  %cmp144 = icmp eq i8 %61, 48
  br i1 %cmp144, label %if.then173, label %if.end174

cond.false148:                                    ; preds = %cond.false129
  %and151 = and i64 %55, 65536
  %tobool152 = icmp eq i64 %and151, 0
  br i1 %tobool152, label %cond.false158, label %cond.true153

cond.true153:                                     ; preds = %cond.false148
  %sv_any155 = getelementptr inbounds %struct.sv* %54, i64 0, i32 0
  %62 = load i8** %sv_any155, align 8, !tbaa !36
  %xiv_iv = getelementptr inbounds i8* %62, i64 24
  %63 = bitcast i8* %xiv_iv to i64*
  %64 = load i64* %63, align 8, !tbaa !53
  %cmp156 = icmp eq i64 %64, 0
  br i1 %cmp156, label %if.then173, label %if.end174

cond.false158:                                    ; preds = %cond.false148
  %and161 = and i64 %55, 131072
  %tobool162 = icmp eq i64 %and161, 0
  br i1 %tobool162, label %cond.false168, label %cond.true163

cond.true163:                                     ; preds = %cond.false158
  %sv_any165 = getelementptr inbounds %struct.sv* %54, i64 0, i32 0
  %65 = load i8** %sv_any165, align 8, !tbaa !36
  %xnv_nv = getelementptr inbounds i8* %65, i64 32
  %66 = bitcast i8* %xnv_nv to double*
  %67 = load double* %66, align 8, !tbaa !51
  %cmp166 = fcmp une double %67, 0.000000e+00
  br i1 %cmp166, label %if.end174, label %if.then173

cond.false168:                                    ; preds = %cond.false158
  %call170 = call signext i8 @Perl_sv_2bool(%struct.sv* %54) #4
  %tobool172 = icmp eq i8 %call170, 0
  br i1 %tobool172, label %cond.false168.if.then173_crit_edge, label %if.end174

cond.false168.if.then173_crit_edge:               ; preds = %cond.false168
  %.pre = load %struct.op** %expr.addr, align 8, !tbaa !6
  br label %if.then173

if.then173:                                       ; preds = %cond.false168.if.then173_crit_edge, %land.lhs.true142, %lor.lhs.false139, %cond.true133, %cond.true153, %land.lhs.true126, %cond.true163
  %68 = phi %struct.op* [ %.pre, %cond.false168.if.then173_crit_edge ], [ %50, %land.lhs.true142 ], [ %50, %lor.lhs.false139 ], [ %50, %cond.true133 ], [ %50, %cond.true153 ], [ %50, %land.lhs.true126 ], [ %50, %cond.true163 ]
  call void @Perl_op_free(%struct.op* %68)
  %69 = bitcast %struct.loop* %loop to %struct.op*
  call void @Perl_op_free(%struct.op* %69)
  br label %return

if.end174:                                        ; preds = %land.lhs.true142, %cond.true153, %cond.false168, %land.lhs.true136, %cond.true163, %land.lhs.true121, %if.then115
  %70 = load %struct.op** %listop, align 8, !tbaa !6
  %tobool175 = icmp eq %struct.op* %70, null
  br i1 %tobool175, label %if.end195, label %if.then176

if.then176:                                       ; preds = %if.end174
  %cmp177 = icmp eq %struct.op* %50, %70
  br i1 %cmp177, label %cond.end190, label %cond.false180

cond.false180:                                    ; preds = %if.then176
  %op_next181 = getelementptr inbounds %struct.op* %50, i64 0, i32 0
  %71 = load %struct.op** %op_next181, align 8, !tbaa !42
  %tobool182 = icmp eq %struct.op* %71, null
  br i1 %tobool182, label %cond.false185, label %cond.end190

cond.false185:                                    ; preds = %cond.false180
  %call186 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %50) #4
  %conv187 = sext i32 %call186 to i64
  %72 = inttoptr i64 %conv187 to %struct.op*
  %.pre302 = load %struct.op** %listop, align 8, !tbaa !6
  br label %cond.end190

cond.end190:                                      ; preds = %cond.false180, %if.then176, %cond.false185
  %73 = phi %struct.op* [ %.pre302, %cond.false185 ], [ %50, %if.then176 ], [ %70, %cond.false180 ]
  %cond191 = phi %struct.op* [ %72, %cond.false185 ], [ %cond113, %if.then176 ], [ %71, %cond.false180 ]
  %74 = getelementptr inbounds %struct.op* %73, i64 1, i32 1
  %75 = load %struct.op** %74, align 8, !tbaa !70
  %op_next192 = getelementptr inbounds %struct.op* %75, i64 0, i32 0
  store %struct.op* %cond191, %struct.op** %op_next192, align 8, !tbaa !42
  br label %if.end195

if.else194:                                       ; preds = %cond.end112
  %76 = load %struct.op** %listop, align 8, !tbaa !6
  br label %if.end195

if.end195:                                        ; preds = %if.end174, %cond.end190, %if.else194
  %o.0 = phi %struct.op* [ %50, %cond.end190 ], [ %50, %if.end174 ], [ %76, %if.else194 ]
  %tobool196 = icmp eq %struct.loop* %loop, null
  br i1 %tobool196, label %if.then197, label %if.end201

if.then197:                                       ; preds = %if.end195
  %call198 = call i8* @Perl_safesysmalloc(i64 80) #4
  %77 = bitcast i8* %call198 to %struct.loop*
  call void @llvm.memset.p0i8.i64(i8* %call198, i8 0, i64 80, i32 1, i1 false)
  %op_type199 = getelementptr inbounds i8* %call198, i64 32
  %78 = bitcast i8* %op_type199 to i16*
  store i16 182, i16* %78, align 2, !tbaa !166
  %79 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 182), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds i8* %call198, i64 16
  %80 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %79, %struct.op* ()** %80, align 8, !tbaa !168
  %81 = getelementptr inbounds i8* %call198, i64 37
  store i8 0, i8* %81, align 1, !tbaa !169
  %82 = bitcast i8* %call198 to %struct.op*
  %op_next200 = bitcast i8* %call198 to %struct.op**
  store %struct.op* %82, %struct.op** %op_next200, align 8, !tbaa !170
  br label %if.end201

if.end201:                                        ; preds = %if.end195, %if.then197
  %loop.addr.0 = phi %struct.loop* [ %loop, %if.end195 ], [ %77, %if.then197 ]
  %83 = bitcast %struct.loop* %loop.addr.0 to %struct.op*
  %call202 = call %struct.op* @Perl_newBINOP(i64 183, i64 0, %struct.op* %83, %struct.op* %o.0)
  %op_redoop = getelementptr inbounds %struct.loop* %loop.addr.0, i64 0, i32 10
  store %struct.op* %cond113, %struct.op** %op_redoop, align 8, !tbaa !171
  %op_lastop = getelementptr inbounds %struct.loop* %loop.addr.0, i64 0, i32 12
  store %struct.op* %call202, %struct.op** %op_lastop, align 8, !tbaa !172
  %op_private204 = getelementptr inbounds %struct.op* %call202, i64 0, i32 7
  %tobool207 = icmp eq %struct.op* %next.2, null
  %op_nextop210 = getelementptr inbounds %struct.loop* %loop.addr.0, i64 0, i32 11
  %call202.next.2 = select i1 %tobool207, %struct.op* %call202, %struct.op* %next.2
  store %struct.op* %call202.next.2, %struct.op** %op_nextop210, align 8, !tbaa !173
  %op_flags212 = getelementptr inbounds %struct.op* %call202, i64 0, i32 6
  %84 = load i8* %op_flags212, align 1, !tbaa !14
  %conv213 = zext i8 %84 to i64
  %or214 = or i64 %conv213, %flags
  %conv215 = trunc i64 %or214 to i8
  store i8 %conv215, i8* %op_flags212, align 1, !tbaa !14
  %shr269 = lshr i64 %flags, 8
  %85 = load i8* %op_private204, align 1, !tbaa !11
  %conv217 = zext i8 %85 to i64
  %or218 = or i64 %conv217, %shr269
  %conv219 = trunc i64 %or218 to i8
  store i8 %conv219, i8* %op_private204, align 1, !tbaa !11
  br label %return

return:                                           ; preds = %if.end201, %if.then173
  %retval.0 = phi %struct.op* [ %call202, %if.end201 ], [ null, %if.then173 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newFOROP(i64 %flags, i8* %label, i64 %forline, %struct.op* %sv, %struct.op* %expr, %struct.op* %block, %struct.op* %cont) #0 {
entry:
  %tobool = icmp eq %struct.op* %sv, null
  br i1 %tobool, label %if.else28, label %if.then

if.then:                                          ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %sv, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  switch i16 %0, label %if.else24 [
    i16 15, label %if.then2
    i16 9, label %if.then10
    i16 348, label %if.then21
  ]

if.then2:                                         ; preds = %if.then
  %op_private = getelementptr inbounds %struct.op* %sv, i64 0, i32 7
  %1 = load i8* %op_private, align 1, !tbaa !11
  %and = and i8 %1, 16
  store i16 14, i16* %op_type, align 2, !tbaa !12
  %2 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 14), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %sv, i64 0, i32 2
  store %struct.op* ()* %2, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  br label %if.end29

if.then10:                                        ; preds = %if.then
  %op_private11 = getelementptr inbounds %struct.op* %sv, i64 0, i32 7
  %3 = load i8* %op_private11, align 1, !tbaa !11
  %and13 = and i8 %3, -128
  %op_targ = getelementptr inbounds %struct.op* %sv, i64 0, i32 3
  %4 = load i64* %op_targ, align 8, !tbaa !13
  store i64 0, i64* %op_targ, align 8, !tbaa !13
  tail call void @Perl_op_free(%struct.op* %sv)
  br label %if.end29

if.then21:                                        ; preds = %if.then
  %op_targ22 = getelementptr inbounds %struct.op* %sv, i64 0, i32 3
  %5 = load i64* %op_targ22, align 8, !tbaa !13
  store i64 0, i64* %op_targ22, align 8, !tbaa !13
  tail call void @Perl_op_free(%struct.op* %sv)
  br label %if.end29

if.else24:                                        ; preds = %if.then
  %idxprom = zext i16 %0 to i64
  %arrayidx = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %6 = load i8** %arrayidx, align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str54, i64 0, i64 0), i8* %6) #4
  br label %if.end29

if.else28:                                        ; preds = %entry
  %7 = load %struct.gv** @PL_defgv, align 8, !tbaa !6
  %8 = bitcast %struct.gv* %7 to %struct.sv*
  store %struct.sv* %8, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool.i = icmp eq %struct.gv* %7, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.else28
  %9 = getelementptr inbounds %struct.gv* %7, i64 0, i32 1
  %10 = load i64* %9, align 8, !tbaa !40
  %inc.i = add i64 %10, 1
  store i64 %inc.i, i64* %9, align 8, !tbaa !40
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.else28, %land.rhs.i
  %call.i134 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i134, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i134, i64 32
  %11 = bitcast i8* %op_type.i to i16*
  store i16 7, i16* %11, align 2, !tbaa !71
  %12 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 7), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i134, i64 16
  %13 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %12, %struct.op* ()** %13, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i134, i64 40
  %14 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %8, %struct.sv** %14, align 8, !tbaa !18
  %15 = bitcast i8* %call.i134 to %struct.op*
  %op_next.i = bitcast i8* %call.i134 to %struct.op**
  store %struct.op* %15, %struct.op** %op_next.i, align 8, !tbaa !73
  %16 = getelementptr inbounds i8* %call.i134, i64 36
  store i8 0, i8* %16, align 1, !tbaa !74
  %17 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  %and.i = and i64 %17, 4
  %tobool.i135 = icmp eq i64 %and.i, 0
  br i1 %tobool.i135, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %Perl_newGVOP.exit
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %15) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %Perl_newGVOP.exit
  %18 = phi i64 [ %17, %Perl_newGVOP.exit ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %18, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 7, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i134, i64 24
  %19 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %19, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %20 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %20, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %20, i64 7
  %21 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %21, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %15) #4
  %22 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 7), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %22) #4
  br label %if.end29

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %23 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 7), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %23(%struct.op* %15) #4
  br label %if.end29

if.end29:                                         ; preds = %cond.false.i, %cond.true.i, %if.then2, %if.then21, %if.else24, %if.then10
  %iterpflags.0 = phi i8 [ %and, %if.then2 ], [ %and13, %if.then10 ], [ 0, %if.then21 ], [ 0, %if.else24 ], [ 0, %cond.true.i ], [ 0, %cond.false.i ]
  %iterflags.0 = phi i64 [ 0, %if.then2 ], [ 0, %if.then10 ], [ 128, %if.then21 ], [ 0, %if.else24 ], [ 0, %cond.true.i ], [ 0, %cond.false.i ]
  %padoff.0 = phi i64 [ 0, %if.then2 ], [ %4, %if.then10 ], [ %5, %if.then21 ], [ 0, %if.else24 ], [ 0, %cond.true.i ], [ 0, %cond.false.i ]
  %sv.addr.0 = phi %struct.op* [ %sv, %if.then2 ], [ null, %if.then10 ], [ null, %if.then21 ], [ %sv, %if.else24 ], [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  %op_type30 = getelementptr inbounds %struct.op* %expr, i64 0, i32 4
  %24 = load i16* %op_type30, align 2, !tbaa !12
  switch i16 %24, label %if.else76 [
    i16 125, label %if.then38
    i16 10, label %if.then38
    i16 0, label %land.lhs.true
  ]

if.then38:                                        ; preds = %if.end29, %if.end29
  %call39 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i32, ...)*)(%struct.op* %expr, i32 181) #4
  %call40 = tail call i32 (i32, ...)* bitcast (i32 (...)* @scalar to i32 (i32, ...)*)(i32 %call39) #4
  %call41 = tail call i32 (i32, ...)* bitcast (i32 (...)* @force_list to i32 (i32, ...)*)(i32 %call40) #4
  %call42 = tail call i32 (i32, i32, ...)* bitcast (i32 (...)* @mod to i32 (i32, i32, ...)*)(i32 %call41, i32 152) #4
  %conv43 = sext i32 %call42 to i64
  %25 = inttoptr i64 %conv43 to %struct.op*
  %or44 = or i64 %iterflags.0, 64
  br label %if.end81

land.lhs.true:                                    ; preds = %if.end29
  %op_flags = getelementptr inbounds %struct.op* %expr, i64 0, i32 6
  %26 = load i8* %op_flags, align 1, !tbaa !14
  %and51 = and i8 %26, 4
  %tobool52 = icmp eq i8 %and51, 0
  br i1 %tobool52, label %if.else76, label %land.lhs.true53

land.lhs.true53:                                  ; preds = %land.lhs.true
  %27 = getelementptr inbounds %struct.op* %expr, i64 1, i32 0
  %28 = load %struct.op** %27, align 8, !tbaa !43
  %op_type54 = getelementptr inbounds %struct.op* %28, i64 0, i32 4
  %29 = load i16* %op_type54, align 2, !tbaa !12
  %cmp56 = icmp eq i16 %29, 158
  br i1 %cmp56, label %if.then58, label %if.else76

if.then58:                                        ; preds = %land.lhs.true53
  %30 = getelementptr inbounds %struct.op* %28, i64 1, i32 0
  %31 = load %struct.op** %30, align 8, !tbaa !15
  %32 = getelementptr inbounds %struct.op* %31, i64 1, i32 0
  %33 = load %struct.op** %32, align 8, !tbaa !15
  %34 = getelementptr inbounds %struct.op* %33, i64 1, i32 0
  %35 = load %struct.op** %34, align 8, !tbaa !111
  %op_sibling = getelementptr inbounds %struct.op* %35, i64 0, i32 1
  %36 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %37 = getelementptr inbounds %struct.op* %33, i64 0, i32 6
  %38 = load i8* %37, align 1, !tbaa !112
  %and65 = and i8 %38, -5
  store i8 %and65, i8* %37, align 1, !tbaa !112
  store %struct.op* null, %struct.op** %34, align 8, !tbaa !111
  %call68 = tail call %struct.op* @Perl_newLISTOP(i64 141, i64 0, %struct.op* %35, %struct.op* %36)
  %op_next = getelementptr inbounds %struct.op* %33, i64 0, i32 0
  %39 = load %struct.op** %op_next, align 8, !tbaa !115
  %40 = getelementptr inbounds %struct.op* %call68, i64 1, i32 0
  %41 = load %struct.op** %40, align 8, !tbaa !45
  %op_next70 = getelementptr inbounds %struct.op* %41, i64 0, i32 0
  store %struct.op* %39, %struct.op** %op_next70, align 8, !tbaa !42
  %42 = getelementptr inbounds %struct.op* %33, i64 1, i32 1
  %43 = load %struct.op** %42, align 8, !tbaa !114
  %op_next71 = getelementptr inbounds %struct.op* %35, i64 0, i32 0
  store %struct.op* %43, %struct.op** %op_next71, align 8, !tbaa !42
  %op_next72 = getelementptr inbounds %struct.op* %36, i64 0, i32 0
  store %struct.op* %call68, %struct.op** %op_next72, align 8, !tbaa !42
  %op_next74 = getelementptr inbounds %struct.op* %call68, i64 0, i32 0
  store %struct.op* %41, %struct.op** %op_next74, align 8, !tbaa !174
  tail call void @Perl_op_free(%struct.op* %expr)
  %op_type.i136 = getelementptr inbounds %struct.op* %call68, i64 0, i32 4
  %44 = load i16* %op_type.i136, align 2, !tbaa !12
  %cmp.i = icmp eq i16 %44, 0
  br i1 %cmp.i, label %Perl_op_null.exit, label %if.end.i139

if.end.i139:                                      ; preds = %if.then58
  %call.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %call68) #4
  %45 = load i16* %op_type.i136, align 2, !tbaa !12
  %conv3.i = zext i16 %45 to i64
  %op_targ.i137 = getelementptr inbounds %struct.op* %call68, i64 0, i32 3
  store i64 %conv3.i, i64* %op_targ.i137, align 8, !tbaa !13
  store i16 0, i16* %op_type.i136, align 2, !tbaa !12
  %46 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i138 = getelementptr inbounds %struct.op* %call68, i64 0, i32 2
  store %struct.op* ()* %46, %struct.op* ()** %op_ppaddr.i138, align 8, !tbaa !41
  br label %Perl_op_null.exit

Perl_op_null.exit:                                ; preds = %if.then58, %if.end.i139
  %or75 = or i64 %iterflags.0, 64
  br label %if.end81

if.else76:                                        ; preds = %if.end29, %land.lhs.true, %land.lhs.true53
  %call77 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @force_list to i32 (%struct.op*, ...)*)(%struct.op* %expr) #4
  %call78 = tail call i32 (i32, i32, ...)* bitcast (i32 (...)* @mod to i32 (i32, i32, ...)*)(i32 %call77, i32 152) #4
  %conv79 = sext i32 %call78 to i64
  %47 = inttoptr i64 %conv79 to %struct.op*
  br label %if.end81

if.end81:                                         ; preds = %Perl_op_null.exit, %if.else76, %if.then38
  %iterflags.1 = phi i64 [ %or44, %if.then38 ], [ %or75, %Perl_op_null.exit ], [ %iterflags.0, %if.else76 ]
  %expr.addr.0 = phi %struct.op* [ %25, %if.then38 ], [ %call68, %Perl_op_null.exit ], [ %47, %if.else76 ]
  %call82 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %sv.addr.0) #4
  %call83 = tail call i32 (i32, %struct.op*, i32, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, i32, ...)*)(i32 141, %struct.op* %expr.addr.0, i32 %call82) #4
  %call84 = tail call i32 (i32, i64, i32, ...)* bitcast (i32 (...)* @convert to i32 (i32, i64, i32, ...)*)(i32 180, i64 %iterflags.1, i32 %call83) #4
  %call85 = tail call i32 (i32, ...)* bitcast (i32 (...)* @list to i32 (i32, ...)*)(i32 %call84) #4
  %conv86 = sext i32 %call85 to i64
  %48 = inttoptr i64 %conv86 to %struct.loop*
  %op_private88 = getelementptr inbounds %struct.loop* %48, i64 0, i32 7
  store i8 %iterpflags.0, i8* %op_private88, align 1, !tbaa !169
  %49 = inttoptr i64 %conv86 to i8*
  %call89 = tail call i8* @Perl_safesysrealloc(i8* %49, i64 80) #4
  %50 = bitcast i8* %call89 to %struct.loop*
  %op_targ90 = getelementptr inbounds i8* %call89, i64 24
  %51 = bitcast i8* %op_targ90 to i64*
  store i64 %padoff.0, i64* %51, align 8, !tbaa !175
  %call.i140 = tail call i8* @Perl_safesysmalloc(i64 40) #4
  %52 = bitcast i8* %call.i140 to %struct.op*
  tail call void @llvm.memset.p0i8.i64(i8* %call.i140, i8 0, i64 40, i32 1, i1 false) #4
  %op_type.i141 = getelementptr inbounds i8* %call.i140, i64 32
  %53 = bitcast i8* %op_type.i141 to i16*
  store i16 181, i16* %53, align 2, !tbaa !12
  %54 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 181), align 8, !tbaa !6
  %op_ppaddr.i142 = getelementptr inbounds i8* %call.i140, i64 16
  %55 = bitcast i8* %op_ppaddr.i142 to %struct.op* ()**
  store %struct.op* ()* %54, %struct.op* ()** %55, align 8, !tbaa !41
  %56 = getelementptr inbounds i8* %call.i140, i64 36
  store i8 0, i8* %56, align 1, !tbaa !14
  %op_next.i143 = bitcast i8* %call.i140 to %struct.op**
  store %struct.op* %52, %struct.op** %op_next.i143, align 8, !tbaa !42
  %57 = getelementptr inbounds i8* %call.i140, i64 37
  store i8 0, i8* %57, align 1, !tbaa !11
  %58 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 181), align 8, !tbaa !1
  %and.i144 = and i64 %58, 4
  %tobool.i145 = icmp eq i64 %and.i144, 0
  br i1 %tobool.i145, label %if.end.i148, label %if.then.i147

if.then.i147:                                     ; preds = %if.end81
  %call4.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %52) #4
  %.pre.i146 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 181), align 8, !tbaa !1
  br label %if.end.i148

if.end.i148:                                      ; preds = %if.then.i147, %if.end81
  %59 = phi i64 [ %58, %if.end81 ], [ %.pre.i146, %if.then.i147 ]
  %and6.i = and i64 %59, 8
  %tobool7.i = icmp eq i64 %and6.i, 0
  br i1 %tobool7.i, label %if.end11.i, label %if.then8.i

if.then8.i:                                       ; preds = %if.end.i148
  %call9.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 181, i32 512) #4
  %conv10.i = sext i32 %call9.i to i64
  %op_targ.i149 = getelementptr inbounds i8* %call.i140, i64 24
  %60 = bitcast i8* %op_targ.i149 to i64*
  store i64 %conv10.i, i64* %60, align 8, !tbaa !13
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then8.i, %if.end.i148
  %61 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool12.i = icmp eq i8* %61, null
  br i1 %tobool12.i, label %cond.false.i152, label %land.lhs.true.i150

land.lhs.true.i150:                               ; preds = %if.end11.i
  %arrayidx13.i = getelementptr inbounds i8* %61, i64 181
  %62 = load i8* %arrayidx13.i, align 1, !tbaa !5
  %tobool15.i = icmp eq i8 %62, 0
  br i1 %tobool15.i, label %cond.false.i152, label %cond.true.i151

cond.true.i151:                                   ; preds = %land.lhs.true.i150
  tail call void @Perl_op_free(%struct.op* %52) #4
  %63 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 181), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %63) #4
  br label %Perl_newOP.exit

cond.false.i152:                                  ; preds = %land.lhs.true.i150, %if.end11.i
  %64 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 181), align 8, !tbaa !6
  %call18.i = tail call %struct.op* %64(%struct.op* %52) #4
  br label %Perl_newOP.exit

Perl_newOP.exit:                                  ; preds = %cond.true.i151, %cond.false.i152
  %cond.i153 = phi %struct.op* [ null, %cond.true.i151 ], [ %call18.i, %cond.false.i152 ]
  %call92 = tail call %struct.op* @Perl_newWHILEOP(i64 %flags, i64 undef, %struct.loop* %50, i64 %forline, %struct.op* %cond.i153, %struct.op* %block, %struct.op* %cont)
  store i64 %forline, i64* @PL_copline, align 8, !tbaa !1
  %call93 = tail call %struct.op* @Perl_newSTATEOP(i64 0, i8* %label, %struct.op* %call92)
  ret %struct.op* %call93
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newLOOPEX(i64 %type, %struct.op* %label) #0 {
entry:
  %n_a = alloca i64, align 8
  %cmp = icmp eq i64 %type, 189
  %op_type = getelementptr inbounds %struct.op* %label, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  br i1 %cmp, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  switch i16 %0, label %if.end38 [
    i16 5, label %cond.true
    i16 166, label %land.lhs.true29
  ]

if.then:                                          ; preds = %entry
  switch i16 %0, label %cond.end20 [
    i16 1, label %land.lhs.true
    i16 5, label %cond.true
  ]

land.lhs.true:                                    ; preds = %if.then
  %op_flags = getelementptr inbounds %struct.op* %label, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %1, 8
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.end20, label %if.then8

if.then8:                                         ; preds = %land.lhs.true
  %call = call %struct.op* @Perl_newOP(i64 %type, i64 128)
  br label %if.end

cond.true:                                        ; preds = %if.then, %lor.lhs.false
  %op_sv = getelementptr inbounds %struct.op* %label, i64 1
  %2 = bitcast %struct.op* %op_sv to %struct.sv**
  %3 = load %struct.sv** %2, align 8, !tbaa !18
  store %struct.sv* %3, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i64* %sv_flags, align 8, !tbaa !34
  %and13 = and i64 %4, 262144
  %cmp14 = icmp eq i64 %and13, 0
  br i1 %cmp14, label %cond.false, label %cond.true16

cond.true16:                                      ; preds = %cond.true
  %sv_any = getelementptr inbounds %struct.sv* %3, i64 0, i32 0
  %5 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_cur = getelementptr inbounds i8* %5, i64 8
  %6 = bitcast i8* %xpv_cur to i64*
  %7 = load i64* %6, align 8, !tbaa !37
  store i64 %7, i64* %n_a, align 8, !tbaa !1
  %xpv_pv = bitcast i8* %5 to i8**
  %8 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %cond.end20

cond.false:                                       ; preds = %cond.true
  %call18 = call i8* @Perl_sv_2pv_flags(%struct.sv* %3, i64* %n_a, i64 2) #4
  br label %cond.end20

cond.end20:                                       ; preds = %if.then, %land.lhs.true, %cond.true16, %cond.false
  %cond21 = phi i8* [ %8, %cond.true16 ], [ %call18, %cond.false ], [ getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0), %land.lhs.true ], [ getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0), %if.then ]
  %call22 = call i8* @Perl_savepv(i8* %cond21) #4
  %call23 = call %struct.op* @Perl_newPVOP(i64 %type, i64 0, i8* %call22)
  br label %if.end

if.end:                                           ; preds = %cond.end20, %if.then8
  %o.0 = phi %struct.op* [ %call, %if.then8 ], [ %call23, %cond.end20 ]
  call void @Perl_op_free(%struct.op* %label)
  br label %if.end40

land.lhs.true29:                                  ; preds = %lor.lhs.false
  %op_flags30 = getelementptr inbounds %struct.op* %label, i64 0, i32 6
  %9 = load i8* %op_flags30, align 1, !tbaa !14
  %and32 = and i8 %9, 64
  %tobool33 = icmp eq i8 %and32, 0
  br i1 %tobool33, label %if.then34, label %if.end38

if.then34:                                        ; preds = %land.lhs.true29
  %call35 = call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i32, ...)*)(%struct.op* %label, i32 20) #4
  %conv36 = sext i32 %call35 to i64
  %10 = inttoptr i64 %conv36 to %struct.op*
  %call37 = call %struct.op* @Perl_newUNOP(i64 20, i64 0, %struct.op* %10)
  br label %if.end38

if.end38:                                         ; preds = %lor.lhs.false, %land.lhs.true29, %if.then34
  %label.addr.0 = phi %struct.op* [ %label, %land.lhs.true29 ], [ %call37, %if.then34 ], [ %label, %lor.lhs.false ]
  %call39 = call %struct.op* @Perl_newUNOP(i64 189, i64 64, %struct.op* %label.addr.0)
  br label %if.end40

if.end40:                                         ; preds = %if.end38, %if.end
  %o.1 = phi %struct.op* [ %o.0, %if.end ], [ %call39, %if.end38 ]
  %11 = load i64* @PL_hints, align 8, !tbaa !1
  %or = or i64 %11, 256
  store i64 %or, i64* @PL_hints, align 8, !tbaa !1
  ret %struct.op* %o.1
}

declare i8* @Perl_savepv(i8*) #2

; Function Attrs: nounwind uwtable
define void @Perl_cv_undef(%struct.cv* %cv) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.cv* %cv, i64 0, i32 0
  %0 = load %struct.xpvcv** %sv_any, align 8, !tbaa !66
  %xcv_xsub = getelementptr inbounds %struct.xpvcv* %0, i64 0, i32 10
  %1 = load void (%struct.cv*)** %xcv_xsub, align 8, !tbaa !139
  %tobool = icmp eq void (%struct.cv*)* %1, null
  br i1 %tobool, label %land.lhs.true, label %if.end14

land.lhs.true:                                    ; preds = %entry
  %xcv_root = getelementptr inbounds %struct.xpvcv* %0, i64 0, i32 9
  %2 = load %struct.op** %xcv_root, align 8, !tbaa !138
  %tobool2 = icmp eq %struct.op* %2, null
  br i1 %tobool2, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %xcv_depth = getelementptr inbounds %struct.xpvcv* %0, i64 0, i32 14
  %3 = load i64* %xcv_depth, align 8, !tbaa !176
  %tobool4 = icmp eq i64 %3, 0
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %if.then
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([30 x i8]* @.str55, i64 0, i64 0)) #4
  br label %if.end

if.end:                                           ; preds = %if.then, %if.then5
  tail call void @Perl_push_scope() #4
  %4 = load i64* @PL_savestack_ix, align 8, !tbaa !1
  %add = add nsw i64 %4, 2
  %5 = load i64* @PL_savestack_max, align 8, !tbaa !1
  %cmp = icmp sgt i64 %add, %5
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  tail call void @Perl_savestack_grow() #4
  %.pre = load i64* @PL_savestack_ix, align 8, !tbaa !1
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  %6 = phi i64 [ %.pre, %if.then6 ], [ %4, %if.end ]
  %7 = load %struct.av** @PL_comppad, align 8, !tbaa !6
  %8 = bitcast %struct.av* %7 to i8*
  %inc = add nsw i64 %6, 1
  %9 = load %union.any** @PL_savestack, align 8, !tbaa !6
  %any_ptr = getelementptr inbounds %union.any* %9, i64 %6, i32 0
  store i8* %8, i8** %any_ptr, align 8, !tbaa !6
  %inc8 = add nsw i64 %6, 2
  store i64 %inc8, i64* @PL_savestack_ix, align 8, !tbaa !1
  %10 = load %union.any** @PL_savestack, align 8, !tbaa !6
  %11 = getelementptr inbounds %union.any* %10, i64 %inc, i32 0
  store i8* inttoptr (i64 33 to i8*), i8** %11, align 8, !tbaa !1
  store %struct.av* null, %struct.av** @PL_comppad, align 8, !tbaa !6
  store %struct.sv** null, %struct.sv*** @PL_curpad, align 8, !tbaa !6
  %12 = load %struct.xpvcv** %sv_any, align 8, !tbaa !66
  %xcv_root11 = getelementptr inbounds %struct.xpvcv* %12, i64 0, i32 9
  %13 = load %struct.op** %xcv_root11, align 8, !tbaa !138
  tail call void @Perl_op_free(%struct.op* %13)
  %14 = load %struct.xpvcv** %sv_any, align 8, !tbaa !66
  %xcv_root13 = getelementptr inbounds %struct.xpvcv* %14, i64 0, i32 9
  store %struct.op* null, %struct.op** %xcv_root13, align 8, !tbaa !138
  tail call void @Perl_pop_scope() #4
  %.pre75 = load %struct.xpvcv** %sv_any, align 8, !tbaa !66
  br label %if.end14

if.end14:                                         ; preds = %land.lhs.true, %entry, %if.end7
  %15 = phi %struct.xpvcv* [ %0, %land.lhs.true ], [ %0, %entry ], [ %.pre75, %if.end7 ]
  %16 = getelementptr inbounds %struct.cv* %cv, i64 0, i32 2
  %17 = load i64* %16, align 8, !tbaa !34
  %and = and i64 %17, -67371009
  store i64 %and, i64* %16, align 8, !tbaa !34
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %15, i64 0, i32 12
  store %struct.gv* null, %struct.gv** %xcv_gv, align 8, !tbaa !145
  %call = tail call i32 (%struct.cv*, ...)* bitcast (i32 (...)* @pad_undef to i32 (%struct.cv*, ...)*)(%struct.cv* %cv) #4
  %sv_refcnt = getelementptr inbounds %struct.cv* %cv, i64 0, i32 1
  %18 = load i64* %sv_refcnt, align 8, !tbaa !177
  %tobool16 = icmp eq i64 %18, 0
  %19 = load %struct.xpvcv** %sv_any, align 8, !tbaa !66
  br i1 %tobool16, label %land.lhs.true17, label %if.end30

land.lhs.true17:                                  ; preds = %if.end14
  %xcv_outside = getelementptr inbounds %struct.xpvcv* %19, i64 0, i32 16
  %20 = load %struct.cv** %xcv_outside, align 8, !tbaa !148
  %tobool19 = icmp eq %struct.cv* %20, null
  br i1 %tobool19, label %if.end30, label %if.then20

if.then20:                                        ; preds = %land.lhs.true17
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %19, i64 0, i32 17
  %21 = load i16* %xcv_flags, align 2, !tbaa !68
  %and22 = and i16 %21, 1024
  %tobool23 = icmp eq i16 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end27

if.then24:                                        ; preds = %if.then20
  %22 = bitcast %struct.cv* %20 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %22) #4
  %.pre76 = load %struct.xpvcv** %sv_any, align 8, !tbaa !66
  br label %if.end27

if.end27:                                         ; preds = %if.then20, %if.then24
  %23 = phi %struct.xpvcv* [ %19, %if.then20 ], [ %.pre76, %if.then24 ]
  %xcv_outside29 = getelementptr inbounds %struct.xpvcv* %23, i64 0, i32 16
  store %struct.cv* null, %struct.cv** %xcv_outside29, align 8, !tbaa !148
  br label %if.end30

if.end30:                                         ; preds = %if.end14, %land.lhs.true17, %if.end27
  %24 = phi %struct.xpvcv* [ %19, %land.lhs.true17 ], [ %23, %if.end27 ], [ %19, %if.end14 ]
  %xcv_flags32 = getelementptr inbounds %struct.xpvcv* %24, i64 0, i32 17
  %25 = load i16* %xcv_flags32, align 2, !tbaa !68
  %and34 = and i16 %25, 512
  %tobool35 = icmp eq i16 %and34, 0
  br i1 %tobool35, label %if.end44, label %if.then36

if.then36:                                        ; preds = %if.end30
  %any_ptr38 = getelementptr inbounds %struct.xpvcv* %24, i64 0, i32 11, i32 0
  %26 = load i8** %any_ptr38, align 8, !tbaa !6
  %27 = bitcast i8* %26 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %27) #4
  %28 = load %struct.xpvcv** %sv_any, align 8, !tbaa !66
  %xcv_flags40 = getelementptr inbounds %struct.xpvcv* %28, i64 0, i32 17
  %29 = load i16* %xcv_flags40, align 2, !tbaa !68
  %and42 = and i16 %29, -513
  store i16 %and42, i16* %xcv_flags40, align 2, !tbaa !68
  br label %if.end44

if.end44:                                         ; preds = %if.end30, %if.then36
  %30 = phi i16 [ %25, %if.end30 ], [ %and42, %if.then36 ]
  %31 = phi %struct.xpvcv* [ %24, %if.end30 ], [ %28, %if.then36 ]
  %xcv_xsub46 = getelementptr inbounds %struct.xpvcv* %31, i64 0, i32 10
  %32 = load void (%struct.cv*)** %xcv_xsub46, align 8, !tbaa !139
  %tobool47 = icmp eq void (%struct.cv*)* %32, null
  br i1 %tobool47, label %if.end51, label %if.then48

if.then48:                                        ; preds = %if.end44
  store void (%struct.cv*)* null, void (%struct.cv*)** %xcv_xsub46, align 8, !tbaa !139
  br label %if.end51

if.end51:                                         ; preds = %if.end44, %if.then48
  %xcv_flags53 = getelementptr inbounds %struct.xpvcv* %31, i64 0, i32 17
  %and55 = and i16 %30, 1024
  store i16 %and55, i16* %xcv_flags53, align 2, !tbaa !68
  ret void
}

declare void @Perl_push_scope() #2

declare void @Perl_pop_scope() #2

declare i32 @pad_undef(...) #2

; Function Attrs: nounwind uwtable
define void @Perl_cv_ckproto(%struct.cv* %cv, %struct.gv* %gv, i8* %p) #0 {
entry:
  %tobool = icmp ne i8* %p, null
  %0 = zext i1 %tobool to i32
  %lnot.ext = xor i32 %0, 1
  %sv_flags = getelementptr inbounds %struct.cv* %cv, i64 0, i32 2
  %1 = load i64* %sv_flags, align 8, !tbaa !140
  %and = lshr i64 %1, 18
  %and.lobit = and i64 %and, 1
  %2 = xor i64 %and.lobit, 1
  %lnot.ext3 = trunc i64 %2 to i32
  %cmp = icmp eq i32 %lnot.ext, %lnot.ext3
  br i1 %cmp, label %lor.lhs.false, label %land.lhs.true6

lor.lhs.false:                                    ; preds = %entry
  br i1 %tobool, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %lor.lhs.false
  %sv_any = getelementptr inbounds %struct.cv* %cv, i64 0, i32 0
  %3 = load %struct.xpvcv** %sv_any, align 8, !tbaa !66
  %xpv_pv = getelementptr inbounds %struct.xpvcv* %3, i64 0, i32 0
  %4 = load i8** %xpv_pv, align 8, !tbaa !39
  %call = tail call i32 @strcmp(i8* %p, i8* %4) #4
  %tobool5 = icmp eq i32 %call, 0
  br i1 %tobool5, label %if.end36, label %land.lhs.true6

land.lhs.true6:                                   ; preds = %land.lhs.true, %entry
  %5 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %5, i64 0, i32 14
  %6 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp7 = icmp eq %struct.sv* %6, null
  br i1 %cmp7, label %if.then, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %land.lhs.true6
  %7 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings9 = getelementptr inbounds %struct.cop* %7, i64 0, i32 14
  %8 = load %struct.sv** %cop_warnings9, align 8, !tbaa !47
  %cmp10 = icmp eq %struct.sv* %8, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp10, label %if.then, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %lor.lhs.false8
  %9 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings12 = getelementptr inbounds %struct.cop* %9, i64 0, i32 14
  %10 = load %struct.sv** %cop_warnings12, align 8, !tbaa !47
  %cmp13 = icmp eq %struct.sv* %10, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp13, label %if.end36, label %land.lhs.true14

land.lhs.true14:                                  ; preds = %lor.lhs.false11
  %11 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings15 = getelementptr inbounds %struct.cop* %11, i64 0, i32 14
  %12 = load %struct.sv** %cop_warnings15, align 8, !tbaa !47
  %sv_any16 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %13 = load i8** %sv_any16, align 8, !tbaa !36
  %xpv_pv17 = bitcast i8* %13 to i8**
  %14 = load i8** %xpv_pv17, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8* %14, i64 8
  %15 = load i8* %arrayidx, align 1, !tbaa !5
  %and18 = and i8 %15, 64
  %tobool19 = icmp eq i8 %and18, 0
  br i1 %tobool19, label %if.end36, label %if.then

if.then:                                          ; preds = %land.lhs.true14, %lor.lhs.false8, %land.lhs.true6
  %call20 = tail call %struct.sv* @Perl_sv_newmortal() #4
  %tobool21 = icmp eq %struct.gv* %gv, null
  br i1 %tobool21, label %if.end.thread, label %if.end

if.end.thread:                                    ; preds = %if.then
  tail call void @Perl_sv_setpv(%struct.sv* %call20, i8* getelementptr inbounds ([20 x i8]* @.str56, i64 0, i64 0)) #4
  br label %if.end26

if.end:                                           ; preds = %if.then
  %call23 = tail call %struct.sv* @Perl_sv_newmortal() #4
  tail call void @Perl_gv_efullname4(%struct.sv* %call23, %struct.gv* %gv, i8* null, i8 signext 1) #4
  tail call void @Perl_sv_setpv(%struct.sv* %call20, i8* getelementptr inbounds ([20 x i8]* @.str56, i64 0, i64 0)) #4
  %tobool24 = icmp eq %struct.sv* %call23, null
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.end
  tail call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %call20, i8* getelementptr inbounds ([8 x i8]* @.str57, i64 0, i64 0), %struct.sv* %call23) #4
  br label %if.end26

if.end26:                                         ; preds = %if.end.thread, %if.end, %if.then25
  %16 = load i64* %sv_flags, align 8, !tbaa !140
  %and28 = and i64 %16, 262144
  %tobool29 = icmp eq i64 %and28, 0
  br i1 %tobool29, label %if.else, label %if.then30

if.then30:                                        ; preds = %if.end26
  tail call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %call20, i8* getelementptr inbounds ([6 x i8]* @.str58, i64 0, i64 0), %struct.cv* %cv) #4
  br label %if.end31

if.else:                                          ; preds = %if.end26
  tail call void @Perl_sv_catpv(%struct.sv* %call20, i8* getelementptr inbounds ([7 x i8]* @.str59, i64 0, i64 0)) #4
  br label %if.end31

if.end31:                                         ; preds = %if.else, %if.then30
  tail call void @Perl_sv_catpv(%struct.sv* %call20, i8* getelementptr inbounds ([5 x i8]* @.str60, i64 0, i64 0)) #4
  br i1 %tobool, label %if.then33, label %if.else34

if.then33:                                        ; preds = %if.end31
  tail call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %call20, i8* getelementptr inbounds ([5 x i8]* @.str61, i64 0, i64 0), i8* %p) #4
  br label %if.end35

if.else34:                                        ; preds = %if.end31
  tail call void @Perl_sv_catpv(%struct.sv* %call20, i8* getelementptr inbounds ([5 x i8]* @.str62, i64 0, i64 0)) #4
  br label %if.end35

if.end35:                                         ; preds = %if.else34, %if.then33
  tail call void (i64, i8*, ...)* @Perl_warner(i64 35, i8* getelementptr inbounds ([3 x i8]* @.str63, i64 0, i64 0), %struct.sv* %call20) #4
  br label %if.end36

if.end36:                                         ; preds = %land.lhs.true14, %lor.lhs.false11, %land.lhs.true, %if.end35, %lor.lhs.false
  ret void
}

declare %struct.sv* @Perl_sv_newmortal() #2

declare void @Perl_gv_efullname4(%struct.sv*, %struct.gv*, i8*, i8 signext) #2

declare void @Perl_sv_catpv(%struct.sv*, i8*) #2

; Function Attrs: nounwind readonly uwtable
define %struct.sv* @Perl_cv_const_sv(%struct.cv* readonly %cv) #5 {
entry:
  %tobool = icmp eq %struct.cv* %cv, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %sv_any = getelementptr inbounds %struct.cv* %cv, i64 0, i32 0
  %0 = load %struct.xpvcv** %sv_any, align 8, !tbaa !66
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %0, i64 0, i32 17
  %1 = load i16* %xcv_flags, align 2, !tbaa !68
  %and = and i16 %1, 512
  %tobool1 = icmp eq i16 %and, 0
  br i1 %tobool1, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %any_ptr = getelementptr inbounds %struct.xpvcv* %0, i64 0, i32 11, i32 0
  %2 = load i8** %any_ptr, align 8, !tbaa !6
  %3 = bitcast i8* %2 to %struct.sv*
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi %struct.sv* [ %3, %if.end ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret %struct.sv* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.sv* @Perl_op_const_sv(%struct.op* readonly %o, %struct.cv* readonly %cv) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %0, 173
  br i1 %cmp, label %land.lhs.true, label %for.body.lr.ph

land.lhs.true:                                    ; preds = %if.end
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !45
  %tobool2 = icmp eq %struct.op* %2, null
  br i1 %tobool2, label %for.cond.preheader, label %if.then3

if.then3:                                         ; preds = %land.lhs.true
  %op_sibling = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %3 = load %struct.op** %op_sibling, align 8, !tbaa !17
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.then3, %land.lhs.true
  %o.addr.0.ph = phi %struct.op* [ %o, %land.lhs.true ], [ %3, %if.then3 ]
  %tobool6137 = icmp eq %struct.op* %o.addr.0.ph, null
  br i1 %tobool6137, label %return, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %if.end, %for.cond.preheader
  %o.addr.0.ph152 = phi %struct.op* [ %o.addr.0.ph, %for.cond.preheader ], [ %o, %if.end ]
  %tobool63 = icmp eq %struct.cv* %cv, null
  %sv_any = getelementptr inbounds %struct.cv* %cv, i64 0, i32 0
  %tobool63.old = icmp eq %struct.cv* %cv, null
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %sv.0139 = phi %struct.sv* [ null, %for.body.lr.ph ], [ %sv.2, %for.inc ]
  %o.addr.0138 = phi %struct.op* [ %o.addr.0.ph152, %for.body.lr.ph ], [ %22, %for.inc ]
  %op_type7 = getelementptr inbounds %struct.op* %o.addr.0138, i64 0, i32 4
  %4 = load i16* %op_type7, align 2, !tbaa !12
  %tobool8 = icmp ne %struct.sv* %sv.0139, null
  %op_next = getelementptr inbounds %struct.op* %o.addr.0138, i64 0, i32 0
  %5 = load %struct.op** %op_next, align 8, !tbaa !42
  %cmp10 = icmp eq %struct.op* %5, %o.addr.0138
  %or.cond = and i1 %tobool8, %cmp10
  br i1 %or.cond, label %return, label %if.end13

if.end13:                                         ; preds = %for.body
  %op_next14 = getelementptr inbounds %struct.op* %o.addr.0138, i64 0, i32 0
  %cmp15 = icmp eq %struct.op* %5, %o.addr.0138
  br i1 %cmp15, label %if.end35, label %if.then17

if.then17:                                        ; preds = %if.end13
  switch i16 %4, label %if.end44 [
    i16 174, label %for.inc
    i16 0, label %for.inc
    i16 3, label %for.inc
    i16 175, label %for.inc
    i16 167, label %for.end
    i16 184, label %for.end
  ]

if.end35:                                         ; preds = %if.end13
  switch i16 %4, label %if.end44 [
    i16 167, label %for.end
    i16 184, label %for.end
  ]

if.end44:                                         ; preds = %if.then17, %if.end35
  br i1 %tobool8, label %return, label %if.end47

if.end47:                                         ; preds = %if.end44
  %cmp49 = icmp eq i16 %4, 5
  br i1 %cmp49, label %land.lhs.true51, label %if.else

land.lhs.true51:                                  ; preds = %if.end47
  %op_sv = getelementptr inbounds %struct.op* %o.addr.0138, i64 1
  %6 = bitcast %struct.op* %op_sv to %struct.sv**
  %7 = load %struct.sv** %6, align 8, !tbaa !18
  %tobool52 = icmp eq %struct.sv* %7, null
  br i1 %tobool52, label %lor.lhs.false58, label %for.inc

if.else:                                          ; preds = %if.end47
  %cmp56 = icmp ne i16 %4, 9
  %or.cond135 = or i1 %cmp56, %tobool63.old
  br i1 %or.cond135, label %return, label %if.then64

lor.lhs.false58:                                  ; preds = %land.lhs.true51
  br i1 %tobool63, label %return, label %if.then64

if.then64:                                        ; preds = %lor.lhs.false58, %if.else
  %8 = load %struct.xpvcv** %sv_any, align 8, !tbaa !66
  %xcv_padlist = getelementptr inbounds %struct.xpvcv* %8, i64 0, i32 15
  %9 = load %struct.av** %xcv_padlist, align 8, !tbaa !150
  %sv_any65 = getelementptr inbounds %struct.av* %9, i64 0, i32 0
  %10 = load %struct.xpvav** %sv_any65, align 8, !tbaa !161
  %xav_array = getelementptr inbounds %struct.xpvav* %10, i64 0, i32 0
  %11 = load i8** %xav_array, align 8, !tbaa !163
  %arrayidx = getelementptr inbounds i8* %11, i64 8
  %12 = bitcast i8* %arrayidx to %struct.sv**
  %13 = load %struct.sv** %12, align 8, !tbaa !6
  %tobool66 = icmp eq %struct.sv* %13, null
  br i1 %tobool66, label %return, label %cond.end

cond.end:                                         ; preds = %if.then64
  %op_targ = getelementptr inbounds %struct.op* %o.addr.0138, i64 0, i32 3
  %14 = load i64* %op_targ, align 8, !tbaa !13
  %sv_any72 = bitcast %struct.sv* %13 to %struct.xpvav**
  %15 = load %struct.xpvav** %sv_any72, align 8, !tbaa !161
  %xav_array73 = getelementptr inbounds %struct.xpvav* %15, i64 0, i32 0
  %16 = load i8** %xav_array73, align 8, !tbaa !163
  %17 = bitcast i8* %16 to %struct.sv**
  %arrayidx74 = getelementptr inbounds %struct.sv** %17, i64 %14
  %18 = load %struct.sv** %arrayidx74, align 8, !tbaa !6
  %tobool75 = icmp eq %struct.sv* %18, null
  br i1 %tobool75, label %return, label %if.end77

if.end77:                                         ; preds = %cond.end
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %8, i64 0, i32 17
  %19 = load i16* %xcv_flags, align 2, !tbaa !68
  %and = and i16 %19, 512
  %tobool80 = icmp eq i16 %and, 0
  br i1 %tobool80, label %if.end82, label %if.then81

if.then81:                                        ; preds = %if.end77
  %call = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %18) #4
  br label %if.end82

if.end82:                                         ; preds = %if.end77, %if.then81
  %sv.1 = phi %struct.sv* [ %call, %if.then81 ], [ %18, %if.end77 ]
  %sv_flags = getelementptr inbounds %struct.sv* %sv.1, i64 0, i32 2
  %20 = load i64* %sv_flags, align 8, !tbaa !34
  %and83 = and i64 %20, 8388608
  %tobool84 = icmp eq i64 %and83, 0
  br i1 %tobool84, label %land.lhs.true85, label %for.inc

land.lhs.true85:                                  ; preds = %if.end82
  %sv_refcnt = getelementptr inbounds %struct.sv* %sv.1, i64 0, i32 1
  %21 = load i64* %sv_refcnt, align 8, !tbaa !40
  %cmp86 = icmp ugt i64 %21, 1
  br i1 %cmp86, label %return, label %for.inc

for.inc:                                          ; preds = %land.lhs.true51, %if.then17, %if.then17, %if.then17, %if.then17, %if.end82, %land.lhs.true85
  %sv.2 = phi %struct.sv* [ %sv.0139, %if.then17 ], [ %sv.1, %if.end82 ], [ %sv.1, %land.lhs.true85 ], [ %sv.0139, %if.then17 ], [ %sv.0139, %if.then17 ], [ %sv.0139, %if.then17 ], [ %7, %land.lhs.true51 ]
  %22 = load %struct.op** %op_next14, align 8, !tbaa !42
  %tobool6 = icmp eq %struct.op* %22, null
  br i1 %tobool6, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %if.end35, %if.end35, %if.then17, %if.then17
  %sv.0.lcssa = phi %struct.sv* [ %sv.0139, %if.then17 ], [ %sv.0139, %if.then17 ], [ %sv.0139, %if.end35 ], [ %sv.0139, %if.end35 ], [ %sv.2, %for.inc ]
  %tobool94 = icmp eq %struct.sv* %sv.0.lcssa, null
  br i1 %tobool94, label %return, label %if.then95

if.then95:                                        ; preds = %for.end
  %sv_flags96 = getelementptr inbounds %struct.sv* %sv.0.lcssa, i64 0, i32 2
  %23 = load i64* %sv_flags96, align 8, !tbaa !34
  %or = or i64 %23, 8388608
  store i64 %or, i64* %sv_flags96, align 8, !tbaa !34
  br label %return

return:                                           ; preds = %for.body, %if.else, %if.then64, %land.lhs.true85, %cond.end, %if.end44, %lor.lhs.false58, %for.cond.preheader, %if.then95, %for.end, %entry
  %retval.0 = phi %struct.sv* [ null, %entry ], [ null, %for.end ], [ %sv.0.lcssa, %if.then95 ], [ null, %for.cond.preheader ], [ %sv.0139, %for.body ], [ null, %if.else ], [ null, %if.then64 ], [ null, %land.lhs.true85 ], [ null, %cond.end ], [ null, %if.end44 ], [ null, %lor.lhs.false58 ]
  ret %struct.sv* %retval.0
}

; Function Attrs: nounwind uwtable
define void @Perl_newMYSUB(i64 %floor, %struct.op* %o, %struct.op* %proto, %struct.op* %attrs, %struct.op* %block) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @save_freeop to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %tobool1 = icmp eq %struct.op* %proto, null
  br i1 %tobool1, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %call3 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @save_freeop to i32 (%struct.op*, ...)*)(%struct.op* %proto) #4
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.then2
  %tobool5 = icmp eq %struct.op* %attrs, null
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end4
  %call7 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @save_freeop to i32 (%struct.op*, ...)*)(%struct.op* %attrs) #4
  br label %if.end8

if.end8:                                          ; preds = %if.end4, %if.then6
  %tobool9 = icmp eq %struct.op* %block, null
  br i1 %tobool9, label %if.end12, label %if.then10

if.then10:                                        ; preds = %if.end8
  %call11 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @save_freeop to i32 (%struct.op*, ...)*)(%struct.op* %block) #4
  br label %if.end12

if.end12:                                         ; preds = %if.end8, %if.then10
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([29 x i8]* @.str64, i64 0, i64 0)) #4
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.cv* @Perl_newSUB(i64 %floor, %struct.op* %o, %struct.op* %proto, %struct.op* %block) #0 {
entry:
  %call = tail call %struct.cv* @Perl_newATTRSUB(i64 %floor, %struct.op* %o, %struct.op* %proto, %struct.op* null, %struct.op* %block)
  ret %struct.cv* %call
}

declare void @Perl_sv_setpvf(%struct.sv*, i8*, ...) #2

declare i32 @cv_ckproto(...) #2

declare i32 @op_const_sv(...) #2

declare i64 @Perl_sv_cmp(%struct.sv*, %struct.sv*) #2

; Function Attrs: nounwind uwtable
define internal void @const_sv_xsub(%struct.cv* nocapture readonly %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !6
  %1 = load i64** @PL_markstack_ptr, align 8, !tbaa !6
  %incdec.ptr = getelementptr inbounds i64* %1, i64 -1
  store i64* %incdec.ptr, i64** @PL_markstack_ptr, align 8, !tbaa !6
  %2 = load i64* %1, align 8, !tbaa !1
  %add.ptr.idx = shl nuw i64 %2, 3
  %sub.ptr.div = ashr exact i64 %add.ptr.idx, 3
  %add = add nsw i64 %sub.ptr.div, 1
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %3 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !6
  %sub.ptr.lhs.cast5 = ptrtoint %struct.sv** %3 to i64
  %sub.ptr.sub7 = sub i64 %sub.ptr.lhs.cast5, %sub.ptr.lhs.cast1
  %cmp9 = icmp slt i64 %sub.ptr.sub7, 8
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %entry
  %call = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %0, %struct.sv** %0, i32 1) #4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %entry
  %sv_any = getelementptr inbounds %struct.cv* %cv, i64 0, i32 0
  %4 = load %struct.xpvcv** %sv_any, align 8, !tbaa !66
  %any_ptr = getelementptr inbounds %struct.xpvcv* %4, i64 0, i32 11, i32 0
  %5 = load i8** %any_ptr, align 8, !tbaa !6
  %6 = bitcast i8* %5 to %struct.sv*
  %7 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !6
  %arrayidx = getelementptr inbounds %struct.sv** %7, i64 %add
  store %struct.sv* %6, %struct.sv** %arrayidx, align 8, !tbaa !6
  %8 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !6
  %add.ptr13 = getelementptr inbounds %struct.sv** %8, i64 %add
  store %struct.sv** %add.ptr13, %struct.sv*** @PL_stack_sp, align 8, !tbaa !6
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.cv* @Perl_newCONSTSUB(%struct.hv* %stash, i8* %name, %struct.sv* %sv) #0 {
entry:
  tail call void @Perl_push_scope() #4
  %0 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line = getelementptr inbounds %struct.cop* %0, i64 0, i32 13
  tail call void @Perl_save_I32(i64* %cop_line) #4
  %1 = load i64* @PL_copline, align 8, !tbaa !1
  %2 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line1 = getelementptr inbounds %struct.cop* %2, i64 0, i32 13
  store i64 %1, i64* %cop_line1, align 8, !tbaa !116
  %3 = load i64* @PL_savestack_ix, align 8, !tbaa !1
  %add = add nsw i64 %3, 3
  %4 = load i64* @PL_savestack_max, align 8, !tbaa !1
  %cmp = icmp sgt i64 %add, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @Perl_savestack_grow() #4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i64* @PL_hints, align 8, !tbaa !1
  %and = and i64 %5, 131072
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.end9, label %if.then2

if.then2:                                         ; preds = %if.end
  %6 = load %struct.gv** @PL_hintgv, align 8, !tbaa !6
  %sv_any = getelementptr inbounds %struct.gv* %6, i64 0, i32 0
  %7 = load %struct.xpvgv** %sv_any, align 8, !tbaa !60
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %7, i64 0, i32 7
  %8 = load %struct.gp** %xgv_gp, align 8, !tbaa !62
  %gp_hv = getelementptr inbounds %struct.gp* %8, i64 0, i32 5
  %9 = load %struct.hv** %gp_hv, align 8, !tbaa !94
  %10 = bitcast %struct.hv* %9 to i8*
  %11 = load i64* @PL_savestack_ix, align 8, !tbaa !1
  %inc = add nsw i64 %11, 1
  store i64 %inc, i64* @PL_savestack_ix, align 8, !tbaa !1
  %12 = load %union.any** @PL_savestack, align 8, !tbaa !6
  %any_ptr = getelementptr inbounds %union.any* %12, i64 %11, i32 0
  store i8* %10, i8** %any_ptr, align 8, !tbaa !6
  %13 = load %struct.gv** @PL_hintgv, align 8, !tbaa !6
  %sv_any3 = getelementptr inbounds %struct.gv* %13, i64 0, i32 0
  %14 = load %struct.xpvgv** %sv_any3, align 8, !tbaa !60
  %xgv_gp4 = getelementptr inbounds %struct.xpvgv* %14, i64 0, i32 7
  %15 = load %struct.gp** %xgv_gp4, align 8, !tbaa !62
  %gp_hv5 = getelementptr inbounds %struct.gp* %15, i64 0, i32 5
  %16 = load %struct.hv** %gp_hv5, align 8, !tbaa !94
  %call = tail call %struct.hv* @Perl_newHVhv(%struct.hv* %16) #4
  %17 = load %struct.gv** @PL_hintgv, align 8, !tbaa !6
  %sv_any6 = getelementptr inbounds %struct.gv* %17, i64 0, i32 0
  %18 = load %struct.xpvgv** %sv_any6, align 8, !tbaa !60
  %xgv_gp7 = getelementptr inbounds %struct.xpvgv* %18, i64 0, i32 7
  %19 = load %struct.gp** %xgv_gp7, align 8, !tbaa !62
  %gp_hv8 = getelementptr inbounds %struct.gp* %19, i64 0, i32 5
  store %struct.hv* %call, %struct.hv** %gp_hv8, align 8, !tbaa !94
  %.pre = load i64* @PL_hints, align 8, !tbaa !1
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then2
  %20 = phi i64 [ %5, %if.end ], [ %.pre, %if.then2 ]
  %21 = load i64* @PL_savestack_ix, align 8, !tbaa !1
  %inc10 = add nsw i64 %21, 1
  store i64 %inc10, i64* @PL_savestack_ix, align 8, !tbaa !1
  %22 = load %union.any** @PL_savestack, align 8, !tbaa !6
  %23 = getelementptr inbounds %union.any* %22, i64 %21, i32 0
  %.c = inttoptr i64 %20 to i8*
  store i8* %.c, i8** %23, align 8, !tbaa !1
  %24 = load i64* @PL_savestack_ix, align 8, !tbaa !1
  %inc12 = add nsw i64 %24, 1
  store i64 %inc12, i64* @PL_savestack_ix, align 8, !tbaa !1
  %25 = getelementptr inbounds %union.any* %22, i64 %24, i32 0
  store i8* inttoptr (i64 27 to i8*), i8** %25, align 8, !tbaa !1
  %26 = load i64* @PL_hints, align 8, !tbaa !1
  %and15 = and i64 %26, -257
  store i64 %and15, i64* @PL_hints, align 8, !tbaa !1
  %tobool16 = icmp eq %struct.hv* %stash, null
  br i1 %tobool16, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.end9
  tail call void @Perl_save_sptr(%struct.sv** bitcast (%struct.hv** @PL_curstash to %struct.sv**)) #4
  %27 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_stash = getelementptr inbounds %struct.cop* %27, i64 0, i32 9
  %28 = bitcast %struct.hv** %cop_stash to %struct.sv**
  tail call void @Perl_save_sptr(%struct.sv** %28) #4
  store %struct.hv* %stash, %struct.hv** @PL_curstash, align 8, !tbaa !6
  %29 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_stash18 = getelementptr inbounds %struct.cop* %29, i64 0, i32 9
  store %struct.hv* %stash, %struct.hv** %cop_stash18, align 8, !tbaa !159
  br label %if.end19

if.end19:                                         ; preds = %if.end9, %if.then17
  %30 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv = getelementptr inbounds %struct.cop* %30, i64 0, i32 10
  %31 = load %struct.gv** %cop_filegv, align 8, !tbaa !97
  %tobool20 = icmp eq %struct.gv* %31, null
  br i1 %tobool20, label %cond.end36, label %cond.true

cond.true:                                        ; preds = %if.end19
  %32 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv21 = getelementptr inbounds %struct.cop* %32, i64 0, i32 10
  %33 = load %struct.gv** %cop_filegv21, align 8, !tbaa !97
  %sv_any22 = getelementptr inbounds %struct.gv* %33, i64 0, i32 0
  %34 = load %struct.xpvgv** %sv_any22, align 8, !tbaa !60
  %xgv_gp23 = getelementptr inbounds %struct.xpvgv* %34, i64 0, i32 7
  %35 = load %struct.gp** %xgv_gp23, align 8, !tbaa !62
  %gp_sv = getelementptr inbounds %struct.gp* %35, i64 0, i32 0
  %36 = load %struct.sv** %gp_sv, align 8, !tbaa !135
  %tobool24 = icmp eq %struct.sv* %36, null
  br i1 %tobool24, label %cond.end36, label %cond.true25

cond.true25:                                      ; preds = %cond.true
  %37 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %38 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv29 = getelementptr inbounds %struct.cop* %38, i64 0, i32 10
  %39 = load %struct.gv** %cop_filegv29, align 8, !tbaa !97
  %sv_any30 = getelementptr inbounds %struct.gv* %39, i64 0, i32 0
  %40 = load %struct.xpvgv** %sv_any30, align 8, !tbaa !60
  %xgv_gp31 = getelementptr inbounds %struct.xpvgv* %40, i64 0, i32 7
  %41 = load %struct.gp** %xgv_gp31, align 8, !tbaa !62
  %gp_sv32 = getelementptr inbounds %struct.gp* %41, i64 0, i32 0
  %42 = load %struct.sv** %gp_sv32, align 8, !tbaa !135
  %sv_any34 = getelementptr inbounds %struct.sv* %42, i64 0, i32 0
  %43 = load i8** %sv_any34, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %43 to i8**
  %44 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %cond.end36

cond.end36:                                       ; preds = %cond.true, %if.end19, %cond.true25
  %cond37 = phi i8* [ %44, %cond.true25 ], [ null, %if.end19 ], [ null, %cond.true ]
  %call38 = tail call i8* @Perl_savepv(i8* %cond37) #4
  %call39 = tail call %struct.cv* @Perl_newXS(i8* %name, void (%struct.cv*)* @const_sv_xsub, i8* %call38)
  %45 = bitcast %struct.sv* %sv to i8*
  %sv_any40 = getelementptr inbounds %struct.cv* %call39, i64 0, i32 0
  %46 = load %struct.xpvcv** %sv_any40, align 8, !tbaa !66
  %any_ptr41 = getelementptr inbounds %struct.xpvcv* %46, i64 0, i32 11, i32 0
  store i8* %45, i8** %any_ptr41, align 8, !tbaa !6
  %47 = load %struct.xpvcv** %sv_any40, align 8, !tbaa !66
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %47, i64 0, i32 17
  %48 = load i16* %xcv_flags, align 2, !tbaa !68
  %or = or i16 %48, 512
  store i16 %or, i16* %xcv_flags, align 2, !tbaa !68
  %49 = bitcast %struct.cv* %call39 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %49, i8* getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0)) #4
  tail call void @Perl_pop_scope() #4
  ret %struct.cv* %call39
}

declare i32 @apply_attrs(...) #2

declare i32 @pad_fixup_inner_anons(...) #2

; Function Attrs: nounwind readonly
declare i8* @strrchr(i8*, i32) #1

declare i32 @pad_tidy(...) #2

declare %struct.sv* @Perl_newSV(i64) #2

declare %struct.gv* @Perl_gv_HVadd(%struct.gv*) #2

declare signext i8 @Perl_hv_exists(%struct.hv*, i8*, i64) #2

declare %struct.av* @Perl_newAV() #2

declare void @Perl_av_push(%struct.av*, %struct.sv*) #2

declare void @Perl_call_list(i64, %struct.av*) #2

declare void @Perl_av_unshift(%struct.av*, i64) #2

declare %struct.sv** @Perl_av_store(%struct.av*, i64, %struct.sv*) #2

; Function Attrs: nounwind uwtable
define %struct.cv* @Perl_newXS(i8* %name, void (%struct.cv*)* %subaddr, i8* %filename) #0 {
entry:
  %tobool = icmp ne i8* %name, null
  br i1 %tobool, label %cond.end6, label %cond.end6.thread

cond.end6.thread:                                 ; preds = %entry
  %0 = load %struct.hv** @PL_curstash, align 8, !tbaa !6
  %tobool1 = icmp ne %struct.hv* %0, null
  %cond = select i1 %tobool1, i8* getelementptr inbounds ([9 x i8]* @.str66, i64 0, i64 0), i8* getelementptr inbounds ([19 x i8]* @.str67, i64 0, i64 0)
  %call = tail call %struct.gv* @Perl_gv_fetchpv(i8* %cond, i64 2, i64 12) #4
  br label %if.else76

cond.end6:                                        ; preds = %entry
  %call284 = tail call %struct.gv* @Perl_gv_fetchpv(i8* %name, i64 2, i64 12) #4
  %sv_any = getelementptr inbounds %struct.gv* %call284, i64 0, i32 0
  %1 = load %struct.xpvgv** %sv_any, align 8, !tbaa !60
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %1, i64 0, i32 7
  %2 = load %struct.gp** %xgv_gp, align 8, !tbaa !62
  %gp_cv = getelementptr inbounds %struct.gp* %2, i64 0, i32 7
  %3 = load %struct.cv** %gp_cv, align 8, !tbaa !64
  %tobool8 = icmp eq %struct.cv* %3, null
  br i1 %tobool8, label %if.else76, label %if.then

if.then:                                          ; preds = %cond.end6
  %gp_cvgen = getelementptr inbounds %struct.gp* %2, i64 0, i32 8
  %4 = load i64* %gp_cvgen, align 8, !tbaa !137
  %tobool11 = icmp eq i64 %4, 0
  br i1 %tobool11, label %if.else, label %if.then12

if.then12:                                        ; preds = %if.then
  %5 = bitcast %struct.cv* %3 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %5) #4
  br label %if.else76

if.else:                                          ; preds = %if.then
  %sv_any13 = getelementptr inbounds %struct.cv* %3, i64 0, i32 0
  %6 = load %struct.xpvcv** %sv_any13, align 8, !tbaa !66
  %xcv_root = getelementptr inbounds %struct.xpvcv* %6, i64 0, i32 9
  %7 = load %struct.op** %xcv_root, align 8, !tbaa !138
  %tobool14 = icmp eq %struct.op* %7, null
  br i1 %tobool14, label %lor.lhs.false, label %if.then20

lor.lhs.false:                                    ; preds = %if.else
  %xcv_xsub = getelementptr inbounds %struct.xpvcv* %6, i64 0, i32 10
  %8 = load void (%struct.cv*)** %xcv_xsub, align 8, !tbaa !139
  %tobool16 = icmp eq void (%struct.cv*)* %8, null
  br i1 %tobool16, label %lor.lhs.false17, label %if.then20

lor.lhs.false17:                                  ; preds = %lor.lhs.false
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %1, i64 0, i32 11
  %9 = load i8* %xgv_flags, align 1, !tbaa !141
  %and = and i8 %9, 4
  %tobool19 = icmp eq i8 %and, 0
  br i1 %tobool19, label %if.then75, label %if.then20

if.then20:                                        ; preds = %lor.lhs.false17, %lor.lhs.false, %if.else
  %10 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %10, i64 0, i32 14
  %11 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp = icmp eq %struct.sv* %11, null
  br i1 %cmp, label %lor.lhs.false35, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then20
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings22 = getelementptr inbounds %struct.cop* %12, i64 0, i32 14
  %13 = load %struct.sv** %cop_warnings22, align 8, !tbaa !47
  %cmp23 = icmp eq %struct.sv* %13, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp23, label %lor.lhs.false35, label %land.lhs.true25

land.lhs.true25:                                  ; preds = %land.lhs.true
  %14 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings26 = getelementptr inbounds %struct.cop* %14, i64 0, i32 14
  %15 = load %struct.sv** %cop_warnings26, align 8, !tbaa !47
  %cmp27 = icmp eq %struct.sv* %15, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp27, label %land.lhs.true43, label %lor.lhs.false29

lor.lhs.false29:                                  ; preds = %land.lhs.true25
  %16 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings30 = getelementptr inbounds %struct.cop* %16, i64 0, i32 14
  %17 = load %struct.sv** %cop_warnings30, align 8, !tbaa !47
  %sv_any31 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %18 = load i8** %sv_any31, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %18 to i8**
  %19 = load i8** %xpv_pv, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8* %19, i64 4
  %20 = load i8* %arrayidx, align 1, !tbaa !5
  %and33 = and i8 %20, 64
  %tobool34 = icmp eq i8 %and33, 0
  br i1 %tobool34, label %lor.lhs.false35, label %land.lhs.true43

lor.lhs.false35:                                  ; preds = %lor.lhs.false29, %land.lhs.true, %if.then20
  %21 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings36 = getelementptr inbounds %struct.cop* %21, i64 0, i32 14
  %22 = load %struct.sv** %cop_warnings36, align 8, !tbaa !47
  %cmp37 = icmp eq %struct.sv* %22, null
  br i1 %cmp37, label %land.lhs.true39, label %if.end70

land.lhs.true39:                                  ; preds = %lor.lhs.false35
  %23 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and41 = and i8 %23, 1
  %tobool42 = icmp eq i8 %and41, 0
  br i1 %tobool42, label %if.end70, label %land.lhs.true43

land.lhs.true43:                                  ; preds = %lor.lhs.false29, %land.lhs.true39, %land.lhs.true25
  %24 = load %struct.xpvcv** %sv_any13, align 8, !tbaa !66
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %24, i64 0, i32 12
  %25 = load %struct.gv** %xcv_gv, align 8, !tbaa !145
  %tobool45 = icmp eq %struct.gv* %25, null
  br i1 %tobool45, label %if.then59, label %land.lhs.true46

land.lhs.true46:                                  ; preds = %land.lhs.true43
  %sv_any49 = getelementptr inbounds %struct.gv* %25, i64 0, i32 0
  %26 = load %struct.xpvgv** %sv_any49, align 8, !tbaa !60
  %xgv_stash = getelementptr inbounds %struct.xpvgv* %26, i64 0, i32 10
  %27 = load %struct.hv** %xgv_stash, align 8, !tbaa !146
  %tobool50 = icmp eq %struct.hv* %27, null
  br i1 %tobool50, label %if.then59, label %land.lhs.true51

land.lhs.true51:                                  ; preds = %land.lhs.true46
  %sv_any56 = getelementptr inbounds %struct.hv* %27, i64 0, i32 0
  %28 = load %struct.xpvhv** %sv_any56, align 8, !tbaa !26
  %xhv_name = getelementptr inbounds %struct.xpvhv* %28, i64 0, i32 10
  %29 = load i8** %xhv_name, align 8, !tbaa !178
  %call57 = tail call i32 @strcmp(i8* %29, i8* getelementptr inbounds ([8 x i8]* @.str79, i64 0, i64 0)) #4
  %tobool58 = icmp eq i32 %call57, 0
  br i1 %tobool58, label %if.end70, label %if.then59

if.then59:                                        ; preds = %land.lhs.true51, %land.lhs.true46, %land.lhs.true43
  %30 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line = getelementptr inbounds %struct.cop* %30, i64 0, i32 13
  %31 = load i64* %cop_line, align 8, !tbaa !116
  %32 = load i64* @PL_copline, align 8, !tbaa !1
  %cmp60 = icmp eq i64 %32, 4294967295
  br i1 %cmp60, label %if.end, label %if.then62

if.then62:                                        ; preds = %if.then59
  %33 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line63 = getelementptr inbounds %struct.cop* %33, i64 0, i32 13
  store i64 %32, i64* %cop_line63, align 8, !tbaa !116
  br label %if.end

if.end:                                           ; preds = %if.then59, %if.then62
  %34 = load %struct.xpvcv** %sv_any13, align 8, !tbaa !66
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %34, i64 0, i32 17
  %35 = load i16* %xcv_flags, align 2, !tbaa !68
  %and66 = and i16 %35, 512
  %tobool67 = icmp ne i16 %and66, 0
  %cond68 = select i1 %tobool67, i8* getelementptr inbounds ([33 x i8]* @.str70, i64 0, i64 0), i8* getelementptr inbounds ([24 x i8]* @.str71, i64 0, i64 0)
  tail call void (i64, i8*, ...)* @Perl_warner(i64 19, i8* %cond68, i8* %name) #4
  %36 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line69 = getelementptr inbounds %struct.cop* %36, i64 0, i32 13
  store i64 %31, i64* %cop_line69, align 8, !tbaa !116
  br label %if.end70

if.end70:                                         ; preds = %land.lhs.true51, %land.lhs.true39, %if.end, %lor.lhs.false35
  %37 = bitcast %struct.cv* %3 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %37) #4
  br label %if.else76

if.then75:                                        ; preds = %lor.lhs.false17
  tail call void @Perl_cv_undef(%struct.cv* %3)
  br label %if.end88

if.else76:                                        ; preds = %cond.end6.thread, %cond.end6, %if.end70, %if.then12
  %call285288291 = phi %struct.gv* [ %call284, %if.then12 ], [ %call284, %if.end70 ], [ %call284, %cond.end6 ], [ %call, %cond.end6.thread ]
  %call77 = tail call %struct.sv* @Perl_newSV(i64 0) #4
  %38 = bitcast %struct.sv* %call77 to %struct.cv*
  %call78 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %call77, i64 12) #4
  br i1 %tobool, label %if.then80, label %if.end88

if.then80:                                        ; preds = %if.else76
  %sv_any81 = getelementptr inbounds %struct.gv* %call285288291, i64 0, i32 0
  %39 = load %struct.xpvgv** %sv_any81, align 8, !tbaa !60
  %xgv_gp82 = getelementptr inbounds %struct.xpvgv* %39, i64 0, i32 7
  %40 = load %struct.gp** %xgv_gp82, align 8, !tbaa !62
  %gp_cv83 = getelementptr inbounds %struct.gp* %40, i64 0, i32 7
  store %struct.cv* %38, %struct.cv** %gp_cv83, align 8, !tbaa !64
  %gp_cvgen86 = getelementptr inbounds %struct.gp* %40, i64 0, i32 8
  store i64 0, i64* %gp_cvgen86, align 8, !tbaa !137
  %41 = load i64* @PL_sub_generation, align 8, !tbaa !1
  %inc = add i64 %41, 1
  store i64 %inc, i64* @PL_sub_generation, align 8, !tbaa !1
  br label %if.end88

if.end88:                                         ; preds = %if.else76, %if.then80, %if.then75
  %call285288290 = phi %struct.gv* [ %call284, %if.then75 ], [ %call285288291, %if.then80 ], [ %call285288291, %if.else76 ]
  %cv.1 = phi %struct.cv* [ %3, %if.then75 ], [ %38, %if.then80 ], [ %38, %if.else76 ]
  %sv_any89 = getelementptr inbounds %struct.cv* %cv.1, i64 0, i32 0
  %42 = load %struct.xpvcv** %sv_any89, align 8, !tbaa !66
  %xcv_gv90 = getelementptr inbounds %struct.xpvcv* %42, i64 0, i32 12
  store %struct.gv* %call285288290, %struct.gv** %xcv_gv90, align 8, !tbaa !145
  %call91 = tail call %struct.gv* @Perl_gv_fetchfile(i8* %filename) #4
  %43 = load %struct.xpvcv** %sv_any89, align 8, !tbaa !66
  %xcv_file = getelementptr inbounds %struct.xpvcv* %43, i64 0, i32 13
  store i8* %filename, i8** %xcv_file, align 8, !tbaa !151
  %xcv_xsub94 = getelementptr inbounds %struct.xpvcv* %43, i64 0, i32 10
  store void (%struct.cv*)* %subaddr, void (%struct.cv*)** %xcv_xsub94, align 8, !tbaa !139
  br i1 %tobool, label %if.then96, label %if.else230

if.then96:                                        ; preds = %if.end88
  %call97 = tail call i8* @strrchr(i8* %name, i32 58) #4
  %tobool98 = icmp eq i8* %call97, null
  %incdec.ptr = getelementptr inbounds i8* %call97, i64 1
  %s.0 = select i1 %tobool98, i8* %name, i8* %incdec.ptr
  %44 = load i8* %s.0, align 1, !tbaa !5
  switch i8 %44, label %done [
    i8 66, label %if.end118
    i8 69, label %if.end118
    i8 67, label %if.end118
    i8 73, label %if.end118
  ]

if.end118:                                        ; preds = %if.then96, %if.then96, %if.then96, %if.then96
  %call119 = tail call i32 @strcmp(i8* %s.0, i8* getelementptr inbounds ([6 x i8]* @.str51, i64 0, i64 0)) #4
  %tobool120 = icmp eq i32 %call119, 0
  br i1 %tobool120, label %if.then121, label %if.else129

if.then121:                                       ; preds = %if.end118
  %45 = load %struct.av** @PL_beginav, align 8, !tbaa !6
  %tobool122 = icmp eq %struct.av* %45, null
  br i1 %tobool122, label %if.then123, label %if.end125

if.then123:                                       ; preds = %if.then121
  %call124 = tail call %struct.av* @Perl_newAV() #4
  store %struct.av* %call124, %struct.av** @PL_beginav, align 8, !tbaa !6
  br label %if.end125

if.end125:                                        ; preds = %if.then121, %if.then123
  %46 = phi %struct.av* [ %45, %if.then121 ], [ %call124, %if.then123 ]
  %47 = bitcast %struct.cv* %cv.1 to %struct.sv*
  tail call void @Perl_av_push(%struct.av* %46, %struct.sv* %47) #4
  %sv_any126 = getelementptr inbounds %struct.gv* %call285288290, i64 0, i32 0
  %48 = load %struct.xpvgv** %sv_any126, align 8, !tbaa !60
  %xgv_gp127 = getelementptr inbounds %struct.xpvgv* %48, i64 0, i32 7
  %49 = load %struct.gp** %xgv_gp127, align 8, !tbaa !62
  %gp_cv128 = getelementptr inbounds %struct.gp* %49, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv128, align 8, !tbaa !64
  br label %done

if.else129:                                       ; preds = %if.end118
  %call130 = tail call i32 @strcmp(i8* %s.0, i8* getelementptr inbounds ([4 x i8]* @.str74, i64 0, i64 0)) #4
  %tobool131 = icmp eq i32 %call130, 0
  br i1 %tobool131, label %if.then132, label %if.else141

if.then132:                                       ; preds = %if.else129
  %50 = load %struct.av** @PL_endav, align 8, !tbaa !6
  %tobool133 = icmp eq %struct.av* %50, null
  br i1 %tobool133, label %if.then134, label %if.end136

if.then134:                                       ; preds = %if.then132
  %call135 = tail call %struct.av* @Perl_newAV() #4
  store %struct.av* %call135, %struct.av** @PL_endav, align 8, !tbaa !6
  br label %if.end136

if.end136:                                        ; preds = %if.then132, %if.then134
  %51 = phi %struct.av* [ %50, %if.then132 ], [ %call135, %if.then134 ]
  tail call void @Perl_av_unshift(%struct.av* %51, i64 1) #4
  %52 = load %struct.av** @PL_endav, align 8, !tbaa !6
  %53 = bitcast %struct.cv* %cv.1 to %struct.sv*
  %call137 = tail call %struct.sv** @Perl_av_store(%struct.av* %52, i64 0, %struct.sv* %53) #4
  %sv_any138 = getelementptr inbounds %struct.gv* %call285288290, i64 0, i32 0
  %54 = load %struct.xpvgv** %sv_any138, align 8, !tbaa !60
  %xgv_gp139 = getelementptr inbounds %struct.xpvgv* %54, i64 0, i32 7
  %55 = load %struct.gp** %xgv_gp139, align 8, !tbaa !62
  %gp_cv140 = getelementptr inbounds %struct.gp* %55, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv140, align 8, !tbaa !64
  br label %done

if.else141:                                       ; preds = %if.else129
  %call142 = tail call i32 @strcmp(i8* %s.0, i8* getelementptr inbounds ([6 x i8]* @.str75, i64 0, i64 0)) #4
  %tobool143 = icmp eq i32 %call142, 0
  br i1 %tobool143, label %if.then144, label %if.else184

if.then144:                                       ; preds = %if.else141
  %56 = load %struct.av** @PL_checkav, align 8, !tbaa !6
  %tobool145 = icmp eq %struct.av* %56, null
  br i1 %tobool145, label %if.then146, label %if.end148

if.then146:                                       ; preds = %if.then144
  %call147 = tail call %struct.av* @Perl_newAV() #4
  store %struct.av* %call147, %struct.av** @PL_checkav, align 8, !tbaa !6
  br label %if.end148

if.end148:                                        ; preds = %if.then144, %if.then146
  %57 = load %struct.op** @PL_main_start, align 8, !tbaa !6
  %tobool149 = icmp eq %struct.op* %57, null
  br i1 %tobool149, label %if.end179, label %land.lhs.true150

land.lhs.true150:                                 ; preds = %if.end148
  %58 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings151 = getelementptr inbounds %struct.cop* %58, i64 0, i32 14
  %59 = load %struct.sv** %cop_warnings151, align 8, !tbaa !47
  %cmp152 = icmp eq %struct.sv* %59, null
  br i1 %cmp152, label %lor.lhs.false170, label %land.lhs.true154

land.lhs.true154:                                 ; preds = %land.lhs.true150
  %60 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings155 = getelementptr inbounds %struct.cop* %60, i64 0, i32 14
  %61 = load %struct.sv** %cop_warnings155, align 8, !tbaa !47
  %cmp156 = icmp eq %struct.sv* %61, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp156, label %lor.lhs.false170, label %land.lhs.true158

land.lhs.true158:                                 ; preds = %land.lhs.true154
  %62 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings159 = getelementptr inbounds %struct.cop* %62, i64 0, i32 14
  %63 = load %struct.sv** %cop_warnings159, align 8, !tbaa !47
  %cmp160 = icmp eq %struct.sv* %63, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp160, label %if.then178, label %lor.lhs.false162

lor.lhs.false162:                                 ; preds = %land.lhs.true158
  %64 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings163 = getelementptr inbounds %struct.cop* %64, i64 0, i32 14
  %65 = load %struct.sv** %cop_warnings163, align 8, !tbaa !47
  %sv_any164 = getelementptr inbounds %struct.sv* %65, i64 0, i32 0
  %66 = load i8** %sv_any164, align 8, !tbaa !36
  %xpv_pv165 = bitcast i8* %66 to i8**
  %67 = load i8** %xpv_pv165, align 8, !tbaa !39
  %arrayidx166 = getelementptr inbounds i8* %67, i64 11
  %68 = load i8* %arrayidx166, align 1, !tbaa !5
  %and168 = and i8 %68, 4
  %tobool169 = icmp eq i8 %and168, 0
  br i1 %tobool169, label %lor.lhs.false170, label %if.then178

lor.lhs.false170:                                 ; preds = %lor.lhs.false162, %land.lhs.true154, %land.lhs.true150
  %69 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings171 = getelementptr inbounds %struct.cop* %69, i64 0, i32 14
  %70 = load %struct.sv** %cop_warnings171, align 8, !tbaa !47
  %cmp172 = icmp eq %struct.sv* %70, null
  br i1 %cmp172, label %land.lhs.true174, label %if.end179

land.lhs.true174:                                 ; preds = %lor.lhs.false170
  %71 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and176 = and i8 %71, 1
  %tobool177 = icmp eq i8 %and176, 0
  br i1 %tobool177, label %if.end179, label %if.then178

if.then178:                                       ; preds = %lor.lhs.false162, %land.lhs.true174, %land.lhs.true158
  tail call void (i64, i8*, ...)* @Perl_warner(i64 45, i8* getelementptr inbounds ([28 x i8]* @.str76, i64 0, i64 0)) #4
  br label %if.end179

if.end179:                                        ; preds = %land.lhs.true174, %if.end148, %if.then178, %lor.lhs.false170
  %72 = load %struct.av** @PL_checkav, align 8, !tbaa !6
  tail call void @Perl_av_unshift(%struct.av* %72, i64 1) #4
  %73 = load %struct.av** @PL_checkav, align 8, !tbaa !6
  %74 = bitcast %struct.cv* %cv.1 to %struct.sv*
  %call180 = tail call %struct.sv** @Perl_av_store(%struct.av* %73, i64 0, %struct.sv* %74) #4
  %sv_any181 = getelementptr inbounds %struct.gv* %call285288290, i64 0, i32 0
  %75 = load %struct.xpvgv** %sv_any181, align 8, !tbaa !60
  %xgv_gp182 = getelementptr inbounds %struct.xpvgv* %75, i64 0, i32 7
  %76 = load %struct.gp** %xgv_gp182, align 8, !tbaa !62
  %gp_cv183 = getelementptr inbounds %struct.gp* %76, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv183, align 8, !tbaa !64
  br label %done

if.else184:                                       ; preds = %if.else141
  %call185 = tail call i32 @strcmp(i8* %s.0, i8* getelementptr inbounds ([5 x i8]* @.str77, i64 0, i64 0)) #4
  %tobool186 = icmp eq i32 %call185, 0
  br i1 %tobool186, label %if.then187, label %done

if.then187:                                       ; preds = %if.else184
  %77 = load %struct.av** @PL_initav, align 8, !tbaa !6
  %tobool188 = icmp eq %struct.av* %77, null
  br i1 %tobool188, label %if.then189, label %if.end191

if.then189:                                       ; preds = %if.then187
  %call190 = tail call %struct.av* @Perl_newAV() #4
  store %struct.av* %call190, %struct.av** @PL_initav, align 8, !tbaa !6
  br label %if.end191

if.end191:                                        ; preds = %if.then187, %if.then189
  %78 = load %struct.op** @PL_main_start, align 8, !tbaa !6
  %tobool192 = icmp eq %struct.op* %78, null
  br i1 %tobool192, label %if.end222, label %land.lhs.true193

land.lhs.true193:                                 ; preds = %if.end191
  %79 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings194 = getelementptr inbounds %struct.cop* %79, i64 0, i32 14
  %80 = load %struct.sv** %cop_warnings194, align 8, !tbaa !47
  %cmp195 = icmp eq %struct.sv* %80, null
  br i1 %cmp195, label %lor.lhs.false213, label %land.lhs.true197

land.lhs.true197:                                 ; preds = %land.lhs.true193
  %81 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings198 = getelementptr inbounds %struct.cop* %81, i64 0, i32 14
  %82 = load %struct.sv** %cop_warnings198, align 8, !tbaa !47
  %cmp199 = icmp eq %struct.sv* %82, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp199, label %lor.lhs.false213, label %land.lhs.true201

land.lhs.true201:                                 ; preds = %land.lhs.true197
  %83 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings202 = getelementptr inbounds %struct.cop* %83, i64 0, i32 14
  %84 = load %struct.sv** %cop_warnings202, align 8, !tbaa !47
  %cmp203 = icmp eq %struct.sv* %84, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp203, label %if.then221, label %lor.lhs.false205

lor.lhs.false205:                                 ; preds = %land.lhs.true201
  %85 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings206 = getelementptr inbounds %struct.cop* %85, i64 0, i32 14
  %86 = load %struct.sv** %cop_warnings206, align 8, !tbaa !47
  %sv_any207 = getelementptr inbounds %struct.sv* %86, i64 0, i32 0
  %87 = load i8** %sv_any207, align 8, !tbaa !36
  %xpv_pv208 = bitcast i8* %87 to i8**
  %88 = load i8** %xpv_pv208, align 8, !tbaa !39
  %arrayidx209 = getelementptr inbounds i8* %88, i64 11
  %89 = load i8* %arrayidx209, align 1, !tbaa !5
  %and211 = and i8 %89, 4
  %tobool212 = icmp eq i8 %and211, 0
  br i1 %tobool212, label %lor.lhs.false213, label %if.then221

lor.lhs.false213:                                 ; preds = %lor.lhs.false205, %land.lhs.true197, %land.lhs.true193
  %90 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings214 = getelementptr inbounds %struct.cop* %90, i64 0, i32 14
  %91 = load %struct.sv** %cop_warnings214, align 8, !tbaa !47
  %cmp215 = icmp eq %struct.sv* %91, null
  br i1 %cmp215, label %land.lhs.true217, label %if.end222

land.lhs.true217:                                 ; preds = %lor.lhs.false213
  %92 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and219 = and i8 %92, 1
  %tobool220 = icmp eq i8 %and219, 0
  br i1 %tobool220, label %if.end222, label %if.then221

if.then221:                                       ; preds = %lor.lhs.false205, %land.lhs.true217, %land.lhs.true201
  tail call void (i64, i8*, ...)* @Perl_warner(i64 45, i8* getelementptr inbounds ([27 x i8]* @.str78, i64 0, i64 0)) #4
  br label %if.end222

if.end222:                                        ; preds = %land.lhs.true217, %if.end191, %if.then221, %lor.lhs.false213
  %93 = load %struct.av** @PL_initav, align 8, !tbaa !6
  %94 = bitcast %struct.cv* %cv.1 to %struct.sv*
  tail call void @Perl_av_push(%struct.av* %93, %struct.sv* %94) #4
  %sv_any223 = getelementptr inbounds %struct.gv* %call285288290, i64 0, i32 0
  %95 = load %struct.xpvgv** %sv_any223, align 8, !tbaa !60
  %xgv_gp224 = getelementptr inbounds %struct.xpvgv* %95, i64 0, i32 7
  %96 = load %struct.gp** %xgv_gp224, align 8, !tbaa !62
  %gp_cv225 = getelementptr inbounds %struct.gp* %96, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv225, align 8, !tbaa !64
  br label %done

if.else230:                                       ; preds = %if.end88
  %xcv_flags232 = getelementptr inbounds %struct.xpvcv* %43, i64 0, i32 17
  %97 = load i16* %xcv_flags232, align 2, !tbaa !68
  %or = or i16 %97, 4
  store i16 %or, i16* %xcv_flags232, align 2, !tbaa !68
  br label %done

done:                                             ; preds = %if.then96, %if.else184, %if.else230, %if.end136, %if.end222, %if.end179, %if.end125
  ret %struct.cv* %cv.1
}

declare %struct.gv* @Perl_gv_fetchfile(i8*) #2

; Function Attrs: nounwind uwtable
define void @Perl_newFORM(i64 %floor, %struct.op* %o, %struct.op* %block) #0 {
entry:
  %n_a = alloca i64, align 8
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %0 = bitcast %struct.op* %op_sv to %struct.sv**
  %1 = load %struct.sv** %0, align 8, !tbaa !18
  store %struct.sv* %1, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i64* %sv_flags, align 8, !tbaa !34
  %and = and i64 %2, 262144
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %3 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_cur = getelementptr inbounds i8* %3, i64 8
  %4 = bitcast i8* %xpv_cur to i64*
  %5 = load i64* %4, align 8, !tbaa !37
  store i64 %5, i64* %n_a, align 8, !tbaa !1
  %xpv_pv = bitcast i8* %3 to i8**
  %6 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %if.end

cond.false:                                       ; preds = %if.then
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %1, i64* %n_a, i64 2) #4
  br label %if.end

if.end:                                           ; preds = %entry, %cond.true, %cond.false
  %name.0 = phi i8* [ %6, %cond.true ], [ %call, %cond.false ], [ getelementptr inbounds ([7 x i8]* @.str80, i64 0, i64 0), %entry ]
  %call2 = call %struct.gv* @Perl_gv_fetchpv(i8* %name.0, i64 1, i64 14) #4
  %sv_any3 = getelementptr inbounds %struct.gv* %call2, i64 0, i32 0
  %7 = load %struct.xpvgv** %sv_any3, align 8, !tbaa !60
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %7, i64 0, i32 11
  %8 = load i8* %xgv_flags, align 1, !tbaa !141
  %or = or i8 %8, 2
  store i8 %or, i8* %xgv_flags, align 1, !tbaa !141
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %7, i64 0, i32 7
  %9 = load %struct.gp** %xgv_gp, align 8, !tbaa !62
  %gp_form = getelementptr inbounds %struct.gp* %9, i64 0, i32 3
  %10 = load %struct.cv** %gp_form, align 8, !tbaa !179
  %tobool6 = icmp eq %struct.cv* %10, null
  br i1 %tobool6, label %if.end39, label %if.then7

if.then7:                                         ; preds = %if.end
  %11 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %11, i64 0, i32 14
  %12 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp8 = icmp eq %struct.sv* %12, null
  br i1 %cmp8, label %lor.lhs.false23, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then7
  %13 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings10 = getelementptr inbounds %struct.cop* %13, i64 0, i32 14
  %14 = load %struct.sv** %cop_warnings10, align 8, !tbaa !47
  %cmp11 = icmp eq %struct.sv* %14, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp11, label %lor.lhs.false23, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %land.lhs.true
  %15 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings14 = getelementptr inbounds %struct.cop* %15, i64 0, i32 14
  %16 = load %struct.sv** %cop_warnings14, align 8, !tbaa !47
  %cmp15 = icmp eq %struct.sv* %16, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp15, label %if.then31, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true13
  %17 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings17 = getelementptr inbounds %struct.cop* %17, i64 0, i32 14
  %18 = load %struct.sv** %cop_warnings17, align 8, !tbaa !47
  %sv_any18 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %19 = load i8** %sv_any18, align 8, !tbaa !36
  %xpv_pv19 = bitcast i8* %19 to i8**
  %20 = load i8** %xpv_pv19, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8* %20, i64 4
  %21 = load i8* %arrayidx, align 1, !tbaa !5
  %and21 = and i8 %21, 64
  %tobool22 = icmp eq i8 %and21, 0
  br i1 %tobool22, label %lor.lhs.false23, label %if.then31

lor.lhs.false23:                                  ; preds = %lor.lhs.false, %land.lhs.true, %if.then7
  %22 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings24 = getelementptr inbounds %struct.cop* %22, i64 0, i32 14
  %23 = load %struct.sv** %cop_warnings24, align 8, !tbaa !47
  %cmp25 = icmp eq %struct.sv* %23, null
  br i1 %cmp25, label %land.lhs.true27, label %if.end38

land.lhs.true27:                                  ; preds = %lor.lhs.false23
  %24 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and29 = and i8 %24, 1
  %tobool30 = icmp eq i8 %and29, 0
  br i1 %tobool30, label %if.end38, label %if.then31

if.then31:                                        ; preds = %lor.lhs.false, %land.lhs.true27, %land.lhs.true13
  %25 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line = getelementptr inbounds %struct.cop* %25, i64 0, i32 13
  %26 = load i64* %cop_line, align 8, !tbaa !116
  %27 = load i64* @PL_copline, align 8, !tbaa !1
  %cmp32 = icmp eq i64 %27, 4294967295
  br i1 %cmp32, label %if.end36, label %if.then34

if.then34:                                        ; preds = %if.then31
  %28 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line35 = getelementptr inbounds %struct.cop* %28, i64 0, i32 13
  store i64 %27, i64* %cop_line35, align 8, !tbaa !116
  br label %if.end36

if.end36:                                         ; preds = %if.then31, %if.then34
  call void (i64, i8*, ...)* @Perl_warner(i64 19, i8* getelementptr inbounds ([20 x i8]* @.str81, i64 0, i64 0), i8* %name.0) #4
  %29 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line37 = getelementptr inbounds %struct.cop* %29, i64 0, i32 13
  store i64 %26, i64* %cop_line37, align 8, !tbaa !116
  br label %if.end38

if.end38:                                         ; preds = %land.lhs.true27, %if.end36, %lor.lhs.false23
  %30 = bitcast %struct.cv* %10 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %30) #4
  %.pre = load %struct.xpvgv** %sv_any3, align 8, !tbaa !60
  %xgv_gp41.phi.trans.insert = getelementptr inbounds %struct.xpvgv* %.pre, i64 0, i32 7
  %.pre123 = load %struct.gp** %xgv_gp41.phi.trans.insert, align 8, !tbaa !62
  br label %if.end39

if.end39:                                         ; preds = %if.end, %if.end38
  %31 = phi %struct.gp* [ %9, %if.end ], [ %.pre123, %if.end38 ]
  %32 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %gp_form42 = getelementptr inbounds %struct.gp* %31, i64 0, i32 3
  store %struct.cv* %32, %struct.cv** %gp_form42, align 8, !tbaa !179
  %sv_any43 = getelementptr inbounds %struct.cv* %32, i64 0, i32 0
  %33 = load %struct.xpvcv** %sv_any43, align 8, !tbaa !66
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %33, i64 0, i32 12
  store %struct.gv* %call2, %struct.gv** %xcv_gv, align 8, !tbaa !145
  %34 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv = getelementptr inbounds %struct.cop* %34, i64 0, i32 10
  %35 = load %struct.gv** %cop_filegv, align 8, !tbaa !97
  %tobool44 = icmp eq %struct.gv* %35, null
  br i1 %tobool44, label %cond.end65, label %cond.true45

cond.true45:                                      ; preds = %if.end39
  %36 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv46 = getelementptr inbounds %struct.cop* %36, i64 0, i32 10
  %37 = load %struct.gv** %cop_filegv46, align 8, !tbaa !97
  %sv_any47 = getelementptr inbounds %struct.gv* %37, i64 0, i32 0
  %38 = load %struct.xpvgv** %sv_any47, align 8, !tbaa !60
  %xgv_gp48 = getelementptr inbounds %struct.xpvgv* %38, i64 0, i32 7
  %39 = load %struct.gp** %xgv_gp48, align 8, !tbaa !62
  %gp_sv = getelementptr inbounds %struct.gp* %39, i64 0, i32 0
  %40 = load %struct.sv** %gp_sv, align 8, !tbaa !135
  %tobool49 = icmp eq %struct.sv* %40, null
  br i1 %tobool49, label %cond.end65, label %cond.true51

cond.true51:                                      ; preds = %cond.true45
  %41 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %42 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_filegv55 = getelementptr inbounds %struct.cop* %42, i64 0, i32 10
  %43 = load %struct.gv** %cop_filegv55, align 8, !tbaa !97
  %sv_any56 = getelementptr inbounds %struct.gv* %43, i64 0, i32 0
  %44 = load %struct.xpvgv** %sv_any56, align 8, !tbaa !60
  %xgv_gp57 = getelementptr inbounds %struct.xpvgv* %44, i64 0, i32 7
  %45 = load %struct.gp** %xgv_gp57, align 8, !tbaa !62
  %gp_sv58 = getelementptr inbounds %struct.gp* %45, i64 0, i32 0
  %46 = load %struct.sv** %gp_sv58, align 8, !tbaa !135
  %sv_any62 = getelementptr inbounds %struct.sv* %46, i64 0, i32 0
  %47 = load i8** %sv_any62, align 8, !tbaa !36
  %xpv_pv63 = bitcast i8* %47 to i8**
  %48 = load i8** %xpv_pv63, align 8, !tbaa !39
  br label %cond.end65

cond.end65:                                       ; preds = %cond.true45, %if.end39, %cond.true51
  %cond66 = phi i8* [ %48, %cond.true51 ], [ null, %if.end39 ], [ null, %cond.true45 ]
  %49 = load %struct.xpvcv** %sv_any43, align 8, !tbaa !66
  %xcv_file = getelementptr inbounds %struct.xpvcv* %49, i64 0, i32 13
  store i8* %cond66, i8** %xcv_file, align 8, !tbaa !151
  %call68 = call i32 (i32, ...)* bitcast (i32 (...)* @pad_tidy to i32 (i32, ...)*)(i32 2) #4
  %call69 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarseq to i32 (%struct.op*, ...)*)(%struct.op* %block) #4
  %conv70 = sext i32 %call69 to i64
  %50 = inttoptr i64 %conv70 to %struct.op*
  %call71 = call %struct.op* @Perl_newUNOP(i64 207, i64 0, %struct.op* %50)
  %51 = load %struct.xpvcv** %sv_any43, align 8, !tbaa !66
  %xcv_root = getelementptr inbounds %struct.xpvcv* %51, i64 0, i32 9
  store %struct.op* %call71, %struct.op** %xcv_root, align 8, !tbaa !138
  %op_private = getelementptr inbounds %struct.op* %call71, i64 0, i32 7
  %52 = load i8* %op_private, align 1, !tbaa !11
  %or76 = or i8 %52, 64
  store i8 %or76, i8* %op_private, align 1, !tbaa !11
  %op_targ = getelementptr inbounds %struct.op* %call71, i64 0, i32 3
  store i64 1, i64* %op_targ, align 8, !tbaa !13
  %op_next = getelementptr inbounds %struct.op* %call71, i64 0, i32 0
  %53 = load %struct.op** %op_next, align 8, !tbaa !42
  %tobool82 = icmp eq %struct.op* %53, null
  br i1 %tobool82, label %cond.false87, label %cond.end92

cond.false87:                                     ; preds = %cond.end65
  %call90 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %call71) #4
  %conv91 = sext i32 %call90 to i64
  %54 = inttoptr i64 %conv91 to %struct.op*
  %.pre124 = load %struct.xpvcv** %sv_any43, align 8, !tbaa !66
  %xcv_root96.phi.trans.insert = getelementptr inbounds %struct.xpvcv* %.pre124, i64 0, i32 9
  %.pre125 = load %struct.op** %xcv_root96.phi.trans.insert, align 8, !tbaa !138
  br label %cond.end92

cond.end92:                                       ; preds = %cond.end65, %cond.false87
  %55 = phi %struct.op* [ %.pre125, %cond.false87 ], [ %call71, %cond.end65 ]
  %56 = phi %struct.xpvcv* [ %.pre124, %cond.false87 ], [ %51, %cond.end65 ]
  %cond93 = phi %struct.op* [ %54, %cond.false87 ], [ %53, %cond.end65 ]
  %xcv_start = getelementptr inbounds %struct.xpvcv* %56, i64 0, i32 8
  store %struct.op* %cond93, %struct.op** %xcv_start, align 8, !tbaa !144
  %op_next97 = getelementptr inbounds %struct.op* %55, i64 0, i32 0
  store %struct.op* null, %struct.op** %op_next97, align 8, !tbaa !42
  %57 = load void (%struct.op*)** @PL_peepp, align 8, !tbaa !6
  call void %57(%struct.op* %cond93) #4
  call void @Perl_op_free(%struct.op* %o)
  store i64 4294967295, i64* @PL_copline, align 8, !tbaa !1
  %58 = load i64* @PL_savestack_ix, align 8, !tbaa !1
  %cmp100 = icmp sgt i64 %58, %floor
  br i1 %cmp100, label %if.then102, label %if.end103

if.then102:                                       ; preds = %cond.end92
  call void @Perl_leave_scope(i64 %floor) #4
  br label %if.end103

if.end103:                                        ; preds = %if.then102, %cond.end92
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newANONLIST(%struct.op* %o) #0 {
entry:
  %call = tail call i32 (i32, i32, %struct.op*, ...)* bitcast (i32 (...)* @convert to i32 (i32, i32, %struct.op*, ...)*)(i32 143, i32 0, %struct.op* %o) #4
  %call1 = tail call i32 (i32, ...)* bitcast (i32 (...)* @list to i32 (i32, ...)*)(i32 %call) #4
  %call2 = tail call i32 (i32, i32, ...)* bitcast (i32 (...)* @mod to i32 (i32, i32, ...)*)(i32 %call1, i32 20) #4
  %conv = sext i32 %call2 to i64
  %0 = inttoptr i64 %conv to %struct.op*
  %call3 = tail call %struct.op* @Perl_newUNOP(i64 20, i64 0, %struct.op* %0)
  ret %struct.op* %call3
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newANONHASH(%struct.op* %o) #0 {
entry:
  %call = tail call i32 (i32, i32, %struct.op*, ...)* bitcast (i32 (...)* @convert to i32 (i32, i32, %struct.op*, ...)*)(i32 144, i32 0, %struct.op* %o) #4
  %call1 = tail call i32 (i32, ...)* bitcast (i32 (...)* @list to i32 (i32, ...)*)(i32 %call) #4
  %call2 = tail call i32 (i32, i32, ...)* bitcast (i32 (...)* @mod to i32 (i32, i32, ...)*)(i32 %call1, i32 20) #4
  %conv = sext i32 %call2 to i64
  %0 = inttoptr i64 %conv to %struct.op*
  %call3 = tail call %struct.op* @Perl_newUNOP(i64 20, i64 0, %struct.op* %0)
  ret %struct.op* %call3
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newANONSUB(i64 %floor, %struct.op* %proto, %struct.op* %block) #0 {
entry:
  %call = tail call %struct.op* @Perl_newANONATTRSUB(i64 %floor, %struct.op* %proto, %struct.op* null, %struct.op* %block)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newANONATTRSUB(i64 %floor, %struct.op* %proto, %struct.op* %attrs, %struct.op* %block) #0 {
entry:
  %call = tail call %struct.cv* @Perl_newATTRSUB(i64 %floor, %struct.op* null, %struct.op* %proto, %struct.op* %attrs, %struct.op* %block)
  %0 = bitcast %struct.cv* %call to %struct.sv*
  %call.i = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i, i64 32
  %1 = bitcast i8* %op_type.i to i16*
  store i16 18, i16* %1, align 2, !tbaa !71
  %2 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 18), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %3 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %2, %struct.op* ()** %3, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i, i64 40
  %4 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %0, %struct.sv** %4, align 8, !tbaa !18
  %5 = bitcast i8* %call.i to %struct.op*
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %5, %struct.op** %op_next.i, align 8, !tbaa !73
  %6 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %6, align 1, !tbaa !74
  %7 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 18), align 8, !tbaa !1
  %and.i = and i64 %7, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %5) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 18), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %entry
  %8 = phi i64 [ %7, %entry ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %8, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 18, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %9 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %9, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %10 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %10, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %10, i64 18
  %11 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %11, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %5) #4
  %12 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 18), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %12) #4
  br label %Perl_newSVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %13 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 18), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %13(%struct.op* %5) #4
  br label %Perl_newSVOP.exit

Perl_newSVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  %call2 = tail call %struct.op* @Perl_newUNOP(i64 20, i64 0, %struct.op* %cond.i)
  ret %struct.op* %call2
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_oopsAV(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %conv = zext i16 %0 to i32
  switch i32 %conv, label %sw.default [
    i32 9, label %sw.bb
    i32 15, label %sw.bb3
  ]

sw.bb:                                            ; preds = %entry
  store i16 10, i16* %op_type, align 2, !tbaa !12
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 10), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %1, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %call = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i32, ...)*)(%struct.op* %o, i32 125) #4
  %conv2 = sext i32 %call to i64
  %2 = inttoptr i64 %conv2 to %struct.op*
  br label %return

sw.bb3:                                           ; preds = %entry
  store i16 125, i16* %op_type, align 2, !tbaa !12
  %3 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 125), align 8, !tbaa !6
  %op_ppaddr5 = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %3, %struct.op* ()** %op_ppaddr5, align 8, !tbaa !41
  %call6 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i32, ...)*)(%struct.op* %o, i32 125) #4
  br label %return

sw.default:                                       ; preds = %entry
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %4, i64 0, i32 14
  %5 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp = icmp eq %struct.sv* %5, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.default
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings8 = getelementptr inbounds %struct.cop* %6, i64 0, i32 14
  %7 = load %struct.sv** %cop_warnings8, align 8, !tbaa !47
  %cmp9 = icmp eq %struct.sv* %7, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp9, label %if.then, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %lor.lhs.false
  %8 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings12 = getelementptr inbounds %struct.cop* %8, i64 0, i32 14
  %9 = load %struct.sv** %cop_warnings12, align 8, !tbaa !47
  %cmp13 = icmp eq %struct.sv* %9, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp13, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false11
  %10 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings15 = getelementptr inbounds %struct.cop* %10, i64 0, i32 14
  %11 = load %struct.sv** %cop_warnings15, align 8, !tbaa !47
  %sv_any = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %12 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %12 to i8**
  %13 = load i8** %xpv_pv, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8* %13, i64 6
  %14 = load i8* %arrayidx, align 1, !tbaa !5
  %and = and i8 %14, 1
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %return, label %if.then

if.then:                                          ; preds = %land.lhs.true, %lor.lhs.false, %sw.default
  tail call void (i64, i8*, ...)* @Perl_warner(i64 24, i8* getelementptr inbounds ([13 x i8]* @.str82, i64 0, i64 0)) #4
  br label %return

return:                                           ; preds = %sw.bb3, %if.then, %lor.lhs.false11, %land.lhs.true, %sw.bb
  %retval.0 = phi %struct.op* [ %2, %sw.bb ], [ %o, %land.lhs.true ], [ %o, %lor.lhs.false11 ], [ %o, %if.then ], [ %o, %sw.bb3 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_oopsHV(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %conv = zext i16 %0 to i32
  switch i32 %conv, label %sw.default [
    i32 9, label %sw.bb
    i32 10, label %sw.bb
    i32 15, label %sw.bb3
    i32 125, label %sw.bb3
  ]

sw.bb:                                            ; preds = %entry, %entry
  store i16 11, i16* %op_type, align 2, !tbaa !12
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 11), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %1, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %call = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i32, ...)*)(%struct.op* %o, i32 134) #4
  %conv2 = sext i32 %call to i64
  %2 = inttoptr i64 %conv2 to %struct.op*
  br label %return

sw.bb3:                                           ; preds = %entry, %entry
  store i16 134, i16* %op_type, align 2, !tbaa !12
  %3 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 134), align 8, !tbaa !6
  %op_ppaddr5 = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %3, %struct.op* ()** %op_ppaddr5, align 8, !tbaa !41
  %call6 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i32, ...)*)(%struct.op* %o, i32 134) #4
  br label %return

sw.default:                                       ; preds = %entry
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %4, i64 0, i32 14
  %5 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp = icmp eq %struct.sv* %5, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.default
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings8 = getelementptr inbounds %struct.cop* %6, i64 0, i32 14
  %7 = load %struct.sv** %cop_warnings8, align 8, !tbaa !47
  %cmp9 = icmp eq %struct.sv* %7, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp9, label %if.then, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %lor.lhs.false
  %8 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings12 = getelementptr inbounds %struct.cop* %8, i64 0, i32 14
  %9 = load %struct.sv** %cop_warnings12, align 8, !tbaa !47
  %cmp13 = icmp eq %struct.sv* %9, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp13, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false11
  %10 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings15 = getelementptr inbounds %struct.cop* %10, i64 0, i32 14
  %11 = load %struct.sv** %cop_warnings15, align 8, !tbaa !47
  %sv_any = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %12 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %12 to i8**
  %13 = load i8** %xpv_pv, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8* %13, i64 6
  %14 = load i8* %arrayidx, align 1, !tbaa !5
  %and = and i8 %14, 1
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %return, label %if.then

if.then:                                          ; preds = %land.lhs.true, %lor.lhs.false, %sw.default
  tail call void (i64, i8*, ...)* @Perl_warner(i64 24, i8* getelementptr inbounds ([13 x i8]* @.str83, i64 0, i64 0)) #4
  br label %return

return:                                           ; preds = %sw.bb3, %if.then, %lor.lhs.false11, %land.lhs.true, %sw.bb
  %retval.0 = phi %struct.op* [ %2, %sw.bb ], [ %o, %land.lhs.true ], [ %o, %lor.lhs.false11 ], [ %o, %if.then ], [ %o, %sw.bb3 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newAVREF(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  switch i16 %0, label %if.end33 [
    i16 12, label %if.then
    i16 125, label %land.lhs.true
    i16 10, label %land.lhs.true
  ]

if.then:                                          ; preds = %entry
  store i16 10, i16* %op_type, align 2, !tbaa !12
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 10), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %1, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  br label %return

land.lhs.true:                                    ; preds = %entry, %entry
  %2 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %2, i64 0, i32 14
  %3 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp11 = icmp eq %struct.sv* %3, null
  br i1 %cmp11, label %lor.lhs.false24, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %land.lhs.true
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings14 = getelementptr inbounds %struct.cop* %4, i64 0, i32 14
  %5 = load %struct.sv** %cop_warnings14, align 8, !tbaa !47
  %cmp15 = icmp eq %struct.sv* %5, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp15, label %lor.lhs.false24, label %land.lhs.true17

land.lhs.true17:                                  ; preds = %land.lhs.true13
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings18 = getelementptr inbounds %struct.cop* %6, i64 0, i32 14
  %7 = load %struct.sv** %cop_warnings18, align 8, !tbaa !47
  %cmp19 = icmp eq %struct.sv* %7, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp19, label %if.then32, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %land.lhs.true17
  %8 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings22 = getelementptr inbounds %struct.cop* %8, i64 0, i32 14
  %9 = load %struct.sv** %cop_warnings22, align 8, !tbaa !47
  %sv_any = getelementptr inbounds %struct.sv* %9, i64 0, i32 0
  %10 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %10 to i8**
  %11 = load i8** %xpv_pv, align 8, !tbaa !39
  %12 = load i8* %11, align 1, !tbaa !5
  %and = and i8 %12, 16
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false24, label %if.then32

lor.lhs.false24:                                  ; preds = %lor.lhs.false21, %land.lhs.true13, %land.lhs.true
  %13 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings25 = getelementptr inbounds %struct.cop* %13, i64 0, i32 14
  %14 = load %struct.sv** %cop_warnings25, align 8, !tbaa !47
  %cmp26 = icmp eq %struct.sv* %14, null
  br i1 %cmp26, label %land.lhs.true28, label %if.end33

land.lhs.true28:                                  ; preds = %lor.lhs.false24
  %15 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and30 = and i8 %15, 1
  %tobool31 = icmp eq i8 %and30, 0
  br i1 %tobool31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %lor.lhs.false21, %land.lhs.true28, %land.lhs.true17
  tail call void (i64, i8*, ...)* @Perl_warner(i64 2, i8* getelementptr inbounds ([44 x i8]* @.str84, i64 0, i64 0)) #4
  br label %if.end33

if.end33:                                         ; preds = %entry, %land.lhs.true28, %lor.lhs.false24, %if.then32
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv34 = sext i32 %call to i64
  %16 = inttoptr i64 %conv34 to %struct.op*
  %call35 = tail call %struct.op* @Perl_newUNOP(i64 125, i64 0, %struct.op* %16)
  br label %return

return:                                           ; preds = %if.end33, %if.then
  %retval.0 = phi %struct.op* [ %o, %if.then ], [ %call35, %if.end33 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newGVREF(i64 %type, %struct.op* %o) #0 {
entry:
  switch i64 %type, label %if.end [
    i64 154, label %if.then
    i64 152, label %if.then
    i64 150, label %if.then
  ]

if.then:                                          ; preds = %entry, %entry, %entry
  %call = tail call %struct.op* @Perl_newUNOP(i64 0, i64 0, %struct.op* %o)
  br label %return

if.end:                                           ; preds = %entry
  %call4 = tail call %struct.op* @Perl_newUNOP(i64 14, i64 16, %struct.op* %o)
  %call5 = tail call i32 (%struct.op*, i64, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i64, ...)*)(%struct.op* %call4, i64 %type) #4
  %conv = sext i32 %call5 to i64
  %0 = inttoptr i64 %conv to %struct.op*
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi %struct.op* [ %call, %if.then ], [ %0, %if.end ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newHVREF(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  switch i16 %0, label %if.end33 [
    i16 12, label %if.then
    i16 134, label %land.lhs.true
    i16 11, label %land.lhs.true
  ]

if.then:                                          ; preds = %entry
  store i16 11, i16* %op_type, align 2, !tbaa !12
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 11), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %1, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  br label %return

land.lhs.true:                                    ; preds = %entry, %entry
  %2 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %2, i64 0, i32 14
  %3 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp11 = icmp eq %struct.sv* %3, null
  br i1 %cmp11, label %lor.lhs.false24, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %land.lhs.true
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings14 = getelementptr inbounds %struct.cop* %4, i64 0, i32 14
  %5 = load %struct.sv** %cop_warnings14, align 8, !tbaa !47
  %cmp15 = icmp eq %struct.sv* %5, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp15, label %lor.lhs.false24, label %land.lhs.true17

land.lhs.true17:                                  ; preds = %land.lhs.true13
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings18 = getelementptr inbounds %struct.cop* %6, i64 0, i32 14
  %7 = load %struct.sv** %cop_warnings18, align 8, !tbaa !47
  %cmp19 = icmp eq %struct.sv* %7, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp19, label %if.then32, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %land.lhs.true17
  %8 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings22 = getelementptr inbounds %struct.cop* %8, i64 0, i32 14
  %9 = load %struct.sv** %cop_warnings22, align 8, !tbaa !47
  %sv_any = getelementptr inbounds %struct.sv* %9, i64 0, i32 0
  %10 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %10 to i8**
  %11 = load i8** %xpv_pv, align 8, !tbaa !39
  %12 = load i8* %11, align 1, !tbaa !5
  %and = and i8 %12, 16
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false24, label %if.then32

lor.lhs.false24:                                  ; preds = %lor.lhs.false21, %land.lhs.true13, %land.lhs.true
  %13 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings25 = getelementptr inbounds %struct.cop* %13, i64 0, i32 14
  %14 = load %struct.sv** %cop_warnings25, align 8, !tbaa !47
  %cmp26 = icmp eq %struct.sv* %14, null
  br i1 %cmp26, label %land.lhs.true28, label %if.end33

land.lhs.true28:                                  ; preds = %lor.lhs.false24
  %15 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and30 = and i8 %15, 1
  %tobool31 = icmp eq i8 %and30, 0
  br i1 %tobool31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %lor.lhs.false21, %land.lhs.true28, %land.lhs.true17
  tail call void (i64, i8*, ...)* @Perl_warner(i64 2, i8* getelementptr inbounds ([42 x i8]* @.str85, i64 0, i64 0)) #4
  br label %if.end33

if.end33:                                         ; preds = %entry, %land.lhs.true28, %lor.lhs.false24, %if.then32
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv34 = sext i32 %call to i64
  %16 = inttoptr i64 %conv34 to %struct.op*
  %call35 = tail call %struct.op* @Perl_newUNOP(i64 134, i64 0, %struct.op* %16)
  br label %return

return:                                           ; preds = %if.end33, %if.then
  %retval.0 = phi %struct.op* [ %o, %if.then ], [ %call35, %if.end33 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_oopsCV(%struct.op* readnone %o) #0 {
entry:
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([17 x i8]* @.str86, i64 0, i64 0), i32 4843) #4
  ret %struct.op* %o
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newCVREF(i64 %flags, %struct.op* %o) #0 {
entry:
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv = sext i32 %call to i64
  %0 = inttoptr i64 %conv to %struct.op*
  %call1 = tail call %struct.op* @Perl_newUNOP(i64 17, i64 %flags, %struct.op* %0)
  ret %struct.op* %call1
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_anoncode(%struct.op* %o) #0 {
entry:
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %0 = bitcast %struct.op* %op_sv to %struct.sv**
  %1 = load %struct.sv** %0, align 8, !tbaa !18
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !12
  %conv = zext i16 %2 to i32
  %call = tail call i32 (%struct.sv*, i32, ...)* bitcast (i32 (...)* @pad_add_anon to i32 (%struct.sv*, i32, ...)*)(%struct.sv* %1, i32 %conv) #4
  %conv1 = sext i32 %call to i64
  %3 = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  store i64 %conv1, i64* %3, align 8, !tbaa !75
  %4 = getelementptr inbounds %struct.op* %op_sv, i64 0, i32 0
  store %struct.op* null, %struct.op** %4, align 8, !tbaa !18
  ret %struct.op* %o
}

declare i32 @pad_add_anon(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_bitop(%struct.op* %o) #0 {
entry:
  %0 = load i64* @PL_hints, align 8, !tbaa !1
  %conv = trunc i64 %0 to i8
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  store i8 %conv, i8* %op_private, align 1, !tbaa !11
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !14
  %and2 = and i8 %1, 64
  %tobool = icmp eq i8 %and2, 0
  br i1 %tobool, label %land.lhs.true, label %if.end200

land.lhs.true:                                    ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !12
  %.off = add i16 %2, -91
  %switch = icmp ult i16 %.off, 3
  br i1 %switch, label %if.then, label %if.end200

if.then:                                          ; preds = %land.lhs.true
  %3 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %4 = load %struct.op** %3, align 8, !tbaa !43
  %op_sibling = getelementptr inbounds %struct.op* %4, i64 0, i32 1
  %5 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %op_type14 = getelementptr inbounds %struct.op* %4, i64 0, i32 4
  %6 = load i16* %op_type14, align 2, !tbaa !12
  %.off239 = add i16 %6, -70
  %switch240 = icmp ult i16 %.off239, 14
  br i1 %switch240, label %land.lhs.true83, label %lor.lhs.false89

land.lhs.true83:                                  ; preds = %if.then
  %op_flags84 = getelementptr inbounds %struct.op* %4, i64 0, i32 6
  %7 = load i8* %op_flags84, align 1, !tbaa !14
  %and86 = and i8 %7, 8
  %cmp87 = icmp eq i8 %and86, 0
  br i1 %cmp87, label %if.then165, label %lor.lhs.false89

lor.lhs.false89:                                  ; preds = %if.then, %land.lhs.true83
  %op_type90 = getelementptr inbounds %struct.op* %5, i64 0, i32 4
  %8 = load i16* %op_type90, align 2, !tbaa !12
  %.off241 = add i16 %8, -70
  %switch242 = icmp ult i16 %.off241, 14
  br i1 %switch242, label %land.lhs.true159, label %if.end200

land.lhs.true159:                                 ; preds = %lor.lhs.false89
  %op_flags160 = getelementptr inbounds %struct.op* %5, i64 0, i32 6
  %9 = load i8* %op_flags160, align 1, !tbaa !14
  %and162 = and i8 %9, 8
  %cmp163 = icmp eq i8 %and162, 0
  br i1 %cmp163, label %if.then165, label %if.end200

if.then165:                                       ; preds = %land.lhs.true159, %land.lhs.true83
  %10 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %10, i64 0, i32 14
  %11 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp166 = icmp eq %struct.sv* %11, null
  br i1 %cmp166, label %lor.lhs.false181, label %land.lhs.true168

land.lhs.true168:                                 ; preds = %if.then165
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings169 = getelementptr inbounds %struct.cop* %12, i64 0, i32 14
  %13 = load %struct.sv** %cop_warnings169, align 8, !tbaa !47
  %cmp170 = icmp eq %struct.sv* %13, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp170, label %lor.lhs.false181, label %land.lhs.true172

land.lhs.true172:                                 ; preds = %land.lhs.true168
  %14 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings173 = getelementptr inbounds %struct.cop* %14, i64 0, i32 14
  %15 = load %struct.sv** %cop_warnings173, align 8, !tbaa !47
  %cmp174 = icmp eq %struct.sv* %15, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp174, label %if.then189, label %lor.lhs.false176

lor.lhs.false176:                                 ; preds = %land.lhs.true172
  %16 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings177 = getelementptr inbounds %struct.cop* %16, i64 0, i32 14
  %17 = load %struct.sv** %cop_warnings177, align 8, !tbaa !47
  %sv_any = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %18 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %18 to i8**
  %19 = load i8** %xpv_pv, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8* %19, i64 8
  %20 = load i8* %arrayidx, align 1, !tbaa !5
  %and179 = and i8 %20, 4
  %tobool180 = icmp eq i8 %and179, 0
  br i1 %tobool180, label %lor.lhs.false181, label %if.then189

lor.lhs.false181:                                 ; preds = %lor.lhs.false176, %land.lhs.true168, %if.then165
  %21 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings182 = getelementptr inbounds %struct.cop* %21, i64 0, i32 14
  %22 = load %struct.sv** %cop_warnings182, align 8, !tbaa !47
  %cmp183 = icmp eq %struct.sv* %22, null
  br i1 %cmp183, label %land.lhs.true185, label %if.end200

land.lhs.true185:                                 ; preds = %lor.lhs.false181
  %23 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and187 = and i8 %23, 1
  %tobool188 = icmp eq i8 %and187, 0
  br i1 %tobool188, label %if.end200, label %if.then189

if.then189:                                       ; preds = %lor.lhs.false176, %land.lhs.true185, %land.lhs.true172
  %24 = load i16* %op_type, align 2, !tbaa !12
  %cmp192 = icmp eq i16 %24, 93
  br i1 %cmp192, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.then189
  %cmp196 = icmp eq i16 %24, 91
  %cond = select i1 %cmp196, i32 38, i32 94
  br label %cond.end

cond.end:                                         ; preds = %if.then189, %cond.false
  %cond198 = phi i32 [ %cond, %cond.false ], [ 124, %if.then189 ]
  tail call void (i64, i8*, ...)* @Perl_warner(i64 33, i8* getelementptr inbounds ([51 x i8]* @.str87, i64 0, i64 0), i32 %cond198) #4
  br label %if.end200

if.end200:                                        ; preds = %lor.lhs.false89, %land.lhs.true, %land.lhs.true185, %entry, %land.lhs.true159, %cond.end, %lor.lhs.false181
  ret %struct.op* %o
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_concat(%struct.op* %o) #0 {
entry:
  %0 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %1 = load %struct.op** %0, align 8, !tbaa !15
  %op_type = getelementptr inbounds %struct.op* %1, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %2, 66
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %3 = load i8* %op_private, align 1, !tbaa !11
  %and = and i8 %3, 16
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = getelementptr inbounds %struct.op* %1, i64 1, i32 0
  %5 = load %struct.op** %4, align 8, !tbaa !15
  %op_flags = getelementptr inbounds %struct.op* %5, i64 0, i32 6
  %6 = load i8* %op_flags, align 1, !tbaa !14
  %and6 = and i8 %6, 32
  %tobool7 = icmp eq i8 %and6, 0
  br i1 %tobool7, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true3
  %op_flags8 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %7 = load i8* %op_flags8, align 1, !tbaa !14
  %or = or i8 %7, 64
  store i8 %or, i8* %op_flags8, align 1, !tbaa !14
  br label %if.end

if.end:                                           ; preds = %land.lhs.true3, %land.lhs.true, %if.then, %entry
  ret %struct.op* %o
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_spair(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end33, label %if.then

if.then:                                          ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %1 = load i16* %op_type, align 2, !tbaa !12
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  %conv1 = zext i16 %1 to i32
  %call2 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @modkids to i32 (%struct.op*, i32, ...)*)(%struct.op* %call, i32 %conv1) #4
  %conv3 = sext i32 %call2 to i64
  %2 = inttoptr i64 %conv3 to %struct.op*
  %3 = inttoptr i64 %conv3 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop* %3, i64 0, i32 8
  %4 = load %struct.op** %op_first, align 8, !tbaa !15
  %5 = getelementptr inbounds %struct.op* %4, i64 1, i32 0
  %6 = load %struct.op** %5, align 8, !tbaa !15
  %op_sibling = getelementptr inbounds %struct.op* %6, i64 0, i32 1
  %7 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %tobool5 = icmp eq %struct.op* %7, null
  br i1 %tobool5, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %op_sibling6 = getelementptr inbounds %struct.op* %7, i64 0, i32 1
  %8 = load %struct.op** %op_sibling6, align 8, !tbaa !17
  %tobool7 = icmp eq %struct.op* %8, null
  br i1 %tobool7, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %land.lhs.true
  %op_type8 = getelementptr inbounds %struct.op* %7, i64 0, i32 4
  %9 = load i16* %op_type8, align 2, !tbaa !12
  %idxprom = zext i16 %9 to i64
  %arrayidx = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %idxprom
  %10 = load i64* %arrayidx, align 8, !tbaa !1
  %and9 = and i64 %10, 4
  %tobool10 = icmp eq i64 %and9, 0
  %cmp = icmp eq i16 %9, 10
  %or.cond = or i1 %tobool10, %cmp
  %cmp18 = icmp eq i16 %9, 11
  %or.cond54 = or i1 %or.cond, %cmp18
  %cmp23 = icmp eq i16 %9, 125
  %or.cond55 = or i1 %or.cond54, %cmp23
  %cmp28 = icmp eq i16 %9, 134
  %or.cond56 = or i1 %or.cond55, %cmp28
  br i1 %or.cond56, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false, %if.then
  tail call void @Perl_op_free(%struct.op* %6)
  store %struct.op* %7, %struct.op** %5, align 8, !tbaa !15
  br label %if.end33

if.end33:                                         ; preds = %entry, %if.end
  %o.addr.0 = phi %struct.op* [ %2, %if.end ], [ %o, %entry ]
  %op_type34 = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 4
  %11 = load i16* %op_type34, align 2, !tbaa !12
  %inc = add i16 %11, 1
  store i16 %inc, i16* %op_type34, align 2, !tbaa !12
  %idxprom35 = zext i16 %inc to i64
  %arrayidx36 = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom35
  %12 = load %struct.op* ()** %arrayidx36, align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 2
  store %struct.op* ()* %12, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %call37 = tail call %struct.op* @Perl_ck_fun(%struct.op* %o.addr.0)
  br label %return

return:                                           ; preds = %land.lhs.true, %lor.lhs.false, %if.end33
  %retval.0 = phi %struct.op* [ %call37, %if.end33 ], [ %2, %lor.lhs.false ], [ %2, %land.lhs.true ]
  ret %struct.op* %retval.0
}

declare i32 @modkids(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_fun(%struct.op* %o) #0 {
entry:
  %n_a = alloca i64, align 8
  %len = alloca i64, align 8
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %conv = zext i16 %0 to i32
  %idxprom = zext i16 %0 to i64
  %arrayidx = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %idxprom
  %1 = load i64* %arrayidx, align 8, !tbaa !1
  %shr = lshr i64 %1, 13
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end13, label %if.then

if.then:                                          ; preds = %entry
  %and2 = and i64 %shr, 8
  %tobool3 = icmp eq i64 %and2, 0
  br i1 %tobool3, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %shr4777 = lshr i64 %1, 17
  %tobool5 = icmp ne i64 %shr4777, 0
  %and8 = and i64 %shr4777, 8
  %tobool9 = icmp eq i64 %and8, 0
  %or.cond778 = and i1 %tobool5, %tobool9
  br i1 %or.cond778, label %if.then10, label %if.else

if.then10:                                        ; preds = %land.lhs.true
  %and11 = and i64 %shr, 2251799813685239
  br label %if.end13

if.else:                                          ; preds = %land.lhs.true, %if.then
  %call = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @no_fh_allowed to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv12 = sext i32 %call to i64
  %3 = inttoptr i64 %conv12 to %struct.op*
  br label %return

if.end13:                                         ; preds = %entry, %if.then10
  %oa.0 = phi i64 [ %and11, %if.then10 ], [ %shr, %entry ]
  %and16 = and i8 %2, 4
  %tobool17 = icmp eq i8 %and16, 0
  br i1 %tobool17, label %if.else567, label %if.then18

if.then18:                                        ; preds = %if.end13
  %4 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %5 = load %struct.op** %4, align 8, !tbaa !45
  %op_type20 = getelementptr inbounds %struct.op* %5, i64 0, i32 4
  %6 = load i16* %op_type20, align 2, !tbaa !12
  switch i16 %6, label %if.end32 [
    i16 3, label %if.then30
    i16 0, label %land.lhs.true27
  ]

land.lhs.true27:                                  ; preds = %if.then18
  %op_targ = getelementptr inbounds %struct.op* %5, i64 0, i32 3
  %7 = load i64* %op_targ, align 8, !tbaa !13
  %cmp28 = icmp eq i64 %7, 3
  br i1 %cmp28, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.then18, %land.lhs.true27
  %op_sibling = getelementptr inbounds %struct.op* %5, i64 0, i32 1
  %8 = load %struct.op** %op_sibling, align 8, !tbaa !17
  br label %if.end32

if.end32:                                         ; preds = %if.then18, %if.then30, %land.lhs.true27
  %tokid.0 = phi %struct.op** [ %op_sibling, %if.then30 ], [ %4, %land.lhs.true27 ], [ %4, %if.then18 ]
  %kid.0 = phi %struct.op* [ %8, %if.then30 ], [ %5, %land.lhs.true27 ], [ %5, %if.then18 ]
  %tobool33 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool33, label %land.lhs.true34, label %while.cond.preheader

land.lhs.true34:                                  ; preds = %if.end32
  %and37 = and i64 %1, 128
  %tobool38 = icmp eq i64 %and37, 0
  br i1 %tobool38, label %while.cond.preheader, label %if.then39

if.then39:                                        ; preds = %land.lhs.true34
  %call40 = call i32 (...)* @newDEFSVOP() #4
  %conv41 = sext i32 %call40 to i64
  %9 = inttoptr i64 %conv41 to %struct.op*
  store %struct.op* %9, %struct.op** %tokid.0, align 8, !tbaa !6
  br label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.then39, %if.end32, %land.lhs.true34
  %kid.1.ph = phi %struct.op* [ null, %land.lhs.true34 ], [ %kid.0, %if.end32 ], [ %9, %if.then39 ]
  %cmp58 = icmp ne i16 %0, 2
  %arrayidx168 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %op_ppaddr.i884 = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  %op_private319 = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %10 = getelementptr inbounds %struct.op* %o, i64 1, i32 1
  br label %while.cond.outer

while.cond.outer:                                 ; preds = %while.cond.preheader, %sw.epilog
  %oa.1.ph = phi i64 [ %shr542, %sw.epilog ], [ %oa.0, %while.cond.preheader ]
  %numargs.0.ph = phi i64 [ %inc.us, %sw.epilog ], [ 0, %while.cond.preheader ]
  %tokid.1.ph = phi %struct.op** [ %op_sibling543, %sw.epilog ], [ %tokid.0, %while.cond.preheader ]
  %kid.1.ph946 = phi %struct.op* [ %252, %sw.epilog ], [ %kid.1.ph, %while.cond.preheader ]
  %not.tobool43 = icmp eq i64 %oa.1.ph, 0
  %and46 = and i64 %oa.1.ph, 7
  %cmp68 = icmp slt i64 %oa.1.ph, 16
  br i1 %not.tobool43, label %while.end, label %while.cond.us

while.cond.us:                                    ; preds = %while.cond.outer, %sw.bb67.us
  %numargs.0.us = phi i64 [ %inc.us, %sw.bb67.us ], [ %numargs.0.ph, %while.cond.outer ]
  %kid.1.us = phi %struct.op* [ null, %sw.bb67.us ], [ %kid.1.ph946, %while.cond.outer ]
  %tobool44.us = icmp eq %struct.op* %kid.1.us, null
  br i1 %tobool44.us, label %while.end, label %while.body.us

while.body.us:                                    ; preds = %while.cond.us
  %inc.us = add nsw i64 %numargs.0.us, 1
  switch i64 %and46, label %sw.epilog [
    i64 1, label %sw.bb
    i64 2, label %sw.bb67.us
    i64 3, label %sw.bb74
    i64 4, label %sw.bb188
    i64 5, label %sw.bb275
    i64 6, label %sw.bb281
    i64 7, label %sw.bb539
  ]

sw.bb67.us:                                       ; preds = %while.body.us
  br i1 %cmp68, label %while.cond.us, label %if.else71

sw.bb:                                            ; preds = %while.body.us
  %cmp47 = icmp ne i64 %numargs.0.us, 0
  %tobool51 = icmp ugt i64 %oa.1.ph, 15
  %or.cond779 = or i1 %cmp47, %tobool51
  br i1 %or.cond779, label %if.end65, label %land.lhs.true52

land.lhs.true52:                                  ; preds = %sw.bb
  %op_type53 = getelementptr inbounds %struct.op* %kid.1.us, i64 0, i32 4
  %11 = load i16* %op_type53, align 2, !tbaa !12
  %cmp55 = icmp eq i16 %11, 141
  %or.cond = and i1 %cmp55, %cmp58
  br i1 %or.cond, label %if.then60, label %if.end65

if.then60:                                        ; preds = %land.lhs.true52
  %12 = load i8** %arrayidx168, align 8, !tbaa !6
  %call63 = call i32 (%struct.op*, i8*, ...)* bitcast (i32 (...)* @too_many_arguments to i32 (%struct.op*, i8*, ...)*)(%struct.op* %o, i8* %12) #4
  %conv64 = sext i32 %call63 to i64
  %13 = inttoptr i64 %conv64 to %struct.op*
  br label %return

if.end65:                                         ; preds = %sw.bb, %land.lhs.true52
  %call66 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %kid.1.us) #4
  br label %sw.epilog

if.else71:                                        ; preds = %sw.bb67.us
  %call72 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %kid.1.us) #4
  br label %sw.epilog

sw.bb74:                                          ; preds = %while.body.us
  %op_sibling45.le = getelementptr inbounds %struct.op* %kid.1.us, i64 0, i32 1
  %14 = load %struct.op** %op_sibling45.le, align 8, !tbaa !17
  switch i16 %0, label %if.end111 [
    i16 149, label %land.lhs.true80
    i16 146, label %land.lhs.true80
  ]

land.lhs.true80:                                  ; preds = %sw.bb74, %sw.bb74
  %tobool82 = icmp eq %struct.op* %14, null
  br i1 %tobool82, label %land.lhs.true83, label %if.end111

land.lhs.true83:                                  ; preds = %land.lhs.true80
  %15 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %15, i64 0, i32 14
  %16 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp84 = icmp eq %struct.sv* %16, null
  br i1 %cmp84, label %lor.lhs.false100, label %land.lhs.true86

land.lhs.true86:                                  ; preds = %land.lhs.true83
  %17 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings87 = getelementptr inbounds %struct.cop* %17, i64 0, i32 14
  %18 = load %struct.sv** %cop_warnings87, align 8, !tbaa !47
  %cmp88 = icmp eq %struct.sv* %18, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp88, label %lor.lhs.false100, label %land.lhs.true90

land.lhs.true90:                                  ; preds = %land.lhs.true86
  %19 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings91 = getelementptr inbounds %struct.cop* %19, i64 0, i32 14
  %20 = load %struct.sv** %cop_warnings91, align 8, !tbaa !47
  %cmp92 = icmp eq %struct.sv* %20, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp92, label %if.then108, label %lor.lhs.false94

lor.lhs.false94:                                  ; preds = %land.lhs.true90
  %21 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings95 = getelementptr inbounds %struct.cop* %21, i64 0, i32 14
  %22 = load %struct.sv** %cop_warnings95, align 8, !tbaa !47
  %sv_any = getelementptr inbounds %struct.sv* %22, i64 0, i32 0
  %23 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %23 to i8**
  %24 = load i8** %xpv_pv, align 8, !tbaa !39
  %arrayidx96 = getelementptr inbounds i8* %24, i64 7
  %25 = load i8* %arrayidx96, align 1, !tbaa !5
  %and98 = and i8 %25, 1
  %tobool99 = icmp eq i8 %and98, 0
  br i1 %tobool99, label %lor.lhs.false100, label %if.then108

lor.lhs.false100:                                 ; preds = %lor.lhs.false94, %land.lhs.true86, %land.lhs.true83
  %26 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings101 = getelementptr inbounds %struct.cop* %26, i64 0, i32 14
  %27 = load %struct.sv** %cop_warnings101, align 8, !tbaa !47
  %cmp102 = icmp eq %struct.sv* %27, null
  br i1 %cmp102, label %land.lhs.true104, label %if.end111

land.lhs.true104:                                 ; preds = %lor.lhs.false100
  %28 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and106 = and i8 %28, 1
  %tobool107 = icmp eq i8 %and106, 0
  br i1 %tobool107, label %if.end111, label %if.then108

if.then108:                                       ; preds = %lor.lhs.false94, %land.lhs.true104, %land.lhs.true90
  %29 = load i8** %arrayidx168, align 8, !tbaa !6
  call void (i64, i8*, ...)* @Perl_warner(i64 28, i8* getelementptr inbounds ([33 x i8]* @.str97, i64 0, i64 0), i8* %29) #4
  br label %if.end111

if.end111:                                        ; preds = %sw.bb74, %land.lhs.true104, %land.lhs.true80, %if.then108, %lor.lhs.false100
  %op_type112 = getelementptr inbounds %struct.op* %kid.1.us, i64 0, i32 4
  %30 = load i16* %op_type112, align 2, !tbaa !12
  switch i16 %30, label %if.then181 [
    i16 5, label %land.lhs.true116
    i16 125, label %if.end186
    i16 10, label %if.end186
  ]

land.lhs.true116:                                 ; preds = %if.end111
  %op_private = getelementptr inbounds %struct.op* %kid.1.us, i64 0, i32 7
  %31 = load i8* %op_private, align 1, !tbaa !11
  %and118 = and i8 %31, 64
  %tobool119 = icmp eq i8 %and118, 0
  br i1 %tobool119, label %if.then181, label %if.then120

if.then120:                                       ; preds = %land.lhs.true116
  %op_sv = getelementptr inbounds %struct.op* %kid.1.us, i64 1
  %32 = bitcast %struct.op* %op_sv to %struct.sv**
  %33 = load %struct.sv** %32, align 8, !tbaa !18
  store %struct.sv* %33, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %sv_flags = getelementptr inbounds %struct.sv* %33, i64 0, i32 2
  %34 = load i64* %sv_flags, align 8, !tbaa !34
  %and121 = and i64 %34, 262144
  %cmp122 = icmp eq i64 %and121, 0
  br i1 %cmp122, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then120
  %sv_any124 = getelementptr inbounds %struct.sv* %33, i64 0, i32 0
  %35 = load i8** %sv_any124, align 8, !tbaa !36
  %xpv_cur = getelementptr inbounds i8* %35, i64 8
  %36 = bitcast i8* %xpv_cur to i64*
  %37 = load i64* %36, align 8, !tbaa !37
  store i64 %37, i64* %n_a, align 8, !tbaa !1
  %xpv_pv126 = bitcast i8* %35 to i8**
  %38 = load i8** %xpv_pv126, align 8, !tbaa !39
  br label %cond.end

cond.false:                                       ; preds = %if.then120
  %call127 = call i8* @Perl_sv_2pv_flags(%struct.sv* %33, i64* %n_a, i64 2) #4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %38, %cond.true ], [ %call127, %cond.false ]
  %call128 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond, i64 1, i64 10) #4
  %39 = bitcast %struct.gv* %call128 to %struct.sv*
  store %struct.sv* %39, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool.i = icmp eq %struct.gv* %call128, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %cond.end
  %40 = getelementptr inbounds %struct.gv* %call128, i64 0, i32 1
  %41 = load i64* %40, align 8, !tbaa !40
  %inc.i = add i64 %41, 1
  store i64 %inc.i, i64* %40, align 8, !tbaa !40
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %cond.end, %land.rhs.i
  %call.i780 = call i8* @Perl_safesysmalloc(i64 48) #4
  call void @llvm.memset.p0i8.i64(i8* %call.i780, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i780, i64 32
  %42 = bitcast i8* %op_type.i to i16*
  store i16 7, i16* %42, align 2, !tbaa !71
  %43 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 7), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i780, i64 16
  %44 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %43, %struct.op* ()** %44, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i780, i64 40
  %45 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %39, %struct.sv** %45, align 8, !tbaa !18
  %46 = bitcast i8* %call.i780 to %struct.op*
  %op_next.i = bitcast i8* %call.i780 to %struct.op**
  store %struct.op* %46, %struct.op** %op_next.i, align 8, !tbaa !73
  %47 = getelementptr inbounds i8* %call.i780, i64 36
  store i8 0, i8* %47, align 1, !tbaa !74
  %48 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  %and.i = and i64 %48, 4
  %tobool.i781 = icmp eq i64 %and.i, 0
  br i1 %tobool.i781, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %Perl_newGVOP.exit
  %call3.i = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %46) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %Perl_newGVOP.exit
  %49 = phi i64 [ %48, %Perl_newGVOP.exit ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %49, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 7, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i780, i64 24
  %50 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %50, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %51 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %51, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %51, i64 7
  %52 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %52, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  call void @Perl_op_free(%struct.op* %46) #4
  %53 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 7), align 8, !tbaa !6
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %53) #4
  br label %Perl_newSVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %54 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 7), align 8, !tbaa !6
  %call17.i = call %struct.op* %54(%struct.op* %46) #4
  br label %Perl_newSVOP.exit

Perl_newSVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  %op_type.i782 = getelementptr inbounds %struct.op* %cond.i, i64 0, i32 4
  %55 = load i16* %op_type.i782, align 2, !tbaa !12
  switch i16 %55, label %if.end33.i [
    i16 12, label %if.then.i784
    i16 125, label %land.lhs.true.i785
    i16 10, label %land.lhs.true.i785
  ]

if.then.i784:                                     ; preds = %Perl_newSVOP.exit
  store i16 10, i16* %op_type.i782, align 2, !tbaa !12
  %56 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 10), align 8, !tbaa !6
  %op_ppaddr.i783 = getelementptr inbounds %struct.op* %cond.i, i64 0, i32 2
  store %struct.op* ()* %56, %struct.op* ()** %op_ppaddr.i783, align 8, !tbaa !41
  br label %Perl_newAVREF.exit

land.lhs.true.i785:                               ; preds = %Perl_newSVOP.exit, %Perl_newSVOP.exit
  %57 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings.i = getelementptr inbounds %struct.cop* %57, i64 0, i32 14
  %58 = load %struct.sv** %cop_warnings.i, align 8, !tbaa !47
  %cmp11.i = icmp eq %struct.sv* %58, null
  br i1 %cmp11.i, label %lor.lhs.false24.i, label %land.lhs.true13.i

land.lhs.true13.i:                                ; preds = %land.lhs.true.i785
  %59 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings14.i = getelementptr inbounds %struct.cop* %59, i64 0, i32 14
  %60 = load %struct.sv** %cop_warnings14.i, align 8, !tbaa !47
  %cmp15.i = icmp eq %struct.sv* %60, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp15.i, label %lor.lhs.false24.i, label %land.lhs.true17.i

land.lhs.true17.i:                                ; preds = %land.lhs.true13.i
  %61 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings18.i = getelementptr inbounds %struct.cop* %61, i64 0, i32 14
  %62 = load %struct.sv** %cop_warnings18.i, align 8, !tbaa !47
  %cmp19.i = icmp eq %struct.sv* %62, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp19.i, label %if.then32.i, label %lor.lhs.false21.i

lor.lhs.false21.i:                                ; preds = %land.lhs.true17.i
  %63 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings22.i = getelementptr inbounds %struct.cop* %63, i64 0, i32 14
  %64 = load %struct.sv** %cop_warnings22.i, align 8, !tbaa !47
  %sv_any.i = getelementptr inbounds %struct.sv* %64, i64 0, i32 0
  %65 = load i8** %sv_any.i, align 8, !tbaa !36
  %xpv_pv.i = bitcast i8* %65 to i8**
  %66 = load i8** %xpv_pv.i, align 8, !tbaa !39
  %67 = load i8* %66, align 1, !tbaa !5
  %and.i786 = and i8 %67, 16
  %tobool.i787 = icmp eq i8 %and.i786, 0
  br i1 %tobool.i787, label %lor.lhs.false24.i, label %if.then32.i

lor.lhs.false24.i:                                ; preds = %lor.lhs.false21.i, %land.lhs.true13.i, %land.lhs.true.i785
  %68 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings25.i = getelementptr inbounds %struct.cop* %68, i64 0, i32 14
  %69 = load %struct.sv** %cop_warnings25.i, align 8, !tbaa !47
  %cmp26.i = icmp eq %struct.sv* %69, null
  br i1 %cmp26.i, label %land.lhs.true28.i, label %if.end33.i

land.lhs.true28.i:                                ; preds = %lor.lhs.false24.i
  %70 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and30.i = and i8 %70, 1
  %tobool31.i = icmp eq i8 %and30.i, 0
  br i1 %tobool31.i, label %if.end33.i, label %if.then32.i

if.then32.i:                                      ; preds = %land.lhs.true28.i, %lor.lhs.false21.i, %land.lhs.true17.i
  call void (i64, i8*, ...)* @Perl_warner(i64 2, i8* getelementptr inbounds ([44 x i8]* @.str84, i64 0, i64 0)) #4
  br label %if.end33.i

if.end33.i:                                       ; preds = %if.then32.i, %land.lhs.true28.i, %lor.lhs.false24.i, %Perl_newSVOP.exit
  %call.i = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %cond.i) #4
  %conv34.i = sext i32 %call.i to i64
  %71 = inttoptr i64 %conv34.i to %struct.op*
  %call35.i = call %struct.op* @Perl_newUNOP(i64 125, i64 0, %struct.op* %71) #4
  br label %Perl_newAVREF.exit

Perl_newAVREF.exit:                               ; preds = %if.then.i784, %if.end33.i
  %retval.0.i = phi %struct.op* [ %cond.i, %if.then.i784 ], [ %call35.i, %if.end33.i ]
  %72 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings131 = getelementptr inbounds %struct.cop* %72, i64 0, i32 14
  %73 = load %struct.sv** %cop_warnings131, align 8, !tbaa !47
  %cmp132 = icmp eq %struct.sv* %73, null
  br i1 %cmp132, label %lor.lhs.false158, label %land.lhs.true134

land.lhs.true134:                                 ; preds = %Perl_newAVREF.exit
  %74 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings135 = getelementptr inbounds %struct.cop* %74, i64 0, i32 14
  %75 = load %struct.sv** %cop_warnings135, align 8, !tbaa !47
  %cmp136 = icmp eq %struct.sv* %75, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp136, label %lor.lhs.false158, label %land.lhs.true138

land.lhs.true138:                                 ; preds = %land.lhs.true134
  %76 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings139 = getelementptr inbounds %struct.cop* %76, i64 0, i32 14
  %77 = load %struct.sv** %cop_warnings139, align 8, !tbaa !47
  %cmp140 = icmp eq %struct.sv* %77, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp140, label %if.then166, label %lor.lhs.false142

lor.lhs.false142:                                 ; preds = %land.lhs.true138
  %78 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings143 = getelementptr inbounds %struct.cop* %78, i64 0, i32 14
  %79 = load %struct.sv** %cop_warnings143, align 8, !tbaa !47
  %sv_any144 = getelementptr inbounds %struct.sv* %79, i64 0, i32 0
  %80 = load i8** %sv_any144, align 8, !tbaa !36
  %xpv_pv145 = bitcast i8* %80 to i8**
  %81 = load i8** %xpv_pv145, align 8, !tbaa !39
  %82 = load i8* %81, align 1, !tbaa !5
  %and148 = and i8 %82, 16
  %tobool149 = icmp eq i8 %and148, 0
  br i1 %tobool149, label %lor.lhs.false150, label %if.then166

lor.lhs.false150:                                 ; preds = %lor.lhs.false142
  %83 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings151 = getelementptr inbounds %struct.cop* %83, i64 0, i32 14
  %84 = load %struct.sv** %cop_warnings151, align 8, !tbaa !47
  %sv_any152 = getelementptr inbounds %struct.sv* %84, i64 0, i32 0
  %85 = load i8** %sv_any152, align 8, !tbaa !36
  %xpv_pv153 = bitcast i8* %85 to i8**
  %86 = load i8** %xpv_pv153, align 8, !tbaa !39
  %arrayidx154 = getelementptr inbounds i8* %86, i64 7
  %87 = load i8* %arrayidx154, align 1, !tbaa !5
  %and156 = and i8 %87, 1
  %tobool157 = icmp eq i8 %and156, 0
  br i1 %tobool157, label %lor.lhs.false158, label %if.then166

lor.lhs.false158:                                 ; preds = %lor.lhs.false150, %land.lhs.true134, %Perl_newAVREF.exit
  %88 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings159 = getelementptr inbounds %struct.cop* %88, i64 0, i32 14
  %89 = load %struct.sv** %cop_warnings159, align 8, !tbaa !47
  %cmp160 = icmp eq %struct.sv* %89, null
  br i1 %cmp160, label %land.lhs.true162, label %if.end169

land.lhs.true162:                                 ; preds = %lor.lhs.false158
  %90 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and164 = and i8 %90, 1
  %tobool165 = icmp eq i8 %and164, 0
  br i1 %tobool165, label %if.end169, label %if.then166

if.then166:                                       ; preds = %lor.lhs.false150, %lor.lhs.false142, %land.lhs.true162, %land.lhs.true138
  %91 = load i8** %arrayidx168, align 8, !tbaa !6
  call void (i64, i8*, ...)* @Perl_warner(i64 7170, i8* getelementptr inbounds ([48 x i8]* @.str98, i64 0, i64 0), i8* %cond, i64 %inc.us, i8* %91) #4
  br label %if.end169

if.end169:                                        ; preds = %land.lhs.true162, %if.then166, %lor.lhs.false158
  call void @Perl_op_free(%struct.op* %kid.1.us)
  %op_sibling170 = getelementptr inbounds %struct.op* %retval.0.i, i64 0, i32 1
  store %struct.op* %14, %struct.op** %op_sibling170, align 8, !tbaa !17
  store %struct.op* %retval.0.i, %struct.op** %tokid.1.ph, align 8, !tbaa !6
  br label %if.end186

if.then181:                                       ; preds = %if.end111, %land.lhs.true116
  %92 = load i8** %arrayidx168, align 8, !tbaa !6
  %call184 = call i32 (i64, i8*, i8*, %struct.op*, ...)* bitcast (i32 (...)* @bad_type to i32 (i64, i8*, i8*, %struct.op*, ...)*)(i64 %inc.us, i8* getelementptr inbounds ([6 x i8]* @.str99, i64 0, i64 0), i8* %92, %struct.op* %kid.1.us) #4
  br label %if.end186

if.end186:                                        ; preds = %if.end111, %if.end111, %if.then181, %if.end169
  %kid.2 = phi %struct.op* [ %retval.0.i, %if.end169 ], [ %kid.1.us, %if.then181 ], [ %kid.1.us, %if.end111 ], [ %kid.1.us, %if.end111 ]
  %call187 = call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i32, ...)*)(%struct.op* %kid.2, i32 %conv) #4
  br label %sw.epilog

sw.bb188:                                         ; preds = %while.body.us
  %op_sibling45.le992 = getelementptr inbounds %struct.op* %kid.1.us, i64 0, i32 1
  %93 = load %struct.op** %op_sibling45.le992, align 8, !tbaa !17
  %op_type189 = getelementptr inbounds %struct.op* %kid.1.us, i64 0, i32 4
  %94 = load i16* %op_type189, align 2, !tbaa !12
  switch i16 %94, label %if.then268 [
    i16 5, label %land.lhs.true193
    i16 134, label %if.end273
    i16 11, label %if.end273
  ]

land.lhs.true193:                                 ; preds = %sw.bb188
  %op_private194 = getelementptr inbounds %struct.op* %kid.1.us, i64 0, i32 7
  %95 = load i8* %op_private194, align 1, !tbaa !11
  %and196 = and i8 %95, 64
  %tobool197 = icmp eq i8 %and196, 0
  br i1 %tobool197, label %if.then268, label %if.then198

if.then198:                                       ; preds = %land.lhs.true193
  %op_sv200 = getelementptr inbounds %struct.op* %kid.1.us, i64 1
  %96 = bitcast %struct.op* %op_sv200 to %struct.sv**
  %97 = load %struct.sv** %96, align 8, !tbaa !18
  store %struct.sv* %97, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %sv_flags201 = getelementptr inbounds %struct.sv* %97, i64 0, i32 2
  %98 = load i64* %sv_flags201, align 8, !tbaa !34
  %and202 = and i64 %98, 262144
  %cmp203 = icmp eq i64 %and202, 0
  br i1 %cmp203, label %cond.false210, label %cond.true205

cond.true205:                                     ; preds = %if.then198
  %sv_any206 = getelementptr inbounds %struct.sv* %97, i64 0, i32 0
  %99 = load i8** %sv_any206, align 8, !tbaa !36
  %xpv_cur207 = getelementptr inbounds i8* %99, i64 8
  %100 = bitcast i8* %xpv_cur207 to i64*
  %101 = load i64* %100, align 8, !tbaa !37
  store i64 %101, i64* %n_a, align 8, !tbaa !1
  %xpv_pv209 = bitcast i8* %99 to i8**
  %102 = load i8** %xpv_pv209, align 8, !tbaa !39
  br label %cond.end212

cond.false210:                                    ; preds = %if.then198
  %call211 = call i8* @Perl_sv_2pv_flags(%struct.sv* %97, i64* %n_a, i64 2) #4
  br label %cond.end212

cond.end212:                                      ; preds = %cond.false210, %cond.true205
  %cond213 = phi i8* [ %102, %cond.true205 ], [ %call211, %cond.false210 ]
  %call215 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond213, i64 1, i64 11) #4
  %103 = bitcast %struct.gv* %call215 to %struct.sv*
  store %struct.sv* %103, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool.i788 = icmp eq %struct.gv* %call215, null
  br i1 %tobool.i788, label %Perl_newGVOP.exit792, label %land.rhs.i790

land.rhs.i790:                                    ; preds = %cond.end212
  %104 = getelementptr inbounds %struct.gv* %call215, i64 0, i32 1
  %105 = load i64* %104, align 8, !tbaa !40
  %inc.i789 = add i64 %105, 1
  store i64 %inc.i789, i64* %104, align 8, !tbaa !40
  br label %Perl_newGVOP.exit792

Perl_newGVOP.exit792:                             ; preds = %cond.end212, %land.rhs.i790
  %call.i793 = call i8* @Perl_safesysmalloc(i64 48) #4
  call void @llvm.memset.p0i8.i64(i8* %call.i793, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i794 = getelementptr inbounds i8* %call.i793, i64 32
  %106 = bitcast i8* %op_type.i794 to i16*
  store i16 7, i16* %106, align 2, !tbaa !71
  %107 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 7), align 8, !tbaa !6
  %op_ppaddr.i795 = getelementptr inbounds i8* %call.i793, i64 16
  %108 = bitcast i8* %op_ppaddr.i795 to %struct.op* ()**
  store %struct.op* ()* %107, %struct.op* ()** %108, align 8, !tbaa !72
  %op_sv.i796 = getelementptr inbounds i8* %call.i793, i64 40
  %109 = bitcast i8* %op_sv.i796 to %struct.sv**
  store %struct.sv* %103, %struct.sv** %109, align 8, !tbaa !18
  %110 = bitcast i8* %call.i793 to %struct.op*
  %op_next.i797 = bitcast i8* %call.i793 to %struct.op**
  store %struct.op* %110, %struct.op** %op_next.i797, align 8, !tbaa !73
  %111 = getelementptr inbounds i8* %call.i793, i64 36
  store i8 0, i8* %111, align 1, !tbaa !74
  %112 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  %and.i798 = and i64 %112, 4
  %tobool.i799 = icmp eq i64 %and.i798, 0
  br i1 %tobool.i799, label %if.end.i805, label %if.then.i802

if.then.i802:                                     ; preds = %Perl_newGVOP.exit792
  %call3.i800 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %110) #4
  %.pre.i801 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  br label %if.end.i805

if.end.i805:                                      ; preds = %if.then.i802, %Perl_newGVOP.exit792
  %113 = phi i64 [ %112, %Perl_newGVOP.exit792 ], [ %.pre.i801, %if.then.i802 ]
  %and5.i803 = and i64 %113, 8
  %tobool6.i804 = icmp eq i64 %and5.i803, 0
  br i1 %tobool6.i804, label %if.end10.i811, label %if.then7.i809

if.then7.i809:                                    ; preds = %if.end.i805
  %call8.i806 = call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 7, i32 512) #4
  %conv9.i807 = sext i32 %call8.i806 to i64
  %op_targ.i808 = getelementptr inbounds i8* %call.i793, i64 24
  %114 = bitcast i8* %op_targ.i808 to i64*
  store i64 %conv9.i807, i64* %114, align 8, !tbaa !75
  br label %if.end10.i811

if.end10.i811:                                    ; preds = %if.then7.i809, %if.end.i805
  %115 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i810 = icmp eq i8* %115, null
  br i1 %tobool11.i810, label %cond.false.i817, label %land.lhs.true.i814

land.lhs.true.i814:                               ; preds = %if.end10.i811
  %arrayidx12.i812 = getelementptr inbounds i8* %115, i64 7
  %116 = load i8* %arrayidx12.i812, align 1, !tbaa !5
  %tobool14.i813 = icmp eq i8 %116, 0
  br i1 %tobool14.i813, label %cond.false.i817, label %cond.true.i815

cond.true.i815:                                   ; preds = %land.lhs.true.i814
  call void @Perl_op_free(%struct.op* %110) #4
  %117 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 7), align 8, !tbaa !6
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %117) #4
  br label %Perl_newSVOP.exit819

cond.false.i817:                                  ; preds = %land.lhs.true.i814, %if.end10.i811
  %118 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 7), align 8, !tbaa !6
  %call17.i816 = call %struct.op* %118(%struct.op* %110) #4
  br label %Perl_newSVOP.exit819

Perl_newSVOP.exit819:                             ; preds = %cond.true.i815, %cond.false.i817
  %cond.i818 = phi %struct.op* [ null, %cond.true.i815 ], [ %call17.i816, %cond.false.i817 ]
  %op_type.i820 = getelementptr inbounds %struct.op* %cond.i818, i64 0, i32 4
  %119 = load i16* %op_type.i820, align 2, !tbaa !12
  switch i16 %119, label %if.end33.i848 [
    i16 12, label %if.then.i822
    i16 134, label %land.lhs.true.i825
    i16 11, label %land.lhs.true.i825
  ]

if.then.i822:                                     ; preds = %Perl_newSVOP.exit819
  store i16 11, i16* %op_type.i820, align 2, !tbaa !12
  %120 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 11), align 8, !tbaa !6
  %op_ppaddr.i821 = getelementptr inbounds %struct.op* %cond.i818, i64 0, i32 2
  store %struct.op* ()* %120, %struct.op* ()** %op_ppaddr.i821, align 8, !tbaa !41
  br label %Perl_newHVREF.exit

land.lhs.true.i825:                               ; preds = %Perl_newSVOP.exit819, %Perl_newSVOP.exit819
  %121 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings.i823 = getelementptr inbounds %struct.cop* %121, i64 0, i32 14
  %122 = load %struct.sv** %cop_warnings.i823, align 8, !tbaa !47
  %cmp11.i824 = icmp eq %struct.sv* %122, null
  br i1 %cmp11.i824, label %lor.lhs.false24.i840, label %land.lhs.true13.i828

land.lhs.true13.i828:                             ; preds = %land.lhs.true.i825
  %123 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings14.i826 = getelementptr inbounds %struct.cop* %123, i64 0, i32 14
  %124 = load %struct.sv** %cop_warnings14.i826, align 8, !tbaa !47
  %cmp15.i827 = icmp eq %struct.sv* %124, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp15.i827, label %lor.lhs.false24.i840, label %land.lhs.true17.i831

land.lhs.true17.i831:                             ; preds = %land.lhs.true13.i828
  %125 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings18.i829 = getelementptr inbounds %struct.cop* %125, i64 0, i32 14
  %126 = load %struct.sv** %cop_warnings18.i829, align 8, !tbaa !47
  %cmp19.i830 = icmp eq %struct.sv* %126, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp19.i830, label %if.then32.i844, label %lor.lhs.false21.i837

lor.lhs.false21.i837:                             ; preds = %land.lhs.true17.i831
  %127 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings22.i832 = getelementptr inbounds %struct.cop* %127, i64 0, i32 14
  %128 = load %struct.sv** %cop_warnings22.i832, align 8, !tbaa !47
  %sv_any.i833 = getelementptr inbounds %struct.sv* %128, i64 0, i32 0
  %129 = load i8** %sv_any.i833, align 8, !tbaa !36
  %xpv_pv.i834 = bitcast i8* %129 to i8**
  %130 = load i8** %xpv_pv.i834, align 8, !tbaa !39
  %131 = load i8* %130, align 1, !tbaa !5
  %and.i835 = and i8 %131, 16
  %tobool.i836 = icmp eq i8 %and.i835, 0
  br i1 %tobool.i836, label %lor.lhs.false24.i840, label %if.then32.i844

lor.lhs.false24.i840:                             ; preds = %lor.lhs.false21.i837, %land.lhs.true13.i828, %land.lhs.true.i825
  %132 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings25.i838 = getelementptr inbounds %struct.cop* %132, i64 0, i32 14
  %133 = load %struct.sv** %cop_warnings25.i838, align 8, !tbaa !47
  %cmp26.i839 = icmp eq %struct.sv* %133, null
  br i1 %cmp26.i839, label %land.lhs.true28.i843, label %if.end33.i848

land.lhs.true28.i843:                             ; preds = %lor.lhs.false24.i840
  %134 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and30.i841 = and i8 %134, 1
  %tobool31.i842 = icmp eq i8 %and30.i841, 0
  br i1 %tobool31.i842, label %if.end33.i848, label %if.then32.i844

if.then32.i844:                                   ; preds = %land.lhs.true28.i843, %lor.lhs.false21.i837, %land.lhs.true17.i831
  call void (i64, i8*, ...)* @Perl_warner(i64 2, i8* getelementptr inbounds ([42 x i8]* @.str85, i64 0, i64 0)) #4
  br label %if.end33.i848

if.end33.i848:                                    ; preds = %if.then32.i844, %land.lhs.true28.i843, %lor.lhs.false24.i840, %Perl_newSVOP.exit819
  %call.i845 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %cond.i818) #4
  %conv34.i846 = sext i32 %call.i845 to i64
  %135 = inttoptr i64 %conv34.i846 to %struct.op*
  %call35.i847 = call %struct.op* @Perl_newUNOP(i64 134, i64 0, %struct.op* %135) #4
  br label %Perl_newHVREF.exit

Perl_newHVREF.exit:                               ; preds = %if.then.i822, %if.end33.i848
  %retval.0.i849 = phi %struct.op* [ %cond.i818, %if.then.i822 ], [ %call35.i847, %if.end33.i848 ]
  %136 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings218 = getelementptr inbounds %struct.cop* %136, i64 0, i32 14
  %137 = load %struct.sv** %cop_warnings218, align 8, !tbaa !47
  %cmp219 = icmp eq %struct.sv* %137, null
  br i1 %cmp219, label %lor.lhs.false245, label %land.lhs.true221

land.lhs.true221:                                 ; preds = %Perl_newHVREF.exit
  %138 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings222 = getelementptr inbounds %struct.cop* %138, i64 0, i32 14
  %139 = load %struct.sv** %cop_warnings222, align 8, !tbaa !47
  %cmp223 = icmp eq %struct.sv* %139, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp223, label %lor.lhs.false245, label %land.lhs.true225

land.lhs.true225:                                 ; preds = %land.lhs.true221
  %140 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings226 = getelementptr inbounds %struct.cop* %140, i64 0, i32 14
  %141 = load %struct.sv** %cop_warnings226, align 8, !tbaa !47
  %cmp227 = icmp eq %struct.sv* %141, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp227, label %if.then253, label %lor.lhs.false229

lor.lhs.false229:                                 ; preds = %land.lhs.true225
  %142 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings230 = getelementptr inbounds %struct.cop* %142, i64 0, i32 14
  %143 = load %struct.sv** %cop_warnings230, align 8, !tbaa !47
  %sv_any231 = getelementptr inbounds %struct.sv* %143, i64 0, i32 0
  %144 = load i8** %sv_any231, align 8, !tbaa !36
  %xpv_pv232 = bitcast i8* %144 to i8**
  %145 = load i8** %xpv_pv232, align 8, !tbaa !39
  %146 = load i8* %145, align 1, !tbaa !5
  %and235 = and i8 %146, 16
  %tobool236 = icmp eq i8 %and235, 0
  br i1 %tobool236, label %lor.lhs.false237, label %if.then253

lor.lhs.false237:                                 ; preds = %lor.lhs.false229
  %147 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings238 = getelementptr inbounds %struct.cop* %147, i64 0, i32 14
  %148 = load %struct.sv** %cop_warnings238, align 8, !tbaa !47
  %sv_any239 = getelementptr inbounds %struct.sv* %148, i64 0, i32 0
  %149 = load i8** %sv_any239, align 8, !tbaa !36
  %xpv_pv240 = bitcast i8* %149 to i8**
  %150 = load i8** %xpv_pv240, align 8, !tbaa !39
  %arrayidx241 = getelementptr inbounds i8* %150, i64 7
  %151 = load i8* %arrayidx241, align 1, !tbaa !5
  %and243 = and i8 %151, 1
  %tobool244 = icmp eq i8 %and243, 0
  br i1 %tobool244, label %lor.lhs.false245, label %if.then253

lor.lhs.false245:                                 ; preds = %lor.lhs.false237, %land.lhs.true221, %Perl_newHVREF.exit
  %152 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings246 = getelementptr inbounds %struct.cop* %152, i64 0, i32 14
  %153 = load %struct.sv** %cop_warnings246, align 8, !tbaa !47
  %cmp247 = icmp eq %struct.sv* %153, null
  br i1 %cmp247, label %land.lhs.true249, label %if.end256

land.lhs.true249:                                 ; preds = %lor.lhs.false245
  %154 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and251 = and i8 %154, 1
  %tobool252 = icmp eq i8 %and251, 0
  br i1 %tobool252, label %if.end256, label %if.then253

if.then253:                                       ; preds = %lor.lhs.false237, %lor.lhs.false229, %land.lhs.true249, %land.lhs.true225
  %155 = load i8** %arrayidx168, align 8, !tbaa !6
  call void (i64, i8*, ...)* @Perl_warner(i64 7170, i8* getelementptr inbounds ([49 x i8]* @.str100, i64 0, i64 0), i8* %cond213, i64 %inc.us, i8* %155) #4
  br label %if.end256

if.end256:                                        ; preds = %land.lhs.true249, %if.then253, %lor.lhs.false245
  call void @Perl_op_free(%struct.op* %kid.1.us)
  %op_sibling257 = getelementptr inbounds %struct.op* %retval.0.i849, i64 0, i32 1
  store %struct.op* %93, %struct.op** %op_sibling257, align 8, !tbaa !17
  store %struct.op* %retval.0.i849, %struct.op** %tokid.1.ph, align 8, !tbaa !6
  br label %if.end273

if.then268:                                       ; preds = %sw.bb188, %land.lhs.true193
  %156 = load i8** %arrayidx168, align 8, !tbaa !6
  %call271 = call i32 (i64, i8*, i8*, %struct.op*, ...)* bitcast (i32 (...)* @bad_type to i32 (i64, i8*, i8*, %struct.op*, ...)*)(i64 %inc.us, i8* getelementptr inbounds ([5 x i8]* @.str101, i64 0, i64 0), i8* %156, %struct.op* %kid.1.us) #4
  br label %if.end273

if.end273:                                        ; preds = %sw.bb188, %sw.bb188, %if.then268, %if.end256
  %kid.3 = phi %struct.op* [ %retval.0.i849, %if.end256 ], [ %kid.1.us, %if.then268 ], [ %kid.1.us, %sw.bb188 ], [ %kid.1.us, %sw.bb188 ]
  %call274 = call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i32, ...)*)(%struct.op* %kid.3, i32 %conv) #4
  br label %sw.epilog

sw.bb275:                                         ; preds = %while.body.us
  %op_sibling45.le1000 = getelementptr inbounds %struct.op* %kid.1.us, i64 0, i32 1
  %op_sibling45.le994 = getelementptr inbounds %struct.op* %kid.1.us, i64 0, i32 1
  %157 = load %struct.op** %op_sibling45.le994, align 8, !tbaa !17
  %call277 = call %struct.op* @Perl_newUNOP(i64 0, i64 0, %struct.op* %kid.1.us)
  store %struct.op* null, %struct.op** %op_sibling45.le1000, align 8, !tbaa !17
  %call279 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %kid.1.us) #4
  %op_next = getelementptr inbounds %struct.op* %call277, i64 0, i32 0
  store %struct.op* %call277, %struct.op** %op_next, align 8, !tbaa !42
  %op_sibling280 = getelementptr inbounds %struct.op* %call277, i64 0, i32 1
  store %struct.op* %157, %struct.op** %op_sibling280, align 8, !tbaa !17
  store %struct.op* %call277, %struct.op** %tokid.1.ph, align 8, !tbaa !6
  br label %sw.epilog

sw.bb281:                                         ; preds = %while.body.us
  %op_sibling45.le998 = getelementptr inbounds %struct.op* %kid.1.us, i64 0, i32 1
  %op_sibling45.le996 = getelementptr inbounds %struct.op* %kid.1.us, i64 0, i32 1
  %158 = load %struct.op** %op_sibling45.le996, align 8, !tbaa !17
  %op_type282 = getelementptr inbounds %struct.op* %kid.1.us, i64 0, i32 4
  %159 = load i16* %op_type282, align 2, !tbaa !12
  switch i16 %159, label %if.else348 [
    i16 7, label %if.end537
    i16 14, label %if.end537
    i16 5, label %land.lhs.true296
    i16 26, label %if.then334
  ]

land.lhs.true296:                                 ; preds = %sw.bb281
  %op_private297 = getelementptr inbounds %struct.op* %kid.1.us, i64 0, i32 7
  %160 = load i8* %op_private297, align 1, !tbaa !11
  %and299 = and i8 %160, 64
  %tobool300 = icmp eq i8 %and299, 0
  br i1 %tobool300, label %if.else348, label %if.then301

if.then301:                                       ; preds = %land.lhs.true296
  %op_sv303 = getelementptr inbounds %struct.op* %kid.1.us, i64 1
  %161 = bitcast %struct.op* %op_sv303 to %struct.sv**
  %162 = load %struct.sv** %161, align 8, !tbaa !18
  store %struct.sv* %162, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %sv_flags304 = getelementptr inbounds %struct.sv* %162, i64 0, i32 2
  %163 = load i64* %sv_flags304, align 8, !tbaa !34
  %and305 = and i64 %163, 262144
  %cmp306 = icmp eq i64 %and305, 0
  br i1 %cmp306, label %cond.false313, label %cond.true308

cond.true308:                                     ; preds = %if.then301
  %sv_any309 = getelementptr inbounds %struct.sv* %162, i64 0, i32 0
  %164 = load i8** %sv_any309, align 8, !tbaa !36
  %xpv_cur310 = getelementptr inbounds i8* %164, i64 8
  %165 = bitcast i8* %xpv_cur310 to i64*
  %166 = load i64* %165, align 8, !tbaa !37
  store i64 %166, i64* %n_a, align 8, !tbaa !1
  %xpv_pv312 = bitcast i8* %164 to i8**
  %167 = load i8** %xpv_pv312, align 8, !tbaa !39
  br label %cond.end315

cond.false313:                                    ; preds = %if.then301
  %call314 = call i8* @Perl_sv_2pv_flags(%struct.sv* %162, i64* %n_a, i64 2) #4
  br label %cond.end315

cond.end315:                                      ; preds = %cond.false313, %cond.true308
  %cond316 = phi i8* [ %167, %cond.true308 ], [ %call314, %cond.false313 ]
  %call317 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond316, i64 1, i64 15) #4
  %168 = bitcast %struct.gv* %call317 to %struct.sv*
  store %struct.sv* %168, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool.i850 = icmp eq %struct.gv* %call317, null
  br i1 %tobool.i850, label %Perl_newGVOP.exit854, label %land.rhs.i852

land.rhs.i852:                                    ; preds = %cond.end315
  %169 = getelementptr inbounds %struct.gv* %call317, i64 0, i32 1
  %170 = load i64* %169, align 8, !tbaa !40
  %inc.i851 = add i64 %170, 1
  store i64 %inc.i851, i64* %169, align 8, !tbaa !40
  br label %Perl_newGVOP.exit854

Perl_newGVOP.exit854:                             ; preds = %cond.end315, %land.rhs.i852
  %call.i855 = call i8* @Perl_safesysmalloc(i64 48) #4
  call void @llvm.memset.p0i8.i64(i8* %call.i855, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i856 = getelementptr inbounds i8* %call.i855, i64 32
  %171 = bitcast i8* %op_type.i856 to i16*
  store i16 7, i16* %171, align 2, !tbaa !71
  %172 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 7), align 8, !tbaa !6
  %op_ppaddr.i857 = getelementptr inbounds i8* %call.i855, i64 16
  %173 = bitcast i8* %op_ppaddr.i857 to %struct.op* ()**
  store %struct.op* ()* %172, %struct.op* ()** %173, align 8, !tbaa !72
  %op_sv.i858 = getelementptr inbounds i8* %call.i855, i64 40
  %174 = bitcast i8* %op_sv.i858 to %struct.sv**
  store %struct.sv* %168, %struct.sv** %174, align 8, !tbaa !18
  %175 = bitcast i8* %call.i855 to %struct.op*
  %op_next.i859 = bitcast i8* %call.i855 to %struct.op**
  store %struct.op* %175, %struct.op** %op_next.i859, align 8, !tbaa !73
  %176 = getelementptr inbounds i8* %call.i855, i64 36
  store i8 0, i8* %176, align 1, !tbaa !74
  %177 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  %and.i860 = and i64 %177, 4
  %tobool.i861 = icmp eq i64 %and.i860, 0
  br i1 %tobool.i861, label %if.end.i867, label %if.then.i864

if.then.i864:                                     ; preds = %Perl_newGVOP.exit854
  %call3.i862 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %175) #4
  %.pre.i863 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  br label %if.end.i867

if.end.i867:                                      ; preds = %if.then.i864, %Perl_newGVOP.exit854
  %178 = phi i64 [ %177, %Perl_newGVOP.exit854 ], [ %.pre.i863, %if.then.i864 ]
  %and5.i865 = and i64 %178, 8
  %tobool6.i866 = icmp eq i64 %and5.i865, 0
  br i1 %tobool6.i866, label %if.end10.i873, label %if.then7.i871

if.then7.i871:                                    ; preds = %if.end.i867
  %call8.i868 = call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 7, i32 512) #4
  %conv9.i869 = sext i32 %call8.i868 to i64
  %op_targ.i870 = getelementptr inbounds i8* %call.i855, i64 24
  %179 = bitcast i8* %op_targ.i870 to i64*
  store i64 %conv9.i869, i64* %179, align 8, !tbaa !75
  br label %if.end10.i873

if.end10.i873:                                    ; preds = %if.then7.i871, %if.end.i867
  %180 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i872 = icmp eq i8* %180, null
  br i1 %tobool11.i872, label %cond.false.i879, label %land.lhs.true.i876

land.lhs.true.i876:                               ; preds = %if.end10.i873
  %arrayidx12.i874 = getelementptr inbounds i8* %180, i64 7
  %181 = load i8* %arrayidx12.i874, align 1, !tbaa !5
  %tobool14.i875 = icmp eq i8 %181, 0
  br i1 %tobool14.i875, label %cond.false.i879, label %cond.true.i877

cond.true.i877:                                   ; preds = %land.lhs.true.i876
  call void @Perl_op_free(%struct.op* %175) #4
  %182 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 7), align 8, !tbaa !6
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %182) #4
  br label %Perl_newSVOP.exit881

cond.false.i879:                                  ; preds = %land.lhs.true.i876, %if.end10.i873
  %183 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 7), align 8, !tbaa !6
  %call17.i878 = call %struct.op* %183(%struct.op* %175) #4
  br label %Perl_newSVOP.exit881

Perl_newSVOP.exit881:                             ; preds = %cond.true.i877, %cond.false.i879
  %cond.i880 = phi %struct.op* [ null, %cond.true.i877 ], [ %call17.i878, %cond.false.i879 ]
  %184 = load i8* %op_private319, align 1, !tbaa !11
  %and321 = and i8 %184, 1
  %tobool322 = icmp eq i8 %and321, 0
  br i1 %tobool322, label %land.lhs.true323, label %if.end328

land.lhs.true323:                                 ; preds = %Perl_newSVOP.exit881
  %185 = load %struct.op** %10, align 8, !tbaa !70
  %cmp324 = icmp eq %struct.op* %kid.1.us, %185
  br i1 %cmp324, label %if.then326, label %if.end328

if.then326:                                       ; preds = %land.lhs.true323
  store %struct.op* %cond.i880, %struct.op** %10, align 8, !tbaa !70
  br label %if.end328

if.end328:                                        ; preds = %Perl_newSVOP.exit881, %if.then326, %land.lhs.true323
  call void @Perl_op_free(%struct.op* %kid.1.us)
  br label %if.end535

if.then334:                                       ; preds = %sw.bb281
  %186 = load i16* %op_type, align 2, !tbaa !12
  %cmp337 = icmp eq i16 %186, 351
  br i1 %cmp337, label %cond.true339, label %cond.false341

cond.true339:                                     ; preds = %if.then334
  %187 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %tobool.i882 = icmp eq %struct.hv* %187, null
  br i1 %tobool.i882, label %if.then.i883, label %if.end.i886

if.then.i883:                                     ; preds = %cond.true339
  %188 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end345

if.end.i886:                                      ; preds = %cond.true339
  %189 = load %struct.op* ()** %op_ppaddr.i884, align 8, !tbaa !41
  %190 = ptrtoint %struct.op* ()* %189 to i64
  %call.i885 = call %struct.sv* @Perl_newSViv(i64 %190) #4
  %call1.i = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call.i885) #4
  %191 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %call2.i = call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %191, %struct.sv* %call1.i, i64 0, i64 0) #4
  %tobool3.i = icmp eq %struct.he* %call2.i, null
  br i1 %tobool3.i, label %if.then4.i, label %if.end5.i

if.then4.i:                                       ; preds = %if.end.i886
  %192 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end345

if.end5.i:                                        ; preds = %if.end.i886
  %hent_val.i = getelementptr inbounds %struct.he* %call2.i, i64 0, i32 2
  %193 = load %struct.sv** %hent_val.i, align 8, !tbaa !49
  %sv_flags.i = getelementptr inbounds %struct.sv* %193, i64 0, i32 2
  %194 = load i64* %sv_flags.i, align 8, !tbaa !34
  %and.i887 = and i64 %194, 262144
  %cmp.i = icmp eq i64 %and.i887, 0
  br i1 %cmp.i, label %cond.false.i892, label %cond.true.i890

cond.true.i890:                                   ; preds = %if.end5.i
  %sv_any.i888 = getelementptr inbounds %struct.sv* %193, i64 0, i32 0
  %195 = load i8** %sv_any.i888, align 8, !tbaa !36
  %xpv_pv.i889 = bitcast i8* %195 to i8**
  %196 = load i8** %xpv_pv.i889, align 8, !tbaa !39
  br label %cond.end345

cond.false.i892:                                  ; preds = %if.end5.i
  %call8.i891 = call i8* @Perl_sv_2pv_nolen(%struct.sv* %193) #4
  br label %cond.end345

cond.false341:                                    ; preds = %if.then334
  %idxprom343 = zext i16 %186 to i64
  %arrayidx344 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom343
  %197 = load i8** %arrayidx344, align 8, !tbaa !6
  br label %cond.end345

cond.end345:                                      ; preds = %cond.false.i892, %cond.true.i890, %if.then4.i, %if.then.i883, %cond.false341
  %cond346 = phi i8* [ %197, %cond.false341 ], [ %192, %if.then4.i ], [ %188, %if.then.i883 ], [ %196, %cond.true.i890 ], [ %call8.i891, %cond.false.i892 ]
  %call347 = call i32 (i64, i8*, i8*, %struct.op*, ...)* bitcast (i32 (...)* @bad_type to i32 (i64, i8*, i8*, %struct.op*, ...)*)(i64 %inc.us, i8* getelementptr inbounds ([7 x i8]* @.str102, i64 0, i64 0), i8* %cond346, %struct.op* %kid.1.us) #4
  br label %if.end535

if.else348:                                       ; preds = %sw.bb281, %land.lhs.true296
  %call349 = call i32 (%struct.op*, i64, ...)* bitcast (i32 (...)* @is_handle_constructor to i32 (%struct.op*, i64, ...)*)(%struct.op* %o, i64 %inc.us) #4
  %tobool350 = icmp eq i32 %call349, 0
  br i1 %tobool350, label %if.end525, label %if.then351

if.then351:                                       ; preds = %if.else348
  store i64 0, i64* %len, align 8, !tbaa !1
  %198 = load i16* %op_type282, align 2, !tbaa !12
  switch i16 %198, label %if.end525 [
    i16 9, label %if.then357
    i16 15, label %land.lhs.true384
    i16 127, label %if.then405
    i16 135, label %if.then405
  ]

if.then357:                                       ; preds = %if.then351
  %199 = load %struct.av** @PL_comppad_name, align 8, !tbaa !6
  %op_targ358 = getelementptr inbounds %struct.op* %kid.1.us, i64 0, i32 3
  %200 = load i64* %op_targ358, align 8, !tbaa !13
  %call359 = call %struct.sv** @Perl_av_fetch(%struct.av* %199, i64 %200, i64 0) #4
  %201 = load %struct.sv** %call359, align 8, !tbaa !6
  %sv_flags360 = getelementptr inbounds %struct.sv* %201, i64 0, i32 2
  %202 = load i64* %sv_flags360, align 8, !tbaa !34
  %and361 = and i64 %202, 262144
  %cmp362 = icmp eq i64 %and361, 0
  %203 = load %struct.av** @PL_comppad_name, align 8, !tbaa !6
  %204 = load i64* %op_targ358, align 8, !tbaa !13
  %call366 = call %struct.sv** @Perl_av_fetch(%struct.av* %203, i64 %204, i64 0) #4
  %205 = load %struct.sv** %call366, align 8, !tbaa !6
  br i1 %cmp362, label %cond.false369, label %cond.true364

cond.true364:                                     ; preds = %if.then357
  %sv_any367 = getelementptr inbounds %struct.sv* %205, i64 0, i32 0
  %206 = load i8** %sv_any367, align 8, !tbaa !36
  %xpv_pv368 = bitcast i8* %206 to i8**
  %207 = load i8** %xpv_pv368, align 8, !tbaa !39
  br label %cond.end373

cond.false369:                                    ; preds = %if.then357
  %call372 = call i8* @Perl_sv_2pv_nolen(%struct.sv* %205) #4
  br label %cond.end373

cond.end373:                                      ; preds = %cond.false369, %cond.true364
  %cond374 = phi i8* [ %207, %cond.true364 ], [ %call372, %cond.false369 ]
  %tobool375 = icmp eq i8* %cond374, null
  br i1 %tobool375, label %if.end525, label %if.then376

if.then376:                                       ; preds = %cond.end373
  %call377 = call i64 @strlen(i8* %cond374) #4
  store i64 %call377, i64* %len, align 8, !tbaa !1
  br label %if.then508

land.lhs.true384:                                 ; preds = %if.then351
  %208 = getelementptr inbounds %struct.op* %kid.1.us, i64 1, i32 0
  %209 = load %struct.op** %208, align 8, !tbaa !15
  %op_type386 = getelementptr inbounds %struct.op* %209, i64 0, i32 4
  %210 = load i16* %op_type386, align 2, !tbaa !12
  %cmp388 = icmp eq i16 %210, 7
  br i1 %cmp388, label %if.end506, label %if.end525

if.then405:                                       ; preds = %if.then351, %if.then351
  %.in = getelementptr inbounds %struct.op* %kid.1.us, i64 1, i32 0
  %211 = load %struct.op** %.in, align 8
  %tobool407 = icmp eq %struct.op* %211, null
  br i1 %tobool407, label %if.then501, label %if.then408

if.then408:                                       ; preds = %if.then405
  %cmp411 = icmp eq i16 %198, 127
  %cond413 = select i1 %cmp411, i8* getelementptr inbounds ([3 x i8]* @.str103, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8]* @.str104, i64 0, i64 0)
  %op_type414 = getelementptr inbounds %struct.op* %211, i64 0, i32 4
  %212 = load i16* %op_type414, align 2, !tbaa !12
  switch i16 %212, label %if.else444 [
    i16 125, label %land.lhs.true423
    i16 134, label %land.lhs.true423
  ]

land.lhs.true423:                                 ; preds = %if.then408, %if.then408
  %213 = getelementptr inbounds %struct.op* %211, i64 1, i32 0
  %214 = load %struct.op** %213, align 8, !tbaa !15
  %tobool425 = icmp eq %struct.op* %214, null
  br i1 %tobool425, label %land.lhs.true423.if.else444_crit_edge, label %land.lhs.true426

land.lhs.true423.if.else444_crit_edge:            ; preds = %land.lhs.true423
  %.pre1074 = load i16* inttoptr (i64 32 to i16*), align 32, !tbaa !12
  br label %if.else444

land.lhs.true426:                                 ; preds = %land.lhs.true423
  %op_type427 = getelementptr inbounds %struct.op* %214, i64 0, i32 4
  %215 = load i16* %op_type427, align 2, !tbaa !12
  %cmp429 = icmp eq i16 %215, 7
  br i1 %cmp429, label %if.then431, label %if.else444

if.then431:                                       ; preds = %land.lhs.true426
  %op_sv433 = getelementptr inbounds %struct.op* %214, i64 1
  %216 = bitcast %struct.op* %op_sv433 to %struct.sv**
  %217 = load %struct.sv** %216, align 8, !tbaa !18
  %tobool434 = icmp eq %struct.sv* %217, null
  br i1 %tobool434, label %if.then501, label %if.then435

if.then435:                                       ; preds = %if.then431
  %sv_any436 = bitcast %struct.sv* %217 to %struct.xpvgv**
  %218 = load %struct.xpvgv** %sv_any436, align 8, !tbaa !60
  %xgv_name437 = getelementptr inbounds %struct.xpvgv* %218, i64 0, i32 8
  %219 = load i8** %xgv_name437, align 8, !tbaa !118
  %220 = load i8* %cond413, align 1, !tbaa !5
  %conv439 = sext i8 %220 to i32
  %arrayidx440 = getelementptr inbounds i8* %cond413, i64 1
  %221 = load i8* %arrayidx440, align 1, !tbaa !5
  %conv441 = sext i8 %221 to i32
  %call442 = call %struct.sv* (i8*, ...)* @Perl_newSVpvf(i8* getelementptr inbounds ([10 x i8]* @.str105, i64 0, i64 0), i8* %219, i32 %conv439, i32 %conv441) #4
  br label %if.end481

if.else444:                                       ; preds = %land.lhs.true423.if.else444_crit_edge, %if.then408, %land.lhs.true426
  %222 = phi i16 [ %215, %land.lhs.true426 ], [ %.pre1074, %land.lhs.true423.if.else444_crit_edge ], [ %212, %if.then408 ]
  %op.0 = phi %struct.op* [ %214, %land.lhs.true426 ], [ null, %land.lhs.true423.if.else444_crit_edge ], [ %211, %if.then408 ]
  %223 = and i16 %222, -2
  %switch = icmp eq i16 %223, 10
  br i1 %switch, label %if.then454, label %if.then501

if.then454:                                       ; preds = %if.else444
  %224 = load %struct.av** @PL_comppad_name, align 8, !tbaa !6
  %op_targ455 = getelementptr inbounds %struct.op* %op.0, i64 0, i32 3
  %225 = load i64* %op_targ455, align 8, !tbaa !13
  %call456 = call %struct.sv** @Perl_av_fetch(%struct.av* %224, i64 %225, i64 0) #4
  %226 = load %struct.sv** %call456, align 8, !tbaa !6
  %sv_flags457 = getelementptr inbounds %struct.sv* %226, i64 0, i32 2
  %227 = load i64* %sv_flags457, align 8, !tbaa !34
  %and458 = and i64 %227, 262144
  %cmp459 = icmp eq i64 %and458, 0
  %228 = load %struct.av** @PL_comppad_name, align 8, !tbaa !6
  %229 = load i64* %op_targ455, align 8, !tbaa !13
  %call463 = call %struct.sv** @Perl_av_fetch(%struct.av* %228, i64 %229, i64 0) #4
  %230 = load %struct.sv** %call463, align 8, !tbaa !6
  br i1 %cmp459, label %cond.false466, label %cond.true461

cond.true461:                                     ; preds = %if.then454
  %sv_any464 = getelementptr inbounds %struct.sv* %230, i64 0, i32 0
  %231 = load i8** %sv_any464, align 8, !tbaa !36
  %xpv_pv465 = bitcast i8* %231 to i8**
  %232 = load i8** %xpv_pv465, align 8, !tbaa !39
  br label %cond.end470

cond.false466:                                    ; preds = %if.then454
  %call469 = call i8* @Perl_sv_2pv_nolen(%struct.sv* %230) #4
  br label %cond.end470

cond.end470:                                      ; preds = %cond.false466, %cond.true461
  %cond471 = phi i8* [ %232, %cond.true461 ], [ %call469, %cond.false466 ]
  %tobool472 = icmp eq i8* %cond471, null
  br i1 %tobool472, label %if.then501, label %if.then473

if.then473:                                       ; preds = %cond.end470
  %add.ptr = getelementptr inbounds i8* %cond471, i64 1
  %233 = load i8* %cond413, align 1, !tbaa !5
  %conv475 = sext i8 %233 to i32
  %arrayidx476 = getelementptr inbounds i8* %cond413, i64 1
  %234 = load i8* %arrayidx476, align 1, !tbaa !5
  %conv477 = sext i8 %234 to i32
  %call478 = call %struct.sv* (i8*, ...)* @Perl_newSVpvf(i8* getelementptr inbounds ([10 x i8]* @.str105, i64 0, i64 0), i8* %add.ptr, i32 %conv475, i32 %conv477) #4
  br label %if.end481

if.end481:                                        ; preds = %if.then473, %if.then435
  %tmpstr.0 = phi %struct.sv* [ %call442, %if.then435 ], [ %call478, %if.then473 ]
  %tobool482 = icmp eq %struct.sv* %tmpstr.0, null
  br i1 %tobool482, label %if.then501, label %if.then483

if.then483:                                       ; preds = %if.end481
  %sv_flags484 = getelementptr inbounds %struct.sv* %tmpstr.0, i64 0, i32 2
  %235 = load i64* %sv_flags484, align 8, !tbaa !34
  %and485 = and i64 %235, 262144
  %cmp486 = icmp eq i64 %and485, 0
  br i1 %cmp486, label %cond.false493, label %cond.true488

cond.true488:                                     ; preds = %if.then483
  %sv_any489 = getelementptr inbounds %struct.sv* %tmpstr.0, i64 0, i32 0
  %236 = load i8** %sv_any489, align 8, !tbaa !36
  %xpv_cur490 = getelementptr inbounds i8* %236, i64 8
  %237 = bitcast i8* %xpv_cur490 to i64*
  %238 = load i64* %237, align 8, !tbaa !37
  store i64 %238, i64* %len, align 8, !tbaa !1
  %xpv_pv492 = bitcast i8* %236 to i8**
  %239 = load i8** %xpv_pv492, align 8, !tbaa !39
  br label %if.end499

cond.false493:                                    ; preds = %if.then483
  %call494 = call i8* @Perl_sv_2pv_flags(%struct.sv* %tmpstr.0, i64* %len, i64 2) #4
  br label %if.end499

if.end499:                                        ; preds = %cond.true488, %cond.false493
  %cond496 = phi i8* [ %239, %cond.true488 ], [ %call494, %cond.false493 ]
  %call497 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %tmpstr.0) #4
  %tobool500 = icmp eq i8* %cond496, null
  br i1 %tobool500, label %if.then501, label %if.end502

if.then501:                                       ; preds = %if.else444, %cond.end470, %if.then431, %if.then405, %if.end481, %if.end499
  store i64 10, i64* %len, align 8, !tbaa !1
  br label %if.end502

if.end502:                                        ; preds = %if.end499, %if.then501
  %name352.1 = phi i8* [ %cond496, %if.end499 ], [ getelementptr inbounds ([11 x i8]* @.str106, i64 0, i64 0), %if.then501 ]
  %call503 = call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i32, ...)*)(%struct.op* %kid.1.us, i32 %conv) #4
  br label %if.then508

if.end506:                                        ; preds = %land.lhs.true384
  %op_sv392 = getelementptr inbounds %struct.op* %209, i64 1
  %240 = bitcast %struct.op* %op_sv392 to %struct.sv**
  %241 = load %struct.sv** %240, align 8, !tbaa !18
  %sv_any393 = bitcast %struct.sv* %241 to %struct.xpvgv**
  %242 = load %struct.xpvgv** %sv_any393, align 8, !tbaa !60
  %xgv_name = getelementptr inbounds %struct.xpvgv* %242, i64 0, i32 8
  %243 = load i8** %xgv_name, align 8, !tbaa !118
  %xgv_namelen = getelementptr inbounds %struct.xpvgv* %242, i64 0, i32 9
  %244 = load i64* %xgv_namelen, align 8, !tbaa !180
  store i64 %244, i64* %len, align 8, !tbaa !1
  %tobool507 = icmp eq i8* %243, null
  br i1 %tobool507, label %if.end525, label %if.then508

if.then508:                                       ; preds = %if.end502, %if.then376, %if.end506
  %name352.2945 = phi i8* [ %243, %if.end506 ], [ %cond374, %if.then376 ], [ %name352.1, %if.end502 ]
  %call509 = call i32 (i32, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i32, i32, ...)*)(i32 14, i32 512) #4
  %conv510 = sext i32 %call509 to i64
  %245 = load %struct.sv*** @PL_curpad, align 8, !tbaa !6
  %arrayidx511 = getelementptr inbounds %struct.sv** %245, i64 %conv510
  %246 = load %struct.sv** %arrayidx511, align 8, !tbaa !6
  %sv_flags512 = getelementptr inbounds %struct.sv* %246, i64 0, i32 2
  %247 = load i64* %sv_flags512, align 8, !tbaa !34
  %and513 = and i64 %247, 252
  %cmp514 = icmp eq i64 %and513, 0
  br i1 %cmp514, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.then508
  %call516 = call signext i8 @Perl_sv_upgrade(%struct.sv* %246, i64 4) #4
  br label %lor.end

lor.end:                                          ; preds = %if.then508, %lor.rhs
  %248 = load i8* %name352.2945, align 1, !tbaa !5
  %cmp520 = icmp eq i8 %248, 36
  br i1 %cmp520, label %if.end523, label %if.then522

if.then522:                                       ; preds = %lor.end
  call void @Perl_sv_setpvn(%struct.sv* %246, i8* getelementptr inbounds ([2 x i8]* @.str107, i64 0, i64 0), i64 1) #4
  br label %if.end523

if.end523:                                        ; preds = %lor.end, %if.then522
  %249 = load i64* %len, align 8, !tbaa !1
  call void @Perl_sv_catpvn_flags(%struct.sv* %246, i8* %name352.2945, i64 %249, i64 2) #4
  br label %if.end525

if.end525:                                        ; preds = %if.then351, %land.lhs.true384, %cond.end373, %if.end506, %if.else348, %if.end523
  %flags.0 = phi i64 [ 0, %if.end523 ], [ 0, %if.end506 ], [ 128, %if.else348 ], [ 0, %cond.end373 ], [ 0, %land.lhs.true384 ], [ 0, %if.then351 ]
  %priv.0 = phi i8 [ 96, %if.end523 ], [ 96, %if.end506 ], [ 0, %if.else348 ], [ 96, %cond.end373 ], [ 96, %land.lhs.true384 ], [ 96, %if.then351 ]
  %targ.0 = phi i64 [ %conv510, %if.end523 ], [ 0, %if.end506 ], [ 0, %if.else348 ], [ 0, %cond.end373 ], [ 0, %land.lhs.true384 ], [ 0, %if.then351 ]
  store %struct.op* null, %struct.op** %op_sibling45.le998, align 8, !tbaa !17
  %call527 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %kid.1.us) #4
  %conv528 = sext i32 %call527 to i64
  %250 = inttoptr i64 %conv528 to %struct.op*
  %call529 = call %struct.op* @Perl_newUNOP(i64 14, i64 %flags.0, %struct.op* %250)
  %op_targ530 = getelementptr inbounds %struct.op* %call529, i64 0, i32 3
  store i64 %targ.0, i64* %op_targ530, align 8, !tbaa !13
  %op_private531 = getelementptr inbounds %struct.op* %call529, i64 0, i32 7
  %251 = load i8* %op_private531, align 1, !tbaa !11
  %or = or i8 %251, %priv.0
  store i8 %or, i8* %op_private531, align 1, !tbaa !11
  br label %if.end535

if.end535:                                        ; preds = %cond.end345, %if.end525, %if.end328
  %kid.4 = phi %struct.op* [ %cond.i880, %if.end328 ], [ %kid.1.us, %cond.end345 ], [ %call529, %if.end525 ]
  %op_sibling536 = getelementptr inbounds %struct.op* %kid.4, i64 0, i32 1
  store %struct.op* %158, %struct.op** %op_sibling536, align 8, !tbaa !17
  store %struct.op* %kid.4, %struct.op** %tokid.1.ph, align 8, !tbaa !6
  br label %if.end537

if.end537:                                        ; preds = %sw.bb281, %sw.bb281, %if.end535
  %kid.5 = phi %struct.op* [ %kid.4, %if.end535 ], [ %kid.1.us, %sw.bb281 ], [ %kid.1.us, %sw.bb281 ]
  %call538 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %kid.5) #4
  br label %sw.epilog

sw.bb539:                                         ; preds = %while.body.us
  %call540 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %kid.1.us) #4
  %call541 = call i32 (i32, i32, ...)* bitcast (i32 (...)* @mod to i32 (i32, i32, ...)*)(i32 %call540, i32 %conv) #4
  br label %sw.epilog

sw.epilog:                                        ; preds = %while.body.us, %sw.bb539, %if.end537, %sw.bb275, %if.end273, %if.end186, %if.else71, %if.end65
  %kid.6 = phi %struct.op* [ %kid.1.us, %sw.bb539 ], [ %kid.5, %if.end537 ], [ %call277, %sw.bb275 ], [ %kid.3, %if.end273 ], [ %kid.2, %if.end186 ], [ %kid.1.us, %if.else71 ], [ %kid.1.us, %if.end65 ], [ %kid.1.us, %while.body.us ]
  %shr542 = ashr i64 %oa.1.ph, 4
  %op_sibling543 = getelementptr inbounds %struct.op* %kid.6, i64 0, i32 1
  %252 = load %struct.op** %op_sibling543, align 8, !tbaa !17
  br label %while.cond.outer

while.end:                                        ; preds = %while.cond.outer, %while.cond.us
  %oa.1.ph1069 = phi i64 [ %oa.1.ph, %while.cond.us ], [ 0, %while.cond.outer ]
  %kid.1.lcssa = phi %struct.op* [ null, %while.cond.us ], [ %kid.1.ph946, %while.cond.outer ]
  %numargs.0.lcssa = phi i64 [ %numargs.0.us, %while.cond.us ], [ %numargs.0.ph, %while.cond.outer ]
  %253 = load i8* %op_private319, align 1, !tbaa !11
  %conv546 = zext i8 %253 to i64
  %or547 = or i64 %conv546, %numargs.0.lcssa
  %conv548 = trunc i64 %or547 to i8
  store i8 %conv548, i8* %op_private319, align 1, !tbaa !11
  %tobool549 = icmp eq %struct.op* %kid.1.lcssa, null
  br i1 %tobool549, label %if.end565, label %if.then550

if.then550:                                       ; preds = %while.end
  %254 = load i16* %op_type, align 2, !tbaa !12
  %cmp553 = icmp eq i16 %254, 351
  br i1 %cmp553, label %cond.true555, label %cond.false557

cond.true555:                                     ; preds = %if.then550
  %255 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %tobool.i894 = icmp eq %struct.hv* %255, null
  br i1 %tobool.i894, label %if.then.i895, label %if.end.i901

if.then.i895:                                     ; preds = %cond.true555
  %256 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end561

if.end.i901:                                      ; preds = %cond.true555
  %257 = load %struct.op* ()** %op_ppaddr.i884, align 8, !tbaa !41
  %258 = ptrtoint %struct.op* ()* %257 to i64
  %call.i897 = call %struct.sv* @Perl_newSViv(i64 %258) #4
  %call1.i898 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call.i897) #4
  %259 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %call2.i899 = call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %259, %struct.sv* %call1.i898, i64 0, i64 0) #4
  %tobool3.i900 = icmp eq %struct.he* %call2.i899, null
  br i1 %tobool3.i900, label %if.then4.i902, label %if.end5.i907

if.then4.i902:                                    ; preds = %if.end.i901
  %260 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end561

if.end5.i907:                                     ; preds = %if.end.i901
  %hent_val.i903 = getelementptr inbounds %struct.he* %call2.i899, i64 0, i32 2
  %261 = load %struct.sv** %hent_val.i903, align 8, !tbaa !49
  %sv_flags.i904 = getelementptr inbounds %struct.sv* %261, i64 0, i32 2
  %262 = load i64* %sv_flags.i904, align 8, !tbaa !34
  %and.i905 = and i64 %262, 262144
  %cmp.i906 = icmp eq i64 %and.i905, 0
  br i1 %cmp.i906, label %cond.false.i912, label %cond.true.i910

cond.true.i910:                                   ; preds = %if.end5.i907
  %sv_any.i908 = getelementptr inbounds %struct.sv* %261, i64 0, i32 0
  %263 = load i8** %sv_any.i908, align 8, !tbaa !36
  %xpv_pv.i909 = bitcast i8* %263 to i8**
  %264 = load i8** %xpv_pv.i909, align 8, !tbaa !39
  br label %cond.end561

cond.false.i912:                                  ; preds = %if.end5.i907
  %call8.i911 = call i8* @Perl_sv_2pv_nolen(%struct.sv* %261) #4
  br label %cond.end561

cond.false557:                                    ; preds = %if.then550
  %idxprom559 = zext i16 %254 to i64
  %arrayidx560 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom559
  %265 = load i8** %arrayidx560, align 8, !tbaa !6
  br label %cond.end561

cond.end561:                                      ; preds = %cond.false.i912, %cond.true.i910, %if.then4.i902, %if.then.i895, %cond.false557
  %cond562 = phi i8* [ %265, %cond.false557 ], [ %260, %if.then4.i902 ], [ %256, %if.then.i895 ], [ %264, %cond.true.i910 ], [ %call8.i911, %cond.false.i912 ]
  %call563 = call i32 (%struct.op*, i8*, ...)* bitcast (i32 (...)* @too_many_arguments to i32 (%struct.op*, i8*, ...)*)(%struct.op* %o, i8* %cond562) #4
  %conv564 = sext i32 %call563 to i64
  %266 = inttoptr i64 %conv564 to %struct.op*
  br label %return

if.end565:                                        ; preds = %while.end
  %call566 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @listkids to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  br label %if.end578

if.else567:                                       ; preds = %if.end13
  %and570 = and i64 %1, 128
  %tobool571 = icmp eq i64 %and570, 0
  br i1 %tobool571, label %if.end578, label %if.then572

if.then572:                                       ; preds = %if.else567
  call void @Perl_op_free(%struct.op* %o)
  %call574 = call i32 (...)* @newDEFSVOP() #4
  %conv575 = sext i32 %call574 to i64
  %267 = inttoptr i64 %conv575 to %struct.op*
  %call576 = call %struct.op* @Perl_newUNOP(i64 %idxprom, i64 0, %struct.op* %267)
  br label %return

if.end578:                                        ; preds = %if.else567, %if.end565
  %oa.2 = phi i64 [ %oa.1.ph1069, %if.end565 ], [ %oa.0, %if.else567 ]
  %tobool579 = icmp eq i64 %oa.2, 0
  br i1 %tobool579, label %return, label %while.cond581

while.cond581:                                    ; preds = %if.end578, %while.cond581
  %oa.3 = phi i64 [ %shr585, %while.cond581 ], [ %oa.2, %if.end578 ]
  %and582 = and i64 %oa.3, 8
  %tobool583 = icmp eq i64 %and582, 0
  %shr585 = ashr i64 %oa.3, 4
  br i1 %tobool583, label %while.end586, label %while.cond581

while.end586:                                     ; preds = %while.cond581
  switch i64 %oa.3, label %if.then591 [
    i64 2, label %return
    i64 0, label %return
  ]

if.then591:                                       ; preds = %while.end586
  %268 = load i16* %op_type, align 2, !tbaa !12
  %cmp594 = icmp eq i16 %268, 351
  br i1 %cmp594, label %cond.true596, label %cond.false598

cond.true596:                                     ; preds = %if.then591
  %269 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %tobool.i915 = icmp eq %struct.hv* %269, null
  br i1 %tobool.i915, label %if.then.i916, label %if.end.i922

if.then.i916:                                     ; preds = %cond.true596
  %270 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end602

if.end.i922:                                      ; preds = %cond.true596
  %op_ppaddr.i917 = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  %271 = load %struct.op* ()** %op_ppaddr.i917, align 8, !tbaa !41
  %272 = ptrtoint %struct.op* ()* %271 to i64
  %call.i918 = call %struct.sv* @Perl_newSViv(i64 %272) #4
  %call1.i919 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call.i918) #4
  %273 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %call2.i920 = call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %273, %struct.sv* %call1.i919, i64 0, i64 0) #4
  %tobool3.i921 = icmp eq %struct.he* %call2.i920, null
  br i1 %tobool3.i921, label %if.then4.i923, label %if.end5.i928

if.then4.i923:                                    ; preds = %if.end.i922
  %274 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end602

if.end5.i928:                                     ; preds = %if.end.i922
  %hent_val.i924 = getelementptr inbounds %struct.he* %call2.i920, i64 0, i32 2
  %275 = load %struct.sv** %hent_val.i924, align 8, !tbaa !49
  %sv_flags.i925 = getelementptr inbounds %struct.sv* %275, i64 0, i32 2
  %276 = load i64* %sv_flags.i925, align 8, !tbaa !34
  %and.i926 = and i64 %276, 262144
  %cmp.i927 = icmp eq i64 %and.i926, 0
  br i1 %cmp.i927, label %cond.false.i933, label %cond.true.i931

cond.true.i931:                                   ; preds = %if.end5.i928
  %sv_any.i929 = getelementptr inbounds %struct.sv* %275, i64 0, i32 0
  %277 = load i8** %sv_any.i929, align 8, !tbaa !36
  %xpv_pv.i930 = bitcast i8* %277 to i8**
  %278 = load i8** %xpv_pv.i930, align 8, !tbaa !39
  br label %cond.end602

cond.false.i933:                                  ; preds = %if.end5.i928
  %call8.i932 = call i8* @Perl_sv_2pv_nolen(%struct.sv* %275) #4
  br label %cond.end602

cond.false598:                                    ; preds = %if.then591
  %idxprom600 = zext i16 %268 to i64
  %arrayidx601 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom600
  %279 = load i8** %arrayidx601, align 8, !tbaa !6
  br label %cond.end602

cond.end602:                                      ; preds = %cond.false.i933, %cond.true.i931, %if.then4.i923, %if.then.i916, %cond.false598
  %cond603 = phi i8* [ %279, %cond.false598 ], [ %274, %if.then4.i923 ], [ %270, %if.then.i916 ], [ %278, %cond.true.i931 ], [ %call8.i932, %cond.false.i933 ]
  %call604 = call i32 (%struct.op*, i8*, ...)* bitcast (i32 (...)* @too_few_arguments to i32 (%struct.op*, i8*, ...)*)(%struct.op* %o, i8* %cond603) #4
  %conv605 = sext i32 %call604 to i64
  %280 = inttoptr i64 %conv605 to %struct.op*
  br label %return

return:                                           ; preds = %if.end578, %while.end586, %while.end586, %cond.end602, %if.then572, %cond.end561, %if.then60, %if.else
  %retval.0 = phi %struct.op* [ %3, %if.else ], [ %13, %if.then60 ], [ %266, %cond.end561 ], [ %280, %cond.end602 ], [ %call576, %if.then572 ], [ %o, %while.end586 ], [ %o, %while.end586 ], [ %o, %if.end578 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_delete(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  %op_private = getelementptr inbounds %struct.op* %call, i64 0, i32 7
  store i8 0, i8* %op_private, align 1, !tbaa !11
  %op_flags = getelementptr inbounds %struct.op* %call, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %call, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !15
  %op_type = getelementptr inbounds %struct.op* %2, i64 0, i32 4
  %3 = load i16* %op_type, align 2, !tbaa !12
  %conv1 = zext i16 %3 to i32
  switch i32 %conv1, label %sw.default [
    i32 128, label %sw.bb
    i32 136, label %sw.bb5
    i32 127, label %sw.bb10
    i32 135, label %sw.epilog
  ]

sw.bb:                                            ; preds = %if.then
  %or = or i8 %0, -128
  store i8 %or, i8* %op_flags, align 1, !tbaa !14
  br label %sw.bb5

sw.bb5:                                           ; preds = %if.then, %sw.bb
  store i8 64, i8* %op_private, align 1, !tbaa !11
  br label %sw.epilog

sw.bb10:                                          ; preds = %if.then
  %or13 = or i8 %0, -128
  store i8 %or13, i8* %op_flags, align 1, !tbaa !14
  br label %sw.epilog

sw.default:                                       ; preds = %if.then
  %op_type15 = getelementptr inbounds %struct.op* %call, i64 0, i32 4
  %4 = load i16* %op_type15, align 2, !tbaa !12
  %cmp = icmp eq i16 %4, 351
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.default
  %5 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %tobool.i = icmp eq %struct.hv* %5, null
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %cond.true
  %6 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end

if.end.i:                                         ; preds = %cond.true
  %op_ppaddr.i = getelementptr inbounds %struct.op* %call, i64 0, i32 2
  %7 = load %struct.op* ()** %op_ppaddr.i, align 8, !tbaa !41
  %8 = ptrtoint %struct.op* ()* %7 to i64
  %call.i = tail call %struct.sv* @Perl_newSViv(i64 %8) #4
  %call1.i = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call.i) #4
  %9 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %call2.i = tail call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %9, %struct.sv* %call1.i, i64 0, i64 0) #4
  %tobool3.i = icmp eq %struct.he* %call2.i, null
  br i1 %tobool3.i, label %if.then4.i, label %if.end5.i

if.then4.i:                                       ; preds = %if.end.i
  %10 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end

if.end5.i:                                        ; preds = %if.end.i
  %hent_val.i = getelementptr inbounds %struct.he* %call2.i, i64 0, i32 2
  %11 = load %struct.sv** %hent_val.i, align 8, !tbaa !49
  %sv_flags.i = getelementptr inbounds %struct.sv* %11, i64 0, i32 2
  %12 = load i64* %sv_flags.i, align 8, !tbaa !34
  %and.i = and i64 %12, 262144
  %cmp.i = icmp eq i64 %and.i, 0
  br i1 %cmp.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.end5.i
  %sv_any.i = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %13 = load i8** %sv_any.i, align 8, !tbaa !36
  %xpv_pv.i = bitcast i8* %13 to i8**
  %14 = load i8** %xpv_pv.i, align 8, !tbaa !39
  br label %cond.end

cond.false.i:                                     ; preds = %if.end5.i
  %call8.i = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %11) #4
  br label %cond.end

cond.false:                                       ; preds = %sw.default
  %idxprom = zext i16 %4 to i64
  %arrayidx = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %15 = load i8** %arrayidx, align 8, !tbaa !6
  br label %cond.end

cond.end:                                         ; preds = %cond.false.i, %cond.true.i, %if.then4.i, %if.then.i, %cond.false
  %cond = phi i8* [ %15, %cond.false ], [ %10, %if.then4.i ], [ %6, %if.then.i ], [ %14, %cond.true.i ], [ %call8.i, %cond.false.i ]
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([52 x i8]* @.str88, i64 0, i64 0), i8* %cond) #4
  %.pr.pre = load i16* %op_type, align 2, !tbaa !12
  br label %sw.epilog

sw.epilog:                                        ; preds = %cond.end, %sw.bb10, %sw.bb5, %if.then
  %16 = phi i16 [ %3, %if.then ], [ %3, %sw.bb5 ], [ %3, %sw.bb10 ], [ %.pr.pre, %cond.end ]
  %cmp.i30 = icmp eq i16 %16, 0
  br i1 %cmp.i30, label %if.end, label %if.end.i33

if.end.i33:                                       ; preds = %sw.epilog
  %call.i31 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %2) #4
  %17 = load i16* %op_type, align 2, !tbaa !12
  %conv3.i = zext i16 %17 to i64
  %op_targ.i = getelementptr inbounds %struct.op* %2, i64 0, i32 3
  store i64 %conv3.i, i64* %op_targ.i, align 8, !tbaa !13
  store i16 0, i16* %op_type, align 2, !tbaa !12
  %18 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i32 = getelementptr inbounds %struct.op* %2, i64 0, i32 2
  store %struct.op* ()* %18, %struct.op* ()** %op_ppaddr.i32, align 8, !tbaa !41
  br label %if.end

if.end:                                           ; preds = %if.end.i33, %sw.epilog, %entry
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_die(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_eof(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %conv = zext i16 %0 to i64
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %1, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %return, label %if.then

if.then:                                          ; preds = %entry
  %2 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %3 = load %struct.op** %2, align 8, !tbaa !45
  %op_type2 = getelementptr inbounds %struct.op* %3, i64 0, i32 4
  %4 = load i16* %op_type2, align 2, !tbaa !12
  %cmp = icmp eq i16 %4, 1
  br i1 %cmp, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  tail call void @Perl_op_free(%struct.op* %o)
  %5 = load %struct.gv** @PL_argvgv, align 8, !tbaa !6
  %6 = bitcast %struct.gv* %5 to %struct.sv*
  store %struct.sv* %6, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool.i = icmp eq %struct.gv* %5, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then5
  %7 = getelementptr inbounds %struct.gv* %5, i64 0, i32 1
  %8 = load i64* %7, align 8, !tbaa !40
  %inc.i = add i64 %8, 1
  store i64 %inc.i, i64* %7, align 8, !tbaa !40
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.then5, %land.rhs.i
  %call.i13 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i13, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i13, i64 32
  %9 = bitcast i8* %op_type.i to i16*
  store i16 7, i16* %9, align 2, !tbaa !71
  %10 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 7), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i13, i64 16
  %11 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %10, %struct.op* ()** %11, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i13, i64 40
  %12 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %6, %struct.sv** %12, align 8, !tbaa !18
  %13 = bitcast i8* %call.i13 to %struct.op*
  %op_next.i = bitcast i8* %call.i13 to %struct.op**
  store %struct.op* %13, %struct.op** %op_next.i, align 8, !tbaa !73
  %14 = getelementptr inbounds i8* %call.i13, i64 36
  store i8 0, i8* %14, align 1, !tbaa !74
  %15 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  %and.i = and i64 %15, 4
  %tobool.i14 = icmp eq i64 %and.i, 0
  br i1 %tobool.i14, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %Perl_newGVOP.exit
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %13) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %Perl_newGVOP.exit
  %16 = phi i64 [ %15, %Perl_newGVOP.exit ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %16, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 7, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i13, i64 24
  %17 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %17, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %18 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %18, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %18, i64 7
  %19 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %19, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %13) #4
  %20 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 7), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %20) #4
  br label %Perl_newSVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %21 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 7), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %21(%struct.op* %13) #4
  br label %Perl_newSVOP.exit

Perl_newSVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  %call6 = tail call %struct.op* @Perl_newUNOP(i64 %conv, i64 128, %struct.op* %cond.i)
  br label %if.end

if.end:                                           ; preds = %Perl_newSVOP.exit, %if.then
  %o.addr.0 = phi %struct.op* [ %call6, %Perl_newSVOP.exit ], [ %o, %if.then ]
  %call7 = tail call %struct.op* @Perl_ck_fun(%struct.op* %o.addr.0)
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi %struct.op* [ %call7, %if.end ], [ %o, %entry ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_eval(%struct.op* %o) #0 {
entry:
  %0 = load i64* @PL_hints, align 8, !tbaa !1
  %or = or i64 %0, 256
  store i64 %or, i64* @PL_hints, align 8, !tbaa !1
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %1, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.else23, label %if.then

if.then:                                          ; preds = %entry
  %2 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %3 = load %struct.op** %2, align 8, !tbaa !15
  %tobool1 = icmp eq %struct.op* %3, null
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %and5 = and i8 %1, -5
  store i8 %and5, i8* %op_flags, align 1, !tbaa !14
  %op_type.i = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %4 = load i16* %op_type.i, align 2, !tbaa !12
  %cmp.i = icmp eq i16 %4, 0
  br i1 %cmp.i, label %if.end27, label %if.end.i

if.end.i:                                         ; preds = %if.then2
  %call.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %5 = load i16* %op_type.i, align 2, !tbaa !12
  %conv3.i = zext i16 %5 to i64
  %op_targ.i = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  store i64 %conv3.i, i64* %op_targ.i, align 8, !tbaa !13
  store i16 0, i16* %op_type.i, align 2, !tbaa !12
  %6 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %6, %struct.op* ()** %op_ppaddr.i, align 8, !tbaa !41
  br label %if.end27

if.else:                                          ; preds = %if.then
  %7 = getelementptr inbounds %struct.op* %3, i64 0, i32 4
  %8 = load i16* %7, align 2, !tbaa !71
  switch i16 %8, label %if.else20 [
    i16 173, label %if.then13
    i16 1, label %if.then13
  ]

if.then13:                                        ; preds = %if.else, %if.else
  store %struct.op* null, %struct.op** %2, align 8, !tbaa !15
  tail call void @Perl_op_free(%struct.op* %o)
  %call = tail call i8* @Perl_safesysmalloc(i64 56) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 56, i32 1, i1 false)
  %op_type15 = getelementptr inbounds i8* %call, i64 32
  %9 = bitcast i8* %op_type15 to i16*
  store i16 313, i16* %9, align 2, !tbaa !108
  %10 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 313), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %11 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %10, %struct.op* ()** %11, align 8, !tbaa !110
  %12 = getelementptr inbounds i8* %call, i64 37
  store i8 0, i8* %12, align 1, !tbaa !113
  %13 = bitcast i8* %call to %struct.op*
  %op_next = bitcast i8* %call to %struct.op**
  store %struct.op* %13, %struct.op** %op_next, align 8, !tbaa !115
  %call16 = tail call i32 (i32, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @prepend_elem to i32 (i32, %struct.op*, %struct.op*, ...)*)(i32 173, %struct.op* %13, %struct.op* %3) #4
  %conv17 = sext i32 %call16 to i64
  %14 = inttoptr i64 %conv17 to %struct.op*
  %op_type18 = getelementptr inbounds %struct.op* %14, i64 0, i32 4
  store i16 314, i16* %op_type18, align 2, !tbaa !12
  %15 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 314), align 8, !tbaa !6
  %op_ppaddr19 = getelementptr inbounds %struct.op* %14, i64 0, i32 2
  store %struct.op* ()* %15, %struct.op* ()** %op_ppaddr19, align 8, !tbaa !41
  %op_other = getelementptr inbounds i8* %call, i64 48
  %16 = bitcast i8* %op_other to %struct.op**
  store %struct.op* %14, %struct.op** %16, align 8, !tbaa !114
  br label %return

if.else20:                                        ; preds = %if.else
  %call21 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %3) #4
  br label %if.end27

if.else23:                                        ; preds = %entry
  tail call void @Perl_op_free(%struct.op* %o)
  %call24 = tail call i32 (...)* @newDEFSVOP() #4
  %conv25 = sext i32 %call24 to i64
  %17 = inttoptr i64 %conv25 to %struct.op*
  %call26 = tail call %struct.op* @Perl_newUNOP(i64 311, i64 0, %struct.op* %17)
  br label %if.end27

if.end27:                                         ; preds = %if.end.i, %if.then2, %if.else20, %if.else23
  %o.addr.0 = phi %struct.op* [ %o, %if.else20 ], [ %call26, %if.else23 ], [ %o, %if.then2 ], [ %o, %if.end.i ]
  %18 = load i64* @PL_hints, align 8, !tbaa !1
  %op_targ = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 3
  store i64 %18, i64* %op_targ, align 8, !tbaa !13
  br label %return

return:                                           ; preds = %if.end27, %if.then13
  %retval.0 = phi %struct.op* [ %14, %if.then13 ], [ %o.addr.0, %if.end27 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_exit(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_exec(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  %1 = getelementptr inbounds %struct.op* %call, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !15
  %op_sibling = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %3 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %op_type = getelementptr inbounds %struct.op* %3, i64 0, i32 4
  %4 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %4, 14
  br i1 %cmp, label %Perl_op_null.exit, label %if.end6

Perl_op_null.exit:                                ; preds = %if.then
  %call.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %3) #4
  %5 = load i16* %op_type, align 2, !tbaa !12
  %conv3.i = zext i16 %5 to i64
  %op_targ.i = getelementptr inbounds %struct.op* %3, i64 0, i32 3
  store i64 %conv3.i, i64* %op_targ.i, align 8, !tbaa !13
  store i16 0, i16* %op_type, align 2, !tbaa !12
  %6 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds %struct.op* %3, i64 0, i32 2
  store %struct.op* ()* %6, %struct.op* ()** %op_ppaddr.i, align 8, !tbaa !41
  br label %if.end6

if.else:                                          ; preds = %entry
  %call4 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @listkids to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv5 = sext i32 %call4 to i64
  %7 = inttoptr i64 %conv5 to %struct.op*
  br label %if.end6

if.end6:                                          ; preds = %if.then, %Perl_op_null.exit, %if.else
  %o.addr.0 = phi %struct.op* [ %call, %Perl_op_null.exit ], [ %call, %if.then ], [ %7, %if.else ]
  ret %struct.op* %o.addr.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_exists(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  %op_flags = getelementptr inbounds %struct.op* %call, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end51, label %if.then

if.then:                                          ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %call, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !15
  %op_type = getelementptr inbounds %struct.op* %2, i64 0, i32 4
  %3 = load i16* %op_type, align 2, !tbaa !12
  switch i16 %3, label %if.then35 [
    i16 166, label %if.then3
    i16 127, label %if.then25
    i16 135, label %if.end.i90
  ]

if.then3:                                         ; preds = %if.then
  %op_type4 = getelementptr inbounds %struct.op* %call, i64 0, i32 4
  %4 = load i16* %op_type4, align 2, !tbaa !12
  %conv5 = zext i16 %4 to i32
  %call6 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @ref to i32 (%struct.op*, i32, ...)*)(%struct.op* %2, i32 %conv5) #4
  %5 = load i16* %op_type, align 2, !tbaa !12
  %cmp9 = icmp eq i16 %5, 17
  %6 = load i64* @PL_error_count, align 8
  %tobool11 = icmp ne i64 %6, 0
  %or.cond = or i1 %cmp9, %tobool11
  br i1 %or.cond, label %if.end, label %if.then12

if.then12:                                        ; preds = %if.then3
  %7 = load i16* %op_type4, align 2, !tbaa !12
  %cmp15 = icmp eq i16 %7, 351
  br i1 %cmp15, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then12
  %8 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %tobool.i = icmp eq %struct.hv* %8, null
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %cond.true
  %9 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end

if.end.i:                                         ; preds = %cond.true
  %op_ppaddr.i = getelementptr inbounds %struct.op* %call, i64 0, i32 2
  %10 = load %struct.op* ()** %op_ppaddr.i, align 8, !tbaa !41
  %11 = ptrtoint %struct.op* ()* %10 to i64
  %call.i = tail call %struct.sv* @Perl_newSViv(i64 %11) #4
  %call1.i = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call.i) #4
  %12 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %call2.i = tail call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %12, %struct.sv* %call1.i, i64 0, i64 0) #4
  %tobool3.i = icmp eq %struct.he* %call2.i, null
  br i1 %tobool3.i, label %if.then4.i, label %if.end5.i

if.then4.i:                                       ; preds = %if.end.i
  %13 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end

if.end5.i:                                        ; preds = %if.end.i
  %hent_val.i = getelementptr inbounds %struct.he* %call2.i, i64 0, i32 2
  %14 = load %struct.sv** %hent_val.i, align 8, !tbaa !49
  %sv_flags.i = getelementptr inbounds %struct.sv* %14, i64 0, i32 2
  %15 = load i64* %sv_flags.i, align 8, !tbaa !34
  %and.i = and i64 %15, 262144
  %cmp.i = icmp eq i64 %and.i, 0
  br i1 %cmp.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.end5.i
  %sv_any.i = getelementptr inbounds %struct.sv* %14, i64 0, i32 0
  %16 = load i8** %sv_any.i, align 8, !tbaa !36
  %xpv_pv.i = bitcast i8* %16 to i8**
  %17 = load i8** %xpv_pv.i, align 8, !tbaa !39
  br label %cond.end

cond.false.i:                                     ; preds = %if.end5.i
  %call8.i = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %14) #4
  br label %cond.end

cond.false:                                       ; preds = %if.then12
  %idxprom = zext i16 %7 to i64
  %arrayidx = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %18 = load i8** %arrayidx, align 8, !tbaa !6
  br label %cond.end

cond.end:                                         ; preds = %cond.false.i, %cond.true.i, %if.then4.i, %if.then.i, %cond.false
  %cond = phi i8* [ %18, %cond.false ], [ %13, %if.then4.i ], [ %9, %if.then.i ], [ %17, %cond.true.i ], [ %call8.i, %cond.false.i ]
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([37 x i8]* @.str89, i64 0, i64 0), i8* %cond) #4
  br label %if.end

if.end:                                           ; preds = %if.then3, %cond.end
  %op_private = getelementptr inbounds %struct.op* %call, i64 0, i32 7
  %19 = load i8* %op_private, align 1, !tbaa !11
  %or = or i8 %19, 64
  store i8 %or, i8* %op_private, align 1, !tbaa !11
  br label %if.end50

if.then25:                                        ; preds = %if.then
  %or28 = or i8 %0, -128
  store i8 %or28, i8* %op_flags, align 1, !tbaa !14
  br label %if.end50

if.then35:                                        ; preds = %if.then
  %op_type36 = getelementptr inbounds %struct.op* %call, i64 0, i32 4
  %20 = load i16* %op_type36, align 2, !tbaa !12
  %cmp38 = icmp eq i16 %20, 351
  br i1 %cmp38, label %cond.true40, label %cond.false42

cond.true40:                                      ; preds = %if.then35
  %21 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %tobool.i66 = icmp eq %struct.hv* %21, null
  br i1 %tobool.i66, label %if.then.i67, label %if.end.i73

if.then.i67:                                      ; preds = %cond.true40
  %22 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end46

if.end.i73:                                       ; preds = %cond.true40
  %op_ppaddr.i68 = getelementptr inbounds %struct.op* %call, i64 0, i32 2
  %23 = load %struct.op* ()** %op_ppaddr.i68, align 8, !tbaa !41
  %24 = ptrtoint %struct.op* ()* %23 to i64
  %call.i69 = tail call %struct.sv* @Perl_newSViv(i64 %24) #4
  %call1.i70 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call.i69) #4
  %25 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %call2.i71 = tail call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %25, %struct.sv* %call1.i70, i64 0, i64 0) #4
  %tobool3.i72 = icmp eq %struct.he* %call2.i71, null
  br i1 %tobool3.i72, label %if.then4.i74, label %if.end5.i79

if.then4.i74:                                     ; preds = %if.end.i73
  %26 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end46

if.end5.i79:                                      ; preds = %if.end.i73
  %hent_val.i75 = getelementptr inbounds %struct.he* %call2.i71, i64 0, i32 2
  %27 = load %struct.sv** %hent_val.i75, align 8, !tbaa !49
  %sv_flags.i76 = getelementptr inbounds %struct.sv* %27, i64 0, i32 2
  %28 = load i64* %sv_flags.i76, align 8, !tbaa !34
  %and.i77 = and i64 %28, 262144
  %cmp.i78 = icmp eq i64 %and.i77, 0
  br i1 %cmp.i78, label %cond.false.i84, label %cond.true.i82

cond.true.i82:                                    ; preds = %if.end5.i79
  %sv_any.i80 = getelementptr inbounds %struct.sv* %27, i64 0, i32 0
  %29 = load i8** %sv_any.i80, align 8, !tbaa !36
  %xpv_pv.i81 = bitcast i8* %29 to i8**
  %30 = load i8** %xpv_pv.i81, align 8, !tbaa !39
  br label %cond.end46

cond.false.i84:                                   ; preds = %if.end5.i79
  %call8.i83 = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %27) #4
  br label %cond.end46

cond.false42:                                     ; preds = %if.then35
  %idxprom44 = zext i16 %20 to i64
  %arrayidx45 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom44
  %31 = load i8** %arrayidx45, align 8, !tbaa !6
  br label %cond.end46

cond.end46:                                       ; preds = %cond.false.i84, %cond.true.i82, %if.then4.i74, %if.then.i67, %cond.false42
  %cond47 = phi i8* [ %31, %cond.false42 ], [ %26, %if.then4.i74 ], [ %22, %if.then.i67 ], [ %30, %cond.true.i82 ], [ %call8.i83, %cond.false.i84 ]
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([43 x i8]* @.str90, i64 0, i64 0), i8* %cond47) #4
  br label %if.end50

if.end50:                                         ; preds = %if.then25, %cond.end46, %if.end
  %.pr = load i16* %op_type, align 2, !tbaa !12
  %cmp.i87 = icmp eq i16 %.pr, 0
  br i1 %cmp.i87, label %if.end51, label %if.end.i90

if.end.i90:                                       ; preds = %if.then, %if.end50
  %call.i88 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %2) #4
  %32 = load i16* %op_type, align 2, !tbaa !12
  %conv3.i = zext i16 %32 to i64
  %op_targ.i = getelementptr inbounds %struct.op* %2, i64 0, i32 3
  store i64 %conv3.i, i64* %op_targ.i, align 8, !tbaa !13
  store i16 0, i16* %op_type, align 2, !tbaa !12
  %33 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i89 = getelementptr inbounds %struct.op* %2, i64 0, i32 2
  store %struct.op* ()* %33, %struct.op* ()** %op_ppaddr.i89, align 8, !tbaa !41
  br label %if.end51

if.end51:                                         ; preds = %if.end.i90, %if.end50, %entry
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_rvconst(%struct.op* %o) #0 {
entry:
  %n_a = alloca i64, align 8
  %0 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %1 = load %struct.op** %0, align 8, !tbaa !15
  %2 = load i64* @PL_hints, align 8, !tbaa !1
  %and = and i64 %2, 2
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %3 = load i8* %op_private, align 1, !tbaa !11
  %conv = zext i8 %3 to i64
  %or = or i64 %conv, %and
  %conv1 = trunc i64 %or to i8
  store i8 %conv1, i8* %op_private, align 1, !tbaa !11
  %4 = getelementptr inbounds %struct.op* %1, i64 0, i32 4
  %5 = load i16* %4, align 2, !tbaa !71
  %cmp = icmp eq i16 %5, 5
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %op_sv = getelementptr inbounds %struct.op* %1, i64 1
  %6 = bitcast %struct.op* %op_sv to %struct.sv**
  %7 = load %struct.sv** %6, align 8, !tbaa !18
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i64* %sv_flags, align 8, !tbaa !34
  %9 = and i64 %8, 8912896
  %10 = icmp eq i64 %9, 8912896
  br i1 %10, label %if.then8, label %if.end53

if.then8:                                         ; preds = %if.then
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %11 = load i8** %sv_any, align 8, !tbaa !36
  %xrv_rv = bitcast i8* %11 to %struct.sv**
  %12 = load %struct.sv** %xrv_rv, align 8, !tbaa !98
  %sv_flags9 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i64* %sv_flags9, align 8, !tbaa !34
  %.tr = trunc i64 %13 to i32
  %conv11 = and i32 %.tr, 255
  %op_type12 = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %14 = load i16* %op_type12, align 2, !tbaa !12
  %conv13 = zext i16 %14 to i32
  switch i32 %conv13, label %return [
    i32 15, label %sw.bb
    i32 125, label %sw.bb17
    i32 134, label %sw.bb22
    i32 17, label %sw.bb45
  ]

sw.bb:                                            ; preds = %if.then8
  %cmp14 = icmp ugt i32 %conv11, 7
  br i1 %cmp14, label %if.then51, label %return

sw.bb17:                                          ; preds = %if.then8
  %cmp18 = icmp eq i32 %conv11, 10
  br i1 %cmp18, label %return, label %if.then51

sw.bb22:                                          ; preds = %if.then8
  switch i32 %conv11, label %if.then51 [
    i32 11, label %return
    i32 10, label %if.then28
  ]

if.then28:                                        ; preds = %sw.bb22
  %15 = bitcast %struct.sv* %12 to %struct.av*
  %call = call %struct.sv** @Perl_av_fetch(%struct.av* %15, i64 0, i64 0) #4
  %tobool29 = icmp eq %struct.sv** %call, null
  br i1 %tobool29, label %if.then51, label %land.lhs.true30

land.lhs.true30:                                  ; preds = %if.then28
  %16 = load %struct.sv** %call, align 8, !tbaa !6
  %sv_flags31 = getelementptr inbounds %struct.sv* %16, i64 0, i32 2
  %17 = load i64* %sv_flags31, align 8, !tbaa !34
  %and32 = and i64 %17, 524288
  %tobool33 = icmp eq i64 %and32, 0
  br i1 %tobool33, label %if.then51, label %land.lhs.true34

land.lhs.true34:                                  ; preds = %land.lhs.true30
  %sv_any35 = getelementptr inbounds %struct.sv* %16, i64 0, i32 0
  %18 = load i8** %sv_any35, align 8, !tbaa !36
  %xrv_rv36 = bitcast i8* %18 to %struct.sv**
  %19 = load %struct.sv** %xrv_rv36, align 8, !tbaa !98
  %sv_flags37 = getelementptr inbounds %struct.sv* %19, i64 0, i32 2
  %20 = load i64* %sv_flags37, align 8, !tbaa !34
  %and38 = and i64 %20, 255
  %cmp39 = icmp eq i64 %and38, 11
  br i1 %cmp39, label %return, label %if.then51

sw.bb45:                                          ; preds = %if.then8
  %cmp46 = icmp eq i32 %conv11, 12
  br i1 %cmp46, label %return, label %if.then51

if.then51:                                        ; preds = %sw.bb, %land.lhs.true34, %if.then28, %land.lhs.true30, %sw.bb22, %sw.bb17, %sw.bb45
  %badtype.0.ph = phi i8* [ getelementptr inbounds ([9 x i8]* @.str92, i64 0, i64 0), %sw.bb17 ], [ getelementptr inbounds ([7 x i8]* @.str94, i64 0, i64 0), %sw.bb45 ], [ getelementptr inbounds ([7 x i8]* @.str93, i64 0, i64 0), %sw.bb22 ], [ getelementptr inbounds ([7 x i8]* @.str93, i64 0, i64 0), %land.lhs.true30 ], [ getelementptr inbounds ([7 x i8]* @.str93, i64 0, i64 0), %if.then28 ], [ getelementptr inbounds ([7 x i8]* @.str93, i64 0, i64 0), %land.lhs.true34 ], [ getelementptr inbounds ([9 x i8]* @.str91, i64 0, i64 0), %sw.bb ]
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([29 x i8]* @.str95, i64 0, i64 0), i8* %badtype.0.ph) #4
  br label %return

if.end53:                                         ; preds = %if.then
  %and55 = and i64 %8, 262144
  %cmp56 = icmp eq i64 %and55, 0
  br i1 %cmp56, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end53
  %sv_any58 = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %21 = load i8** %sv_any58, align 8, !tbaa !36
  %xpv_cur = getelementptr inbounds i8* %21, i64 8
  %22 = bitcast i8* %xpv_cur to i64*
  %23 = load i64* %22, align 8, !tbaa !37
  store i64 %23, i64* %n_a, align 8, !tbaa !1
  %xpv_pv = bitcast i8* %21 to i8**
  %24 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %cond.end

cond.false:                                       ; preds = %if.end53
  %call60 = call i8* @Perl_sv_2pv_flags(%struct.sv* %7, i64* %n_a, i64 2) #4
  %.pre = load i64* @PL_hints, align 8, !tbaa !1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %25 = phi i64 [ %2, %cond.true ], [ %.pre, %cond.false ]
  %cond = phi i8* [ %24, %cond.true ], [ %call60, %cond.false ]
  %and61 = and i64 %25, 2
  %tobool62 = icmp eq i64 %and61, 0
  %.pre203 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  br i1 %tobool62, label %if.end78, label %land.lhs.true63

land.lhs.true63:                                  ; preds = %cond.end
  %26 = load i8* %.pre203, align 1, !tbaa !33
  %and66 = and i8 %26, 64
  %tobool67 = icmp eq i8 %and66, 0
  br i1 %tobool67, label %if.end78, label %if.then68

if.then68:                                        ; preds = %land.lhs.true63
  %op_type69 = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %27 = load i16* %op_type69, align 2, !tbaa !12
  %conv70 = zext i16 %27 to i32
  switch i32 %conv70, label %if.end78 [
    i32 15, label %if.then76
    i32 125, label %sw.bb72
    i32 134, label %sw.bb73
  ]

sw.bb72:                                          ; preds = %if.then68
  br label %if.then76

sw.bb73:                                          ; preds = %if.then68
  br label %if.then76

if.then76:                                        ; preds = %if.then68, %sw.bb73, %sw.bb72
  %badthing.0.ph = phi i8* [ getelementptr inbounds ([7 x i8]* @.str93, i64 0, i64 0), %sw.bb73 ], [ getelementptr inbounds ([9 x i8]* @.str92, i64 0, i64 0), %sw.bb72 ], [ getelementptr inbounds ([9 x i8]* @.str91, i64 0, i64 0), %if.then68 ]
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([63 x i8]* @.str96, i64 0, i64 0), i8* %cond, i8* %badthing.0.ph) #4
  br label %if.end78

if.end78:                                         ; preds = %cond.end, %if.then68, %land.lhs.true63, %if.then76
  %op_type79 = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %28 = load i16* %op_type79, align 2, !tbaa !12
  %cmp81 = icmp eq i16 %28, 17
  %conv82 = zext i1 %cmp81 to i32
  %mul = shl nuw nsw i32 %conv82, 1
  %.pre202 = load i8* %.pre203, align 1, !tbaa !33
  br label %do.body

do.body:                                          ; preds = %land.rhs, %if.end78
  %29 = phi i8 [ %.pre202, %if.end78 ], [ %32, %land.rhs ]
  %iscv.0 = phi i32 [ %mul, %if.end78 ], [ %inc, %land.rhs ]
  %and85 = lshr i8 %29, 4
  %and85.lobit = and i8 %and85, 1
  %30 = xor i8 %and85.lobit, 1
  %lnot.ext = zext i8 %30 to i32
  %or87 = or i32 %lnot.ext, %iscv.0
  %conv88 = sext i32 %or87 to i64
  %tobool89 = icmp ne i32 %iscv.0, 0
  br i1 %tobool89, label %cond.end113, label %cond.false91

cond.false91:                                     ; preds = %do.body
  %31 = load i16* %op_type79, align 2, !tbaa !12
  %cmp94 = icmp eq i16 %31, 15
  br i1 %cmp94, label %cond.end113, label %cond.false97

cond.false97:                                     ; preds = %cond.false91
  %cmp100 = icmp eq i16 %31, 125
  br i1 %cmp100, label %cond.end113, label %cond.false103

cond.false103:                                    ; preds = %cond.false97
  %cmp106 = icmp eq i16 %31, 134
  %phitmp = select i1 %cmp106, i64 11, i64 13
  br label %cond.end113

cond.end113:                                      ; preds = %cond.false91, %cond.false97, %cond.false103, %do.body
  %cond114 = phi i64 [ 12, %do.body ], [ 4, %cond.false91 ], [ %phitmp, %cond.false103 ], [ 10, %cond.false97 ]
  %call116 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond, i64 %conv88, i64 %cond114) #4
  %tobool117 = icmp eq %struct.gv* %call116, null
  br i1 %tobool117, label %land.lhs.true118, label %land.end134

land.lhs.true118:                                 ; preds = %cond.end113
  %32 = load i8* %.pre203, align 1, !tbaa !33
  %and121 = and i8 %32, 16
  %tobool122 = icmp eq i8 %and121, 0
  br i1 %tobool122, label %land.rhs, label %return

land.rhs:                                         ; preds = %land.lhs.true118
  %inc = add nsw i32 %iscv.0, 1
  br i1 %tobool89, label %return, label %do.body

land.end134:                                      ; preds = %cond.end113
  store i16 7, i16* %4, align 2, !tbaa !71
  %33 = load %struct.sv** %6, align 8, !tbaa !18
  call void @Perl_sv_free(%struct.sv* %33) #4
  %34 = bitcast %struct.gv* %call116 to %struct.sv*
  store %struct.sv* %34, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %35 = getelementptr inbounds %struct.gv* %call116, i64 0, i32 1
  %36 = load i64* %35, align 8, !tbaa !40
  %inc132 = add i64 %36, 1
  store i64 %inc132, i64* %35, align 8, !tbaa !40
  %37 = getelementptr inbounds %struct.op* %op_sv, i64 0, i32 0
  %.c = bitcast %struct.gv* %call116 to %struct.op*
  store %struct.op* %.c, %struct.op** %37, align 8, !tbaa !18
  store i8 0, i8* %.pre203, align 1, !tbaa !33
  %38 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 7), align 8, !tbaa !6
  %39 = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %38, %struct.op* ()** %39, align 8, !tbaa !72
  br label %return

return:                                           ; preds = %land.lhs.true118, %land.rhs, %sw.bb45, %sw.bb17, %sw.bb, %sw.bb22, %land.lhs.true34, %if.then8, %entry, %land.end134, %if.then51
  ret %struct.op* %o
}

declare i32 @no_fh_allowed(...) #2

declare i32 @too_many_arguments(...) #2

declare i32 @bad_type(...) #2

declare i32 @is_handle_constructor(...) #2

declare %struct.sv* @Perl_newSVpvf(i8*, ...) #2

declare %struct.sv* @Perl_sv_2mortal(%struct.sv*) #2

declare i32 @too_few_arguments(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_glob(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  %op_flags = getelementptr inbounds %struct.op* %call, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %call, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !45
  %op_sibling = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %3 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %tobool1 = icmp eq %struct.op* %3, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %call2 = tail call i32 (...)* @newDEFSVOP() #4
  %call3 = tail call i32 (i32, %struct.op*, i32, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, i32, ...)*)(i32 25, %struct.op* %call, i32 %call2) #4
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry, %if.then
  %call4 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([5 x i8]* @.str108, i64 0, i64 0), i64 0, i64 12) #4
  %tobool5 = icmp eq %struct.gv* %call4, null
  br i1 %tobool5, label %if.then16, label %land.lhs.true6

land.lhs.true6:                                   ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.gv* %call4, i64 0, i32 0
  %4 = load %struct.xpvgv** %sv_any, align 8, !tbaa !60
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %4, i64 0, i32 7
  %5 = load %struct.gp** %xgv_gp, align 8, !tbaa !62
  %gp_cvgen = getelementptr inbounds %struct.gp* %5, i64 0, i32 8
  %6 = load i64* %gp_cvgen, align 8, !tbaa !137
  %tobool7 = icmp eq i64 %6, 0
  br i1 %tobool7, label %cond.false, label %if.then16

cond.false:                                       ; preds = %land.lhs.true6
  %gp_cv = getelementptr inbounds %struct.gp* %5, i64 0, i32 7
  %7 = load %struct.cv** %gp_cv, align 8, !tbaa !64
  %tobool10 = icmp eq %struct.cv* %7, null
  br i1 %tobool10, label %if.then16, label %land.lhs.true11

land.lhs.true11:                                  ; preds = %cond.false
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %4, i64 0, i32 11
  %8 = load i8* %xgv_flags, align 1, !tbaa !141
  %tobool15 = icmp slt i8 %8, 0
  br i1 %tobool15, label %if.end18, label %if.then16

if.then16:                                        ; preds = %cond.false, %land.lhs.true6, %if.end, %land.lhs.true11
  %call17 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([19 x i8]* @.str109, i64 0, i64 0), i64 0, i64 12) #4
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %land.lhs.true11
  %gv.0 = phi %struct.gv* [ %call17, %if.then16 ], [ %call4, %land.lhs.true11 ]
  %tobool19 = icmp eq %struct.gv* %gv.0, null
  br i1 %tobool19, label %if.then37, label %land.lhs.true20

land.lhs.true20:                                  ; preds = %if.end18
  %sv_any21 = getelementptr inbounds %struct.gv* %gv.0, i64 0, i32 0
  %9 = load %struct.xpvgv** %sv_any21, align 8, !tbaa !60
  %xgv_gp22 = getelementptr inbounds %struct.xpvgv* %9, i64 0, i32 7
  %10 = load %struct.gp** %xgv_gp22, align 8, !tbaa !62
  %gp_cvgen23 = getelementptr inbounds %struct.gp* %10, i64 0, i32 8
  %11 = load i64* %gp_cvgen23, align 8, !tbaa !137
  %tobool24 = icmp eq i64 %11, 0
  br i1 %tobool24, label %cond.false26, label %if.then37

cond.false26:                                     ; preds = %land.lhs.true20
  %gp_cv29 = getelementptr inbounds %struct.gp* %10, i64 0, i32 7
  %12 = load %struct.cv** %gp_cv29, align 8, !tbaa !64
  %tobool30 = icmp eq %struct.cv* %12, null
  br i1 %tobool30, label %if.then37, label %land.lhs.true31

land.lhs.true31:                                  ; preds = %cond.false26
  %xgv_flags33 = getelementptr inbounds %struct.xpvgv* %9, i64 0, i32 11
  %13 = load i8* %xgv_flags33, align 1, !tbaa !141
  %tobool36 = icmp slt i8 %13, 0
  br i1 %tobool36, label %if.end56, label %if.then37

if.then37:                                        ; preds = %cond.false26, %land.lhs.true20, %if.end18, %land.lhs.true31
  tail call void @Perl_push_scope() #4
  %call38 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8]* @.str110, i64 0, i64 0), i64 10) #4
  tail call void (i64, %struct.sv*, %struct.sv*, ...)* @Perl_load_module(i64 2, %struct.sv* %call38, %struct.sv* null, %struct.sv* null, %struct.sv* null)
  %call39 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([19 x i8]* @.str109, i64 0, i64 0), i64 0, i64 12) #4
  %call40 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([21 x i8]* @.str111, i64 0, i64 0), i64 0, i64 12) #4
  %sv_any41 = getelementptr inbounds %struct.gv* %call40, i64 0, i32 0
  %14 = load %struct.xpvgv** %sv_any41, align 8, !tbaa !60
  %xgv_gp42 = getelementptr inbounds %struct.xpvgv* %14, i64 0, i32 7
  %15 = load %struct.gp** %xgv_gp42, align 8, !tbaa !62
  %gp_cv43 = getelementptr inbounds %struct.gp* %15, i64 0, i32 7
  %16 = load %struct.cv** %gp_cv43, align 8, !tbaa !64
  %sv_any44 = getelementptr inbounds %struct.gv* %call39, i64 0, i32 0
  %17 = load %struct.xpvgv** %sv_any44, align 8, !tbaa !60
  %xgv_gp45 = getelementptr inbounds %struct.xpvgv* %17, i64 0, i32 7
  %18 = load %struct.gp** %xgv_gp45, align 8, !tbaa !62
  %gp_cv46 = getelementptr inbounds %struct.gp* %18, i64 0, i32 7
  store %struct.cv* %16, %struct.cv** %gp_cv46, align 8, !tbaa !64
  %19 = bitcast %struct.cv* %16 to %struct.sv*
  store %struct.sv* %19, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool50 = icmp eq %struct.cv* %16, null
  br i1 %tobool50, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.then37
  %20 = getelementptr inbounds %struct.cv* %16, i64 0, i32 1
  %21 = load i64* %20, align 8, !tbaa !40
  %inc = add i64 %21, 1
  store i64 %inc, i64* %20, align 8, !tbaa !40
  br label %land.end

land.end:                                         ; preds = %if.then37, %land.rhs
  %22 = load %struct.xpvgv** %sv_any44, align 8, !tbaa !60
  %xgv_flags53 = getelementptr inbounds %struct.xpvgv* %22, i64 0, i32 11
  %23 = load i8* %xgv_flags53, align 1, !tbaa !141
  %or = or i8 %23, -128
  store i8 %or, i8* %xgv_flags53, align 1, !tbaa !141
  tail call void @Perl_pop_scope() #4
  br label %if.end56

if.end56:                                         ; preds = %land.end, %land.lhs.true31
  %gv.1 = phi %struct.gv* [ %call39, %land.end ], [ %gv.0, %land.lhs.true31 ]
  %tobool57 = icmp eq %struct.gv* %gv.1, null
  br i1 %tobool57, label %if.end95, label %land.lhs.true58

land.lhs.true58:                                  ; preds = %if.end56
  %sv_any59 = getelementptr inbounds %struct.gv* %gv.1, i64 0, i32 0
  %24 = load %struct.xpvgv** %sv_any59, align 8, !tbaa !60
  %xgv_gp60 = getelementptr inbounds %struct.xpvgv* %24, i64 0, i32 7
  %25 = load %struct.gp** %xgv_gp60, align 8, !tbaa !62
  %gp_cvgen61 = getelementptr inbounds %struct.gp* %25, i64 0, i32 8
  %26 = load i64* %gp_cvgen61, align 8, !tbaa !137
  %tobool62 = icmp eq i64 %26, 0
  br i1 %tobool62, label %cond.false64, label %if.end95

cond.false64:                                     ; preds = %land.lhs.true58
  %gp_cv67 = getelementptr inbounds %struct.gp* %25, i64 0, i32 7
  %27 = load %struct.cv** %gp_cv67, align 8, !tbaa !64
  %tobool68 = icmp eq %struct.cv* %27, null
  br i1 %tobool68, label %if.end95, label %land.lhs.true69

land.lhs.true69:                                  ; preds = %cond.false64
  %xgv_flags71 = getelementptr inbounds %struct.xpvgv* %24, i64 0, i32 11
  %28 = load i8* %xgv_flags71, align 1, !tbaa !141
  %tobool74 = icmp slt i8 %28, 0
  br i1 %tobool74, label %if.then75, label %if.end95

if.then75:                                        ; preds = %land.lhs.true69
  %29 = load i32* @PL_glob_index, align 4, !tbaa !92
  %inc76 = add nsw i32 %29, 1
  store i32 %inc76, i32* @PL_glob_index, align 4, !tbaa !92
  %conv77 = sext i32 %29 to i64
  %call78 = tail call %struct.sv* @Perl_newSViv(i64 %conv77) #4
  %call.i = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i, i64 32
  %30 = bitcast i8* %op_type.i to i16*
  store i16 5, i16* %30, align 2, !tbaa !71
  %31 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %32 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %31, %struct.op* ()** %32, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i, i64 40
  %33 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %call78, %struct.sv** %33, align 8, !tbaa !18
  %34 = bitcast i8* %call.i to %struct.op*
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %34, %struct.op** %op_next.i, align 8, !tbaa !73
  %35 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %35, align 1, !tbaa !74
  %36 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i = and i64 %36, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %if.then75
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %34) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then75
  %37 = phi i64 [ %36, %if.then75 ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %37, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %38 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %38, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %39 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %39, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %39, i64 5
  %40 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %40, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %34) #4
  %41 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %41) #4
  br label %Perl_newGVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %42 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %42(%struct.op* %34) #4
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  %call80 = tail call i32 (i32, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, %struct.op*, ...)*)(i32 25, %struct.op* %call, %struct.op* %cond.i) #4
  %op_type = getelementptr inbounds %struct.op* %call, i64 0, i32 4
  store i16 141, i16* %op_type, align 2, !tbaa !12
  %43 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 141), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %call, i64 0, i32 2
  store %struct.op* ()* %43, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %44 = getelementptr inbounds %struct.op* %call, i64 1, i32 0
  %45 = load %struct.op** %44, align 8, !tbaa !45
  %op_type82 = getelementptr inbounds %struct.op* %45, i64 0, i32 4
  store i16 3, i16* %op_type82, align 2, !tbaa !12
  %46 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 3), align 8, !tbaa !6
  %op_ppaddr84 = getelementptr inbounds %struct.op* %45, i64 0, i32 2
  store %struct.op* ()* %46, %struct.op* ()** %op_ppaddr84, align 8, !tbaa !41
  %op_targ = getelementptr inbounds %struct.op* %45, i64 0, i32 3
  store i64 0, i64* %op_targ, align 8, !tbaa !13
  %47 = bitcast %struct.gv* %gv.1 to %struct.sv*
  store %struct.sv* %47, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %48 = getelementptr inbounds %struct.gv* %gv.1, i64 0, i32 1
  %49 = load i64* %48, align 8, !tbaa !40
  %inc.i = add i64 %49, 1
  store i64 %inc.i, i64* %48, align 8, !tbaa !40
  %call.i135 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i135, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i136 = getelementptr inbounds i8* %call.i135, i64 32
  %50 = bitcast i8* %op_type.i136 to i16*
  store i16 7, i16* %50, align 2, !tbaa !71
  %51 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 7), align 8, !tbaa !6
  %op_ppaddr.i137 = getelementptr inbounds i8* %call.i135, i64 16
  %52 = bitcast i8* %op_ppaddr.i137 to %struct.op* ()**
  store %struct.op* ()* %51, %struct.op* ()** %52, align 8, !tbaa !72
  %op_sv.i138 = getelementptr inbounds i8* %call.i135, i64 40
  %53 = bitcast i8* %op_sv.i138 to %struct.sv**
  store %struct.sv* %47, %struct.sv** %53, align 8, !tbaa !18
  %54 = bitcast i8* %call.i135 to %struct.op*
  %op_next.i139 = bitcast i8* %call.i135 to %struct.op**
  store %struct.op* %54, %struct.op** %op_next.i139, align 8, !tbaa !73
  %55 = getelementptr inbounds i8* %call.i135, i64 36
  store i8 0, i8* %55, align 1, !tbaa !74
  %56 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  %and.i140 = and i64 %56, 4
  %tobool.i141 = icmp eq i64 %and.i140, 0
  br i1 %tobool.i141, label %if.end.i147, label %if.then.i144

if.then.i144:                                     ; preds = %Perl_newGVOP.exit
  %call3.i142 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %54) #4
  %.pre.i143 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  br label %if.end.i147

if.end.i147:                                      ; preds = %if.then.i144, %Perl_newGVOP.exit
  %57 = phi i64 [ %56, %Perl_newGVOP.exit ], [ %.pre.i143, %if.then.i144 ]
  %and5.i145 = and i64 %57, 8
  %tobool6.i146 = icmp eq i64 %and5.i145, 0
  br i1 %tobool6.i146, label %if.end10.i153, label %if.then7.i151

if.then7.i151:                                    ; preds = %if.end.i147
  %call8.i148 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 7, i32 512) #4
  %conv9.i149 = sext i32 %call8.i148 to i64
  %op_targ.i150 = getelementptr inbounds i8* %call.i135, i64 24
  %58 = bitcast i8* %op_targ.i150 to i64*
  store i64 %conv9.i149, i64* %58, align 8, !tbaa !75
  br label %if.end10.i153

if.end10.i153:                                    ; preds = %if.then7.i151, %if.end.i147
  %59 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i152 = icmp eq i8* %59, null
  br i1 %tobool11.i152, label %cond.false.i159, label %land.lhs.true.i156

land.lhs.true.i156:                               ; preds = %if.end10.i153
  %arrayidx12.i154 = getelementptr inbounds i8* %59, i64 7
  %60 = load i8* %arrayidx12.i154, align 1, !tbaa !5
  %tobool14.i155 = icmp eq i8 %60, 0
  br i1 %tobool14.i155, label %cond.false.i159, label %cond.true.i157

cond.true.i157:                                   ; preds = %land.lhs.true.i156
  tail call void @Perl_op_free(%struct.op* %54) #4
  %61 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 7), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %61) #4
  br label %Perl_newSVOP.exit161

cond.false.i159:                                  ; preds = %land.lhs.true.i156, %if.end10.i153
  %62 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 7), align 8, !tbaa !6
  %call17.i158 = tail call %struct.op* %62(%struct.op* %54) #4
  br label %Perl_newSVOP.exit161

Perl_newSVOP.exit161:                             ; preds = %cond.true.i157, %cond.false.i159
  %cond.i160 = phi %struct.op* [ null, %cond.true.i157 ], [ %call17.i158, %cond.false.i159 ]
  %call87 = tail call %struct.op* @Perl_newUNOP(i64 17, i64 0, %struct.op* %cond.i160)
  %call88 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %call87) #4
  %call89 = tail call i32 (i32, %struct.op*, i32, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, i32, ...)*)(i32 141, %struct.op* %call, i32 %call88) #4
  %conv90 = sext i32 %call89 to i64
  %63 = inttoptr i64 %conv90 to %struct.op*
  %call91 = tail call %struct.op* @Perl_newUNOP(i64 166, i64 64, %struct.op* %63)
  %call92 = tail call %struct.op* @Perl_ck_subr(%struct.op* %call91)
  %call93 = tail call %struct.op* @Perl_newUNOP(i64 0, i64 0, %struct.op* %call92)
  %op_targ94 = getelementptr inbounds %struct.op* %call93, i64 0, i32 3
  store i64 25, i64* %op_targ94, align 8, !tbaa !13
  br label %return

if.end95:                                         ; preds = %cond.false64, %land.lhs.true58, %if.end56, %land.lhs.true69
  %call96 = tail call %struct.gv* @Perl_newGVgen(i8* getelementptr inbounds ([5 x i8]* @.str112, i64 0, i64 0)) #4
  %call97 = tail call %struct.gv* @Perl_gv_IOadd(%struct.gv* %call96) #4
  %64 = bitcast %struct.gv* %call96 to %struct.sv*
  store %struct.sv* %64, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool.i162 = icmp eq %struct.gv* %call96, null
  br i1 %tobool.i162, label %Perl_newGVOP.exit166, label %land.rhs.i164

land.rhs.i164:                                    ; preds = %if.end95
  %65 = getelementptr inbounds %struct.gv* %call96, i64 0, i32 1
  %66 = load i64* %65, align 8, !tbaa !40
  %inc.i163 = add i64 %66, 1
  store i64 %inc.i163, i64* %65, align 8, !tbaa !40
  br label %Perl_newGVOP.exit166

Perl_newGVOP.exit166:                             ; preds = %if.end95, %land.rhs.i164
  %call.i167 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i167, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i168 = getelementptr inbounds i8* %call.i167, i64 32
  %67 = bitcast i8* %op_type.i168 to i16*
  store i16 7, i16* %67, align 2, !tbaa !71
  %68 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 7), align 8, !tbaa !6
  %op_ppaddr.i169 = getelementptr inbounds i8* %call.i167, i64 16
  %69 = bitcast i8* %op_ppaddr.i169 to %struct.op* ()**
  store %struct.op* ()* %68, %struct.op* ()** %69, align 8, !tbaa !72
  %op_sv.i170 = getelementptr inbounds i8* %call.i167, i64 40
  %70 = bitcast i8* %op_sv.i170 to %struct.sv**
  store %struct.sv* %64, %struct.sv** %70, align 8, !tbaa !18
  %71 = bitcast i8* %call.i167 to %struct.op*
  %op_next.i171 = bitcast i8* %call.i167 to %struct.op**
  store %struct.op* %71, %struct.op** %op_next.i171, align 8, !tbaa !73
  %72 = getelementptr inbounds i8* %call.i167, i64 36
  store i8 0, i8* %72, align 1, !tbaa !74
  %73 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  %and.i172 = and i64 %73, 4
  %tobool.i173 = icmp eq i64 %and.i172, 0
  br i1 %tobool.i173, label %if.end.i179, label %if.then.i176

if.then.i176:                                     ; preds = %Perl_newGVOP.exit166
  %call3.i174 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %71) #4
  %.pre.i175 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  br label %if.end.i179

if.end.i179:                                      ; preds = %if.then.i176, %Perl_newGVOP.exit166
  %74 = phi i64 [ %73, %Perl_newGVOP.exit166 ], [ %.pre.i175, %if.then.i176 ]
  %and5.i177 = and i64 %74, 8
  %tobool6.i178 = icmp eq i64 %and5.i177, 0
  br i1 %tobool6.i178, label %if.end10.i185, label %if.then7.i183

if.then7.i183:                                    ; preds = %if.end.i179
  %call8.i180 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 7, i32 512) #4
  %conv9.i181 = sext i32 %call8.i180 to i64
  %op_targ.i182 = getelementptr inbounds i8* %call.i167, i64 24
  %75 = bitcast i8* %op_targ.i182 to i64*
  store i64 %conv9.i181, i64* %75, align 8, !tbaa !75
  br label %if.end10.i185

if.end10.i185:                                    ; preds = %if.then7.i183, %if.end.i179
  %76 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i184 = icmp eq i8* %76, null
  br i1 %tobool11.i184, label %cond.false.i191, label %land.lhs.true.i188

land.lhs.true.i188:                               ; preds = %if.end10.i185
  %arrayidx12.i186 = getelementptr inbounds i8* %76, i64 7
  %77 = load i8* %arrayidx12.i186, align 1, !tbaa !5
  %tobool14.i187 = icmp eq i8 %77, 0
  br i1 %tobool14.i187, label %cond.false.i191, label %cond.true.i189

cond.true.i189:                                   ; preds = %land.lhs.true.i188
  tail call void @Perl_op_free(%struct.op* %71) #4
  %78 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 7), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %78) #4
  br label %Perl_newSVOP.exit193

cond.false.i191:                                  ; preds = %land.lhs.true.i188, %if.end10.i185
  %79 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 7), align 8, !tbaa !6
  %call17.i190 = tail call %struct.op* %79(%struct.op* %71) #4
  br label %Perl_newSVOP.exit193

Perl_newSVOP.exit193:                             ; preds = %cond.true.i189, %cond.false.i191
  %cond.i192 = phi %struct.op* [ null, %cond.true.i189 ], [ %call17.i190, %cond.false.i191 ]
  %call99 = tail call i32 (i32, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, %struct.op*, ...)*)(i32 25, %struct.op* %call, %struct.op* %cond.i192) #4
  %call100 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalarkids to i32 (%struct.op*, ...)*)(%struct.op* %call) #4
  br label %return

return:                                           ; preds = %Perl_newSVOP.exit193, %Perl_newSVOP.exit161
  %retval.0 = phi %struct.op* [ %call, %Perl_newSVOP.exit193 ], [ %call93, %Perl_newSVOP.exit161 ]
  ret %struct.op* %retval.0
}

declare %struct.sv* @Perl_newSViv(i64) #2

declare %struct.gv* @Perl_newGVgen(i8*) #2

declare %struct.gv* @Perl_gv_IOadd(%struct.gv*) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_grep(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %0, 152
  %conv2 = select i1 %cmp, i16 153, i16 155
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 152), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %1, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %call = tail call i8* @Perl_safesysmalloc(i64 56) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 56, i32 1, i1 false)
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end15, label %if.then

if.then:                                          ; preds = %entry
  %call4 = tail call %struct.op* @Perl_ck_sort(%struct.op* %o)
  %3 = getelementptr inbounds %struct.op* %call4, i64 1, i32 0
  %4 = load %struct.op** %3, align 8, !tbaa !45
  %op_sibling = getelementptr inbounds %struct.op* %4, i64 0, i32 1
  %5 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %op_next = getelementptr inbounds %struct.op* %5, i64 0, i32 0
  %6 = load %struct.op** %op_next, align 8, !tbaa !58
  %tobool5 = icmp eq %struct.op* %6, null
  br i1 %tobool5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([15 x i8]* @.str113, i64 0, i64 0)) #4
  br label %if.end

if.end:                                           ; preds = %if.then, %if.then6
  %7 = getelementptr inbounds %struct.op* %5, i64 1, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.cond, %if.end
  %kid.0 = phi %struct.op* [ %5, %if.end ], [ %k.0, %for.cond ]
  %k.0.in = phi %struct.op** [ %7, %if.end ], [ %op_next9, %for.cond ]
  %k.0 = load %struct.op** %k.0.in, align 8
  %tobool8 = icmp eq %struct.op* %k.0, null
  %op_next9 = getelementptr inbounds %struct.op* %k.0, i64 0, i32 0
  br i1 %tobool8, label %for.end, label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = bitcast i8* %call to %struct.op*
  %op_next10 = getelementptr inbounds %struct.op* %kid.0, i64 0, i32 0
  store %struct.op* %8, %struct.op** %op_next10, align 8, !tbaa !42
  %op_flags11 = getelementptr inbounds %struct.op* %call4, i64 0, i32 6
  %9 = load i8* %op_flags11, align 1, !tbaa !14
  %and13 = and i8 %9, -65
  store i8 %and13, i8* %op_flags11, align 1, !tbaa !14
  br label %if.end15

if.end15:                                         ; preds = %entry, %for.end
  %o.addr.0 = phi %struct.op* [ %call4, %for.end ], [ %o, %entry ]
  %10 = getelementptr inbounds %struct.op* %o.addr.0, i64 1, i32 0
  %11 = load %struct.op** %10, align 8, !tbaa !45
  %op_sibling17 = getelementptr inbounds %struct.op* %11, i64 0, i32 1
  %12 = load %struct.op** %op_sibling17, align 8, !tbaa !17
  %conv18 = zext i16 %conv2 to i32
  br i1 %cmp, label %if.else, label %if.then21

if.then21:                                        ; preds = %if.end15
  %call22 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %12) #4
  br label %if.end24

if.else:                                          ; preds = %if.end15
  %call23 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %12) #4
  br label %if.end24

if.end24:                                         ; preds = %if.else, %if.then21
  %call25 = tail call %struct.op* @Perl_ck_fun(%struct.op* %o.addr.0)
  %13 = load i64* @PL_error_count, align 8, !tbaa !1
  %tobool26 = icmp eq i64 %13, 0
  br i1 %tobool26, label %if.end28, label %return

if.end28:                                         ; preds = %if.end24
  %14 = getelementptr inbounds %struct.op* %call25, i64 1, i32 0
  %15 = load %struct.op** %14, align 8, !tbaa !45
  %op_sibling30 = getelementptr inbounds %struct.op* %15, i64 0, i32 1
  %16 = load %struct.op** %op_sibling30, align 8, !tbaa !17
  %op_type31 = getelementptr inbounds %struct.op* %16, i64 0, i32 4
  %17 = load i16* %op_type31, align 2, !tbaa !12
  %cmp33 = icmp eq i16 %17, 0
  br i1 %cmp33, label %if.end36, label %if.then35

if.then35:                                        ; preds = %if.end28
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([15 x i8]* @.str113, i64 0, i64 0)) #4
  br label %if.end36

if.end36:                                         ; preds = %if.end28, %if.then35
  %18 = getelementptr inbounds %struct.op* %16, i64 1, i32 0
  %19 = load %struct.op** %18, align 8, !tbaa !15
  %op_type38 = getelementptr inbounds i8* %call, i64 32
  %20 = bitcast i8* %op_type38 to i16*
  store i16 %conv2, i16* %20, align 2, !tbaa !108
  %idxprom = zext i16 %conv2 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom
  %21 = load %struct.op* ()** %arrayidx, align 8, !tbaa !6
  %op_ppaddr39 = getelementptr inbounds i8* %call, i64 16
  %22 = bitcast i8* %op_ppaddr39 to %struct.op* ()**
  store %struct.op* ()* %21, %struct.op* ()** %22, align 8, !tbaa !110
  %call40 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @listkids to i32 (%struct.op*, ...)*)(%struct.op* %call25) #4
  %conv41 = sext i32 %call40 to i64
  %23 = inttoptr i64 %conv41 to %struct.op*
  %op_first42 = getelementptr inbounds i8* %call, i64 40
  %24 = bitcast i8* %op_first42 to %struct.op**
  store %struct.op* %23, %struct.op** %24, align 8, !tbaa !111
  %25 = getelementptr inbounds i8* %call, i64 36
  %26 = load i8* %25, align 1, !tbaa !112
  %or = or i8 %26, 4
  store i8 %or, i8* %25, align 1, !tbaa !112
  %27 = getelementptr inbounds i8* %call, i64 37
  store i8 1, i8* %27, align 1, !tbaa !113
  %op_next46 = getelementptr inbounds %struct.op* %19, i64 0, i32 0
  %28 = load %struct.op** %op_next46, align 8, !tbaa !42
  %tobool47 = icmp eq %struct.op* %28, null
  br i1 %tobool47, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.end36
  %call49 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %19) #4
  %conv50 = sext i32 %call49 to i64
  %29 = inttoptr i64 %conv50 to %struct.op*
  br label %cond.end

cond.end:                                         ; preds = %if.end36, %cond.false
  %cond51 = phi %struct.op* [ %29, %cond.false ], [ %28, %if.end36 ]
  %op_other = getelementptr inbounds i8* %call, i64 48
  %30 = bitcast i8* %op_other to %struct.op**
  store %struct.op* %cond51, %struct.op** %30, align 8, !tbaa !114
  %call53 = tail call i32 (i32, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i32, i32, ...)*)(i32 %conv18, i32 512) #4
  %conv54 = sext i32 %call53 to i64
  %op_targ = getelementptr inbounds i8* %call, i64 24
  %31 = bitcast i8* %op_targ to i64*
  store i64 %conv54, i64* %31, align 8, !tbaa !165
  %32 = bitcast i8* %call to %struct.op*
  store %struct.op* %32, %struct.op** %op_next46, align 8, !tbaa !42
  %33 = load %struct.op** %14, align 8, !tbaa !45
  %op_sibling57 = getelementptr inbounds %struct.op* %33, i64 0, i32 1
  %34 = load %struct.op** %op_sibling57, align 8, !tbaa !17
  %tobool58 = icmp eq %struct.op* %34, null
  br i1 %tobool58, label %if.then61, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %op_sibling59 = getelementptr inbounds %struct.op* %34, i64 0, i32 1
  %35 = load %struct.op** %op_sibling59, align 8, !tbaa !17
  %tobool60 = icmp eq %struct.op* %35, null
  br i1 %tobool60, label %if.then61, label %for.body80

if.then61:                                        ; preds = %lor.lhs.false, %cond.end
  %op_type62 = getelementptr inbounds %struct.op* %call25, i64 0, i32 4
  %36 = load i16* %op_type62, align 2, !tbaa !12
  %cmp64 = icmp eq i16 %36, 351
  br i1 %cmp64, label %cond.true66, label %cond.false68

cond.true66:                                      ; preds = %if.then61
  %37 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %tobool.i = icmp eq %struct.hv* %37, null
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %cond.true66
  %38 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end72

if.end.i:                                         ; preds = %cond.true66
  %op_ppaddr.i = getelementptr inbounds %struct.op* %call25, i64 0, i32 2
  %39 = load %struct.op* ()** %op_ppaddr.i, align 8, !tbaa !41
  %40 = ptrtoint %struct.op* ()* %39 to i64
  %call.i = tail call %struct.sv* @Perl_newSViv(i64 %40) #4
  %call1.i = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call.i) #4
  %41 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %call2.i = tail call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %41, %struct.sv* %call1.i, i64 0, i64 0) #4
  %tobool3.i = icmp eq %struct.he* %call2.i, null
  br i1 %tobool3.i, label %if.then4.i, label %if.end5.i

if.then4.i:                                       ; preds = %if.end.i
  %42 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end72

if.end5.i:                                        ; preds = %if.end.i
  %hent_val.i = getelementptr inbounds %struct.he* %call2.i, i64 0, i32 2
  %43 = load %struct.sv** %hent_val.i, align 8, !tbaa !49
  %sv_flags.i = getelementptr inbounds %struct.sv* %43, i64 0, i32 2
  %44 = load i64* %sv_flags.i, align 8, !tbaa !34
  %and.i = and i64 %44, 262144
  %cmp.i = icmp eq i64 %and.i, 0
  br i1 %cmp.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.end5.i
  %sv_any.i = getelementptr inbounds %struct.sv* %43, i64 0, i32 0
  %45 = load i8** %sv_any.i, align 8, !tbaa !36
  %xpv_pv.i = bitcast i8* %45 to i8**
  %46 = load i8** %xpv_pv.i, align 8, !tbaa !39
  br label %cond.end72

cond.false.i:                                     ; preds = %if.end5.i
  %call8.i = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %43) #4
  br label %cond.end72

cond.false68:                                     ; preds = %if.then61
  %idxprom70 = zext i16 %36 to i64
  %arrayidx71 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom70
  %47 = load i8** %arrayidx71, align 8, !tbaa !6
  br label %cond.end72

cond.end72:                                       ; preds = %cond.false.i, %cond.true.i, %if.then4.i, %if.then.i, %cond.false68
  %cond73 = phi i8* [ %47, %cond.false68 ], [ %42, %if.then4.i ], [ %38, %if.then.i ], [ %46, %cond.true.i ], [ %call8.i, %cond.false.i ]
  %call74 = tail call i32 (%struct.op*, i8*, ...)* bitcast (i32 (...)* @too_few_arguments to i32 (%struct.op*, i8*, ...)*)(%struct.op* %call25, i8* %cond73) #4
  %conv75 = sext i32 %call74 to i64
  %48 = inttoptr i64 %conv75 to %struct.op*
  br label %return

for.body80:                                       ; preds = %lor.lhs.false, %for.body80
  %kid.1128 = phi %struct.op* [ %49, %for.body80 ], [ %35, %lor.lhs.false ]
  %call81 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i32, ...)*)(%struct.op* %kid.1128, i32 152) #4
  %op_sibling83 = getelementptr inbounds %struct.op* %kid.1128, i64 0, i32 1
  %49 = load %struct.op** %op_sibling83, align 8, !tbaa !17
  %tobool79 = icmp eq %struct.op* %49, null
  br i1 %tobool79, label %return, label %for.body80

return:                                           ; preds = %for.body80, %if.end24, %cond.end72
  %retval.0 = phi %struct.op* [ %48, %cond.end72 ], [ %call25, %if.end24 ], [ %32, %for.body80 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_sort(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %0, 150
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %1, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @simplify_sort to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  br label %if.end

if.end:                                           ; preds = %entry, %land.lhs.true, %if.then
  %2 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %3 = load %struct.op** %2, align 8, !tbaa !45
  %op_sibling = getelementptr inbounds %struct.op* %3, i64 0, i32 1
  %4 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %5 = load i8* %op_flags, align 1, !tbaa !14
  %and5 = and i8 %5, 64
  %tobool6 = icmp eq i8 %and5, 0
  br i1 %tobool6, label %if.end92, label %if.then7

if.then7:                                         ; preds = %if.end
  %6 = getelementptr inbounds %struct.op* %4, i64 1, i32 0
  %7 = load %struct.op** %6, align 8, !tbaa !15
  %op_type9 = getelementptr inbounds %struct.op* %7, i64 0, i32 4
  %8 = load i16* %op_type9, align 2, !tbaa !12
  switch i16 %8, label %if.end90 [
    i16 179, label %if.then17
    i16 178, label %if.then17
    i16 15, label %if.then88
    i16 9, label %if.then88
  ]

if.then17:                                        ; preds = %if.then7, %if.then7
  %call18 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @linklist to i32 (%struct.op*, ...)*)(%struct.op* %7) #4
  %9 = load i16* %op_type9, align 2, !tbaa !12
  switch i16 %9, label %if.end63 [
    i16 179, label %if.then23
    i16 178, label %if.then29
  ]

if.then23:                                        ; preds = %if.then17
  %op_next = getelementptr inbounds %struct.op* %7, i64 0, i32 0
  %10 = load %struct.op** %op_next, align 8, !tbaa !42
  store %struct.op* null, %struct.op** %op_next, align 8, !tbaa !42
  br label %if.end63

if.then29:                                        ; preds = %if.then17
  %11 = load i16* %op_type, align 2, !tbaa !12
  %cmp32 = icmp eq i16 %11, 150
  br i1 %cmp32, label %Perl_op_null.exit, label %if.else58

Perl_op_null.exit:                                ; preds = %if.then29
  %call.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %7) #4
  %12 = load i16* %op_type9, align 2, !tbaa !12
  %conv3.i = zext i16 %12 to i64
  %op_targ.i = getelementptr inbounds %struct.op* %7, i64 0, i32 3
  store i64 %conv3.i, i64* %op_targ.i, align 8, !tbaa !13
  store i16 0, i16* %op_type9, align 2, !tbaa !12
  %13 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds %struct.op* %7, i64 0, i32 2
  store %struct.op* ()* %13, %struct.op* ()** %op_ppaddr.i, align 8, !tbaa !41
  %op_next35 = getelementptr inbounds %struct.op* %7, i64 0, i32 0
  store %struct.op* %7, %struct.op** %op_next35, align 8, !tbaa !42
  %14 = getelementptr inbounds %struct.op* %7, i64 1, i32 0
  %15 = load %struct.op** %14, align 8, !tbaa !45
  %k.0.in145 = getelementptr inbounds %struct.op* %15, i64 0, i32 0
  %k.0146 = load %struct.op** %k.0.in145, align 8
  %tobool38147 = icmp eq %struct.op* %k.0146, null
  br i1 %tobool38147, label %if.end63, label %for.body

for.body:                                         ; preds = %Perl_op_null.exit, %for.cond.backedge
  %k.0148 = phi %struct.op* [ %k.0, %for.cond.backedge ], [ %k.0146, %Perl_op_null.exit ]
  %op_next39 = getelementptr inbounds %struct.op* %k.0148, i64 0, i32 0
  %16 = load %struct.op** %op_next39, align 8, !tbaa !42
  %cmp40 = icmp eq %struct.op* %16, %7
  br i1 %cmp40, label %for.cond.backedge.thread, label %if.else44

for.cond.backedge.thread:                         ; preds = %for.body
  store %struct.op* null, %struct.op** %op_next39, align 8, !tbaa !42
  br label %if.end63

if.else44:                                        ; preds = %for.body
  %op_type45 = getelementptr inbounds %struct.op* %k.0148, i64 0, i32 4
  %17 = load i16* %op_type45, align 2, !tbaa !12
  switch i16 %17, label %for.cond.backedge [
    i16 182, label %if.then54
    i16 180, label %if.then54
  ]

for.cond.backedge:                                ; preds = %if.else44, %if.then54
  %k.0 = phi %struct.op* [ %k.0.pre, %if.then54 ], [ %16, %if.else44 ]
  %tobool38 = icmp eq %struct.op* %k.0, null
  br i1 %tobool38, label %if.end63, label %for.body

if.then54:                                        ; preds = %if.else44, %if.else44
  %op_lastop = getelementptr inbounds %struct.op* %k.0148, i64 1, i32 4
  %18 = bitcast i16* %op_lastop to %struct.op**
  %19 = load %struct.op** %18, align 8, !tbaa !172
  %k.0.in.phi.trans.insert = getelementptr inbounds %struct.op* %19, i64 0, i32 0
  %k.0.pre = load %struct.op** %k.0.in.phi.trans.insert, align 8
  br label %for.cond.backedge

if.else58:                                        ; preds = %if.then29
  %op_next59 = getelementptr inbounds %struct.op* %7, i64 0, i32 0
  store %struct.op* null, %struct.op** %op_next59, align 8, !tbaa !42
  %.phi.trans.insert = getelementptr inbounds %struct.op* %7, i64 1, i32 0
  %.pre = load %struct.op** %.phi.trans.insert, align 8, !tbaa !45
  br label %if.end63

if.end63:                                         ; preds = %for.cond.backedge, %if.else58, %for.cond.backedge.thread, %Perl_op_null.exit, %if.then17, %if.then23
  %k.2 = phi %struct.op* [ %10, %if.then23 ], [ null, %if.then17 ], [ %.pre, %if.else58 ], [ %15, %for.cond.backedge.thread ], [ %15, %Perl_op_null.exit ], [ %15, %for.cond.backedge ]
  %20 = load void (%struct.op*)** @PL_peepp, align 8, !tbaa !6
  tail call void %20(%struct.op* %k.2) #4
  %21 = load i16* %op_type, align 2, !tbaa !12
  %cmp66 = icmp eq i16 %21, 150
  br i1 %cmp66, label %if.then68, label %if.else72

if.then68:                                        ; preds = %if.end63
  %call69 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %4) #4
  %conv70 = sext i32 %call69 to i64
  %22 = inttoptr i64 %conv70 to %struct.op*
  %op_next71 = getelementptr inbounds %struct.op* %22, i64 0, i32 0
  store %struct.op* %22, %struct.op** %op_next71, align 8, !tbaa !42
  br label %if.end74

if.else72:                                        ; preds = %if.end63
  %op_next73 = getelementptr inbounds %struct.op* %4, i64 0, i32 0
  store %struct.op* %k.2, %struct.op** %op_next73, align 8, !tbaa !42
  br label %if.end74

if.end74:                                         ; preds = %if.else72, %if.then68
  %23 = load i8* %op_flags, align 1, !tbaa !14
  %or = or i8 %23, -128
  store i8 %or, i8* %op_flags, align 1, !tbaa !14
  br label %if.end90

if.then88:                                        ; preds = %if.then7, %if.then7
  %op_type.i137 = getelementptr inbounds %struct.op* %4, i64 0, i32 4
  %24 = load i16* %op_type.i137, align 2, !tbaa !12
  %cmp.i138 = icmp eq i16 %24, 0
  br i1 %cmp.i138, label %if.end90, label %if.end.i143

if.end.i143:                                      ; preds = %if.then88
  %call.i139 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %4) #4
  %25 = load i16* %op_type.i137, align 2, !tbaa !12
  %conv3.i140 = zext i16 %25 to i64
  %op_targ.i141 = getelementptr inbounds %struct.op* %4, i64 0, i32 3
  store i64 %conv3.i140, i64* %op_targ.i141, align 8, !tbaa !13
  store i16 0, i16* %op_type.i137, align 2, !tbaa !12
  %26 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i142 = getelementptr inbounds %struct.op* %4, i64 0, i32 2
  store %struct.op* ()* %26, %struct.op* ()** %op_ppaddr.i142, align 8, !tbaa !41
  br label %if.end90

if.end90:                                         ; preds = %if.end.i143, %if.then88, %if.then7, %if.end74
  %op_sibling91 = getelementptr inbounds %struct.op* %4, i64 0, i32 1
  %27 = load %struct.op** %op_sibling91, align 8, !tbaa !17
  br label %if.end92

if.end92:                                         ; preds = %if.end, %if.end90
  %firstkid.0 = phi %struct.op* [ %27, %if.end90 ], [ %4, %if.end ]
  %28 = load i16* %op_type, align 2, !tbaa !12
  %cmp95 = icmp eq i16 %28, 150
  br i1 %cmp95, label %if.then97, label %if.end99

if.then97:                                        ; preds = %if.end92
  %call98 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @list to i32 (%struct.op*, ...)*)(%struct.op* %firstkid.0) #4
  br label %if.end99

if.end99:                                         ; preds = %if.then97, %if.end92
  ret %struct.op* %o
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_index(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end9, label %if.then

if.then:                                          ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !45
  %op_sibling = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %3 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %tobool1 = icmp eq %struct.op* %3, null
  br i1 %tobool1, label %if.end9, label %if.end

if.end:                                           ; preds = %if.then
  %op_sibling3 = getelementptr inbounds %struct.op* %3, i64 0, i32 1
  %4 = load %struct.op** %op_sibling3, align 8, !tbaa !17
  %tobool4 = icmp eq %struct.op* %4, null
  br i1 %tobool4, label %if.end9, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %op_type = getelementptr inbounds %struct.op* %4, i64 0, i32 4
  %5 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %5, 5
  br i1 %cmp, label %if.then7, label %if.end9

if.then7:                                         ; preds = %land.lhs.true
  %op_sv = getelementptr inbounds %struct.op* %4, i64 1
  %6 = bitcast %struct.op* %op_sv to %struct.sv**
  %7 = load %struct.sv** %6, align 8, !tbaa !18
  tail call void @Perl_fbm_compile(%struct.sv* %7, i64 0) #4
  br label %if.end9

if.end9:                                          ; preds = %if.then, %if.end, %entry, %land.lhs.true, %if.then7
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  ret %struct.op* %call
}

declare void @Perl_fbm_compile(%struct.sv*, i64) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_lengthconst(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_lfun(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  %conv = zext i16 %0 to i32
  %call1 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @modkids to i32 (%struct.op*, i32, ...)*)(%struct.op* %call, i32 %conv) #4
  %conv2 = sext i32 %call1 to i64
  %1 = inttoptr i64 %conv2 to %struct.op*
  ret %struct.op* %1
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_defined(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %1, i64 0, i32 14
  %2 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp = icmp eq %struct.sv* %2, null
  br i1 %cmp, label %lor.lhs.false22, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %3 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings3 = getelementptr inbounds %struct.cop* %3, i64 0, i32 14
  %4 = load %struct.sv** %cop_warnings3, align 8, !tbaa !47
  %cmp4 = icmp eq %struct.sv* %4, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp4, label %lor.lhs.false22, label %land.lhs.true6

land.lhs.true6:                                   ; preds = %land.lhs.true2
  %5 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings7 = getelementptr inbounds %struct.cop* %5, i64 0, i32 14
  %6 = load %struct.sv** %cop_warnings7, align 8, !tbaa !47
  %cmp8 = icmp eq %struct.sv* %6, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp8, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true6
  %7 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings10 = getelementptr inbounds %struct.cop* %7, i64 0, i32 14
  %8 = load %struct.sv** %cop_warnings10, align 8, !tbaa !47
  %sv_any = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %9 to i8**
  %10 = load i8** %xpv_pv, align 8, !tbaa !39
  %11 = load i8* %10, align 1, !tbaa !5
  %and12 = and i8 %11, 16
  %tobool13 = icmp eq i8 %and12, 0
  br i1 %tobool13, label %lor.lhs.false14, label %if.then

lor.lhs.false14:                                  ; preds = %lor.lhs.false
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings15 = getelementptr inbounds %struct.cop* %12, i64 0, i32 14
  %13 = load %struct.sv** %cop_warnings15, align 8, !tbaa !47
  %sv_any16 = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %14 = load i8** %sv_any16, align 8, !tbaa !36
  %xpv_pv17 = bitcast i8* %14 to i8**
  %15 = load i8** %xpv_pv17, align 8, !tbaa !39
  %arrayidx18 = getelementptr inbounds i8* %15, i64 7
  %16 = load i8* %arrayidx18, align 1, !tbaa !5
  %and20 = and i8 %16, 1
  %tobool21 = icmp eq i8 %and20, 0
  br i1 %tobool21, label %lor.lhs.false22, label %if.then

lor.lhs.false22:                                  ; preds = %lor.lhs.false14, %land.lhs.true2, %land.lhs.true
  %17 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings23 = getelementptr inbounds %struct.cop* %17, i64 0, i32 14
  %18 = load %struct.sv** %cop_warnings23, align 8, !tbaa !47
  %cmp24 = icmp eq %struct.sv* %18, null
  br i1 %cmp24, label %land.lhs.true26, label %if.end

land.lhs.true26:                                  ; preds = %lor.lhs.false22
  %19 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and28 = and i8 %19, 1
  %tobool29 = icmp eq i8 %and28, 0
  br i1 %tobool29, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false14, %lor.lhs.false, %land.lhs.true26, %land.lhs.true6
  %20 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %21 = load %struct.op** %20, align 8, !tbaa !15
  %op_type = getelementptr inbounds %struct.op* %21, i64 0, i32 4
  %22 = load i16* %op_type, align 2, !tbaa !12
  %conv30 = zext i16 %22 to i32
  switch i32 %conv30, label %if.end [
    i32 11, label %sw.bb31
    i32 10, label %sw.bb
    i32 37, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.then, %if.then
  tail call void (i64, i8*, ...)* @Perl_warner(i64 7170, i8* getelementptr inbounds ([30 x i8]* @.str114, i64 0, i64 0)) #4
  tail call void (i64, i8*, ...)* @Perl_warner(i64 7170, i8* getelementptr inbounds ([46 x i8]* @.str115, i64 0, i64 0)) #4
  br label %if.end

sw.bb31:                                          ; preds = %if.then
  tail call void (i64, i8*, ...)* @Perl_warner(i64 7170, i8* getelementptr inbounds ([30 x i8]* @.str116, i64 0, i64 0)) #4
  tail call void (i64, i8*, ...)* @Perl_warner(i64 7170, i8* getelementptr inbounds ([46 x i8]* @.str115, i64 0, i64 0)) #4
  br label %if.end

if.end:                                           ; preds = %land.lhs.true26, %entry, %sw.bb, %sw.bb31, %if.then, %lor.lhs.false22
  %op_type.i = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %23 = load i16* %op_type.i, align 2, !tbaa !12
  %call.i = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #4
  %conv.i = zext i16 %23 to i32
  %call1.i = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @refkids to i32 (%struct.op*, i32, ...)*)(%struct.op* %call.i, i32 %conv.i) #4
  %conv2.i = sext i32 %call1.i to i64
  %24 = inttoptr i64 %conv2.i to %struct.op*
  ret %struct.op* %24
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_rfun(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  %conv = zext i16 %0 to i32
  %call1 = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @refkids to i32 (%struct.op*, i32, ...)*)(%struct.op* %call, i32 %conv) #4
  %conv2 = sext i32 %call1 to i64
  %1 = inttoptr i64 %conv2 to %struct.op*
  ret %struct.op* %1
}

declare i32 @refkids(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_listiob(%struct.op* %o) #0 {
entry:
  %0 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %1 = load %struct.op** %0, align 8, !tbaa !45
  %tobool = icmp eq %struct.op* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @force_list to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv = sext i32 %call to i64
  %2 = inttoptr i64 %conv to %struct.op*
  %3 = inttoptr i64 %conv to %struct.listop*
  %op_first1 = getelementptr inbounds %struct.listop* %3, i64 0, i32 8
  %4 = load %struct.op** %op_first1, align 8, !tbaa !45
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %o.addr.0 = phi %struct.op* [ %o, %entry ], [ %2, %if.then ]
  %kid.0 = phi %struct.op* [ %1, %entry ], [ %4, %if.then ]
  %op_type = getelementptr inbounds %struct.op* %kid.0, i64 0, i32 4
  %5 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %5, 3
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %op_sibling = getelementptr inbounds %struct.op* %kid.0, i64 0, i32 1
  %6 = load %struct.op** %op_sibling, align 8, !tbaa !17
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %kid.1 = phi %struct.op* [ %6, %if.then4 ], [ %kid.0, %if.end ]
  %tobool6 = icmp eq %struct.op* %kid.1, null
  br i1 %tobool6, label %if.then38, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end5
  %op_flags = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 6
  %7 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %7, 64
  %tobool8 = icmp eq i8 %and, 0
  %op_sibling13 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 1
  %8 = load %struct.op** %op_sibling13, align 8, !tbaa !17
  br i1 %tobool8, label %land.lhs.true12, label %if.end36

land.lhs.true12:                                  ; preds = %land.lhs.true
  %tobool14 = icmp eq %struct.op* %8, null
  br i1 %tobool14, label %if.then15, label %if.end43

if.then15:                                        ; preds = %land.lhs.true12
  %op_type16 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 4
  %9 = load i16* %op_type16, align 2, !tbaa !12
  %cmp18 = icmp eq i16 %9, 5
  br i1 %cmp18, label %land.lhs.true20, label %if.end43

land.lhs.true20:                                  ; preds = %if.then15
  %op_private = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 7
  %10 = load i8* %op_private, align 1, !tbaa !11
  %and22 = and i8 %10, 64
  %tobool23 = icmp eq i8 %and22, 0
  br i1 %tobool23, label %if.end36, label %if.then24

if.then24:                                        ; preds = %land.lhs.true20
  %or = or i8 %7, 64
  store i8 %or, i8* %op_flags, align 1, !tbaa !14
  %call28 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %kid.1) #4
  %conv29 = sext i32 %call28 to i64
  %11 = inttoptr i64 %conv29 to %struct.op*
  %call30 = tail call %struct.op* @Perl_newUNOP(i64 14, i64 16, %struct.op* %11)
  %12 = getelementptr inbounds %struct.op* %o.addr.0, i64 1, i32 0
  %13 = load %struct.op** %12, align 8, !tbaa !45
  %op_sibling32 = getelementptr inbounds %struct.op* %13, i64 0, i32 1
  store %struct.op* %call30, %struct.op** %op_sibling32, align 8, !tbaa !17
  %14 = getelementptr inbounds %struct.op* %o.addr.0, i64 1, i32 1
  store %struct.op* %call30, %struct.op** %14, align 8, !tbaa !70
  %op_sibling33 = getelementptr inbounds %struct.op* %call30, i64 0, i32 1
  %15 = load %struct.op** %op_sibling33, align 8, !tbaa !17
  br label %if.end36

if.end36:                                         ; preds = %land.lhs.true, %land.lhs.true20, %if.then24
  %kid.2 = phi %struct.op* [ %15, %if.then24 ], [ %kid.1, %land.lhs.true20 ], [ %8, %land.lhs.true ]
  %tobool37 = icmp eq %struct.op* %kid.2, null
  br i1 %tobool37, label %if.then38, label %if.end43

if.then38:                                        ; preds = %if.end5, %if.end36
  %op_type39 = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 4
  %16 = load i16* %op_type39, align 2, !tbaa !12
  %conv40 = zext i16 %16 to i32
  %call41 = tail call i32 (...)* @newDEFSVOP() #4
  %call42 = tail call i32 (i32, %struct.op*, i32, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, i32, ...)*)(i32 %conv40, %struct.op* %o.addr.0, i32 %call41) #4
  br label %if.end43

if.end43:                                         ; preds = %if.then15, %land.lhs.true12, %if.end36, %if.then38
  %call44 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @listkids to i32 (%struct.op*, ...)*)(%struct.op* %o.addr.0) #4
  %conv45 = sext i32 %call44 to i64
  %17 = inttoptr i64 %conv45 to %struct.op*
  ret %struct.op* %17
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_sassign(%struct.op* %o) #0 {
entry:
  %0 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %1 = load %struct.op** %0, align 8, !tbaa !45
  %op_type = getelementptr inbounds %struct.op* %1, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !12
  %idxprom = zext i16 %2 to i64
  %arrayidx = getelementptr inbounds [0 x i64]* @PL_opargs, i64 0, i64 %idxprom
  %3 = load i64* %arrayidx, align 8, !tbaa !1
  %and = and i64 %3, 256
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.end26, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %4 = load i8* %op_flags, align 1, !tbaa !14
  %and1 = and i8 %4, 64
  %tobool2 = icmp eq i8 %and1, 0
  br i1 %tobool2, label %land.lhs.true3, label %if.end26

land.lhs.true3:                                   ; preds = %land.lhs.true
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %5 = load i8* %op_private, align 1, !tbaa !11
  %and5 = and i8 %5, 16
  %tobool6 = icmp eq i8 %and5, 0
  br i1 %tobool6, label %if.then, label %if.end26

if.then:                                          ; preds = %land.lhs.true3
  %op_sibling = getelementptr inbounds %struct.op* %1, i64 0, i32 1
  %6 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %tobool7 = icmp eq %struct.op* %6, null
  br i1 %tobool7, label %if.end26, label %land.lhs.true8

land.lhs.true8:                                   ; preds = %if.then
  %op_type9 = getelementptr inbounds %struct.op* %6, i64 0, i32 4
  %7 = load i16* %op_type9, align 2, !tbaa !12
  %cmp = icmp eq i16 %7, 9
  br i1 %cmp, label %land.lhs.true12, label %if.end26

land.lhs.true12:                                  ; preds = %land.lhs.true8
  %op_private13 = getelementptr inbounds %struct.op* %6, i64 0, i32 7
  %8 = load i8* %op_private13, align 1, !tbaa !11
  %tobool16 = icmp slt i8 %8, 0
  br i1 %tobool16, label %if.end26, label %if.then17

if.then17:                                        ; preds = %land.lhs.true12
  %op_targ = getelementptr inbounds %struct.op* %6, i64 0, i32 3
  %9 = load i64* %op_targ, align 8, !tbaa !13
  %op_targ18 = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  store i64 %9, i64* %op_targ18, align 8, !tbaa !13
  store i64 0, i64* %op_targ, align 8, !tbaa !13
  %op_sibling20 = getelementptr inbounds %struct.op* %o, i64 0, i32 1
  %10 = load %struct.op** %op_sibling20, align 8, !tbaa !17
  store %struct.op* %10, %struct.op** %op_sibling, align 8, !tbaa !17
  store %struct.op* null, %struct.op** %0, align 8, !tbaa !45
  tail call void @Perl_op_free(%struct.op* %o)
  tail call void @Perl_op_free(%struct.op* %6)
  %11 = load i8* %op_private, align 1, !tbaa !11
  %or = or i8 %11, 16
  store i8 %or, i8* %op_private, align 1, !tbaa !11
  br label %return

if.end26:                                         ; preds = %if.then, %land.lhs.true3, %land.lhs.true, %entry, %land.lhs.true8, %land.lhs.true12
  %cmp29 = icmp eq i16 %2, 43
  br i1 %cmp29, label %if.then31, label %return

if.then31:                                        ; preds = %if.end26
  %op_sibling33 = getelementptr inbounds %struct.op* %1, i64 0, i32 1
  %12 = load %struct.op** %op_sibling33, align 8, !tbaa !17
  %tobool34 = icmp eq %struct.op* %12, null
  br i1 %tobool34, label %return, label %land.lhs.true35

land.lhs.true35:                                  ; preds = %if.then31
  %op_type36 = getelementptr inbounds %struct.op* %12, i64 0, i32 4
  %13 = load i16* %op_type36, align 2, !tbaa !12
  %cmp38 = icmp eq i16 %13, 9
  br i1 %cmp38, label %land.lhs.true40, label %return

land.lhs.true40:                                  ; preds = %land.lhs.true35
  %op_private41 = getelementptr inbounds %struct.op* %12, i64 0, i32 7
  %14 = load i8* %op_private41, align 1, !tbaa !11
  %tobool44 = icmp slt i8 %14, 0
  br i1 %tobool44, label %if.then45, label %return

if.then45:                                        ; preds = %land.lhs.true40
  store %struct.op* null, %struct.op** %0, align 8, !tbaa !45
  store %struct.op* null, %struct.op** %op_sibling33, align 8, !tbaa !17
  tail call void @Perl_op_free(%struct.op* %o)
  tail call void @Perl_op_free(%struct.op* %1)
  br label %return

return:                                           ; preds = %if.end26, %land.lhs.true40, %land.lhs.true35, %if.then31, %if.then45, %if.then17
  %retval.0 = phi %struct.op* [ %12, %if.then45 ], [ %1, %if.then17 ], [ %o, %if.then31 ], [ %o, %land.lhs.true35 ], [ %o, %land.lhs.true40 ], [ %o, %if.end26 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_match(%struct.op* %o) #0 {
entry:
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %0 = load i8* %op_private, align 1, !tbaa !11
  %or = or i8 %0, 64
  store i8 %or, i8* %op_private, align 1, !tbaa !11
  ret %struct.op* %o
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_method(%struct.op* %o) #0 {
entry:
  %0 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %1 = load %struct.op** %0, align 8, !tbaa !15
  %op_type = getelementptr inbounds %struct.op* %1, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %2, 5
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %op_sv = getelementptr inbounds %struct.op* %1, i64 1
  %3 = bitcast %struct.op* %op_sv to %struct.sv**
  %4 = load %struct.sv** %3, align 8, !tbaa !18
  %sv_any = getelementptr inbounds %struct.sv* %4, i64 0, i32 0
  %5 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %5 to i8**
  %6 = load i8** %xpv_pv, align 8, !tbaa !39
  %call = tail call i8* @strchr(i8* %6, i32 58) #4
  %tobool = icmp eq i8* %call, null
  br i1 %tobool, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %if.then
  %call4 = tail call i8* @strchr(i8* %6, i32 39) #4
  %tobool5 = icmp eq i8* %call4, null
  br i1 %tobool5, label %if.then6, label %return

if.then6:                                         ; preds = %lor.lhs.false
  %sv_flags = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %7 = load i64* %sv_flags, align 8, !tbaa !34
  %8 = and i64 %7, 9437184
  %9 = icmp eq i64 %8, 9437184
  br i1 %9, label %if.else, label %if.then12

if.then12:                                        ; preds = %if.then6
  %xpv_cur = getelementptr inbounds i8* %5, i64 8
  %10 = bitcast i8* %xpv_cur to i64*
  %11 = load i64* %10, align 8, !tbaa !37
  %call16 = tail call %struct.sv* @Perl_newSVpvn_share(i8* %6, i64 %11, i64 0) #4
  br label %if.end

if.else:                                          ; preds = %if.then6
  %12 = getelementptr inbounds %struct.op* %op_sv, i64 0, i32 0
  store %struct.op* null, %struct.op** %12, align 8, !tbaa !18
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then12
  %sv.0 = phi %struct.sv* [ %4, %if.else ], [ %call16, %if.then12 ]
  %call.i = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i, i64 32
  %13 = bitcast i8* %op_type.i to i16*
  store i16 350, i16* %13, align 2, !tbaa !71
  %14 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 350), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %15 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %14, %struct.op* ()** %15, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i, i64 40
  %16 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %sv.0, %struct.sv** %16, align 8, !tbaa !18
  %17 = bitcast i8* %call.i to %struct.op*
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %17, %struct.op** %op_next.i, align 8, !tbaa !73
  %18 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %18, align 1, !tbaa !74
  %19 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 350), align 8, !tbaa !1
  %and.i = and i64 %19, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %if.end
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %17) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 350), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.end
  %20 = phi i64 [ %19, %if.end ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %20, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 350, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %21 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %21, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %22 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %22, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %22, i64 350
  %23 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %23, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %17) #4
  %24 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 350), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %24) #4
  br label %Perl_newSVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %25 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 350), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %25(%struct.op* %17) #4
  br label %Perl_newSVOP.exit

Perl_newSVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  tail call void @Perl_op_free(%struct.op* %o)
  br label %return

return:                                           ; preds = %entry, %if.then, %lor.lhs.false, %Perl_newSVOP.exit
  %retval.0 = phi %struct.op* [ %cond.i, %Perl_newSVOP.exit ], [ %o, %lor.lhs.false ], [ %o, %if.then ], [ %o, %entry ]
  ret %struct.op* %retval.0
}

declare %struct.sv* @Perl_newSVpvn_share(i8*, i64, i64) #2

; Function Attrs: nounwind readnone uwtable
define %struct.op* @Perl_ck_null(%struct.op* readnone %o) #3 {
entry:
  ret %struct.op* %o
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_open(%struct.op* %o) #0 {
entry:
  %0 = load %struct.gv** @PL_hintgv, align 8, !tbaa !6
  %sv_any = getelementptr inbounds %struct.gv* %0, i64 0, i32 0
  %1 = load %struct.xpvgv** %sv_any, align 8, !tbaa !60
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %1, i64 0, i32 7
  %2 = load %struct.gp** %xgv_gp, align 8, !tbaa !62
  %gp_hv = getelementptr inbounds %struct.gp* %2, i64 0, i32 5
  %3 = load %struct.hv** %gp_hv, align 8, !tbaa !94
  %tobool = icmp eq %struct.hv* %3, null
  br i1 %tobool, label %if.end43, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call %struct.sv** @Perl_hv_fetch(%struct.hv* %3, i8* getelementptr inbounds ([8 x i8]* @.str117, i64 0, i64 0), i64 7, i64 0) #4
  %tobool1 = icmp eq %struct.sv** %call, null
  br i1 %tobool1, label %if.end17, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %4 = load %struct.sv** %call, align 8, !tbaa !6
  %tobool2 = icmp eq %struct.sv* %4, null
  br i1 %tobool2, label %if.end17, label %if.then3

if.then3:                                         ; preds = %land.lhs.true
  %call4 = tail call i32 (%struct.sv*, ...)* bitcast (i32 (...)* @mode_from_discipline to i32 (%struct.sv*, ...)*)(%struct.sv* %4) #4
  br label %if.end17

if.end17:                                         ; preds = %land.lhs.true, %if.then, %if.then3
  %call18 = tail call %struct.sv** @Perl_hv_fetch(%struct.hv* %3, i8* getelementptr inbounds ([9 x i8]* @.str118, i64 0, i64 0), i64 8, i64 0) #4
  %tobool19 = icmp eq %struct.sv** %call18, null
  br i1 %tobool19, label %if.end43, label %land.lhs.true20

land.lhs.true20:                                  ; preds = %if.end17
  %5 = load %struct.sv** %call18, align 8, !tbaa !6
  %tobool21 = icmp eq %struct.sv* %5, null
  br i1 %tobool21, label %if.end43, label %if.then22

if.then22:                                        ; preds = %land.lhs.true20
  %call23 = tail call i32 (%struct.sv*, ...)* bitcast (i32 (...)* @mode_from_discipline to i32 (%struct.sv*, ...)*)(%struct.sv* %5) #4
  br label %if.end43

if.end43:                                         ; preds = %land.lhs.true20, %if.end17, %entry, %if.then22
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %6 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %6, 24
  br i1 %cmp, label %return, label %if.end47

if.end47:                                         ; preds = %if.end43
  %7 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %8 = load %struct.op** %7, align 8, !tbaa !45
  %9 = getelementptr inbounds %struct.op* %o, i64 1, i32 1
  %10 = load %struct.op** %9, align 8, !tbaa !70
  %op_type49 = getelementptr inbounds %struct.op* %10, i64 0, i32 4
  %11 = load i16* %op_type49, align 2, !tbaa !12
  %cmp51 = icmp eq i16 %11, 5
  br i1 %cmp51, label %land.lhs.true53, label %if.end93

land.lhs.true53:                                  ; preds = %if.end47
  %op_private54 = getelementptr inbounds %struct.op* %10, i64 0, i32 7
  %12 = load i8* %op_private54, align 1, !tbaa !11
  %13 = and i8 %12, 72
  %14 = icmp eq i8 %13, 72
  br i1 %14, label %land.lhs.true63, label %if.end93

land.lhs.true63:                                  ; preds = %land.lhs.true53
  %op_sibling = getelementptr inbounds %struct.op* %8, i64 0, i32 1
  %15 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %tobool64 = icmp eq %struct.op* %15, null
  br i1 %tobool64, label %if.end93, label %land.lhs.true65

land.lhs.true65:                                  ; preds = %land.lhs.true63
  %op_sibling66 = getelementptr inbounds %struct.op* %15, i64 0, i32 1
  %16 = load %struct.op** %op_sibling66, align 8, !tbaa !17
  %tobool67 = icmp eq %struct.op* %16, null
  br i1 %tobool67, label %if.end93, label %land.lhs.true68

land.lhs.true68:                                  ; preds = %land.lhs.true65
  %op_sv = getelementptr inbounds %struct.op* %16, i64 1
  %17 = bitcast %struct.op* %op_sv to %struct.sv**
  %18 = load %struct.sv** %17, align 8, !tbaa !18
  %sv_flags = getelementptr inbounds %struct.sv* %18, i64 0, i32 2
  %19 = load i64* %sv_flags, align 8, !tbaa !34
  %and69 = and i64 %19, 262144
  %tobool70 = icmp eq i64 %and69, 0
  br i1 %tobool70, label %if.end93, label %land.lhs.true71

land.lhs.true71:                                  ; preds = %land.lhs.true68
  %sv_any73 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %20 = load i8** %sv_any73, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %20 to i8**
  %21 = load i8** %xpv_pv, align 8, !tbaa !39
  %tobool74 = icmp eq i8* %21, null
  br i1 %tobool74, label %if.end93, label %land.lhs.true75

land.lhs.true75:                                  ; preds = %land.lhs.true71
  %22 = load i8* %21, align 1, !tbaa !5
  %cmp77 = icmp eq i8 %22, 62
  br i1 %cmp77, label %land.lhs.true79, label %if.end93

land.lhs.true79:                                  ; preds = %land.lhs.true75
  %arrayidx80 = getelementptr inbounds i8* %21, i64 1
  %23 = load i8* %arrayidx80, align 1, !tbaa !5
  %cmp82 = icmp eq i8 %23, 38
  br i1 %cmp82, label %land.lhs.true84, label %if.end93

land.lhs.true84:                                  ; preds = %land.lhs.true79
  %op_sibling85 = getelementptr inbounds %struct.op* %16, i64 0, i32 1
  %24 = load %struct.op** %op_sibling85, align 8, !tbaa !17
  %cmp86 = icmp eq %struct.op* %10, %24
  br i1 %cmp86, label %if.then88, label %if.end93

if.then88:                                        ; preds = %land.lhs.true84
  %and91 = and i8 %12, -9
  store i8 %and91, i8* %op_private54, align 1, !tbaa !11
  br label %if.end93

if.end93:                                         ; preds = %land.lhs.true53, %land.lhs.true71, %land.lhs.true68, %land.lhs.true65, %land.lhs.true63, %if.then88, %land.lhs.true84, %land.lhs.true79, %land.lhs.true75, %if.end47
  %call94 = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  br label %return

return:                                           ; preds = %if.end43, %if.end93
  %retval.0 = phi %struct.op* [ %call94, %if.end93 ], [ %o, %if.end43 ]
  ret %struct.op* %retval.0
}

declare %struct.sv** @Perl_hv_fetch(%struct.hv*, i8*, i64, i64) #2

declare i32 @mode_from_discipline(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_repeat(%struct.op* %o) #0 {
entry:
  %0 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %1 = load %struct.op** %0, align 8, !tbaa !43
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %2, 8
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %3 = load i8* %op_private, align 1, !tbaa !11
  %or = or i8 %3, 64
  store i8 %or, i8* %op_private, align 1, !tbaa !11
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @force_list to i32 (%struct.op*, ...)*)(%struct.op* %1) #4
  %conv4 = sext i32 %call to i64
  %4 = inttoptr i64 %conv4 to %struct.op*
  store %struct.op* %4, %struct.op** %0, align 8, !tbaa !43
  br label %if.end

if.else:                                          ; preds = %entry
  %call6 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret %struct.op* %o
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_require(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end33, label %if.then

if.then:                                          ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !15
  %3 = getelementptr inbounds %struct.op* %2, i64 0, i32 4
  %4 = load i16* %3, align 2, !tbaa !71
  %cmp = icmp eq i16 %4, 5
  br i1 %cmp, label %land.lhs.true, label %if.end33

land.lhs.true:                                    ; preds = %if.then
  %5 = getelementptr inbounds %struct.op* %2, i64 0, i32 7
  %6 = load i8* %5, align 1, !tbaa !33
  %and4 = and i8 %6, 64
  %tobool5 = icmp eq i8 %and4, 0
  br i1 %tobool5, label %if.end33, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %op_sv = getelementptr inbounds %struct.op* %2, i64 1
  %7 = bitcast %struct.op* %op_sv to %struct.sv**
  %8 = load %struct.sv** %7, align 8, !tbaa !18
  %sv_any = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %9 to i8**
  %10 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %for.cond.outer

for.cond.outer:                                   ; preds = %if.then15, %if.then6
  %.ph = phi %struct.sv* [ %8, %if.then6 ], [ %13, %if.then15 ]
  %s.0.ph = phi i8* [ %10, %if.then6 ], [ %arrayidx, %if.then15 ]
  br label %for.cond

for.cond:                                         ; preds = %land.lhs.true11, %for.cond.for.inc_crit_edge, %for.cond.outer
  %s.0 = phi i8* [ %s.0.ph, %for.cond.outer ], [ %incdec.ptr.pre, %for.cond.for.inc_crit_edge ], [ %arrayidx, %land.lhs.true11 ]
  %11 = load i8* %s.0, align 1, !tbaa !5
  switch i8 %11, label %for.cond.for.inc_crit_edge [
    i8 0, label %for.end
    i8 58, label %land.lhs.true11
  ]

for.cond.for.inc_crit_edge:                       ; preds = %for.cond
  %incdec.ptr.pre = getelementptr inbounds i8* %s.0, i64 1
  br label %for.cond

land.lhs.true11:                                  ; preds = %for.cond
  %arrayidx = getelementptr inbounds i8* %s.0, i64 1
  %12 = load i8* %arrayidx, align 1, !tbaa !5
  %cmp13 = icmp eq i8 %12, 58
  br i1 %cmp13, label %if.then15, label %for.cond

if.then15:                                        ; preds = %land.lhs.true11
  store i8 47, i8* %s.0, align 1, !tbaa !5
  %add.ptr16 = getelementptr inbounds i8* %s.0, i64 2
  %call = tail call i64 @strlen(i8* %add.ptr16) #4
  %add = add i64 %call, 1
  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %arrayidx, i8* %add.ptr16, i64 %add, i32 1, i1 false)
  %13 = load %struct.sv** %7, align 8, !tbaa !18
  %sv_any19 = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %14 = load i8** %sv_any19, align 8, !tbaa !36
  %xpv_cur = getelementptr inbounds i8* %14, i64 8
  %15 = bitcast i8* %xpv_cur to i64*
  %16 = load i64* %15, align 8, !tbaa !37
  %dec = add i64 %16, -1
  store i64 %dec, i64* %15, align 8, !tbaa !37
  br label %for.cond.outer

for.end:                                          ; preds = %for.cond
  %sv_flags = getelementptr inbounds %struct.sv* %.ph, i64 0, i32 2
  %17 = load i64* %sv_flags, align 8, !tbaa !34
  %and21 = and i64 %17, 8388608
  %tobool22 = icmp eq i64 %and21, 0
  br i1 %tobool22, label %if.else, label %if.then23

if.then23:                                        ; preds = %for.end
  %and26 = and i64 %17, -8388609
  store i64 %and26, i64* %sv_flags, align 8, !tbaa !34
  tail call void @Perl_sv_catpvn_flags(%struct.sv* %.ph, i8* getelementptr inbounds ([4 x i8]* @.str119, i64 0, i64 0), i64 3, i64 2) #4
  %18 = load %struct.sv** %7, align 8, !tbaa !18
  %sv_flags29 = getelementptr inbounds %struct.sv* %18, i64 0, i32 2
  %19 = load i64* %sv_flags29, align 8, !tbaa !34
  %or = or i64 %19, 8388608
  store i64 %or, i64* %sv_flags29, align 8, !tbaa !34
  br label %if.end33

if.else:                                          ; preds = %for.end
  tail call void @Perl_sv_catpvn_flags(%struct.sv* %.ph, i8* getelementptr inbounds ([4 x i8]* @.str119, i64 0, i64 0), i64 3, i64 2) #4
  br label %if.end33

if.end33:                                         ; preds = %land.lhs.true, %entry, %if.then, %if.else, %if.then23
  %call34 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([8 x i8]* @.str120, i64 0, i64 0), i64 0, i64 12) #4
  %tobool35 = icmp eq %struct.gv* %call34, null
  br i1 %tobool35, label %if.then47, label %land.lhs.true36

land.lhs.true36:                                  ; preds = %if.end33
  %sv_any37 = getelementptr inbounds %struct.gv* %call34, i64 0, i32 0
  %20 = load %struct.xpvgv** %sv_any37, align 8, !tbaa !60
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %20, i64 0, i32 7
  %21 = load %struct.gp** %xgv_gp, align 8, !tbaa !62
  %gp_cvgen = getelementptr inbounds %struct.gp* %21, i64 0, i32 8
  %22 = load i64* %gp_cvgen, align 8, !tbaa !137
  %tobool38 = icmp eq i64 %22, 0
  br i1 %tobool38, label %cond.false, label %if.then47

cond.false:                                       ; preds = %land.lhs.true36
  %gp_cv = getelementptr inbounds %struct.gp* %21, i64 0, i32 7
  %23 = load %struct.cv** %gp_cv, align 8, !tbaa !64
  %tobool41 = icmp eq %struct.cv* %23, null
  br i1 %tobool41, label %if.then47, label %land.lhs.true42

land.lhs.true42:                                  ; preds = %cond.false
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %20, i64 0, i32 11
  %24 = load i8* %xgv_flags, align 1, !tbaa !141
  %tobool46 = icmp slt i8 %24, 0
  br i1 %tobool46, label %if.end49, label %if.then47

if.then47:                                        ; preds = %cond.false, %land.lhs.true36, %if.end33, %land.lhs.true42
  %call48 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([22 x i8]* @.str121, i64 0, i64 0), i64 0, i64 12) #4
  br label %if.end49

if.end49:                                         ; preds = %if.then47, %land.lhs.true42
  %gv.0 = phi %struct.gv* [ %call48, %if.then47 ], [ %call34, %land.lhs.true42 ]
  %tobool50 = icmp eq %struct.gv* %gv.0, null
  br i1 %tobool50, label %if.end79, label %land.lhs.true51

land.lhs.true51:                                  ; preds = %if.end49
  %sv_any52 = getelementptr inbounds %struct.gv* %gv.0, i64 0, i32 0
  %25 = load %struct.xpvgv** %sv_any52, align 8, !tbaa !60
  %xgv_gp53 = getelementptr inbounds %struct.xpvgv* %25, i64 0, i32 7
  %26 = load %struct.gp** %xgv_gp53, align 8, !tbaa !62
  %gp_cvgen54 = getelementptr inbounds %struct.gp* %26, i64 0, i32 8
  %27 = load i64* %gp_cvgen54, align 8, !tbaa !137
  %tobool55 = icmp eq i64 %27, 0
  br i1 %tobool55, label %cond.false57, label %if.end79

cond.false57:                                     ; preds = %land.lhs.true51
  %gp_cv60 = getelementptr inbounds %struct.gp* %26, i64 0, i32 7
  %28 = load %struct.cv** %gp_cv60, align 8, !tbaa !64
  %tobool61 = icmp eq %struct.cv* %28, null
  br i1 %tobool61, label %if.end79, label %land.lhs.true62

land.lhs.true62:                                  ; preds = %cond.false57
  %xgv_flags64 = getelementptr inbounds %struct.xpvgv* %25, i64 0, i32 11
  %29 = load i8* %xgv_flags64, align 1, !tbaa !141
  %tobool67 = icmp slt i8 %29, 0
  br i1 %tobool67, label %Perl_newGVOP.exit, label %if.end79

Perl_newGVOP.exit:                                ; preds = %land.lhs.true62
  %30 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %31 = load %struct.op** %30, align 8, !tbaa !15
  store %struct.op* null, %struct.op** %30, align 8, !tbaa !15
  tail call void @Perl_op_free(%struct.op* %o)
  %32 = bitcast %struct.gv* %gv.0 to %struct.sv*
  store %struct.sv* %32, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %33 = getelementptr inbounds %struct.gv* %gv.0, i64 0, i32 1
  %34 = load i64* %33, align 8, !tbaa !40
  %inc.i = add i64 %34, 1
  store i64 %inc.i, i64* %33, align 8, !tbaa !40
  %call.i108 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i108, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i108, i64 32
  %35 = bitcast i8* %op_type.i to i16*
  store i16 7, i16* %35, align 2, !tbaa !71
  %36 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 7), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i108, i64 16
  %37 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %36, %struct.op* ()** %37, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i108, i64 40
  %38 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %32, %struct.sv** %38, align 8, !tbaa !18
  %39 = bitcast i8* %call.i108 to %struct.op*
  %op_next.i = bitcast i8* %call.i108 to %struct.op**
  store %struct.op* %39, %struct.op** %op_next.i, align 8, !tbaa !73
  %40 = getelementptr inbounds i8* %call.i108, i64 36
  store i8 0, i8* %40, align 1, !tbaa !74
  %41 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  %and.i = and i64 %41, 4
  %tobool.i109 = icmp eq i64 %and.i, 0
  br i1 %tobool.i109, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %Perl_newGVOP.exit
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %39) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %Perl_newGVOP.exit
  %42 = phi i64 [ %41, %Perl_newGVOP.exit ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %42, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 7, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i108, i64 24
  %43 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %43, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %44 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %44, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %44, i64 7
  %45 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %45, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %39) #4
  %46 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 7), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %46) #4
  br label %Perl_newSVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %47 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 7), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %47(%struct.op* %39) #4
  br label %Perl_newSVOP.exit

Perl_newSVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  %call73 = tail call %struct.op* @Perl_newUNOP(i64 17, i64 0, %struct.op* %cond.i)
  %call74 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %call73) #4
  %call75 = tail call i32 (i32, %struct.op*, i32, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, i32, ...)*)(i32 141, %struct.op* %31, i32 %call74) #4
  %conv76 = sext i32 %call75 to i64
  %48 = inttoptr i64 %conv76 to %struct.op*
  %call77 = tail call %struct.op* @Perl_newUNOP(i64 166, i64 64, %struct.op* %48)
  %call78 = tail call %struct.op* @Perl_ck_subr(%struct.op* %call77)
  br label %return

if.end79:                                         ; preds = %cond.false57, %land.lhs.true51, %if.end49, %land.lhs.true62
  %call80 = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  br label %return

return:                                           ; preds = %if.end79, %Perl_newSVOP.exit
  %retval.0 = phi %struct.op* [ %call80, %if.end79 ], [ %call78, %Perl_newSVOP.exit ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #4

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_return(%struct.op* readonly %o) #0 {
entry:
  %0 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %sv_any = getelementptr inbounds %struct.cv* %0, i64 0, i32 0
  %1 = load %struct.xpvcv** %sv_any, align 8, !tbaa !66
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %1, i64 0, i32 17
  %2 = load i16* %xcv_flags, align 2, !tbaa !68
  %and = and i16 %2, 256
  %tobool = icmp eq i16 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %4 = load %struct.op** %3, align 8, !tbaa !45
  %kid.0.in6 = getelementptr inbounds %struct.op* %4, i64 0, i32 1
  %kid.07 = load %struct.op** %kid.0.in6, align 8
  %tobool18 = icmp eq %struct.op* %kid.07, null
  br i1 %tobool18, label %if.end, label %for.body

for.body:                                         ; preds = %if.then, %for.body
  %kid.09 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.07, %if.then ]
  %call = tail call i32 (%struct.op*, i32, ...)* bitcast (i32 (...)* @mod to i32 (%struct.op*, i32, ...)*)(%struct.op* %kid.09, i32 168) #4
  %kid.0.in = getelementptr inbounds %struct.op* %kid.09, i64 0, i32 1
  %kid.0 = load %struct.op** %kid.0.in, align 8
  %tobool1 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool1, label %if.end, label %for.body

if.end:                                           ; preds = %for.body, %if.then, %entry
  ret %struct.op* %o
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_select(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end7, label %if.then

if.then:                                          ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !45
  %op_sibling = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %3 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %tobool1 = icmp eq %struct.op* %3, null
  br i1 %tobool1, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %op_sibling2 = getelementptr inbounds %struct.op* %3, i64 0, i32 1
  %4 = load %struct.op** %op_sibling2, align 8, !tbaa !17
  %tobool3 = icmp eq %struct.op* %4, null
  br i1 %tobool3, label %if.end7, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  store i16 202, i16* %op_type, align 2, !tbaa !12
  %5 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 202), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %5, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  %call5 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @fold_constants to i32 (%struct.op*, ...)*)(%struct.op* %call) #4
  %conv6 = sext i32 %call5 to i64
  %6 = inttoptr i64 %conv6 to %struct.op*
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %if.then, %entry
  %call8 = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  %7 = getelementptr inbounds %struct.op* %call8, i64 1, i32 0
  %8 = load %struct.op** %7, align 8, !tbaa !45
  %op_sibling10 = getelementptr inbounds %struct.op* %8, i64 0, i32 1
  %9 = load %struct.op** %op_sibling10, align 8, !tbaa !17
  %tobool11 = icmp eq %struct.op* %9, null
  br i1 %tobool11, label %return, label %land.lhs.true12

land.lhs.true12:                                  ; preds = %if.end7
  %op_type13 = getelementptr inbounds %struct.op* %9, i64 0, i32 4
  %10 = load i16* %op_type13, align 2, !tbaa !12
  %cmp = icmp eq i16 %10, 14
  br i1 %cmp, label %if.then16, label %return

if.then16:                                        ; preds = %land.lhs.true12
  %op_private = getelementptr inbounds %struct.op* %9, i64 0, i32 7
  %11 = load i8* %op_private, align 1, !tbaa !11
  %and18 = and i8 %11, -3
  store i8 %and18, i8* %op_private, align 1, !tbaa !11
  br label %return

return:                                           ; preds = %land.lhs.true12, %if.then16, %if.end7, %if.then4
  %retval.0 = phi %struct.op* [ %6, %if.then4 ], [ %call8, %if.end7 ], [ %call8, %if.then16 ], [ %call8, %land.lhs.true12 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_shift(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !12
  %conv = zext i16 %0 to i64
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %1, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @Perl_op_free(%struct.op* %o)
  %2 = load %struct.cv** @PL_compcv, align 8, !tbaa !6
  %sv_any = getelementptr inbounds %struct.cv* %2, i64 0, i32 0
  %3 = load %struct.xpvcv** %sv_any, align 8, !tbaa !66
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %3, i64 0, i32 17
  %4 = load i16* %xcv_flags, align 2, !tbaa !68
  %and3 = and i16 %4, 16
  %tobool4 = icmp ne i16 %and3, 0
  %5 = load %struct.gv** @PL_argvgv, align 8, !tbaa !6
  %6 = load %struct.gv** @PL_defgv, align 8, !tbaa !6
  %cond = select i1 %tobool4, %struct.gv* %5, %struct.gv* %6
  %7 = bitcast %struct.gv* %cond to %struct.sv*
  store %struct.sv* %7, %struct.sv** @PL_Sv, align 8, !tbaa !6
  %tobool.i = icmp eq %struct.gv* %cond, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then
  %8 = getelementptr inbounds %struct.gv* %cond, i64 0, i32 1
  %9 = load i64* %8, align 8, !tbaa !40
  %inc.i = add i64 %9, 1
  store i64 %inc.i, i64* %8, align 8, !tbaa !40
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.then, %land.rhs.i
  %call.i18 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i18, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i18, i64 32
  %10 = bitcast i8* %op_type.i to i16*
  store i16 7, i16* %10, align 2, !tbaa !71
  %11 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 7), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i18, i64 16
  %12 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %11, %struct.op* ()** %12, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i18, i64 40
  %13 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %7, %struct.sv** %13, align 8, !tbaa !18
  %14 = bitcast i8* %call.i18 to %struct.op*
  %op_next.i = bitcast i8* %call.i18 to %struct.op**
  store %struct.op* %14, %struct.op** %op_next.i, align 8, !tbaa !73
  %15 = getelementptr inbounds i8* %call.i18, i64 36
  store i8 0, i8* %15, align 1, !tbaa !74
  %16 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  %and.i = and i64 %16, 4
  %tobool.i19 = icmp eq i64 %and.i, 0
  br i1 %tobool.i19, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %Perl_newGVOP.exit
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %14) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 7), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %Perl_newGVOP.exit
  %17 = phi i64 [ %16, %Perl_newGVOP.exit ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %17, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 7, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i18, i64 24
  %18 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %18, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %19 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %19, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %19, i64 7
  %20 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %20, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %14) #4
  %21 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 7), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %21) #4
  br label %Perl_newSVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %22 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 7), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %22(%struct.op* %14) #4
  br label %Perl_newSVOP.exit

Perl_newSVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  %call5 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %cond.i) #4
  %conv6 = sext i32 %call5 to i64
  %23 = inttoptr i64 %conv6 to %struct.op*
  %call7 = tail call %struct.op* @Perl_newUNOP(i64 125, i64 0, %struct.op* %23)
  %call8 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %call7) #4
  %conv9 = sext i32 %call8 to i64
  %24 = inttoptr i64 %conv9 to %struct.op*
  %call10 = tail call %struct.op* @Perl_newUNOP(i64 %conv, i64 0, %struct.op* %24)
  br label %return

if.end:                                           ; preds = %entry
  %call11 = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  %call12 = tail call i32 (%struct.op*, i64, ...)* bitcast (i32 (...)* @modkids to i32 (%struct.op*, i64, ...)*)(%struct.op* %call11, i64 %conv) #4
  %call13 = tail call i32 (i32, ...)* bitcast (i32 (...)* @scalar to i32 (i32, ...)*)(i32 %call12) #4
  %conv14 = sext i32 %call13 to i64
  %25 = inttoptr i64 %conv14 to %struct.op*
  br label %return

return:                                           ; preds = %if.end, %Perl_newSVOP.exit
  %retval.0 = phi %struct.op* [ %25, %if.end ], [ %call10, %Perl_newSVOP.exit ]
  ret %struct.op* %retval.0
}

declare i32 @simplify_sort(...) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_split(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @no_fh_allowed to i32 (%struct.op*, ...)*)(%struct.op* %o) #4
  %conv1 = sext i32 %call to i64
  %1 = inttoptr i64 %conv1 to %struct.op*
  br label %return

if.end:                                           ; preds = %entry
  %2 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %3 = load %struct.op** %2, align 8, !tbaa !45
  %op_type = getelementptr inbounds %struct.op* %3, i64 0, i32 4
  %4 = load i16* %op_type, align 2, !tbaa !12
  %cmp = icmp eq i16 %4, 0
  br i1 %cmp, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([16 x i8]* @.str122, i64 0, i64 0)) #4
  %.pre = load %struct.op** %2, align 8, !tbaa !45
  br label %if.end5

if.end5:                                          ; preds = %if.end, %if.then4
  %5 = phi %struct.op* [ %3, %if.end ], [ %.pre, %if.then4 ]
  %op_sibling = getelementptr inbounds %struct.op* %3, i64 0, i32 1
  %6 = load %struct.op** %op_sibling, align 8, !tbaa !17
  tail call void @Perl_op_free(%struct.op* %5)
  store %struct.op* %6, %struct.op** %2, align 8, !tbaa !45
  %tobool8 = icmp eq %struct.op* %6, null
  br i1 %tobool8, label %if.then9, label %if.end13

if.then9:                                         ; preds = %if.end5
  %call10 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([2 x i8]* @.str123, i64 0, i64 0), i64 1) #4
  %call.i = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i = getelementptr inbounds i8* %call.i, i64 32
  %7 = bitcast i8* %op_type.i to i16*
  store i16 5, i16* %7, align 2, !tbaa !71
  %8 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds i8* %call.i, i64 16
  %9 = bitcast i8* %op_ppaddr.i to %struct.op* ()**
  store %struct.op* ()* %8, %struct.op* ()** %9, align 8, !tbaa !72
  %op_sv.i = getelementptr inbounds i8* %call.i, i64 40
  %10 = bitcast i8* %op_sv.i to %struct.sv**
  store %struct.sv* %call10, %struct.sv** %10, align 8, !tbaa !18
  %11 = bitcast i8* %call.i to %struct.op*
  %op_next.i = bitcast i8* %call.i to %struct.op**
  store %struct.op* %11, %struct.op** %op_next.i, align 8, !tbaa !73
  %12 = getelementptr inbounds i8* %call.i, i64 36
  store i8 0, i8* %12, align 1, !tbaa !74
  %13 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i = and i64 %13, 4
  %tobool.i = icmp eq i64 %and.i, 0
  br i1 %tobool.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %if.then9
  %call3.i = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %11) #4
  %.pre.i = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then9
  %14 = phi i64 [ %13, %if.then9 ], [ %.pre.i, %if.then.i ]
  %and5.i = and i64 %14, 8
  %tobool6.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.i, label %if.end10.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.end.i
  %call8.i = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i = sext i32 %call8.i to i64
  %op_targ.i = getelementptr inbounds i8* %call.i, i64 24
  %15 = bitcast i8* %op_targ.i to i64*
  store i64 %conv9.i, i64* %15, align 8, !tbaa !75
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %if.end.i
  %16 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i = icmp eq i8* %16, null
  br i1 %tobool11.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end10.i
  %arrayidx12.i = getelementptr inbounds i8* %16, i64 5
  %17 = load i8* %arrayidx12.i, align 1, !tbaa !5
  %tobool14.i = icmp eq i8 %17, 0
  br i1 %tobool14.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.lhs.true.i
  tail call void @Perl_op_free(%struct.op* %11) #4
  %18 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %18) #4
  br label %Perl_newSVOP.exit

cond.false.i:                                     ; preds = %land.lhs.true.i, %if.end10.i
  %19 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i = tail call %struct.op* %19(%struct.op* %11) #4
  br label %Perl_newSVOP.exit

Perl_newSVOP.exit:                                ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi %struct.op* [ null, %cond.true.i ], [ %call17.i, %cond.false.i ]
  store %struct.op* %cond.i, %struct.op** %2, align 8, !tbaa !45
  %20 = getelementptr inbounds %struct.op* %o, i64 1, i32 1
  store %struct.op* %cond.i, %struct.op** %20, align 8, !tbaa !70
  br label %if.end13

if.end13:                                         ; preds = %if.end5, %Perl_newSVOP.exit
  %kid.0 = phi %struct.op* [ %6, %if.end5 ], [ %cond.i, %Perl_newSVOP.exit ]
  %op_type14 = getelementptr inbounds %struct.op* %kid.0, i64 0, i32 4
  %21 = load i16* %op_type14, align 2, !tbaa !12
  %cmp16 = icmp eq i16 %21, 31
  br i1 %cmp16, label %lor.lhs.false, label %if.then22

lor.lhs.false:                                    ; preds = %if.end13
  %op_flags18 = getelementptr inbounds %struct.op* %kid.0, i64 0, i32 6
  %22 = load i8* %op_flags18, align 1, !tbaa !14
  %and20 = and i8 %22, 64
  %tobool21 = icmp eq i8 %and20, 0
  br i1 %tobool21, label %if.end37, label %if.then22

if.then22:                                        ; preds = %lor.lhs.false, %if.end13
  %op_sibling23 = getelementptr inbounds %struct.op* %kid.0, i64 0, i32 1
  %23 = load %struct.op** %op_sibling23, align 8, !tbaa !17
  store %struct.op* null, %struct.op** %op_sibling23, align 8, !tbaa !17
  %call25 = tail call %struct.op* @Perl_newPMOP(i64 31, i64 128)
  %call26 = tail call i32 (%struct.op*, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @pmruntime to i32 (%struct.op*, %struct.op*, %struct.op*, ...)*)(%struct.op* %call25, %struct.op* %kid.0, %struct.op* null) #4
  %conv27 = sext i32 %call26 to i64
  %24 = inttoptr i64 %conv27 to %struct.op*
  %25 = load %struct.op** %2, align 8, !tbaa !45
  %26 = getelementptr inbounds %struct.op* %o, i64 1, i32 1
  %27 = load %struct.op** %26, align 8, !tbaa !70
  %cmp30 = icmp eq %struct.op* %25, %27
  br i1 %cmp30, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.then22
  store %struct.op* %24, %struct.op** %26, align 8, !tbaa !70
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.then22
  store %struct.op* %24, %struct.op** %2, align 8, !tbaa !45
  %op_sibling36 = getelementptr inbounds %struct.op* %24, i64 0, i32 1
  store %struct.op* %23, %struct.op** %op_sibling36, align 8, !tbaa !17
  br label %if.end37

if.end37:                                         ; preds = %lor.lhs.false, %if.end34
  %kid.1 = phi %struct.op* [ %24, %if.end34 ], [ %kid.0, %lor.lhs.false ]
  %op_type38 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 4
  store i16 13, i16* %op_type38, align 2, !tbaa !12
  %28 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 13), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 2
  store %struct.op* ()* %28, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %call39 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %kid.1) #4
  %29 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %29, i64 0, i32 14
  %30 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp40 = icmp eq %struct.sv* %30, null
  br i1 %cmp40, label %lor.lhs.false54, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end37
  %31 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings42 = getelementptr inbounds %struct.cop* %31, i64 0, i32 14
  %32 = load %struct.sv** %cop_warnings42, align 8, !tbaa !47
  %cmp43 = icmp eq %struct.sv* %32, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp43, label %lor.lhs.false54, label %land.lhs.true45

land.lhs.true45:                                  ; preds = %land.lhs.true
  %33 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings46 = getelementptr inbounds %struct.cop* %33, i64 0, i32 14
  %34 = load %struct.sv** %cop_warnings46, align 8, !tbaa !47
  %cmp47 = icmp eq %struct.sv* %34, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp47, label %land.lhs.true62, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %land.lhs.true45
  %35 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings50 = getelementptr inbounds %struct.cop* %35, i64 0, i32 14
  %36 = load %struct.sv** %cop_warnings50, align 8, !tbaa !47
  %sv_any = getelementptr inbounds %struct.sv* %36, i64 0, i32 0
  %37 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %37 to i8**
  %38 = load i8** %xpv_pv, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8* %38, i64 5
  %39 = load i8* %arrayidx, align 1, !tbaa !5
  %and52 = and i8 %39, 1
  %tobool53 = icmp eq i8 %and52, 0
  br i1 %tobool53, label %lor.lhs.false54, label %land.lhs.true62

lor.lhs.false54:                                  ; preds = %lor.lhs.false49, %land.lhs.true, %if.end37
  %40 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings55 = getelementptr inbounds %struct.cop* %40, i64 0, i32 14
  %41 = load %struct.sv** %cop_warnings55, align 8, !tbaa !47
  %cmp56 = icmp eq %struct.sv* %41, null
  br i1 %cmp56, label %land.lhs.true58, label %if.end66

land.lhs.true58:                                  ; preds = %lor.lhs.false54
  %42 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and60 = and i8 %42, 1
  %tobool61 = icmp eq i8 %and60, 0
  br i1 %tobool61, label %if.end66, label %land.lhs.true62

land.lhs.true62:                                  ; preds = %lor.lhs.false49, %land.lhs.true58, %land.lhs.true45
  %op_pmflags = getelementptr inbounds %struct.op* %kid.1, i64 2, i32 1
  %43 = bitcast %struct.op** %op_pmflags to i64*
  %44 = load i64* %43, align 8, !tbaa !88
  %and63 = and i64 %44, 256
  %tobool64 = icmp eq i64 %and63, 0
  br i1 %tobool64, label %if.end66, label %if.then65

if.then65:                                        ; preds = %land.lhs.true62
  tail call void (i64, i8*, ...)* @Perl_warner(i64 20, i8* getelementptr inbounds ([43 x i8]* @.str124, i64 0, i64 0)) #4
  br label %if.end66

if.end66:                                         ; preds = %land.lhs.true62, %land.lhs.true58, %if.then65, %lor.lhs.false54
  %op_sibling67 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 1
  %45 = load %struct.op** %op_sibling67, align 8, !tbaa !17
  %tobool68 = icmp eq %struct.op* %45, null
  br i1 %tobool68, label %if.then69, label %if.end72

if.then69:                                        ; preds = %if.end66
  %call70 = tail call i32 (...)* @newDEFSVOP() #4
  %call71 = tail call i32 (i32, %struct.op*, i32, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, i32, ...)*)(i32 139, %struct.op* %o, i32 %call70) #4
  %.pre171 = load %struct.op** %op_sibling67, align 8, !tbaa !17
  br label %if.end72

if.end72:                                         ; preds = %if.end66, %if.then69
  %46 = phi %struct.op* [ %45, %if.end66 ], [ %.pre171, %if.then69 ]
  %call74 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %46) #4
  %op_sibling75 = getelementptr inbounds %struct.op* %46, i64 0, i32 1
  %47 = load %struct.op** %op_sibling75, align 8, !tbaa !17
  %tobool76 = icmp eq %struct.op* %47, null
  br i1 %tobool76, label %if.then77, label %if.end81

if.then77:                                        ; preds = %if.end72
  %call78 = tail call %struct.sv* @Perl_newSViv(i64 0) #4
  %call.i135 = tail call i8* @Perl_safesysmalloc(i64 48) #4
  tail call void @llvm.memset.p0i8.i64(i8* %call.i135, i8 0, i64 48, i32 1, i1 false) #4
  %op_type.i136 = getelementptr inbounds i8* %call.i135, i64 32
  %48 = bitcast i8* %op_type.i136 to i16*
  store i16 5, i16* %48, align 2, !tbaa !71
  %49 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 5), align 8, !tbaa !6
  %op_ppaddr.i137 = getelementptr inbounds i8* %call.i135, i64 16
  %50 = bitcast i8* %op_ppaddr.i137 to %struct.op* ()**
  store %struct.op* ()* %49, %struct.op* ()** %50, align 8, !tbaa !72
  %op_sv.i138 = getelementptr inbounds i8* %call.i135, i64 40
  %51 = bitcast i8* %op_sv.i138 to %struct.sv**
  store %struct.sv* %call78, %struct.sv** %51, align 8, !tbaa !18
  %52 = bitcast i8* %call.i135 to %struct.op*
  %op_next.i139 = bitcast i8* %call.i135 to %struct.op**
  store %struct.op* %52, %struct.op** %op_next.i139, align 8, !tbaa !73
  %53 = getelementptr inbounds i8* %call.i135, i64 36
  store i8 0, i8* %53, align 1, !tbaa !74
  %54 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  %and.i140 = and i64 %54, 4
  %tobool.i141 = icmp eq i64 %and.i140, 0
  br i1 %tobool.i141, label %if.end.i147, label %if.then.i144

if.then.i144:                                     ; preds = %if.then77
  %call3.i142 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %52) #4
  %.pre.i143 = load i64* getelementptr inbounds ([0 x i64]* @PL_opargs, i64 0, i64 5), align 8, !tbaa !1
  br label %if.end.i147

if.end.i147:                                      ; preds = %if.then.i144, %if.then77
  %55 = phi i64 [ %54, %if.then77 ], [ %.pre.i143, %if.then.i144 ]
  %and5.i145 = and i64 %55, 8
  %tobool6.i146 = icmp eq i64 %and5.i145, 0
  br i1 %tobool6.i146, label %if.end10.i153, label %if.then7.i151

if.then7.i151:                                    ; preds = %if.end.i147
  %call8.i148 = tail call i32 (i64, i32, ...)* bitcast (i32 (...)* @pad_alloc to i32 (i64, i32, ...)*)(i64 5, i32 512) #4
  %conv9.i149 = sext i32 %call8.i148 to i64
  %op_targ.i150 = getelementptr inbounds i8* %call.i135, i64 24
  %56 = bitcast i8* %op_targ.i150 to i64*
  store i64 %conv9.i149, i64* %56, align 8, !tbaa !75
  br label %if.end10.i153

if.end10.i153:                                    ; preds = %if.then7.i151, %if.end.i147
  %57 = load i8** @PL_op_mask, align 8, !tbaa !6
  %tobool11.i152 = icmp eq i8* %57, null
  br i1 %tobool11.i152, label %cond.false.i159, label %land.lhs.true.i156

land.lhs.true.i156:                               ; preds = %if.end10.i153
  %arrayidx12.i154 = getelementptr inbounds i8* %57, i64 5
  %58 = load i8* %arrayidx12.i154, align 1, !tbaa !5
  %tobool14.i155 = icmp eq i8 %58, 0
  br i1 %tobool14.i155, label %cond.false.i159, label %cond.true.i157

cond.true.i157:                                   ; preds = %land.lhs.true.i156
  tail call void @Perl_op_free(%struct.op* %52) #4
  %59 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 5), align 8, !tbaa !6
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %59) #4
  br label %Perl_newSVOP.exit161

cond.false.i159:                                  ; preds = %land.lhs.true.i156, %if.end10.i153
  %60 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 5), align 8, !tbaa !6
  %call17.i158 = tail call %struct.op* %60(%struct.op* %52) #4
  br label %Perl_newSVOP.exit161

Perl_newSVOP.exit161:                             ; preds = %cond.true.i157, %cond.false.i159
  %cond.i160 = phi %struct.op* [ null, %cond.true.i157 ], [ %call17.i158, %cond.false.i159 ]
  %call80 = tail call i32 (i32, %struct.op*, %struct.op*, ...)* bitcast (i32 (...)* @append_elem to i32 (i32, %struct.op*, %struct.op*, ...)*)(i32 139, %struct.op* %o, %struct.op* %cond.i160) #4
  %.pre172 = load %struct.op** %op_sibling75, align 8, !tbaa !17
  br label %if.end81

if.end81:                                         ; preds = %if.end72, %Perl_newSVOP.exit161
  %61 = phi %struct.op* [ %47, %if.end72 ], [ %.pre172, %Perl_newSVOP.exit161 ]
  %call83 = tail call i32 (%struct.op*, ...)* bitcast (i32 (...)* @scalar to i32 (%struct.op*, ...)*)(%struct.op* %61) #4
  %op_sibling84 = getelementptr inbounds %struct.op* %61, i64 0, i32 1
  %62 = load %struct.op** %op_sibling84, align 8, !tbaa !17
  %tobool85 = icmp eq %struct.op* %62, null
  br i1 %tobool85, label %return, label %if.then86

if.then86:                                        ; preds = %if.end81
  %op_type87 = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %63 = load i16* %op_type87, align 2, !tbaa !12
  %cmp89 = icmp eq i16 %63, 351
  br i1 %cmp89, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then86
  %64 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %tobool.i162 = icmp eq %struct.hv* %64, null
  br i1 %tobool.i162, label %if.then.i163, label %if.end.i166

if.then.i163:                                     ; preds = %cond.true
  %65 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end

if.end.i166:                                      ; preds = %cond.true
  %op_ppaddr.i164 = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  %66 = load %struct.op* ()** %op_ppaddr.i164, align 8, !tbaa !41
  %67 = ptrtoint %struct.op* ()* %66 to i64
  %call.i165 = tail call %struct.sv* @Perl_newSViv(i64 %67) #4
  %call1.i = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call.i165) #4
  %68 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !6
  %call2.i = tail call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %68, %struct.sv* %call1.i, i64 0, i64 0) #4
  %tobool3.i = icmp eq %struct.he* %call2.i, null
  br i1 %tobool3.i, label %if.then4.i, label %if.end5.i

if.then4.i:                                       ; preds = %if.end.i166
  %69 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !6
  br label %cond.end

if.end5.i:                                        ; preds = %if.end.i166
  %hent_val.i = getelementptr inbounds %struct.he* %call2.i, i64 0, i32 2
  %70 = load %struct.sv** %hent_val.i, align 8, !tbaa !49
  %sv_flags.i = getelementptr inbounds %struct.sv* %70, i64 0, i32 2
  %71 = load i64* %sv_flags.i, align 8, !tbaa !34
  %and.i167 = and i64 %71, 262144
  %cmp.i = icmp eq i64 %and.i167, 0
  br i1 %cmp.i, label %cond.false.i170, label %cond.true.i168

cond.true.i168:                                   ; preds = %if.end5.i
  %sv_any.i = getelementptr inbounds %struct.sv* %70, i64 0, i32 0
  %72 = load i8** %sv_any.i, align 8, !tbaa !36
  %xpv_pv.i = bitcast i8* %72 to i8**
  %73 = load i8** %xpv_pv.i, align 8, !tbaa !39
  br label %cond.end

cond.false.i170:                                  ; preds = %if.end5.i
  %call8.i169 = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %70) #4
  br label %cond.end

cond.false:                                       ; preds = %if.then86
  %idxprom = zext i16 %63 to i64
  %arrayidx93 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %74 = load i8** %arrayidx93, align 8, !tbaa !6
  br label %cond.end

cond.end:                                         ; preds = %cond.false.i170, %cond.true.i168, %if.then4.i, %if.then.i163, %cond.false
  %cond = phi i8* [ %74, %cond.false ], [ %69, %if.then4.i ], [ %65, %if.then.i163 ], [ %73, %cond.true.i168 ], [ %call8.i169, %cond.false.i170 ]
  %call94 = tail call i32 (%struct.op*, i8*, ...)* bitcast (i32 (...)* @too_many_arguments to i32 (%struct.op*, i8*, ...)*)(%struct.op* %o, i8* %cond) #4
  %conv95 = sext i32 %call94 to i64
  %75 = inttoptr i64 %conv95 to %struct.op*
  br label %return

return:                                           ; preds = %if.end81, %cond.end, %if.then
  %retval.0 = phi %struct.op* [ %1, %if.then ], [ %75, %cond.end ], [ %o, %if.end81 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_join(%struct.op* %o) #0 {
entry:
  %0 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %0, i64 0, i32 14
  %1 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp = icmp eq %struct.sv* %1, null
  br i1 %cmp, label %lor.lhs.false7, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %2 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings1 = getelementptr inbounds %struct.cop* %2, i64 0, i32 14
  %3 = load %struct.sv** %cop_warnings1, align 8, !tbaa !47
  %cmp2 = icmp eq %struct.sv* %3, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp2, label %lor.lhs.false7, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings4 = getelementptr inbounds %struct.cop* %4, i64 0, i32 14
  %5 = load %struct.sv** %cop_warnings4, align 8, !tbaa !47
  %cmp5 = icmp eq %struct.sv* %5, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp5, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true3
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings6 = getelementptr inbounds %struct.cop* %6, i64 0, i32 14
  %7 = load %struct.sv** %cop_warnings6, align 8, !tbaa !47
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %8 to i8**
  %9 = load i8** %xpv_pv, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8* %9, i64 7
  %10 = load i8* %arrayidx, align 1, !tbaa !5
  %and = and i8 %10, 1
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false7, label %if.then

lor.lhs.false7:                                   ; preds = %lor.lhs.false, %land.lhs.true, %entry
  %11 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings8 = getelementptr inbounds %struct.cop* %11, i64 0, i32 14
  %12 = load %struct.sv** %cop_warnings8, align 8, !tbaa !47
  %cmp9 = icmp eq %struct.sv* %12, null
  br i1 %cmp9, label %land.lhs.true11, label %if.end25

land.lhs.true11:                                  ; preds = %lor.lhs.false7
  %13 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and13 = and i8 %13, 1
  %tobool14 = icmp eq i8 %and13, 0
  br i1 %tobool14, label %if.end25, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true11, %land.lhs.true3
  %14 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %15 = load %struct.op** %14, align 8, !tbaa !45
  %op_sibling = getelementptr inbounds %struct.op* %15, i64 0, i32 1
  %16 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %tobool15 = icmp eq %struct.op* %16, null
  br i1 %tobool15, label %if.end25, label %land.lhs.true16

land.lhs.true16:                                  ; preds = %if.then
  %op_type = getelementptr inbounds %struct.op* %16, i64 0, i32 4
  %17 = load i16* %op_type, align 2, !tbaa !12
  %cmp18 = icmp eq i16 %17, 31
  br i1 %cmp18, label %if.then20, label %if.end25

if.then20:                                        ; preds = %land.lhs.true16
  %op_pmregexp = getelementptr inbounds %struct.op* %16, i64 2
  %18 = bitcast %struct.op* %op_pmregexp to %struct.regexp**
  %19 = load %struct.regexp** %18, align 8, !tbaa !32
  %tobool21 = icmp eq %struct.regexp* %19, null
  br i1 %tobool21, label %if.end, label %if.then22

if.then22:                                        ; preds = %if.then20
  %precomp = getelementptr inbounds %struct.regexp* %19, i64 0, i32 4
  %20 = load i8** %precomp, align 8, !tbaa !106
  br label %if.end

if.end:                                           ; preds = %if.then20, %if.then22
  %pmstr.0 = phi i8* [ %20, %if.then22 ], [ getelementptr inbounds ([7 x i8]* @.str125, i64 0, i64 0), %if.then20 ]
  tail call void (i64, i8*, ...)* @Perl_warner(i64 28, i8* getelementptr inbounds ([40 x i8]* @.str126, i64 0, i64 0), i8* %pmstr.0, i8* %pmstr.0) #4
  br label %if.end25

if.end25:                                         ; preds = %if.then, %land.lhs.true11, %land.lhs.true16, %if.end, %lor.lhs.false7
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  ret %struct.op* %call
}

declare i32 @gv_ename(...) #2

declare void @Perl_gv_fullname4(%struct.sv*, %struct.gv*, i8*, i8 signext) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_svconst(%struct.op* readonly %o) #0 {
entry:
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %0 = bitcast %struct.op* %op_sv to %struct.sv**
  %1 = load %struct.sv** %0, align 8, !tbaa !18
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i64* %sv_flags, align 8, !tbaa !34
  %or = or i64 %2, 8388608
  store i64 %or, i64* %sv_flags, align 8, !tbaa !34
  ret %struct.op* %o
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_trunc(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end22, label %if.then

if.then:                                          ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !15
  %3 = getelementptr inbounds %struct.op* %2, i64 0, i32 4
  %4 = load i16* %3, align 2, !tbaa !71
  %cmp = icmp eq i16 %4, 0
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %5 = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %6 = load %struct.op** %5, align 8, !tbaa !181
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %kid.0.in = phi %struct.op* [ %6, %if.then3 ], [ %2, %if.then ]
  %tobool4 = icmp eq %struct.op* %kid.0.in, null
  br i1 %tobool4, label %if.end22, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %7 = getelementptr inbounds %struct.op* %kid.0.in, i64 0, i32 4
  %8 = load i16* %7, align 2, !tbaa !71
  %cmp7 = icmp eq i16 %8, 5
  br i1 %cmp7, label %land.lhs.true9, label %if.end22

land.lhs.true9:                                   ; preds = %land.lhs.true
  %9 = getelementptr inbounds %struct.op* %kid.0.in, i64 0, i32 7
  %10 = load i8* %9, align 1, !tbaa !33
  %and11 = and i8 %10, 64
  %tobool12 = icmp eq i8 %and11, 0
  br i1 %tobool12, label %if.end22, label %if.then13

if.then13:                                        ; preds = %land.lhs.true9
  %or = or i8 %0, -128
  store i8 %or, i8* %op_flags, align 1, !tbaa !14
  %and19 = and i8 %10, -9
  store i8 %and19, i8* %9, align 1, !tbaa !33
  br label %if.end22

if.end22:                                         ; preds = %land.lhs.true9, %if.end, %entry, %land.lhs.true, %if.then13
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_substr(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o)
  %op_flags = getelementptr inbounds %struct.op* %call, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !14
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_private = getelementptr inbounds %struct.op* %call, i64 0, i32 7
  %1 = load i8* %op_private, align 1, !tbaa !11
  %cmp = icmp eq i8 %1, 4
  br i1 %cmp, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true
  %2 = getelementptr inbounds %struct.op* %call, i64 1, i32 0
  %3 = load %struct.op** %2, align 8, !tbaa !45
  %op_type = getelementptr inbounds %struct.op* %3, i64 0, i32 4
  %4 = load i16* %op_type, align 2, !tbaa !12
  %cmp4 = icmp eq i16 %4, 0
  br i1 %cmp4, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %op_sibling = getelementptr inbounds %struct.op* %3, i64 0, i32 1
  %5 = load %struct.op** %op_sibling, align 8, !tbaa !17
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  %kid.0 = phi %struct.op* [ %5, %if.then6 ], [ %3, %if.then ]
  %tobool7 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool7, label %if.end13, label %if.then8

if.then8:                                         ; preds = %if.end
  %op_flags9 = getelementptr inbounds %struct.op* %kid.0, i64 0, i32 6
  %6 = load i8* %op_flags9, align 1, !tbaa !14
  %or = or i8 %6, 32
  store i8 %or, i8* %op_flags9, align 1, !tbaa !14
  br label %if.end13

if.end13:                                         ; preds = %if.end, %entry, %if.then8, %land.lhs.true
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define void @Perl_peep(%struct.op* %o) #0 {
entry:
  %n_a = alloca i64, align 8
  %keylen = alloca i64, align 8
  %keylen622 = alloca i64, align 8
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %op_seq = getelementptr inbounds %struct.op* %o, i64 0, i32 5
  %0 = load i16* %op_seq, align 2, !tbaa !8
  %tobool1 = icmp eq i16 %0, 0
  br i1 %tobool1, label %for.body.lr.ph, label %return

for.body.lr.ph:                                   ; preds = %lor.lhs.false
  call void @Perl_push_scope() #4
  %call = call i32 (...)* @save_op() #4
  call void @Perl_save_vptr(i8* bitcast (%struct.cop** @PL_curcop to i8*)) #4
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc1165
  %1 = phi %struct.op* [ %o, %for.body.lr.ph ], [ %457, %for.inc1165 ]
  %oldop.01622 = phi %struct.op* [ null, %for.body.lr.ph ], [ %oldop.1, %for.inc1165 ]
  %op_seq3 = getelementptr inbounds %struct.op* %1, i64 0, i32 5
  %2 = load i16* %op_seq3, align 2, !tbaa !8
  %tobool4 = icmp eq i16 %2, 0
  br i1 %tobool4, label %if.end6, label %for.end1167

if.end6:                                          ; preds = %for.body
  %3 = load i16* @PL_op_seqmax, align 2, !tbaa !100
  switch i16 %3, label %if.end12 [
    i16 0, label %if.then11
    i16 -1, label %if.then11
  ]

if.then11:                                        ; preds = %if.end6, %if.end6
  store i16 1, i16* @PL_op_seqmax, align 2, !tbaa !100
  br label %if.end12

if.end12:                                         ; preds = %if.end6, %if.then11
  %4 = phi i16 [ %3, %if.end6 ], [ 1, %if.then11 ]
  store %struct.op* %1, %struct.op** @PL_op, align 8, !tbaa !6
  %op_type = getelementptr inbounds %struct.op* %1, i64 0, i32 4
  %5 = load i16* %op_type, align 2, !tbaa !12
  %conv13 = zext i16 %5 to i32
  switch i32 %conv13, label %sw.default [
    i32 349, label %sw.bb
    i32 174, label %sw.bb
    i32 175, label %sw.bb
    i32 5, label %sw.bb15
    i32 66, label %sw.bb23
    i32 1, label %sw.bb54
    i32 0, label %sw.bb64
    i32 2, label %nothin
    i32 173, label %nothin
    i32 179, label %nothin
    i32 10, label %sw.bb97
    i32 7, label %sw.bb97
    i32 155, label %sw.bb324
    i32 153, label %sw.bb324
    i32 159, label %sw.bb324
    i32 160, label %sw.bb324
    i32 163, label %sw.bb324
    i32 164, label %sw.bb324
    i32 162, label %sw.bb324
    i32 156, label %sw.bb324
    i32 182, label %sw.bb336
    i32 180, label %sw.bb336
    i32 32, label %sw.bb375
    i32 31, label %sw.bb375
    i32 33, label %sw.bb375
    i32 285, label %sw.bb392
    i32 135, label %sw.bb462
    i32 136, label %sw.bb613
    i32 150, label %sw.bb769
    i32 151, label %sw.bb1003
  ]

sw.bb:                                            ; preds = %if.end12, %if.end12, %if.end12
  %6 = bitcast %struct.op* %1 to %struct.cop*
  store volatile %struct.cop* %6, %struct.cop** @PL_curcop, align 8, !tbaa !6
  %7 = load i16* @PL_op_seqmax, align 2, !tbaa !100
  %inc = add i16 %7, 1
  store i16 %inc, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %7, i16* %op_seq3, align 2, !tbaa !8
  br label %for.inc1165

sw.bb15:                                          ; preds = %if.end12
  %8 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %9 = load i8* %8, align 1, !tbaa !33
  %and = and i8 %9, 8
  %tobool17 = icmp eq i8 %and, 0
  br i1 %tobool17, label %if.end20, label %if.then18

if.then18:                                        ; preds = %sw.bb15
  %call19 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @no_bareword_allowed to i32 (%struct.op*, ...)*)(%struct.op* %1) #4
  %.pre = load i16* @PL_op_seqmax, align 2, !tbaa !100
  br label %if.end20

if.end20:                                         ; preds = %sw.bb15, %if.then18
  %10 = phi i16 [ %4, %sw.bb15 ], [ %.pre, %if.then18 ]
  %inc21 = add i16 %10, 1
  store i16 %inc21, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %10, i16* %op_seq3, align 2, !tbaa !8
  br label %for.inc1165

sw.bb23:                                          ; preds = %if.end12
  %op_next = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %11 = load %struct.op** %op_next, align 8, !tbaa !42
  %tobool24 = icmp eq %struct.op* %11, null
  br i1 %tobool24, label %ignore_optimization, label %land.lhs.true

land.lhs.true:                                    ; preds = %sw.bb23
  %op_type26 = getelementptr inbounds %struct.op* %11, i64 0, i32 4
  %12 = load i16* %op_type26, align 2, !tbaa !12
  %cmp28 = icmp eq i16 %12, 67
  br i1 %cmp28, label %if.then30, label %ignore_optimization

if.then30:                                        ; preds = %land.lhs.true
  %op_private32 = getelementptr inbounds %struct.op* %11, i64 0, i32 7
  %13 = load i8* %op_private32, align 1, !tbaa !11
  %and34 = and i8 %13, 16
  %tobool35 = icmp eq i8 %and34, 0
  br i1 %tobool35, label %if.end.i, label %if.then36

if.then36:                                        ; preds = %if.then30
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %14 = load i8* %op_flags, align 1, !tbaa !14
  %and38 = and i8 %14, 64
  %tobool39 = icmp eq i8 %and38, 0
  br i1 %tobool39, label %if.else, label %ignore_optimization

if.else:                                          ; preds = %if.then36
  %op_targ = getelementptr inbounds %struct.op* %11, i64 0, i32 3
  %15 = load i64* %op_targ, align 8, !tbaa !13
  %op_targ42 = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  store i64 %15, i64* %op_targ42, align 8, !tbaa !13
  store i64 0, i64* %op_targ, align 8, !tbaa !13
  %op_private45 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %16 = load i8* %op_private45, align 1, !tbaa !11
  %or = or i8 %16, 16
  store i8 %or, i8* %op_private45, align 1, !tbaa !11
  br label %if.end.i

if.end.i:                                         ; preds = %if.else, %if.then30
  %call.i = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %11) #4
  %17 = load i16* %op_type26, align 2, !tbaa !12
  %conv3.i = zext i16 %17 to i64
  %op_targ.i = getelementptr inbounds %struct.op* %11, i64 0, i32 3
  store i64 %conv3.i, i64* %op_targ.i, align 8, !tbaa !13
  store i16 0, i16* %op_type26, align 2, !tbaa !12
  %18 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i = getelementptr inbounds %struct.op* %11, i64 0, i32 2
  store %struct.op* ()* %18, %struct.op* ()** %op_ppaddr.i, align 8, !tbaa !41
  %.pre1631 = load i16* @PL_op_seqmax, align 2, !tbaa !100
  br label %ignore_optimization

ignore_optimization:                              ; preds = %if.end.i, %if.then36, %sw.bb23, %land.lhs.true
  %19 = phi i16 [ %.pre1631, %if.end.i ], [ %4, %if.then36 ], [ %4, %sw.bb23 ], [ %4, %land.lhs.true ]
  %inc52 = add i16 %19, 1
  store i16 %inc52, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %19, i16* %op_seq3, align 2, !tbaa !8
  br label %for.inc1165

sw.bb54:                                          ; preds = %if.end12
  %op_flags55 = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %20 = load i8* %op_flags55, align 1, !tbaa !14
  %and57 = and i8 %20, 3
  %cmp58 = icmp eq i8 %and57, 3
  br i1 %cmp58, label %nothin, label %if.then60

if.then60:                                        ; preds = %sw.bb54
  %inc61 = add i16 %4, 1
  store i16 %inc61, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %4, i16* %op_seq3, align 2, !tbaa !8
  br label %for.inc1165

sw.bb64:                                          ; preds = %if.end12
  %op_targ65 = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %21 = load i64* %op_targ65, align 8, !tbaa !13
  switch i64 %21, label %if.end77 [
    i64 174, label %if.then76
    i64 175, label %if.then76
    i64 349, label %if.then76
  ]

if.then76:                                        ; preds = %sw.bb64, %sw.bb64, %sw.bb64
  %22 = bitcast %struct.op* %1 to %struct.cop*
  store volatile %struct.cop* %22, %struct.cop** @PL_curcop, align 8, !tbaa !6
  br label %if.end77

if.end77:                                         ; preds = %sw.bb64, %if.then76
  %tobool78 = icmp eq %struct.op* %oldop.01622, null
  br i1 %tobool78, label %for.inc1165, label %land.lhs.true79

land.lhs.true79:                                  ; preds = %if.end77
  %op_next80 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %23 = load %struct.op** %op_next80, align 8, !tbaa !42
  %tobool81 = icmp eq %struct.op* %23, null
  br i1 %tobool81, label %for.inc1165, label %if.then82

if.then82:                                        ; preds = %land.lhs.true79
  %op_next84 = getelementptr inbounds %struct.op* %oldop.01622, i64 0, i32 0
  store %struct.op* %23, %struct.op** %op_next84, align 8, !tbaa !42
  br label %for.inc1165

nothin:                                           ; preds = %sw.bb54, %if.end12, %if.end12, %if.end12
  %tobool87 = icmp eq %struct.op* %oldop.01622, null
  br i1 %tobool87, label %if.end94, label %land.lhs.true88

land.lhs.true88:                                  ; preds = %nothin
  %op_next89 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %24 = load %struct.op** %op_next89, align 8, !tbaa !42
  %tobool90 = icmp eq %struct.op* %24, null
  br i1 %tobool90, label %if.end94, label %if.then91

if.then91:                                        ; preds = %land.lhs.true88
  %op_next93 = getelementptr inbounds %struct.op* %oldop.01622, i64 0, i32 0
  store %struct.op* %24, %struct.op** %op_next93, align 8, !tbaa !42
  br label %for.inc1165

if.end94:                                         ; preds = %land.lhs.true88, %nothin
  %inc95 = add i16 %4, 1
  store i16 %inc95, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %4, i16* %op_seq3, align 2, !tbaa !8
  br label %for.inc1165

sw.bb97:                                          ; preds = %if.end12, %if.end12
  %cmp100 = icmp eq i16 %5, 10
  %op_next113.phi.trans.insert = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %.pre1633 = load %struct.op** %op_next113.phi.trans.insert, align 8, !tbaa !42
  br i1 %cmp100, label %cond.end, label %lor.lhs.false102

lor.lhs.false102:                                 ; preds = %sw.bb97
  %op_type104 = getelementptr inbounds %struct.op* %.pre1633, i64 0, i32 4
  %25 = load i16* %op_type104, align 2, !tbaa !12
  switch i16 %25, label %if.else238 [
    i16 125, label %cond.false
    i16 15, label %if.then216
  ]

cond.false:                                       ; preds = %lor.lhs.false102
  %op_next115 = getelementptr inbounds %struct.op* %.pre1633, i64 0, i32 0
  %26 = load %struct.op** %op_next115, align 8, !tbaa !42
  br label %cond.end

cond.end:                                         ; preds = %sw.bb97, %cond.false
  %cond = phi %struct.op* [ %26, %cond.false ], [ %.pre1633, %sw.bb97 ]
  %op_next1131656 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %tobool116 = icmp eq %struct.op* %cond, null
  br i1 %tobool116, label %if.end207, label %land.lhs.true117

land.lhs.true117:                                 ; preds = %cond.end
  %op_type118 = getelementptr inbounds %struct.op* %cond, i64 0, i32 4
  %27 = load i16* %op_type118, align 2, !tbaa !12
  %cmp120 = icmp eq i16 %27, 5
  br i1 %cmp120, label %land.lhs.true122, label %if.end207

land.lhs.true122:                                 ; preds = %land.lhs.true117
  %op_next123 = getelementptr inbounds %struct.op* %cond, i64 0, i32 0
  %28 = load %struct.op** %op_next123, align 8, !tbaa !42
  store %struct.op* %28, %struct.op** @PL_op, align 8, !tbaa !6
  %tobool124 = icmp eq %struct.op* %28, null
  br i1 %tobool124, label %if.end207, label %land.lhs.true125

land.lhs.true125:                                 ; preds = %land.lhs.true122
  %29 = load %struct.op** %op_next123, align 8, !tbaa !42
  %op_type127 = getelementptr inbounds %struct.op* %29, i64 0, i32 4
  %30 = load i16* %op_type127, align 2, !tbaa !12
  %cmp129 = icmp eq i16 %30, 127
  br i1 %cmp129, label %land.lhs.true131, label %if.end207

land.lhs.true131:                                 ; preds = %land.lhs.true125
  %op_private133 = getelementptr inbounds %struct.op* %29, i64 0, i32 7
  %31 = load i8* %op_private133, align 1, !tbaa !11
  %tobool136 = icmp ugt i8 %31, 7
  br i1 %tobool136, label %if.end207, label %land.lhs.true137

land.lhs.true137:                                 ; preds = %land.lhs.true131
  %op_sv = getelementptr inbounds %struct.op* %cond, i64 1
  %32 = bitcast %struct.op* %op_sv to %struct.sv**
  %33 = load %struct.sv** %32, align 8, !tbaa !18
  %sv_flags = getelementptr inbounds %struct.sv* %33, i64 0, i32 2
  %34 = load i64* %sv_flags, align 8, !tbaa !34
  %and138 = and i64 %34, 65536
  %tobool139 = icmp eq i64 %and138, 0
  br i1 %tobool139, label %cond.false142, label %cond.true140

cond.true140:                                     ; preds = %land.lhs.true137
  %sv_any = getelementptr inbounds %struct.sv* %33, i64 0, i32 0
  %35 = load i8** %sv_any, align 8, !tbaa !36
  %xiv_iv = getelementptr inbounds i8* %35, i64 24
  %36 = bitcast i8* %xiv_iv to i64*
  %37 = load i64* %36, align 8, !tbaa !53
  br label %cond.end145

cond.false142:                                    ; preds = %land.lhs.true137
  %call144 = call i64 @Perl_sv_2iv(%struct.sv* %33) #4
  br label %cond.end145

cond.end145:                                      ; preds = %cond.false142, %cond.true140
  %cond146 = phi i64 [ %37, %cond.true140 ], [ %call144, %cond.false142 ]
  %38 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_arybase = getelementptr inbounds %struct.cop* %38, i64 0, i32 12
  %39 = load i64* %cop_arybase, align 8, !tbaa !55
  %sub = sub nsw i64 %cond146, %39
  %40 = icmp ult i64 %sub, 256
  br i1 %40, label %if.then152, label %if.end207

if.then152:                                       ; preds = %cond.end145
  %41 = getelementptr inbounds %struct.op* %cond, i64 0, i32 7
  %42 = load i8* %41, align 1, !tbaa !33
  %and155 = and i8 %42, 8
  %tobool156 = icmp eq i8 %and155, 0
  br i1 %tobool156, label %if.end159, label %if.then157

if.then157:                                       ; preds = %if.then152
  %call158 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @no_bareword_allowed to i32 (%struct.op*, ...)*)(%struct.op* %cond) #4
  br label %if.end159

if.end159:                                        ; preds = %if.then152, %if.then157
  %43 = load i16* %op_type, align 2, !tbaa !12
  %cmp162 = icmp eq i16 %43, 7
  br i1 %cmp162, label %if.then164, label %if.end166

if.then164:                                       ; preds = %if.end159
  %44 = load %struct.op** %op_next1131656, align 8, !tbaa !42
  %op_type.i1475 = getelementptr inbounds %struct.op* %44, i64 0, i32 4
  %45 = load i16* %op_type.i1475, align 2, !tbaa !12
  %cmp.i1476 = icmp eq i16 %45, 0
  br i1 %cmp.i1476, label %if.end166, label %if.end.i1481

if.end.i1481:                                     ; preds = %if.then164
  %call.i1477 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %44) #4
  %46 = load i16* %op_type.i1475, align 2, !tbaa !12
  %conv3.i1478 = zext i16 %46 to i64
  %op_targ.i1479 = getelementptr inbounds %struct.op* %44, i64 0, i32 3
  store i64 %conv3.i1478, i64* %op_targ.i1479, align 8, !tbaa !13
  store i16 0, i16* %op_type.i1475, align 2, !tbaa !12
  %47 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i1480 = getelementptr inbounds %struct.op* %44, i64 0, i32 2
  store %struct.op* ()* %47, %struct.op* ()** %op_ppaddr.i1480, align 8, !tbaa !41
  br label %if.end166

if.end166:                                        ; preds = %if.end.i1481, %if.then164, %if.end159
  %48 = load %struct.op** %op_next123, align 8, !tbaa !42
  %op_type.i1483 = getelementptr inbounds %struct.op* %48, i64 0, i32 4
  %49 = load i16* %op_type.i1483, align 2, !tbaa !12
  %cmp.i1484 = icmp eq i16 %49, 0
  br i1 %cmp.i1484, label %Perl_op_null.exit1490, label %if.end.i1489

if.end.i1489:                                     ; preds = %if.end166
  %call.i1485 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %48) #4
  %50 = load i16* %op_type.i1483, align 2, !tbaa !12
  %conv3.i1486 = zext i16 %50 to i64
  %op_targ.i1487 = getelementptr inbounds %struct.op* %48, i64 0, i32 3
  store i64 %conv3.i1486, i64* %op_targ.i1487, align 8, !tbaa !13
  store i16 0, i16* %op_type.i1483, align 2, !tbaa !12
  %51 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i1488 = getelementptr inbounds %struct.op* %48, i64 0, i32 2
  store %struct.op* ()* %51, %struct.op* ()** %op_ppaddr.i1488, align 8, !tbaa !41
  br label %Perl_op_null.exit1490

Perl_op_null.exit1490:                            ; preds = %if.end166, %if.end.i1489
  %52 = load i16* %op_type118, align 2, !tbaa !12
  %cmp.i1492 = icmp eq i16 %52, 0
  br i1 %cmp.i1492, label %Perl_op_null.exit1498, label %if.end.i1497

if.end.i1497:                                     ; preds = %Perl_op_null.exit1490
  %call.i1493 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %cond) #4
  %53 = load i16* %op_type118, align 2, !tbaa !12
  %conv3.i1494 = zext i16 %53 to i64
  %op_targ.i1495 = getelementptr inbounds %struct.op* %cond, i64 0, i32 3
  store i64 %conv3.i1494, i64* %op_targ.i1495, align 8, !tbaa !13
  store i16 0, i16* %op_type118, align 2, !tbaa !12
  %54 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i1496 = getelementptr inbounds %struct.op* %cond, i64 0, i32 2
  store %struct.op* ()* %54, %struct.op* ()** %op_ppaddr.i1496, align 8, !tbaa !41
  br label %Perl_op_null.exit1498

Perl_op_null.exit1498:                            ; preds = %Perl_op_null.exit1490, %if.end.i1497
  %55 = load %struct.op** %op_next123, align 8, !tbaa !42
  %op_flags169 = getelementptr inbounds %struct.op* %55, i64 0, i32 6
  %56 = load i8* %op_flags169, align 1, !tbaa !14
  %and171 = and i8 %56, 32
  %op_flags172 = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %57 = load i8* %op_flags172, align 1, !tbaa !14
  %or174 = or i8 %57, %and171
  store i8 %or174, i8* %op_flags172, align 1, !tbaa !14
  %op_next177 = getelementptr inbounds %struct.op* %55, i64 0, i32 0
  %58 = load %struct.op** %op_next177, align 8, !tbaa !42
  store %struct.op* %58, %struct.op** %op_next1131656, align 8, !tbaa !42
  %59 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 126), align 8, !tbaa !6
  %op_ppaddr = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %59, %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %conv179 = trunc i64 %sub to i8
  %op_private180 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  store i8 %conv179, i8* %op_private180, align 1, !tbaa !11
  %60 = load i16* %op_type, align 2, !tbaa !12
  %cmp183 = icmp eq i16 %60, 7
  br i1 %cmp183, label %if.then185, label %if.else200

if.then185:                                       ; preds = %Perl_op_null.exit1498
  %op_sv186 = getelementptr inbounds %struct.op* %1, i64 1
  %61 = bitcast %struct.op* %op_sv186 to %struct.sv**
  %62 = load %struct.sv** %61, align 8, !tbaa !18
  %sv_any187 = bitcast %struct.sv* %62 to %struct.xpvgv**
  %63 = load %struct.xpvgv** %sv_any187, align 8, !tbaa !60
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %63, i64 0, i32 7
  %64 = load %struct.gp** %xgv_gp, align 8, !tbaa !62
  %gp_av = getelementptr inbounds %struct.gp* %64, i64 0, i32 4
  %65 = load %struct.av** %gp_av, align 8, !tbaa !160
  %tobool188 = icmp eq %struct.av* %65, null
  br i1 %tobool188, label %cond.false193, label %if.end205

cond.false193:                                    ; preds = %if.then185
  %66 = bitcast %struct.sv* %62 to %struct.gv*
  %call194 = call %struct.gv* @Perl_gv_AVadd(%struct.gv* %66) #4
  br label %if.end205

if.else200:                                       ; preds = %Perl_op_null.exit1498
  %or203 = or i8 %or174, -128
  store i8 %or203, i8* %op_flags172, align 1, !tbaa !14
  br label %if.end205

if.end205:                                        ; preds = %if.then185, %cond.false193, %if.else200
  store i16 126, i16* %op_type, align 2, !tbaa !12
  br label %if.end207

if.end207:                                        ; preds = %land.lhs.true122, %cond.end, %if.end205, %cond.end145, %land.lhs.true131, %land.lhs.true125, %land.lhs.true117
  %67 = load i16* @PL_op_seqmax, align 2, !tbaa !100
  %inc208 = add i16 %67, 1
  store i16 %inc208, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %67, i16* %op_seq3, align 2, !tbaa !8
  br label %for.inc1165

if.then216:                                       ; preds = %lor.lhs.false102
  %op_private218 = getelementptr inbounds %struct.op* %.pre1633, i64 0, i32 7
  %68 = load i8* %op_private218, align 1, !tbaa !11
  %and220 = and i8 %68, 96
  %tobool221 = icmp eq i8 %and220, 0
  br i1 %tobool221, label %Perl_op_null.exit1506, label %if.end321

Perl_op_null.exit1506:                            ; preds = %if.then216
  %call.i1501 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %.pre1633) #4
  %69 = load i16* %op_type104, align 2, !tbaa !12
  %conv3.i1502 = zext i16 %69 to i64
  %op_targ.i1503 = getelementptr inbounds %struct.op* %.pre1633, i64 0, i32 3
  store i64 %conv3.i1502, i64* %op_targ.i1503, align 8, !tbaa !13
  store i16 0, i16* %op_type104, align 2, !tbaa !12
  %70 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i1504 = getelementptr inbounds %struct.op* %.pre1633, i64 0, i32 2
  store %struct.op* ()* %70, %struct.op* ()** %op_ppaddr.i1504, align 8, !tbaa !41
  %71 = load %struct.op** %op_next113.phi.trans.insert, align 8, !tbaa !42
  %op_private225 = getelementptr inbounds %struct.op* %71, i64 0, i32 7
  %72 = load i8* %op_private225, align 1, !tbaa !11
  %and227 = and i8 %72, -112
  %op_private228 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %73 = load i8* %op_private228, align 1, !tbaa !11
  %or230 = or i8 %73, %and227
  store i8 %or230, i8* %op_private228, align 1, !tbaa !11
  %op_next233 = getelementptr inbounds %struct.op* %71, i64 0, i32 0
  %74 = load %struct.op** %op_next233, align 8, !tbaa !42
  store %struct.op* %74, %struct.op** %op_next113.phi.trans.insert, align 8, !tbaa !42
  store i16 6, i16* %op_type, align 2, !tbaa !12
  %75 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 6), align 8, !tbaa !6
  %op_ppaddr236 = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %75, %struct.op* ()** %op_ppaddr236, align 8, !tbaa !41
  br label %if.end321

if.else238:                                       ; preds = %lor.lhs.false102
  %op_private239 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %76 = load i8* %op_private239, align 1, !tbaa !11
  %and241 = and i8 %76, 32
  %tobool242 = icmp eq i8 %and241, 0
  br i1 %tobool242, label %if.else289, label %land.lhs.true243

land.lhs.true243:                                 ; preds = %if.else238
  %77 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings = getelementptr inbounds %struct.cop* %77, i64 0, i32 14
  %78 = load %struct.sv** %cop_warnings, align 8, !tbaa !47
  %cmp244 = icmp eq %struct.sv* %78, null
  br i1 %cmp244, label %lor.lhs.false260, label %land.lhs.true246

land.lhs.true246:                                 ; preds = %land.lhs.true243
  %79 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings247 = getelementptr inbounds %struct.cop* %79, i64 0, i32 14
  %80 = load %struct.sv** %cop_warnings247, align 8, !tbaa !47
  %cmp248 = icmp eq %struct.sv* %80, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp248, label %lor.lhs.false260, label %land.lhs.true250

land.lhs.true250:                                 ; preds = %land.lhs.true246
  %81 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings251 = getelementptr inbounds %struct.cop* %81, i64 0, i32 14
  %82 = load %struct.sv** %cop_warnings251, align 8, !tbaa !47
  %cmp252 = icmp eq %struct.sv* %82, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp252, label %if.then268, label %lor.lhs.false254

lor.lhs.false254:                                 ; preds = %land.lhs.true250
  %83 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings255 = getelementptr inbounds %struct.cop* %83, i64 0, i32 14
  %84 = load %struct.sv** %cop_warnings255, align 8, !tbaa !47
  %sv_any256 = getelementptr inbounds %struct.sv* %84, i64 0, i32 0
  %85 = load i8** %sv_any256, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %85 to i8**
  %86 = load i8** %xpv_pv, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8* %86, i64 8
  %87 = load i8* %arrayidx, align 1, !tbaa !5
  %and258 = and i8 %87, 64
  %tobool259 = icmp eq i8 %and258, 0
  br i1 %tobool259, label %lor.lhs.false260, label %if.then268

lor.lhs.false260:                                 ; preds = %lor.lhs.false254, %land.lhs.true246, %land.lhs.true243
  %88 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings261 = getelementptr inbounds %struct.cop* %88, i64 0, i32 14
  %89 = load %struct.sv** %cop_warnings261, align 8, !tbaa !47
  %cmp262 = icmp eq %struct.sv* %89, null
  br i1 %cmp262, label %land.lhs.true264, label %if.else289

land.lhs.true264:                                 ; preds = %lor.lhs.false260
  %90 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and266 = and i8 %90, 1
  %tobool267 = icmp eq i8 %and266, 0
  br i1 %tobool267, label %if.else289, label %if.then268

if.then268:                                       ; preds = %lor.lhs.false254, %land.lhs.true264, %land.lhs.true250
  %op_sv270 = getelementptr inbounds %struct.op* %1, i64 1
  %91 = bitcast %struct.op* %op_sv270 to %struct.sv**
  %92 = load %struct.sv** %91, align 8, !tbaa !18
  %93 = bitcast %struct.sv* %92 to %struct.gv*
  %94 = getelementptr inbounds %struct.sv* %92, i64 0, i32 2
  %95 = load i64* %94, align 8, !tbaa !136
  %and272 = and i64 %95, 255
  %cmp273 = icmp eq i64 %and272, 13
  br i1 %cmp273, label %land.lhs.true275, label %if.end321

land.lhs.true275:                                 ; preds = %if.then268
  %sv_any276 = bitcast %struct.sv* %92 to %struct.xpvgv**
  %96 = load %struct.xpvgv** %sv_any276, align 8, !tbaa !60
  %xgv_gp277 = getelementptr inbounds %struct.xpvgv* %96, i64 0, i32 7
  %97 = load %struct.gp** %xgv_gp277, align 8, !tbaa !62
  %gp_cv = getelementptr inbounds %struct.gp* %97, i64 0, i32 7
  %98 = load %struct.cv** %gp_cv, align 8, !tbaa !64
  %tobool278 = icmp eq %struct.cv* %98, null
  br i1 %tobool278, label %if.end321, label %land.lhs.true279

land.lhs.true279:                                 ; preds = %land.lhs.true275
  %sv_any283 = getelementptr inbounds %struct.cv* %98, i64 0, i32 0
  %99 = load %struct.xpvcv** %sv_any283, align 8, !tbaa !66
  %xpv_pv284 = getelementptr inbounds %struct.xpvcv* %99, i64 0, i32 0
  %100 = load i8** %xpv_pv284, align 8, !tbaa !39
  %tobool285 = icmp eq i8* %100, null
  br i1 %tobool285, label %if.end321, label %if.then286

if.then286:                                       ; preds = %land.lhs.true279
  %call287 = call %struct.sv* @Perl_sv_newmortal() #4
  call void @Perl_gv_efullname4(%struct.sv* %call287, %struct.gv* %93, i8* null, i8 signext 1) #4
  call void (i64, i8*, ...)* @Perl_warner(i64 35, i8* getelementptr inbounds ([41 x i8]* @.str134, i64 0, i64 0), %struct.sv* %call287) #4
  br label %if.end321

if.else289:                                       ; preds = %land.lhs.true264, %if.else238, %lor.lhs.false260
  %101 = load %struct.op** %op_next113.phi.trans.insert, align 8, !tbaa !42
  %op_type291 = getelementptr inbounds %struct.op* %101, i64 0, i32 4
  %102 = load i16* %op_type291, align 2, !tbaa !12
  %cmp293 = icmp eq i16 %102, 26
  br i1 %cmp293, label %land.lhs.true295, label %if.end321

land.lhs.true295:                                 ; preds = %if.else289
  %op_next297 = getelementptr inbounds %struct.op* %101, i64 0, i32 0
  %103 = load %struct.op** %op_next297, align 8, !tbaa !42
  %op_type298 = getelementptr inbounds %struct.op* %103, i64 0, i32 4
  %104 = load i16* %op_type298, align 2, !tbaa !12
  %cmp300 = icmp eq i16 %104, 66
  br i1 %cmp300, label %land.lhs.true302, label %if.end321

land.lhs.true302:                                 ; preds = %land.lhs.true295
  %op_flags305 = getelementptr inbounds %struct.op* %103, i64 0, i32 6
  %105 = load i8* %op_flags305, align 1, !tbaa !14
  %and307 = and i8 %105, 64
  %tobool308 = icmp eq i8 %and307, 0
  br i1 %tobool308, label %if.end321, label %if.then309

if.then309:                                       ; preds = %land.lhs.true302
  store i16 27, i16* %op_type, align 2, !tbaa !12
  %op_flags311 = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %106 = load i8* %op_flags311, align 1, !tbaa !14
  %or313 = or i8 %106, 64
  store i8 %or313, i8* %op_flags311, align 1, !tbaa !14
  %107 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 27), align 8, !tbaa !6
  %op_ppaddr315 = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %107, %struct.op* ()** %op_ppaddr315, align 8, !tbaa !41
  %108 = load i16* %op_type298, align 2, !tbaa !12
  %cmp.i1508 = icmp eq i16 %108, 0
  br i1 %cmp.i1508, label %Perl_op_null.exit1514, label %if.end.i1513

if.end.i1513:                                     ; preds = %if.then309
  %call.i1509 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %103) #4
  %109 = load i16* %op_type298, align 2, !tbaa !12
  %conv3.i1510 = zext i16 %109 to i64
  %op_targ.i1511 = getelementptr inbounds %struct.op* %103, i64 0, i32 3
  store i64 %conv3.i1510, i64* %op_targ.i1511, align 8, !tbaa !13
  store i16 0, i16* %op_type298, align 2, !tbaa !12
  %110 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i1512 = getelementptr inbounds %struct.op* %103, i64 0, i32 2
  store %struct.op* ()* %110, %struct.op* ()** %op_ppaddr.i1512, align 8, !tbaa !41
  %.pre1634 = load %struct.op** %op_next113.phi.trans.insert, align 8, !tbaa !42
  br label %Perl_op_null.exit1514

Perl_op_null.exit1514:                            ; preds = %if.then309, %if.end.i1513
  %111 = phi %struct.op* [ %101, %if.then309 ], [ %.pre1634, %if.end.i1513 ]
  %op_type.i1515 = getelementptr inbounds %struct.op* %111, i64 0, i32 4
  %112 = load i16* %op_type.i1515, align 2, !tbaa !12
  %cmp.i1516 = icmp eq i16 %112, 0
  br i1 %cmp.i1516, label %if.end321, label %if.end.i1521

if.end.i1521:                                     ; preds = %Perl_op_null.exit1514
  %call.i1517 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %111) #4
  %113 = load i16* %op_type.i1515, align 2, !tbaa !12
  %conv3.i1518 = zext i16 %113 to i64
  %op_targ.i1519 = getelementptr inbounds %struct.op* %111, i64 0, i32 3
  store i64 %conv3.i1518, i64* %op_targ.i1519, align 8, !tbaa !13
  store i16 0, i16* %op_type.i1515, align 2, !tbaa !12
  %114 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i1520 = getelementptr inbounds %struct.op* %111, i64 0, i32 2
  store %struct.op* ()* %114, %struct.op* ()** %op_ppaddr.i1520, align 8, !tbaa !41
  br label %if.end321

if.end321:                                        ; preds = %if.end.i1521, %Perl_op_null.exit1514, %if.then216, %land.lhs.true279, %land.lhs.true275, %land.lhs.true302, %if.then286, %if.then268, %land.lhs.true295, %if.else289, %Perl_op_null.exit1506
  %115 = load i16* @PL_op_seqmax, align 2, !tbaa !100
  %inc322 = add i16 %115, 1
  store i16 %inc322, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %115, i16* %op_seq3, align 2, !tbaa !8
  br label %for.inc1165

sw.bb324:                                         ; preds = %if.end12, %if.end12, %if.end12, %if.end12, %if.end12, %if.end12, %if.end12, %if.end12
  %inc325 = add i16 %4, 1
  store i16 %inc325, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %4, i16* %op_seq3, align 2, !tbaa !8
  %116 = getelementptr inbounds %struct.op* %1, i64 1, i32 1
  %117 = load %struct.op** %116, align 8, !tbaa !114
  %op_type3271618 = getelementptr inbounds %struct.op* %117, i64 0, i32 4
  %118 = load i16* %op_type3271618, align 2, !tbaa !12
  %cmp3291619 = icmp eq i16 %118, 0
  br i1 %cmp3291619, label %while.body, label %while.end

while.body:                                       ; preds = %sw.bb324, %while.body
  %119 = phi %struct.op* [ %124, %while.body ], [ %117, %sw.bb324 ]
  %120 = phi %struct.op** [ %123, %while.body ], [ %116, %sw.bb324 ]
  %op_next332 = getelementptr inbounds %struct.op* %119, i64 0, i32 0
  %121 = load %struct.op** %op_next332, align 8, !tbaa !42
  store %struct.op* %121, %struct.op** %120, align 8, !tbaa !114
  %122 = load %struct.op** @PL_op, align 8, !tbaa !6
  %123 = getelementptr inbounds %struct.op* %122, i64 1, i32 1
  %124 = load %struct.op** %123, align 8, !tbaa !114
  %op_type327 = getelementptr inbounds %struct.op* %124, i64 0, i32 4
  %125 = load i16* %op_type327, align 2, !tbaa !12
  %cmp329 = icmp eq i16 %125, 0
  br i1 %cmp329, label %while.body, label %while.end

while.end:                                        ; preds = %while.body, %sw.bb324
  %.lcssa1598 = phi %struct.op* [ %117, %sw.bb324 ], [ %124, %while.body ]
  %call335 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @peep to i32 (%struct.op*, ...)*)(%struct.op* %.lcssa1598) #4
  br label %for.inc1165

sw.bb336:                                         ; preds = %if.end12, %if.end12
  %inc337 = add i16 %4, 1
  store i16 %inc337, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %4, i16* %op_seq3, align 2, !tbaa !8
  %op_redoop1605 = getelementptr inbounds %struct.op* %1, i64 1, i32 2
  %126 = load %struct.op* ()** %op_redoop1605, align 8
  %127 = bitcast %struct.op* ()* %126 to %struct.op*
  %op_type3401606 = getelementptr inbounds %struct.op* %127, i64 0, i32 4
  %128 = load i16* %op_type3401606, align 2, !tbaa !12
  %cmp3421607 = icmp eq i16 %128, 0
  br i1 %cmp3421607, label %while.body344, label %while.end348

while.body344:                                    ; preds = %sw.bb336, %while.body344
  %129 = phi %struct.op* ()* [ %132, %while.body344 ], [ %126, %sw.bb336 ]
  %op_redoop1608 = phi %struct.op* ()** [ %op_redoop, %while.body344 ], [ %op_redoop1605, %sw.bb336 ]
  %op_next346 = bitcast %struct.op* ()* %129 to %struct.op**
  %130 = load %struct.op** %op_next346, align 8, !tbaa !42
  %.c1473 = bitcast %struct.op* %130 to %struct.op* ()*
  store %struct.op* ()* %.c1473, %struct.op* ()** %op_redoop1608, align 8, !tbaa !171
  %131 = load %struct.op** @PL_op, align 8, !tbaa !6
  %op_redoop = getelementptr inbounds %struct.op* %131, i64 1, i32 2
  %132 = load %struct.op* ()** %op_redoop, align 8
  %133 = bitcast %struct.op* ()* %132 to %struct.op*
  %op_type340 = getelementptr inbounds %struct.op* %133, i64 0, i32 4
  %134 = load i16* %op_type340, align 2, !tbaa !12
  %cmp342 = icmp eq i16 %134, 0
  br i1 %cmp342, label %while.body344, label %while.end348

while.end348:                                     ; preds = %while.body344, %sw.bb336
  %.lcssa1595 = phi %struct.op* [ %127, %sw.bb336 ], [ %133, %while.body344 ]
  %call350 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @peep to i32 (%struct.op*, ...)*)(%struct.op* %.lcssa1595) #4
  %135 = load %struct.op** @PL_op, align 8, !tbaa !6
  %op_nextop1609 = getelementptr inbounds %struct.op* %135, i64 1, i32 3
  %136 = bitcast i64* %op_nextop1609 to %struct.op**
  %137 = load %struct.op** %136, align 8, !tbaa !173
  %op_type3521610 = getelementptr inbounds %struct.op* %137, i64 0, i32 4
  %138 = load i16* %op_type3521610, align 2, !tbaa !12
  %cmp3541611 = icmp eq i16 %138, 0
  br i1 %cmp3541611, label %while.body356, label %while.end360

while.body356:                                    ; preds = %while.end348, %while.body356
  %139 = phi %struct.op* [ %143, %while.body356 ], [ %137, %while.end348 ]
  %op_nextop1612 = phi i64* [ %op_nextop, %while.body356 ], [ %op_nextop1609, %while.end348 ]
  %op_next358 = getelementptr inbounds %struct.op* %139, i64 0, i32 0
  %140 = load %struct.op** %op_next358, align 8, !tbaa !42
  %.c1472 = ptrtoint %struct.op* %140 to i64
  store i64 %.c1472, i64* %op_nextop1612, align 8, !tbaa !173
  %141 = load %struct.op** @PL_op, align 8, !tbaa !6
  %op_nextop = getelementptr inbounds %struct.op* %141, i64 1, i32 3
  %142 = bitcast i64* %op_nextop to %struct.op**
  %143 = load %struct.op** %142, align 8, !tbaa !173
  %op_type352 = getelementptr inbounds %struct.op* %143, i64 0, i32 4
  %144 = load i16* %op_type352, align 2, !tbaa !12
  %cmp354 = icmp eq i16 %144, 0
  br i1 %cmp354, label %while.body356, label %while.end360

while.end360:                                     ; preds = %while.body356, %while.end348
  %.lcssa1596 = phi %struct.op* [ %137, %while.end348 ], [ %143, %while.body356 ]
  %call362 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @peep to i32 (%struct.op*, ...)*)(%struct.op* %.lcssa1596) #4
  %145 = load %struct.op** @PL_op, align 8, !tbaa !6
  %op_lastop1614 = getelementptr inbounds %struct.op* %145, i64 1, i32 4
  %146 = bitcast i16* %op_lastop1614 to %struct.op**
  %147 = load %struct.op** %146, align 8, !tbaa !172
  %op_type3641615 = getelementptr inbounds %struct.op* %147, i64 0, i32 4
  %148 = load i16* %op_type3641615, align 2, !tbaa !12
  %cmp3661616 = icmp eq i16 %148, 0
  br i1 %cmp3661616, label %while.body368, label %while.end372

while.body368:                                    ; preds = %while.end360, %while.body368
  %149 = phi %struct.op* [ %154, %while.body368 ], [ %147, %while.end360 ]
  %150 = phi %struct.op** [ %153, %while.body368 ], [ %146, %while.end360 ]
  %op_next370 = getelementptr inbounds %struct.op* %149, i64 0, i32 0
  %151 = load %struct.op** %op_next370, align 8, !tbaa !42
  store %struct.op* %151, %struct.op** %150, align 8, !tbaa !172
  %152 = load %struct.op** @PL_op, align 8, !tbaa !6
  %op_lastop = getelementptr inbounds %struct.op* %152, i64 1, i32 4
  %153 = bitcast i16* %op_lastop to %struct.op**
  %154 = load %struct.op** %153, align 8, !tbaa !172
  %op_type364 = getelementptr inbounds %struct.op* %154, i64 0, i32 4
  %155 = load i16* %op_type364, align 2, !tbaa !12
  %cmp366 = icmp eq i16 %155, 0
  br i1 %cmp366, label %while.body368, label %while.end372

while.end372:                                     ; preds = %while.body368, %while.end360
  %.lcssa1597 = phi %struct.op* [ %147, %while.end360 ], [ %154, %while.body368 ]
  %call374 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @peep to i32 (%struct.op*, ...)*)(%struct.op* %.lcssa1597) #4
  br label %for.inc1165

sw.bb375:                                         ; preds = %if.end12, %if.end12, %if.end12
  %inc376 = add i16 %4, 1
  store i16 %inc376, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %4, i16* %op_seq3, align 2, !tbaa !8
  %op_pmreplstart1603 = getelementptr inbounds %struct.op* %1, i64 1, i32 3
  %156 = bitcast i64* %op_pmreplstart1603 to %struct.op**
  %157 = load %struct.op** %156, align 8, !tbaa !120
  %tobool3791604 = icmp eq %struct.op* %157, null
  br i1 %tobool3791604, label %while.end389, label %land.end

land.end:                                         ; preds = %sw.bb375, %while.body385
  %158 = phi %struct.op* [ %162, %while.body385 ], [ %1, %sw.bb375 ]
  %159 = phi %struct.op* [ %164, %while.body385 ], [ %157, %sw.bb375 ]
  %op_type381 = getelementptr inbounds %struct.op* %159, i64 0, i32 4
  %160 = load i16* %op_type381, align 2, !tbaa !12
  %cmp383 = icmp eq i16 %160, 0
  br i1 %cmp383, label %while.body385, label %while.end389

while.body385:                                    ; preds = %land.end
  %op_pmreplstart386 = getelementptr inbounds %struct.op* %158, i64 1, i32 3
  %op_next387 = getelementptr inbounds %struct.op* %159, i64 0, i32 0
  %161 = load %struct.op** %op_next387, align 8, !tbaa !42
  %.c = ptrtoint %struct.op* %161 to i64
  store i64 %.c, i64* %op_pmreplstart386, align 8, !tbaa !120
  %162 = load %struct.op** @PL_op, align 8, !tbaa !6
  %op_pmreplstart = getelementptr inbounds %struct.op* %162, i64 1, i32 3
  %163 = bitcast i64* %op_pmreplstart to %struct.op**
  %164 = load %struct.op** %163, align 8, !tbaa !120
  %tobool379 = icmp eq %struct.op* %164, null
  br i1 %tobool379, label %while.end389, label %land.end

while.end389:                                     ; preds = %land.end, %while.body385, %sw.bb375
  %165 = phi %struct.op* [ null, %sw.bb375 ], [ %159, %land.end ], [ null, %while.body385 ]
  %call391 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @peep to i32 (%struct.op*, ...)*)(%struct.op* %165) #4
  br label %for.inc1165

sw.bb392:                                         ; preds = %if.end12
  %inc393 = add i16 %4, 1
  store i16 %inc393, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %4, i16* %op_seq3, align 2, !tbaa !8
  %166 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings395 = getelementptr inbounds %struct.cop* %166, i64 0, i32 14
  %167 = load %struct.sv** %cop_warnings395, align 8, !tbaa !47
  %cmp396 = icmp eq %struct.sv* %167, null
  br i1 %cmp396, label %lor.lhs.false414, label %land.lhs.true398

land.lhs.true398:                                 ; preds = %sw.bb392
  %168 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings399 = getelementptr inbounds %struct.cop* %168, i64 0, i32 14
  %169 = load %struct.sv** %cop_warnings399, align 8, !tbaa !47
  %cmp400 = icmp eq %struct.sv* %169, inttoptr (i64 48 to %struct.sv*)
  br i1 %cmp400, label %lor.lhs.false414, label %land.lhs.true402

land.lhs.true402:                                 ; preds = %land.lhs.true398
  %170 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings403 = getelementptr inbounds %struct.cop* %170, i64 0, i32 14
  %171 = load %struct.sv** %cop_warnings403, align 8, !tbaa !47
  %cmp404 = icmp eq %struct.sv* %171, inttoptr (i64 24 to %struct.sv*)
  br i1 %cmp404, label %land.lhs.true422, label %lor.lhs.false406

lor.lhs.false406:                                 ; preds = %land.lhs.true402
  %172 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings407 = getelementptr inbounds %struct.cop* %172, i64 0, i32 14
  %173 = load %struct.sv** %cop_warnings407, align 8, !tbaa !47
  %sv_any408 = getelementptr inbounds %struct.sv* %173, i64 0, i32 0
  %174 = load i8** %sv_any408, align 8, !tbaa !36
  %xpv_pv409 = bitcast i8* %174 to i8**
  %175 = load i8** %xpv_pv409, align 8, !tbaa !39
  %arrayidx410 = getelementptr inbounds i8* %175, i64 7
  %176 = load i8* %arrayidx410, align 1, !tbaa !5
  %and412 = and i8 %176, 1
  %tobool413 = icmp eq i8 %and412, 0
  br i1 %tobool413, label %lor.lhs.false414, label %land.lhs.true422

lor.lhs.false414:                                 ; preds = %lor.lhs.false406, %land.lhs.true398, %sw.bb392
  %177 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_warnings415 = getelementptr inbounds %struct.cop* %177, i64 0, i32 14
  %178 = load %struct.sv** %cop_warnings415, align 8, !tbaa !47
  %cmp416 = icmp eq %struct.sv* %178, null
  br i1 %cmp416, label %land.lhs.true418, label %for.inc1165

land.lhs.true418:                                 ; preds = %lor.lhs.false414
  %179 = load i8* @PL_dowarn, align 1, !tbaa !5
  %and420 = and i8 %179, 1
  %tobool421 = icmp eq i8 %and420, 0
  br i1 %tobool421, label %for.inc1165, label %land.lhs.true422

land.lhs.true422:                                 ; preds = %lor.lhs.false406, %land.lhs.true418, %land.lhs.true402
  %op_next423 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %180 = load %struct.op** %op_next423, align 8, !tbaa !42
  %tobool424 = icmp eq %struct.op* %180, null
  br i1 %tobool424, label %for.inc1165, label %land.lhs.true425

land.lhs.true425:                                 ; preds = %land.lhs.true422
  %op_type427 = getelementptr inbounds %struct.op* %180, i64 0, i32 4
  %181 = load i16* %op_type427, align 2, !tbaa !12
  %cmp429 = icmp eq i16 %181, 174
  br i1 %cmp429, label %if.then431, label %for.inc1165

if.then431:                                       ; preds = %land.lhs.true425
  %op_sibling = getelementptr inbounds %struct.op* %180, i64 0, i32 1
  %182 = load %struct.op** %op_sibling, align 8, !tbaa !17
  %tobool433 = icmp eq %struct.op* %182, null
  br i1 %tobool433, label %for.inc1165, label %land.lhs.true434

land.lhs.true434:                                 ; preds = %if.then431
  %op_type437 = getelementptr inbounds %struct.op* %182, i64 0, i32 4
  %183 = load i16* %op_type437, align 2, !tbaa !12
  switch i16 %183, label %if.then455 [
    i16 190, label %for.inc1165
    i16 170, label %for.inc1165
    i16 171, label %for.inc1165
  ]

if.then455:                                       ; preds = %land.lhs.true434
  %184 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line = getelementptr inbounds %struct.cop* %184, i64 0, i32 13
  %185 = load i64* %cop_line, align 8, !tbaa !116
  %cop_line457 = getelementptr inbounds %struct.op* %180, i64 2
  %186 = bitcast %struct.op* %cop_line457 to i64*
  %187 = load i64* %186, align 8, !tbaa !116
  %188 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line458 = getelementptr inbounds %struct.cop* %188, i64 0, i32 13
  store i64 %187, i64* %cop_line458, align 8, !tbaa !116
  call void (i64, i8*, ...)* @Perl_warner(i64 7, i8* getelementptr inbounds ([33 x i8]* @.str135, i64 0, i64 0)) #4
  call void (i64, i8*, ...)* @Perl_warner(i64 7, i8* getelementptr inbounds ([51 x i8]* @.str136, i64 0, i64 0)) #4
  %189 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !6
  %cop_line459 = getelementptr inbounds %struct.cop* %189, i64 0, i32 13
  store i64 %185, i64* %cop_line459, align 8, !tbaa !116
  br label %for.inc1165

sw.bb462:                                         ; preds = %if.end12
  %inc464 = add i16 %4, 1
  store i16 %inc464, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %4, i16* %op_seq3, align 2, !tbaa !8
  %190 = getelementptr inbounds %struct.op* %1, i64 1, i32 1
  %191 = load %struct.op** %190, align 8, !tbaa !81
  %op_type466 = getelementptr inbounds %struct.op* %191, i64 0, i32 4
  %192 = load i16* %op_type466, align 2, !tbaa !12
  %cmp468 = icmp eq i16 %192, 5
  br i1 %cmp468, label %if.end471, label %for.inc1165

if.end471:                                        ; preds = %sw.bb462
  %op_sv473 = getelementptr inbounds %struct.op* %191, i64 1
  %193 = bitcast %struct.op* %op_sv473 to %struct.sv**
  %194 = load %struct.sv** %193, align 8, !tbaa !6
  %sv_flags474 = getelementptr inbounds %struct.sv* %194, i64 0, i32 2
  %195 = load i64* %sv_flags474, align 8, !tbaa !34
  %196 = and i64 %195, 9437184
  %197 = icmp eq i64 %196, 9437184
  br i1 %197, label %if.end503, label %if.then481

if.then481:                                       ; preds = %if.end471
  %and483 = and i64 %195, 262144
  %cmp484 = icmp eq i64 %and483, 0
  br i1 %cmp484, label %cond.false490, label %cond.true486

cond.true486:                                     ; preds = %if.then481
  %sv_any487 = getelementptr inbounds %struct.sv* %194, i64 0, i32 0
  %198 = load i8** %sv_any487, align 8, !tbaa !36
  %xpv_cur = getelementptr inbounds i8* %198, i64 8
  %199 = bitcast i8* %xpv_cur to i64*
  %200 = load i64* %199, align 8, !tbaa !37
  store i64 %200, i64* %keylen, align 8, !tbaa !1
  %xpv_pv489 = bitcast i8* %198 to i8**
  %201 = load i8** %xpv_pv489, align 8, !tbaa !39
  br label %cond.end492

cond.false490:                                    ; preds = %if.then481
  %call491 = call i8* @Perl_sv_2pv_flags(%struct.sv* %194, i64* %keylen, i64 2) #4
  %.pre1640 = load i64* %keylen, align 8, !tbaa !1
  br label %cond.end492

cond.end492:                                      ; preds = %cond.false490, %cond.true486
  %202 = phi i64 [ %200, %cond.true486 ], [ %.pre1640, %cond.false490 ]
  %cond493 = phi i8* [ %201, %cond.true486 ], [ %call491, %cond.false490 ]
  %203 = load i64* %sv_flags474, align 8, !tbaa !34
  %and495 = and i64 %203, 536870912
  %tobool496 = icmp ne i64 %and495, 0
  %sub498 = sub nsw i64 0, %202
  %cond501 = select i1 %tobool496, i64 %sub498, i64 %202
  %call502 = call %struct.sv* @Perl_newSVpvn_share(i8* %cond493, i64 %cond501, i64 0) #4
  call void @Perl_sv_free(%struct.sv* %194) #4
  %204 = getelementptr inbounds %struct.op* %op_sv473, i64 0, i32 0
  %call502.c = bitcast %struct.sv* %call502 to %struct.op*
  store %struct.op* %call502.c, %struct.op** %204, align 8, !tbaa !6
  br label %if.end503

if.end503:                                        ; preds = %if.end471, %cond.end492
  %op_private504 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %205 = load i8* %op_private504, align 1, !tbaa !11
  %tobool507 = icmp slt i8 %205, 0
  br i1 %tobool507, label %for.inc1165, label %if.end509

if.end509:                                        ; preds = %if.end503
  %206 = getelementptr inbounds %struct.op* %1, i64 1, i32 0
  %207 = load %struct.op** %206, align 8, !tbaa !43
  %208 = getelementptr inbounds %struct.op* %207, i64 0, i32 4
  %209 = load i16* %208, align 2, !tbaa !56
  %cmp512 = icmp eq i16 %209, 134
  br i1 %cmp512, label %lor.lhs.false514, label %for.inc1165

lor.lhs.false514:                                 ; preds = %if.end509
  %210 = getelementptr inbounds %struct.op* %207, i64 1, i32 0
  %211 = load %struct.op** %210, align 8, !tbaa !15
  %op_type516 = getelementptr inbounds %struct.op* %211, i64 0, i32 4
  %212 = load i16* %op_type516, align 2, !tbaa !12
  %cmp518 = icmp eq i16 %212, 9
  br i1 %cmp518, label %if.end521, label %for.inc1165

if.end521:                                        ; preds = %lor.lhs.false514
  %213 = load %struct.av** @PL_comppad_name, align 8, !tbaa !6
  %op_targ523 = getelementptr inbounds %struct.op* %211, i64 0, i32 3
  %214 = load i64* %op_targ523, align 8, !tbaa !13
  %call524 = call %struct.sv** @Perl_av_fetch(%struct.av* %213, i64 %214, i64 1) #4
  %215 = load %struct.sv** %call524, align 8, !tbaa !6
  %sv_flags525 = getelementptr inbounds %struct.sv* %215, i64 0, i32 2
  %216 = load i64* %sv_flags525, align 8, !tbaa !34
  %and526 = and i64 %216, 1073741824
  %tobool527 = icmp eq i64 %and526, 0
  br i1 %tobool527, label %for.inc1165, label %if.end529

if.end529:                                        ; preds = %if.end521
  %sv_any530 = getelementptr inbounds %struct.sv* %215, i64 0, i32 0
  %217 = load i8** %sv_any530, align 8, !tbaa !36
  %xmg_stash = getelementptr inbounds i8* %217, i64 48
  %218 = bitcast i8* %xmg_stash to %struct.hv**
  %219 = load %struct.hv** %218, align 8, !tbaa !182
  %call531 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %219, i8* getelementptr inbounds ([7 x i8]* @.str137, i64 0, i64 0), i64 6, i64 0) #4
  %tobool532 = icmp eq %struct.sv** %call531, null
  br i1 %tobool532, label %for.inc1165, label %lor.lhs.false533

lor.lhs.false533:                                 ; preds = %if.end529
  %220 = load %struct.sv** %call531, align 8
  %sv_any534 = bitcast %struct.sv* %220 to %struct.xpvgv**
  %221 = load %struct.xpvgv** %sv_any534, align 8, !tbaa !60
  %xgv_gp535 = getelementptr inbounds %struct.xpvgv* %221, i64 0, i32 7
  %222 = load %struct.gp** %xgv_gp535, align 8, !tbaa !62
  %gp_hv = getelementptr inbounds %struct.gp* %222, i64 0, i32 5
  %223 = load %struct.hv** %gp_hv, align 8, !tbaa !94
  %tobool536 = icmp eq %struct.hv* %223, null
  br i1 %tobool536, label %for.inc1165, label %if.end538

if.end538:                                        ; preds = %lor.lhs.false533
  %224 = load %struct.sv** %193, align 8, !tbaa !6
  %sv_flags539 = getelementptr inbounds %struct.sv* %224, i64 0, i32 2
  %225 = load i64* %sv_flags539, align 8, !tbaa !34
  %and540 = and i64 %225, 262144
  %cmp541 = icmp eq i64 %and540, 0
  br i1 %cmp541, label %cond.false548, label %cond.true543

cond.true543:                                     ; preds = %if.end538
  %sv_any544 = getelementptr inbounds %struct.sv* %224, i64 0, i32 0
  %226 = load i8** %sv_any544, align 8, !tbaa !36
  %xpv_cur545 = getelementptr inbounds i8* %226, i64 8
  %227 = bitcast i8* %xpv_cur545 to i64*
  %228 = load i64* %227, align 8, !tbaa !37
  store i64 %228, i64* %keylen, align 8, !tbaa !1
  %xpv_pv547 = bitcast i8* %226 to i8**
  %229 = load i8** %xpv_pv547, align 8, !tbaa !39
  br label %cond.end550

cond.false548:                                    ; preds = %if.end538
  %call549 = call i8* @Perl_sv_2pv_flags(%struct.sv* %224, i64* %keylen, i64 2) #4
  %.pre1635 = load %struct.sv** %193, align 8, !tbaa !6
  %.pre1636 = load i64* %keylen, align 8, !tbaa !1
  br label %cond.end550

cond.end550:                                      ; preds = %cond.false548, %cond.true543
  %230 = phi i64 [ %228, %cond.true543 ], [ %.pre1636, %cond.false548 ]
  %231 = phi %struct.sv* [ %224, %cond.true543 ], [ %.pre1635, %cond.false548 ]
  %cond551 = phi i8* [ %229, %cond.true543 ], [ %call549, %cond.false548 ]
  %232 = load %struct.sv** %call531, align 8
  %sv_any552 = bitcast %struct.sv* %232 to %struct.xpvgv**
  %233 = load %struct.xpvgv** %sv_any552, align 8, !tbaa !60
  %xgv_gp553 = getelementptr inbounds %struct.xpvgv* %233, i64 0, i32 7
  %234 = load %struct.gp** %xgv_gp553, align 8, !tbaa !62
  %gp_hv554 = getelementptr inbounds %struct.gp* %234, i64 0, i32 5
  %235 = load %struct.hv** %gp_hv554, align 8, !tbaa !94
  %sv_flags555 = getelementptr inbounds %struct.sv* %231, i64 0, i32 2
  %236 = load i64* %sv_flags555, align 8, !tbaa !34
  %and556 = and i64 %236, 536870912
  %tobool557 = icmp ne i64 %and556, 0
  %sub559 = sub nsw i64 0, %230
  %cond562 = select i1 %tobool557, i64 %sub559, i64 %230
  %call563 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %235, i8* %cond551, i64 %cond562, i64 0) #4
  %tobool564 = icmp eq %struct.sv** %call563, null
  br i1 %tobool564, label %if.then565, label %if.end582

if.then565:                                       ; preds = %cond.end550
  %237 = load i64* %sv_flags525, align 8, !tbaa !34
  %and567 = and i64 %237, 262144
  %cmp568 = icmp eq i64 %and567, 0
  br i1 %cmp568, label %cond.false575, label %cond.true570

cond.true570:                                     ; preds = %if.then565
  %238 = load i8** %sv_any530, align 8, !tbaa !36
  %xpv_cur572 = getelementptr inbounds i8* %238, i64 8
  %239 = bitcast i8* %xpv_cur572 to i64*
  %240 = load i64* %239, align 8, !tbaa !37
  store i64 %240, i64* %n_a, align 8, !tbaa !1
  %xpv_pv574 = bitcast i8* %238 to i8**
  %241 = load i8** %xpv_pv574, align 8, !tbaa !39
  br label %cond.end577

cond.false575:                                    ; preds = %if.then565
  %call576 = call i8* @Perl_sv_2pv_flags(%struct.sv* %215, i64* %n_a, i64 2) #4
  %.pre1637 = load i8** %sv_any530, align 8, !tbaa !36
  br label %cond.end577

cond.end577:                                      ; preds = %cond.false575, %cond.true570
  %242 = phi i8* [ %238, %cond.true570 ], [ %.pre1637, %cond.false575 ]
  %cond578 = phi i8* [ %241, %cond.true570 ], [ %call576, %cond.false575 ]
  %xmg_stash580 = getelementptr inbounds i8* %242, i64 48
  %243 = bitcast i8* %xmg_stash580 to %struct.hv**
  %244 = load %struct.hv** %243, align 8, !tbaa !182
  %sv_any581 = getelementptr inbounds %struct.hv* %244, i64 0, i32 0
  %245 = load %struct.xpvhv** %sv_any581, align 8, !tbaa !26
  %xhv_name = getelementptr inbounds %struct.xpvhv* %245, i64 0, i32 10
  %246 = load i8** %xhv_name, align 8, !tbaa !178
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([57 x i8]* @.str138, i64 0, i64 0), i8* %cond551, i8* %cond578, i8* %246) #4
  br label %if.end582

if.end582:                                        ; preds = %cond.end550, %cond.end577
  %247 = load %struct.sv** %call563, align 8, !tbaa !6
  %sv_flags583 = getelementptr inbounds %struct.sv* %247, i64 0, i32 2
  %248 = load i64* %sv_flags583, align 8, !tbaa !34
  %and584 = and i64 %248, 65536
  %tobool585 = icmp eq i64 %and584, 0
  br i1 %tobool585, label %cond.false589, label %cond.true586

cond.true586:                                     ; preds = %if.end582
  %sv_any587 = getelementptr inbounds %struct.sv* %247, i64 0, i32 0
  %249 = load i8** %sv_any587, align 8, !tbaa !36
  %xiv_iv588 = getelementptr inbounds i8* %249, i64 24
  %250 = bitcast i8* %xiv_iv588 to i64*
  %251 = load i64* %250, align 8, !tbaa !53
  br label %cond.end591

cond.false589:                                    ; preds = %if.end582
  %call590 = call i64 @Perl_sv_2iv(%struct.sv* %247) #4
  br label %cond.end591

cond.end591:                                      ; preds = %cond.false589, %cond.true586
  %cond592 = phi i64 [ %251, %cond.true586 ], [ %call590, %cond.false589 ]
  %cmp593 = icmp slt i64 %cond592, 1
  br i1 %cmp593, label %if.then595, label %if.end596

if.then595:                                       ; preds = %cond.end591
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([41 x i8]* @.str139, i64 0, i64 0)) #4
  br label %if.end596

if.end596:                                        ; preds = %if.then595, %cond.end591
  store i16 125, i16* %208, align 2, !tbaa !56
  %252 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 125), align 8, !tbaa !6
  %253 = getelementptr inbounds %struct.op* %207, i64 0, i32 2
  store %struct.op* ()* %252, %struct.op* ()** %253, align 8, !tbaa !57
  store i16 127, i16* %op_type, align 2, !tbaa !12
  %254 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 127), align 8, !tbaa !6
  %op_ppaddr600 = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %254, %struct.op* ()** %op_ppaddr600, align 8, !tbaa !41
  %call601 = call %struct.sv* @Perl_newSViv(i64 %cond592) #4
  %255 = load %struct.sv** %193, align 8, !tbaa !6
  %sv_flags602 = getelementptr inbounds %struct.sv* %255, i64 0, i32 2
  %256 = load i64* %sv_flags602, align 8, !tbaa !34
  %and603 = and i64 %256, 8388608
  %tobool604 = icmp eq i64 %and603, 0
  %sv_flags611.phi.trans.insert = getelementptr inbounds %struct.sv* %call601, i64 0, i32 2
  %.pre1639 = load i64* %sv_flags611.phi.trans.insert, align 8, !tbaa !34
  br i1 %tobool604, label %if.end608, label %if.then605

if.then605:                                       ; preds = %if.end596
  %or607 = or i64 %.pre1639, 8388608
  store i64 %or607, i64* %sv_flags611.phi.trans.insert, align 8, !tbaa !34
  %.pre1638 = load i64* %sv_flags602, align 8, !tbaa !34
  br label %if.end608

if.end608:                                        ; preds = %if.end596, %if.then605
  %257 = phi i64 [ %or607, %if.then605 ], [ %.pre1639, %if.end596 ]
  %258 = phi i64 [ %.pre1638, %if.then605 ], [ %256, %if.end596 ]
  %and610 = and i64 %258, 1792
  %sv_flags611 = getelementptr inbounds %struct.sv* %call601, i64 0, i32 2
  %or612 = or i64 %257, %and610
  store i64 %or612, i64* %sv_flags611, align 8, !tbaa !34
  call void @Perl_sv_free(%struct.sv* %255) #4
  %259 = getelementptr inbounds %struct.op* %op_sv473, i64 0, i32 0
  %call601.c = bitcast %struct.sv* %call601 to %struct.op*
  store %struct.op* %call601.c, %struct.op** %259, align 8, !tbaa !6
  br label %for.inc1165

sw.bb613:                                         ; preds = %if.end12
  %inc623 = add i16 %4, 1
  store i16 %inc623, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %4, i16* %op_seq3, align 2, !tbaa !8
  %op_private625 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %260 = load i8* %op_private625, align 1, !tbaa !11
  %tobool628 = icmp slt i8 %260, 0
  br i1 %tobool628, label %for.inc1165, label %lor.lhs.false629

lor.lhs.false629:                                 ; preds = %sw.bb613
  %261 = getelementptr inbounds %struct.op* %1, i64 1, i32 0
  %262 = load %struct.op** %261, align 8, !tbaa !45
  %op_sibling631 = getelementptr inbounds %struct.op* %262, i64 0, i32 1
  %263 = load %struct.op** %op_sibling631, align 8, !tbaa !17
  %op_type632 = getelementptr inbounds %struct.op* %263, i64 0, i32 4
  %264 = load i16* %op_type632, align 2, !tbaa !12
  %cmp634 = icmp eq i16 %264, 141
  br i1 %cmp634, label %if.end637, label %for.inc1165

if.end637:                                        ; preds = %lor.lhs.false629
  %265 = getelementptr inbounds %struct.op* %1, i64 1, i32 1
  %266 = load %struct.op** %265, align 8, !tbaa !70
  %267 = getelementptr inbounds %struct.op* %266, i64 0, i32 4
  %268 = load i16* %267, align 2, !tbaa !56
  %cmp641 = icmp eq i16 %268, 134
  br i1 %cmp641, label %lor.lhs.false643, label %for.inc1165

lor.lhs.false643:                                 ; preds = %if.end637
  %269 = getelementptr inbounds %struct.op* %266, i64 1, i32 0
  %270 = load %struct.op** %269, align 8, !tbaa !15
  %op_type645 = getelementptr inbounds %struct.op* %270, i64 0, i32 4
  %271 = load i16* %op_type645, align 2, !tbaa !12
  %cmp647 = icmp eq i16 %271, 9
  br i1 %cmp647, label %if.end650, label %for.inc1165

if.end650:                                        ; preds = %lor.lhs.false643
  %272 = load %struct.av** @PL_comppad_name, align 8, !tbaa !6
  %op_targ652 = getelementptr inbounds %struct.op* %270, i64 0, i32 3
  %273 = load i64* %op_targ652, align 8, !tbaa !13
  %call653 = call %struct.sv** @Perl_av_fetch(%struct.av* %272, i64 %273, i64 1) #4
  %274 = load %struct.sv** %call653, align 8, !tbaa !6
  %sv_flags654 = getelementptr inbounds %struct.sv* %274, i64 0, i32 2
  %275 = load i64* %sv_flags654, align 8, !tbaa !34
  %and655 = and i64 %275, 1073741824
  %tobool656 = icmp eq i64 %and655, 0
  br i1 %tobool656, label %for.inc1165, label %if.end658

if.end658:                                        ; preds = %if.end650
  %sv_any659 = getelementptr inbounds %struct.sv* %274, i64 0, i32 0
  %276 = load i8** %sv_any659, align 8, !tbaa !36
  %xmg_stash660 = getelementptr inbounds i8* %276, i64 48
  %277 = bitcast i8* %xmg_stash660 to %struct.hv**
  %278 = load %struct.hv** %277, align 8, !tbaa !182
  %call661 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %278, i8* getelementptr inbounds ([7 x i8]* @.str137, i64 0, i64 0), i64 6, i64 0) #4
  %tobool662 = icmp eq %struct.sv** %call661, null
  br i1 %tobool662, label %for.inc1165, label %lor.lhs.false663

lor.lhs.false663:                                 ; preds = %if.end658
  %279 = load %struct.sv** %call661, align 8
  %sv_any664 = bitcast %struct.sv* %279 to %struct.xpvgv**
  %280 = load %struct.xpvgv** %sv_any664, align 8, !tbaa !60
  %xgv_gp665 = getelementptr inbounds %struct.xpvgv* %280, i64 0, i32 7
  %281 = load %struct.gp** %xgv_gp665, align 8, !tbaa !62
  %gp_hv666 = getelementptr inbounds %struct.gp* %281, i64 0, i32 5
  %282 = load %struct.hv** %gp_hv666, align 8, !tbaa !94
  %tobool667 = icmp eq %struct.hv* %282, null
  br i1 %tobool667, label %for.inc1165, label %if.end669

if.end669:                                        ; preds = %lor.lhs.false663
  %283 = load %struct.op** %261, align 8, !tbaa !45
  %op_sibling671 = getelementptr inbounds %struct.op* %283, i64 0, i32 1
  %284 = load %struct.op** %op_sibling671, align 8, !tbaa !17
  %285 = getelementptr inbounds %struct.op* %284, i64 1, i32 0
  %286 = load %struct.op** %285, align 8, !tbaa !45
  %op_sibling673 = getelementptr inbounds %struct.op* %286, i64 0, i32 1
  %287 = load %struct.op** %op_sibling673, align 8, !tbaa !17
  %288 = bitcast %struct.op* %287 to %struct.svop*
  %tobool6751599 = icmp eq %struct.op* %287, null
  br i1 %tobool6751599, label %for.inc1165.critedge, label %for.body676

for.body676:                                      ; preds = %if.end669, %for.inc
  %key_op.01600 = phi %struct.svop* [ %291, %for.inc ], [ %288, %if.end669 ]
  %op_type677 = getelementptr inbounds %struct.svop* %key_op.01600, i64 0, i32 4
  %289 = load i16* %op_type677, align 2, !tbaa !71
  %cmp679 = icmp eq i16 %289, 5
  br i1 %cmp679, label %for.inc, label %for.inc1165

for.inc:                                          ; preds = %for.body676
  %op_sibling683 = getelementptr inbounds %struct.svop* %key_op.01600, i64 0, i32 1
  %290 = load %struct.op** %op_sibling683, align 8, !tbaa !181
  %291 = bitcast %struct.op* %290 to %struct.svop*
  %tobool675 = icmp eq %struct.op* %290, null
  br i1 %tobool675, label %if.end686, label %for.body676

if.end686:                                        ; preds = %for.inc
  store i16 125, i16* %267, align 2, !tbaa !56
  %292 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 125), align 8, !tbaa !6
  %293 = getelementptr inbounds %struct.op* %266, i64 0, i32 2
  store %struct.op* ()* %292, %struct.op* ()** %293, align 8, !tbaa !57
  store i16 128, i16* %op_type, align 2, !tbaa !12
  %294 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 128), align 8, !tbaa !6
  %op_ppaddr690 = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %294, %struct.op* ()** %op_ppaddr690, align 8, !tbaa !41
  br i1 %tobool6751599, label %for.inc1165, label %for.body693

for.body693:                                      ; preds = %if.end686, %if.end761
  %key_op.11602 = phi %struct.svop* [ %328, %if.end761 ], [ %288, %if.end686 ]
  %op_sv694 = getelementptr inbounds %struct.svop* %key_op.11602, i64 0, i32 8
  %295 = load %struct.sv** %op_sv694, align 8, !tbaa !6
  %sv_flags695 = getelementptr inbounds %struct.sv* %295, i64 0, i32 2
  %296 = load i64* %sv_flags695, align 8, !tbaa !34
  %and696 = and i64 %296, 262144
  %cmp697 = icmp eq i64 %and696, 0
  br i1 %cmp697, label %cond.false704, label %cond.true699

cond.true699:                                     ; preds = %for.body693
  %sv_any700 = getelementptr inbounds %struct.sv* %295, i64 0, i32 0
  %297 = load i8** %sv_any700, align 8, !tbaa !36
  %xpv_cur701 = getelementptr inbounds i8* %297, i64 8
  %298 = bitcast i8* %xpv_cur701 to i64*
  %299 = load i64* %298, align 8, !tbaa !37
  store i64 %299, i64* %keylen622, align 8, !tbaa !1
  %xpv_pv703 = bitcast i8* %297 to i8**
  %300 = load i8** %xpv_pv703, align 8, !tbaa !39
  br label %cond.end706

cond.false704:                                    ; preds = %for.body693
  %call705 = call i8* @Perl_sv_2pv_flags(%struct.sv* %295, i64* %keylen622, i64 2) #4
  %.pre1641 = load %struct.sv** %op_sv694, align 8, !tbaa !6
  %.pre1642 = load i64* %keylen622, align 8, !tbaa !1
  br label %cond.end706

cond.end706:                                      ; preds = %cond.false704, %cond.true699
  %301 = phi i64 [ %299, %cond.true699 ], [ %.pre1642, %cond.false704 ]
  %302 = phi %struct.sv* [ %295, %cond.true699 ], [ %.pre1641, %cond.false704 ]
  %cond707 = phi i8* [ %300, %cond.true699 ], [ %call705, %cond.false704 ]
  %303 = load %struct.sv** %call661, align 8
  %sv_any708 = bitcast %struct.sv* %303 to %struct.xpvgv**
  %304 = load %struct.xpvgv** %sv_any708, align 8, !tbaa !60
  %xgv_gp709 = getelementptr inbounds %struct.xpvgv* %304, i64 0, i32 7
  %305 = load %struct.gp** %xgv_gp709, align 8, !tbaa !62
  %gp_hv710 = getelementptr inbounds %struct.gp* %305, i64 0, i32 5
  %306 = load %struct.hv** %gp_hv710, align 8, !tbaa !94
  %sv_flags711 = getelementptr inbounds %struct.sv* %302, i64 0, i32 2
  %307 = load i64* %sv_flags711, align 8, !tbaa !34
  %and712 = and i64 %307, 536870912
  %tobool713 = icmp ne i64 %and712, 0
  %sub715 = sub nsw i64 0, %301
  %cond718 = select i1 %tobool713, i64 %sub715, i64 %301
  %call719 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %306, i8* %cond707, i64 %cond718, i64 0) #4
  %tobool720 = icmp eq %struct.sv** %call719, null
  br i1 %tobool720, label %if.then721, label %if.end739

if.then721:                                       ; preds = %cond.end706
  %308 = load i64* %sv_flags654, align 8, !tbaa !34
  %and723 = and i64 %308, 262144
  %cmp724 = icmp eq i64 %and723, 0
  br i1 %cmp724, label %cond.false731, label %cond.true726

cond.true726:                                     ; preds = %if.then721
  %309 = load i8** %sv_any659, align 8, !tbaa !36
  %xpv_cur728 = getelementptr inbounds i8* %309, i64 8
  %310 = bitcast i8* %xpv_cur728 to i64*
  %311 = load i64* %310, align 8, !tbaa !37
  store i64 %311, i64* %n_a, align 8, !tbaa !1
  %xpv_pv730 = bitcast i8* %309 to i8**
  %312 = load i8** %xpv_pv730, align 8, !tbaa !39
  br label %cond.end733

cond.false731:                                    ; preds = %if.then721
  %call732 = call i8* @Perl_sv_2pv_flags(%struct.sv* %274, i64* %n_a, i64 2) #4
  %.pre1643 = load i8** %sv_any659, align 8, !tbaa !36
  br label %cond.end733

cond.end733:                                      ; preds = %cond.false731, %cond.true726
  %313 = phi i8* [ %309, %cond.true726 ], [ %.pre1643, %cond.false731 ]
  %cond734 = phi i8* [ %312, %cond.true726 ], [ %call732, %cond.false731 ]
  %xmg_stash736 = getelementptr inbounds i8* %313, i64 48
  %314 = bitcast i8* %xmg_stash736 to %struct.hv**
  %315 = load %struct.hv** %314, align 8, !tbaa !182
  %sv_any737 = getelementptr inbounds %struct.hv* %315, i64 0, i32 0
  %316 = load %struct.xpvhv** %sv_any737, align 8, !tbaa !26
  %xhv_name738 = getelementptr inbounds %struct.xpvhv* %316, i64 0, i32 10
  %317 = load i8** %xhv_name738, align 8, !tbaa !178
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([57 x i8]* @.str138, i64 0, i64 0), i8* %cond707, i8* %cond734, i8* %317) #4
  br label %if.end739

if.end739:                                        ; preds = %cond.end706, %cond.end733
  %318 = load %struct.sv** %call719, align 8, !tbaa !6
  %sv_flags740 = getelementptr inbounds %struct.sv* %318, i64 0, i32 2
  %319 = load i64* %sv_flags740, align 8, !tbaa !34
  %and741 = and i64 %319, 65536
  %tobool742 = icmp eq i64 %and741, 0
  br i1 %tobool742, label %cond.false746, label %cond.true743

cond.true743:                                     ; preds = %if.end739
  %sv_any744 = getelementptr inbounds %struct.sv* %318, i64 0, i32 0
  %320 = load i8** %sv_any744, align 8, !tbaa !36
  %xiv_iv745 = getelementptr inbounds i8* %320, i64 24
  %321 = bitcast i8* %xiv_iv745 to i64*
  %322 = load i64* %321, align 8, !tbaa !53
  br label %cond.end748

cond.false746:                                    ; preds = %if.end739
  %call747 = call i64 @Perl_sv_2iv(%struct.sv* %318) #4
  br label %cond.end748

cond.end748:                                      ; preds = %cond.false746, %cond.true743
  %cond749 = phi i64 [ %322, %cond.true743 ], [ %call747, %cond.false746 ]
  %cmp750 = icmp slt i64 %cond749, 1
  br i1 %cmp750, label %if.then752, label %if.end753

if.then752:                                       ; preds = %cond.end748
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([41 x i8]* @.str139, i64 0, i64 0)) #4
  br label %if.end753

if.end753:                                        ; preds = %if.then752, %cond.end748
  %call754 = call %struct.sv* @Perl_newSViv(i64 %cond749) #4
  %323 = load %struct.sv** %op_sv694, align 8, !tbaa !6
  %sv_flags755 = getelementptr inbounds %struct.sv* %323, i64 0, i32 2
  %324 = load i64* %sv_flags755, align 8, !tbaa !34
  %and756 = and i64 %324, 8388608
  %tobool757 = icmp eq i64 %and756, 0
  %sv_flags764.phi.trans.insert = getelementptr inbounds %struct.sv* %call754, i64 0, i32 2
  %.pre1645 = load i64* %sv_flags764.phi.trans.insert, align 8, !tbaa !34
  br i1 %tobool757, label %if.end761, label %if.then758

if.then758:                                       ; preds = %if.end753
  %or760 = or i64 %.pre1645, 8388608
  store i64 %or760, i64* %sv_flags764.phi.trans.insert, align 8, !tbaa !34
  %.pre1644 = load i64* %sv_flags755, align 8, !tbaa !34
  br label %if.end761

if.end761:                                        ; preds = %if.end753, %if.then758
  %325 = phi i64 [ %or760, %if.then758 ], [ %.pre1645, %if.end753 ]
  %326 = phi i64 [ %.pre1644, %if.then758 ], [ %324, %if.end753 ]
  %and763 = and i64 %326, 1792
  %sv_flags764 = getelementptr inbounds %struct.sv* %call754, i64 0, i32 2
  %or765 = or i64 %325, %and763
  store i64 %or765, i64* %sv_flags764, align 8, !tbaa !34
  call void @Perl_sv_free(%struct.sv* %323) #4
  store %struct.sv* %call754, %struct.sv** %op_sv694, align 8, !tbaa !6
  %op_sibling767 = getelementptr inbounds %struct.svop* %key_op.11602, i64 0, i32 1
  %327 = load %struct.op** %op_sibling767, align 8, !tbaa !181
  %328 = bitcast %struct.op* %327 to %struct.svop*
  %tobool692 = icmp eq %struct.op* %327, null
  br i1 %tobool692, label %for.inc1165, label %for.body693

sw.bb769:                                         ; preds = %if.end12
  %329 = getelementptr inbounds %struct.op* %1, i64 1, i32 0
  %330 = load %struct.op** %329, align 8, !tbaa !15
  %tobool771 = icmp eq %struct.op* %330, null
  br i1 %tobool771, label %for.inc1165, label %lor.lhs.false772

lor.lhs.false772:                                 ; preds = %sw.bb769
  %op_type773 = getelementptr inbounds %struct.op* %330, i64 0, i32 4
  %331 = load i16* %op_type773, align 2, !tbaa !12
  %cmp775 = icmp eq i16 %331, 3
  br i1 %cmp775, label %if.end778, label %for.inc1165

if.end778:                                        ; preds = %lor.lhs.false772
  %332 = getelementptr inbounds %struct.op* %1, i64 0, i32 1
  %333 = load %struct.op** %332, align 8, !tbaa !184
  %tobool780 = icmp eq %struct.op* %333, null
  br i1 %tobool780, label %if.then781, label %if.end814

if.then781:                                       ; preds = %if.end778
  %op_next782 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %334 = load %struct.op** %op_next782, align 8, !tbaa !42
  %op_type783 = getelementptr inbounds %struct.op* %334, i64 0, i32 4
  %335 = load i16* %op_type783, align 2, !tbaa !12
  %cmp785 = icmp eq i16 %335, 151
  br i1 %cmp785, label %land.lhs.true787, label %if.end814

land.lhs.true787:                                 ; preds = %if.then781
  %op_flags788 = getelementptr inbounds %struct.op* %334, i64 0, i32 6
  %336 = load i8* %op_flags788, align 1, !tbaa !14
  %and790 = and i8 %336, 3
  %cmp791 = icmp eq i8 %and790, 3
  br i1 %cmp791, label %if.then793, label %if.end814

if.then793:                                       ; preds = %land.lhs.true787
  %337 = getelementptr inbounds %struct.op* %334, i64 1, i32 0
  %338 = load %struct.op** %337, align 8, !tbaa !15
  %tobool795 = icmp eq %struct.op* %338, null
  br i1 %tobool795, label %if.end814, label %land.lhs.true796

land.lhs.true796:                                 ; preds = %if.then793
  %op_type797 = getelementptr inbounds %struct.op* %338, i64 0, i32 4
  %339 = load i16* %op_type797, align 2, !tbaa !12
  %cmp799 = icmp eq i16 %339, 3
  br i1 %cmp799, label %land.lhs.true801, label %if.end814

land.lhs.true801:                                 ; preds = %land.lhs.true796
  %340 = getelementptr inbounds %struct.op* %338, i64 0, i32 1
  %341 = load %struct.op** %340, align 8, !tbaa !184
  %cmp803 = icmp eq %struct.op* %341, %1
  br i1 %cmp803, label %Perl_op_null.exit1530, label %if.end814

Perl_op_null.exit1530:                            ; preds = %land.lhs.true801
  %op_private806 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %342 = load i8* %op_private806, align 1, !tbaa !11
  %or808 = or i8 %342, 4
  store i8 %or808, i8* %op_private806, align 1, !tbaa !11
  %call.i1525 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %334) #4
  %343 = load i16* %op_type783, align 2, !tbaa !12
  %conv3.i1526 = zext i16 %343 to i64
  %op_targ.i1527 = getelementptr inbounds %struct.op* %334, i64 0, i32 3
  store i64 %conv3.i1526, i64* %op_targ.i1527, align 8, !tbaa !13
  store i16 0, i16* %op_type783, align 2, !tbaa !12
  %344 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i1528 = getelementptr inbounds %struct.op* %334, i64 0, i32 2
  store %struct.op* ()* %344, %struct.op* ()** %op_ppaddr.i1528, align 8, !tbaa !41
  %.pre1646 = load i16* %op_type773, align 2, !tbaa !12
  %phitmp = icmp eq i16 %.pre1646, 0
  %op_next810 = getelementptr inbounds %struct.op* %330, i64 0, i32 0
  %345 = load %struct.op** %op_next810, align 8, !tbaa !42
  %op_next811 = getelementptr inbounds %struct.op* %338, i64 0, i32 0
  store %struct.op* %345, %struct.op** %op_next811, align 8, !tbaa !42
  br i1 %phitmp, label %if.end814, label %if.end.i1537

if.end.i1537:                                     ; preds = %Perl_op_null.exit1530
  %call.i1533 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %330) #4
  %346 = load i16* %op_type773, align 2, !tbaa !12
  %conv3.i1534 = zext i16 %346 to i64
  %op_targ.i1535 = getelementptr inbounds %struct.op* %330, i64 0, i32 3
  store i64 %conv3.i1534, i64* %op_targ.i1535, align 8, !tbaa !13
  store i16 0, i16* %op_type773, align 2, !tbaa !12
  %347 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i1536 = getelementptr inbounds %struct.op* %330, i64 0, i32 2
  store %struct.op* ()* %347, %struct.op* ()** %op_ppaddr.i1536, align 8, !tbaa !41
  br label %if.end814

if.end814:                                        ; preds = %if.end.i1537, %Perl_op_null.exit1530, %if.then793, %if.end778, %if.then781, %land.lhs.true787, %land.lhs.true801, %land.lhs.true796
  %348 = load i16* @PL_op_seqmax, align 2, !tbaa !100
  %inc815 = add i16 %348, 1
  store i16 %inc815, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %348, i16* %op_seq3, align 2, !tbaa !8
  %349 = getelementptr inbounds %struct.op* %330, i64 0, i32 1
  %350 = load %struct.op** %349, align 8, !tbaa !184
  %tobool818 = icmp eq %struct.op* %350, null
  br i1 %tobool818, label %for.inc1165, label %if.end820

if.end820:                                        ; preds = %if.end814
  %op_type821 = getelementptr inbounds %struct.op* %350, i64 0, i32 4
  %351 = load i16* %op_type821, align 2, !tbaa !12
  %cmp823 = icmp eq i16 %351, 0
  br i1 %cmp823, label %if.end827, label %lor.lhs.false829

if.end827:                                        ; preds = %if.end820
  %352 = getelementptr inbounds %struct.op* %350, i64 0, i32 1
  %353 = load %struct.op** %352, align 8, !tbaa !184
  %tobool828 = icmp eq %struct.op* %353, null
  br i1 %tobool828, label %for.inc1165, label %if.end827.lor.lhs.false829_crit_edge

if.end827.lor.lhs.false829_crit_edge:             ; preds = %if.end827
  %op_type830.phi.trans.insert = getelementptr inbounds %struct.op* %353, i64 0, i32 4
  %.pre1647 = load i16* %op_type830.phi.trans.insert, align 2, !tbaa !12
  br label %lor.lhs.false829

lor.lhs.false829:                                 ; preds = %if.end827.lor.lhs.false829_crit_edge, %if.end820
  %354 = phi i16 [ %.pre1647, %if.end827.lor.lhs.false829_crit_edge ], [ %351, %if.end820 ]
  %oright.01589 = phi %struct.op* [ %353, %if.end827.lor.lhs.false829_crit_edge ], [ %350, %if.end820 ]
  switch i16 %354, label %for.inc1165 [
    i16 125, label %lor.lhs.false839
    i16 10, label %lor.lhs.false839
  ]

lor.lhs.false839:                                 ; preds = %lor.lhs.false829, %lor.lhs.false829
  %op_next840 = getelementptr inbounds %struct.op* %oright.01589, i64 0, i32 0
  %355 = load %struct.op** %op_next840, align 8, !tbaa !42
  %cmp841 = icmp eq %struct.op* %355, %1
  br i1 %cmp841, label %lor.lhs.false843, label %for.inc1165

lor.lhs.false843:                                 ; preds = %lor.lhs.false839
  %op_private844 = getelementptr inbounds %struct.op* %oright.01589, i64 0, i32 7
  %356 = load i8* %op_private844, align 1, !tbaa !11
  %tobool847 = icmp slt i8 %356, 0
  br i1 %tobool847, label %for.inc1165, label %if.end849

if.end849:                                        ; preds = %lor.lhs.false843
  %op_next850 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %357 = load %struct.op** %op_next850, align 8, !tbaa !42
  %tobool851 = icmp eq %struct.op* %357, null
  br i1 %tobool851, label %for.inc1165, label %lor.lhs.false852

lor.lhs.false852:                                 ; preds = %if.end849
  %op_type853 = getelementptr inbounds %struct.op* %357, i64 0, i32 4
  %358 = load i16* %op_type853, align 2, !tbaa !12
  %cmp855 = icmp eq i16 %358, 0
  br i1 %cmp855, label %if.end858, label %for.inc1165

if.end858:                                        ; preds = %lor.lhs.false852
  %op_next859 = getelementptr inbounds %struct.op* %357, i64 0, i32 0
  %359 = load %struct.op** %op_next859, align 8, !tbaa !42
  %tobool860 = icmp eq %struct.op* %359, null
  br i1 %tobool860, label %for.inc1165, label %lor.lhs.false861

lor.lhs.false861:                                 ; preds = %if.end858
  %op_type862 = getelementptr inbounds %struct.op* %359, i64 0, i32 4
  %360 = load i16* %op_type862, align 2, !tbaa !12
  %cmp864 = icmp eq i16 %360, 3
  br i1 %cmp864, label %if.end867, label %for.inc1165

if.end867:                                        ; preds = %lor.lhs.false861
  %op_next868 = getelementptr inbounds %struct.op* %359, i64 0, i32 0
  %361 = load %struct.op** %op_next868, align 8, !tbaa !42
  %tobool869 = icmp eq %struct.op* %361, null
  br i1 %tobool869, label %for.inc1165, label %land.lhs.true870

land.lhs.true870:                                 ; preds = %if.end867
  %op_type871 = getelementptr inbounds %struct.op* %361, i64 0, i32 4
  %362 = load i16* %op_type871, align 2, !tbaa !12
  %cmp873 = icmp eq i16 %362, 7
  br i1 %cmp873, label %if.end877, label %lor.lhs.false879

if.end877:                                        ; preds = %land.lhs.true870
  %op_next876 = getelementptr inbounds %struct.op* %361, i64 0, i32 0
  %363 = load %struct.op** %op_next876, align 8, !tbaa !42
  %tobool878 = icmp eq %struct.op* %363, null
  br i1 %tobool878, label %for.inc1165, label %if.end877.lor.lhs.false879_crit_edge

if.end877.lor.lhs.false879_crit_edge:             ; preds = %if.end877
  %op_type880.phi.trans.insert = getelementptr inbounds %struct.op* %363, i64 0, i32 4
  %.pre1648 = load i16* %op_type880.phi.trans.insert, align 2, !tbaa !12
  br label %lor.lhs.false879

lor.lhs.false879:                                 ; preds = %if.end877.lor.lhs.false879_crit_edge, %land.lhs.true870
  %364 = phi i16 [ %.pre1648, %if.end877.lor.lhs.false879_crit_edge ], [ %362, %land.lhs.true870 ]
  %o2.01593 = phi %struct.op* [ %363, %if.end877.lor.lhs.false879_crit_edge ], [ %361, %land.lhs.true870 ]
  switch i16 %364, label %for.inc1165 [
    i16 10, label %lor.lhs.false889
    i16 125, label %lor.lhs.false889
  ]

lor.lhs.false889:                                 ; preds = %lor.lhs.false879, %lor.lhs.false879
  %op_private890 = getelementptr inbounds %struct.op* %o2.01593, i64 0, i32 7
  %365 = load i8* %op_private890, align 1, !tbaa !11
  %tobool893 = icmp slt i8 %365, 0
  br i1 %tobool893, label %for.inc1165, label %if.end895

if.end895:                                        ; preds = %lor.lhs.false889
  %op_next896 = getelementptr inbounds %struct.op* %o2.01593, i64 0, i32 0
  %366 = load %struct.op** %op_next896, align 8, !tbaa !42
  %tobool897 = icmp eq %struct.op* %366, null
  br i1 %tobool897, label %for.inc1165, label %lor.lhs.false898

lor.lhs.false898:                                 ; preds = %if.end895
  %op_type899 = getelementptr inbounds %struct.op* %366, i64 0, i32 4
  %367 = load i16* %op_type899, align 2, !tbaa !12
  %cmp901 = icmp eq i16 %367, 0
  br i1 %cmp901, label %if.end904, label %for.inc1165

if.end904:                                        ; preds = %lor.lhs.false898
  %op_next905 = getelementptr inbounds %struct.op* %366, i64 0, i32 0
  %368 = load %struct.op** %op_next905, align 8, !tbaa !42
  %tobool906 = icmp eq %struct.op* %368, null
  br i1 %tobool906, label %for.inc1165, label %lor.lhs.false907

lor.lhs.false907:                                 ; preds = %if.end904
  %op_type908 = getelementptr inbounds %struct.op* %368, i64 0, i32 4
  %369 = load i16* %op_type908, align 2, !tbaa !12
  %cmp910 = icmp eq i16 %369, 37
  br i1 %cmp910, label %lor.lhs.false912, label %for.inc1165

lor.lhs.false912:                                 ; preds = %lor.lhs.false907
  %op_flags913 = getelementptr inbounds %struct.op* %368, i64 0, i32 6
  %370 = load i8* %op_flags913, align 1, !tbaa !14
  %and915 = and i8 %370, 3
  %cmp916 = icmp eq i8 %and915, 1
  br i1 %cmp916, label %if.end919, label %for.inc1165

if.end919:                                        ; preds = %lor.lhs.false912
  %371 = getelementptr inbounds %struct.op* %368, i64 1, i32 0
  %372 = load %struct.op** %371, align 8, !tbaa !15
  %tobool921 = icmp eq %struct.op* %372, null
  br i1 %tobool921, label %for.inc1165, label %lor.lhs.false922

lor.lhs.false922:                                 ; preds = %if.end919
  %op_type923 = getelementptr inbounds %struct.op* %372, i64 0, i32 4
  %373 = load i16* %op_type923, align 2, !tbaa !12
  %cmp925 = icmp eq i16 %373, 0
  br i1 %cmp925, label %if.end928, label %for.inc1165

if.end928:                                        ; preds = %lor.lhs.false922
  %374 = getelementptr inbounds %struct.op* %372, i64 1, i32 0
  %375 = load %struct.op** %374, align 8, !tbaa !15
  %tobool930 = icmp eq %struct.op* %375, null
  br i1 %tobool930, label %for.inc1165, label %lor.lhs.false931

lor.lhs.false931:                                 ; preds = %if.end928
  %op_type932 = getelementptr inbounds %struct.op* %375, i64 0, i32 4
  %376 = load i16* %op_type932, align 2, !tbaa !12
  %cmp934 = icmp eq i16 %376, 3
  br i1 %cmp934, label %if.end937, label %for.inc1165

if.end937:                                        ; preds = %lor.lhs.false931
  %op_sibling938 = getelementptr inbounds %struct.op* %375, i64 0, i32 1
  %377 = load %struct.op** %op_sibling938, align 8, !tbaa !17
  %cmp939 = icmp eq %struct.op* %377, %1
  br i1 %cmp939, label %if.end942, label %for.inc1165

if.end942:                                        ; preds = %if.end937
  %cmp945 = icmp eq i16 %364, 125
  br i1 %cmp945, label %if.then947, label %if.else970

if.then947:                                       ; preds = %if.end942
  %cmp950 = icmp eq i16 %354, 125
  br i1 %cmp950, label %lor.lhs.false952, label %for.inc1165

lor.lhs.false952:                                 ; preds = %if.then947
  %378 = getelementptr inbounds %struct.op* %oright.01589, i64 1, i32 0
  %379 = load %struct.op** %378, align 8, !tbaa !15
  %tobool954 = icmp eq %struct.op* %379, null
  br i1 %tobool954, label %for.inc1165, label %lor.lhs.false955

lor.lhs.false955:                                 ; preds = %lor.lhs.false952
  %op_type957 = getelementptr inbounds %struct.op* %379, i64 0, i32 4
  %380 = load i16* %op_type957, align 2, !tbaa !12
  %cmp959 = icmp eq i16 %380, 7
  br i1 %cmp959, label %lor.lhs.false961, label %for.inc1165

lor.lhs.false961:                                 ; preds = %lor.lhs.false955
  %381 = getelementptr inbounds %struct.op* %o2.01593, i64 1, i32 0
  %382 = load %struct.op** %381, align 8, !tbaa !15
  %op_sv963 = getelementptr inbounds %struct.op* %382, i64 1
  %383 = bitcast %struct.op* %op_sv963 to %struct.sv**
  %384 = load %struct.sv** %383, align 8, !tbaa !18
  %op_sv965 = getelementptr inbounds %struct.op* %379, i64 1
  %385 = bitcast %struct.op* %op_sv965 to %struct.sv**
  %386 = load %struct.sv** %385, align 8, !tbaa !18
  %cmp966 = icmp eq %struct.sv* %384, %386
  br i1 %cmp966, label %Perl_op_null.exit1546, label %for.inc1165

if.else970:                                       ; preds = %if.end942
  %cmp973 = icmp eq i16 %354, 10
  br i1 %cmp973, label %lor.lhs.false975, label %for.inc1165

lor.lhs.false975:                                 ; preds = %if.else970
  %op_targ976 = getelementptr inbounds %struct.op* %oright.01589, i64 0, i32 3
  %387 = load i64* %op_targ976, align 8, !tbaa !13
  %op_targ977 = getelementptr inbounds %struct.op* %o2.01593, i64 0, i32 3
  %388 = load i64* %op_targ977, align 8, !tbaa !13
  %cmp978 = icmp eq i64 %387, %388
  br i1 %cmp978, label %Perl_op_null.exit1546, label %for.inc1165

Perl_op_null.exit1546:                            ; preds = %lor.lhs.false961, %lor.lhs.false975
  %op_flags983 = getelementptr inbounds %struct.op* %o2.01593, i64 0, i32 6
  %389 = load i8* %op_flags983, align 1, !tbaa !14
  %op_flags984 = getelementptr inbounds %struct.op* %oright.01589, i64 0, i32 6
  store i8 %389, i8* %op_flags984, align 1, !tbaa !14
  %op_private985 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %390 = load i8* %op_private985, align 1, !tbaa !11
  %or987 = or i8 %390, 8
  store i8 %or987, i8* %op_private985, align 1, !tbaa !11
  %call.i1541 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %359) #4
  %391 = load i16* %op_type862, align 2, !tbaa !12
  %conv3.i1542 = zext i16 %391 to i64
  %op_targ.i1543 = getelementptr inbounds %struct.op* %359, i64 0, i32 3
  store i64 %conv3.i1542, i64* %op_targ.i1543, align 8, !tbaa !13
  store i16 0, i16* %op_type862, align 2, !tbaa !12
  %392 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i1544 = getelementptr inbounds %struct.op* %359, i64 0, i32 2
  store %struct.op* ()* %392, %struct.op* ()** %op_ppaddr.i1544, align 8, !tbaa !41
  %.pre1649 = load %struct.op** %op_next868, align 8, !tbaa !42
  %op_type992.phi.trans.insert = getelementptr inbounds %struct.op* %.pre1649, i64 0, i32 4
  %.pre1650 = load i16* %op_type992.phi.trans.insert, align 2, !tbaa !12
  %op_type992 = getelementptr inbounds %struct.op* %.pre1649, i64 0, i32 4
  %cmp994 = icmp eq i16 %.pre1650, 7
  br i1 %cmp994, label %Perl_op_null.exit1554, label %if.end998

Perl_op_null.exit1554:                            ; preds = %Perl_op_null.exit1546
  %call.i1549 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %.pre1649) #4
  %393 = load i16* %op_type992, align 2, !tbaa !12
  %conv3.i1550 = zext i16 %393 to i64
  %op_targ.i1551 = getelementptr inbounds %struct.op* %.pre1649, i64 0, i32 3
  store i64 %conv3.i1550, i64* %op_targ.i1551, align 8, !tbaa !13
  store i16 0, i16* %op_type992, align 2, !tbaa !12
  %394 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i1552 = getelementptr inbounds %struct.op* %.pre1649, i64 0, i32 2
  store %struct.op* ()* %394, %struct.op* ()** %op_ppaddr.i1552, align 8, !tbaa !41
  %op_next997 = getelementptr inbounds %struct.op* %.pre1649, i64 0, i32 0
  %395 = load %struct.op** %op_next997, align 8, !tbaa !42
  %op_type.i1555.phi.trans.insert = getelementptr inbounds %struct.op* %395, i64 0, i32 4
  %.pre1651 = load i16* %op_type.i1555.phi.trans.insert, align 2, !tbaa !12
  br label %if.end998

if.end998:                                        ; preds = %Perl_op_null.exit1554, %Perl_op_null.exit1546
  %396 = phi i16 [ %.pre1651, %Perl_op_null.exit1554 ], [ %.pre1650, %Perl_op_null.exit1546 ]
  %o2.1 = phi %struct.op* [ %395, %Perl_op_null.exit1554 ], [ %.pre1649, %Perl_op_null.exit1546 ]
  %op_type.i1555 = getelementptr inbounds %struct.op* %o2.1, i64 0, i32 4
  %cmp.i1556 = icmp eq i16 %396, 0
  br i1 %cmp.i1556, label %Perl_op_null.exit1562, label %if.end.i1561

if.end.i1561:                                     ; preds = %if.end998
  %call.i1557 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %o2.1) #4
  %397 = load i16* %op_type.i1555, align 2, !tbaa !12
  %conv3.i1558 = zext i16 %397 to i64
  %op_targ.i1559 = getelementptr inbounds %struct.op* %o2.1, i64 0, i32 3
  store i64 %conv3.i1558, i64* %op_targ.i1559, align 8, !tbaa !13
  store i16 0, i16* %op_type.i1555, align 2, !tbaa !12
  %398 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i1560 = getelementptr inbounds %struct.op* %o2.1, i64 0, i32 2
  store %struct.op* ()* %398, %struct.op* ()** %op_ppaddr.i1560, align 8, !tbaa !41
  br label %Perl_op_null.exit1562

Perl_op_null.exit1562:                            ; preds = %if.end998, %if.end.i1561
  %op_next999 = getelementptr inbounds %struct.op* %o2.1, i64 0, i32 0
  %399 = load %struct.op** %op_next999, align 8, !tbaa !42
  %op_next1000 = getelementptr inbounds %struct.op* %399, i64 0, i32 0
  %400 = load %struct.op** %op_next1000, align 8, !tbaa !42
  %op_type.i1563 = getelementptr inbounds %struct.op* %400, i64 0, i32 4
  %401 = load i16* %op_type.i1563, align 2, !tbaa !12
  %cmp.i1564 = icmp eq i16 %401, 0
  br i1 %cmp.i1564, label %Perl_op_null.exit1570, label %if.end.i1569

if.end.i1569:                                     ; preds = %Perl_op_null.exit1562
  %call.i1565 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %400) #4
  %402 = load i16* %op_type.i1563, align 2, !tbaa !12
  %conv3.i1566 = zext i16 %402 to i64
  %op_targ.i1567 = getelementptr inbounds %struct.op* %400, i64 0, i32 3
  store i64 %conv3.i1566, i64* %op_targ.i1567, align 8, !tbaa !13
  store i16 0, i16* %op_type.i1563, align 2, !tbaa !12
  %403 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i1568 = getelementptr inbounds %struct.op* %400, i64 0, i32 2
  store %struct.op* ()* %403, %struct.op* ()** %op_ppaddr.i1568, align 8, !tbaa !41
  br label %Perl_op_null.exit1570

Perl_op_null.exit1570:                            ; preds = %Perl_op_null.exit1562, %if.end.i1569
  %op_next1001 = getelementptr inbounds %struct.op* %400, i64 0, i32 0
  %404 = load %struct.op** %op_next1001, align 8, !tbaa !42
  store %struct.op* %404, %struct.op** %op_next850, align 8, !tbaa !42
  br label %for.inc1165

sw.bb1003:                                        ; preds = %if.end12
  %inc1004 = add i16 %4, 1
  store i16 %inc1004, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %4, i16* %op_seq3, align 2, !tbaa !8
  %op_next1006 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %405 = load %struct.op** %op_next1006, align 8, !tbaa !42
  %tobool1007 = icmp eq %struct.op* %405, null
  br i1 %tobool1007, label %for.inc1165, label %if.end1009

if.end1009:                                       ; preds = %sw.bb1003
  %406 = getelementptr inbounds %struct.op* %405, i64 0, i32 4
  %407 = load i16* %406, align 2, !tbaa !89
  %cmp1012 = icmp eq i16 %407, 0
  br i1 %cmp1012, label %if.then1014, label %if.end1019

if.then1014:                                      ; preds = %if.end1009
  %op_next1015 = getelementptr inbounds %struct.op* %405, i64 0, i32 0
  %408 = load %struct.op** %op_next1015, align 8, !tbaa !174
  %tobool1016 = icmp eq %struct.op* %408, null
  br i1 %tobool1016, label %for.inc1165, label %if.then1014.if.end1019_crit_edge

if.then1014.if.end1019_crit_edge:                 ; preds = %if.then1014
  %.phi.trans.insert = getelementptr inbounds %struct.op* %408, i64 0, i32 4
  %.pre1652 = load i16* %.phi.trans.insert, align 2, !tbaa !89
  br label %if.end1019

if.end1019:                                       ; preds = %if.then1014.if.end1019_crit_edge, %if.end1009
  %409 = phi i16 [ %.pre1652, %if.then1014.if.end1019_crit_edge ], [ %407, %if.end1009 ]
  %enter.0.in = phi %struct.op* [ %408, %if.then1014.if.end1019_crit_edge ], [ %405, %if.end1009 ]
  %cmp1022 = icmp eq i16 %409, 7
  br i1 %cmp1022, label %if.then1024, label %if.end1039

if.then1024:                                      ; preds = %if.end1019
  %op_next1025 = getelementptr inbounds %struct.op* %enter.0.in, i64 0, i32 0
  %410 = load %struct.op** %op_next1025, align 8, !tbaa !174
  %tobool1026 = icmp eq %struct.op* %410, null
  br i1 %tobool1026, label %for.inc1165, label %if.end1028

if.end1028:                                       ; preds = %if.then1024
  %411 = getelementptr inbounds %struct.op* %410, i64 0, i32 4
  %412 = load i16* %411, align 2, !tbaa !89
  %cmp1031 = icmp eq i16 %412, 14
  br i1 %cmp1031, label %if.then1033, label %if.end1039

if.then1033:                                      ; preds = %if.end1028
  %op_next1034 = getelementptr inbounds %struct.op* %410, i64 0, i32 0
  %413 = load %struct.op** %op_next1034, align 8, !tbaa !174
  %tobool1035 = icmp eq %struct.op* %413, null
  br i1 %tobool1035, label %for.inc1165, label %if.then1033.if.end1039_crit_edge

if.then1033.if.end1039_crit_edge:                 ; preds = %if.then1033
  %.phi.trans.insert1653 = getelementptr inbounds %struct.op* %413, i64 0, i32 4
  %.pre1654 = load i16* %.phi.trans.insert1653, align 2, !tbaa !89
  br label %if.end1039

if.end1039:                                       ; preds = %if.then1033.if.end1039_crit_edge, %if.end1028, %if.end1019
  %414 = phi i16 [ %.pre1654, %if.then1033.if.end1039_crit_edge ], [ %412, %if.end1028 ], [ %409, %if.end1019 ]
  %gvop.0 = phi %struct.op* [ %enter.0.in, %if.then1033.if.end1039_crit_edge ], [ %enter.0.in, %if.end1028 ], [ null, %if.end1019 ]
  %enter.1.in = phi %struct.op* [ %413, %if.then1033.if.end1039_crit_edge ], [ %410, %if.end1028 ], [ %enter.0.in, %if.end1019 ]
  %cmp1042 = icmp eq i16 %414, 180
  br i1 %cmp1042, label %if.end1045, label %for.inc1165

if.end1045:                                       ; preds = %if.end1039
  %op_next1046 = getelementptr inbounds %struct.op* %enter.1.in, i64 0, i32 0
  %415 = load %struct.op** %op_next1046, align 8, !tbaa !174
  %tobool1047 = icmp eq %struct.op* %415, null
  br i1 %tobool1047, label %for.inc1165, label %lor.lhs.false1048

lor.lhs.false1048:                                ; preds = %if.end1045
  %op_type1049 = getelementptr inbounds %struct.op* %415, i64 0, i32 4
  %416 = load i16* %op_type1049, align 2, !tbaa !12
  %cmp1051 = icmp eq i16 %416, 181
  br i1 %cmp1051, label %if.end1054, label %for.inc1165

if.end1054:                                       ; preds = %lor.lhs.false1048
  %417 = getelementptr inbounds %struct.op* %enter.1.in, i64 1, i32 0
  %418 = load %struct.op** %417, align 8, !tbaa !45
  %tobool1056 = icmp eq %struct.op* %418, null
  br i1 %tobool1056, label %for.inc1165, label %lor.lhs.false1057

lor.lhs.false1057:                                ; preds = %if.end1054
  %op_type1058 = getelementptr inbounds %struct.op* %418, i64 0, i32 4
  %419 = load i16* %op_type1058, align 2, !tbaa !12
  %cmp1060 = icmp eq i16 %419, 0
  br i1 %cmp1060, label %lor.lhs.false1062, label %for.inc1165

lor.lhs.false1062:                                ; preds = %lor.lhs.false1057
  %op_targ1063 = getelementptr inbounds %struct.op* %418, i64 0, i32 3
  %420 = load i64* %op_targ1063, align 8, !tbaa !13
  %cmp1064 = icmp eq i64 %420, 3
  br i1 %cmp1064, label %if.end1067, label %for.inc1165

if.end1067:                                       ; preds = %lor.lhs.false1062
  %op_sibling1068 = getelementptr inbounds %struct.op* %418, i64 0, i32 1
  %421 = load %struct.op** %op_sibling1068, align 8, !tbaa !17
  %tobool1069 = icmp eq %struct.op* %421, null
  br i1 %tobool1069, label %for.inc1165, label %lor.lhs.false1070

lor.lhs.false1070:                                ; preds = %if.end1067
  %422 = getelementptr inbounds %struct.op* %421, i64 0, i32 4
  %423 = load i16* %422, align 2, !tbaa !89
  %cmp1073 = icmp eq i16 %423, 0
  br i1 %cmp1073, label %lor.lhs.false1075, label %for.inc1165

lor.lhs.false1075:                                ; preds = %lor.lhs.false1070
  %424 = getelementptr inbounds %struct.op* %421, i64 0, i32 3
  %425 = load i64* %424, align 8, !tbaa !185
  %cmp1077 = icmp eq i64 %425, 141
  br i1 %cmp1077, label %if.end1080, label %for.inc1165

if.end1080:                                       ; preds = %lor.lhs.false1075
  %426 = getelementptr inbounds %struct.op* %421, i64 1, i32 1
  %427 = load %struct.op** %426, align 8, !tbaa !70
  %cmp1082 = icmp eq %struct.op* %427, %1
  br i1 %cmp1082, label %if.end1085, label %for.inc1165

if.end1085:                                       ; preds = %if.end1080
  %428 = getelementptr inbounds %struct.op* %421, i64 1, i32 0
  %429 = load %struct.op** %428, align 8, !tbaa !45
  %tobool1087 = icmp eq %struct.op* %429, null
  br i1 %tobool1087, label %for.inc1165, label %lor.lhs.false1088

lor.lhs.false1088:                                ; preds = %if.end1085
  %op_type1089 = getelementptr inbounds %struct.op* %429, i64 0, i32 4
  %430 = load i16* %op_type1089, align 2, !tbaa !12
  %cmp1091 = icmp eq i16 %430, 3
  br i1 %cmp1091, label %if.end1094, label %for.inc1165

if.end1094:                                       ; preds = %lor.lhs.false1088
  %op_sibling1095 = getelementptr inbounds %struct.op* %429, i64 0, i32 1
  %431 = load %struct.op** %op_sibling1095, align 8, !tbaa !17
  %cmp1096 = icmp eq %struct.op* %431, %1
  br i1 %cmp1096, label %if.end1099, label %for.inc1165

if.end1099:                                       ; preds = %if.end1094
  %432 = getelementptr inbounds %struct.op* %1, i64 1, i32 0
  %433 = load %struct.op** %432, align 8, !tbaa !45
  %tobool1101 = icmp eq %struct.op* %433, null
  br i1 %tobool1101, label %for.inc1165, label %lor.lhs.false1102

lor.lhs.false1102:                                ; preds = %if.end1099
  %op_type1103 = getelementptr inbounds %struct.op* %433, i64 0, i32 4
  %434 = load i16* %op_type1103, align 2, !tbaa !12
  %cmp1105 = icmp eq i16 %434, 3
  br i1 %cmp1105, label %if.end1108, label %for.inc1165

if.end1108:                                       ; preds = %lor.lhs.false1102
  %435 = getelementptr inbounds %struct.op* %1, i64 1, i32 1
  %436 = load %struct.op** %435, align 8, !tbaa !70
  %tobool1110 = icmp eq %struct.op* %436, null
  br i1 %tobool1110, label %for.inc1165, label %lor.lhs.false1111

lor.lhs.false1111:                                ; preds = %if.end1108
  %op_next1112 = getelementptr inbounds %struct.op* %436, i64 0, i32 0
  %437 = load %struct.op** %op_next1112, align 8, !tbaa !42
  %cmp1113 = icmp eq %struct.op* %437, %1
  br i1 %cmp1113, label %if.end1116, label %for.inc1165

if.end1116:                                       ; preds = %lor.lhs.false1111
  %op_sibling1117 = getelementptr inbounds %struct.op* %433, i64 0, i32 1
  %438 = load %struct.op** %op_sibling1117, align 8, !tbaa !17
  %tobool1118 = icmp eq %struct.op* %438, null
  br i1 %tobool1118, label %Perl_op_null.exit1578, label %land.lhs.true1119

land.lhs.true1119:                                ; preds = %if.end1116
  %op_type1120 = getelementptr inbounds %struct.op* %438, i64 0, i32 4
  %439 = load i16* %op_type1120, align 2, !tbaa !12
  %cmp1122 = icmp eq i16 %439, 125
  br i1 %cmp1122, label %land.lhs.true1124, label %Perl_op_null.exit1578

land.lhs.true1124:                                ; preds = %land.lhs.true1119
  %op_sibling1125 = getelementptr inbounds %struct.op* %438, i64 0, i32 1
  %440 = load %struct.op** %op_sibling1125, align 8, !tbaa !17
  %cmp1126 = icmp eq %struct.op* %440, null
  br i1 %cmp1126, label %land.lhs.true1128, label %Perl_op_null.exit1578

land.lhs.true1128:                                ; preds = %land.lhs.true1124
  %op_flags1129 = getelementptr inbounds %struct.op* %438, i64 0, i32 6
  %441 = load i8* %op_flags1129, align 1, !tbaa !14
  %cmp1131 = icmp eq i8 %441, 7
  br i1 %cmp1131, label %land.lhs.true1133, label %Perl_op_null.exit1578

land.lhs.true1133:                                ; preds = %land.lhs.true1128
  %442 = getelementptr inbounds %struct.op* %enter.1.in, i64 0, i32 6
  %443 = load i8* %442, align 1, !tbaa !91
  %cmp1136 = icmp eq i8 %443, 7
  br i1 %cmp1136, label %if.then1138, label %Perl_op_null.exit1578

if.then1138:                                      ; preds = %land.lhs.true1133
  store i8 22, i8* %op_flags1129, align 1, !tbaa !14
  store i8 71, i8* %442, align 1, !tbaa !91
  br label %Perl_op_null.exit1578

Perl_op_null.exit1578:                            ; preds = %if.end1116, %if.then1138, %land.lhs.true1133, %land.lhs.true1128, %land.lhs.true1124, %land.lhs.true1119
  %op_next1145 = getelementptr inbounds %struct.op* %433, i64 0, i32 0
  %444 = load %struct.op** %op_next1145, align 8, !tbaa !42
  %op_next1146 = getelementptr inbounds %struct.op* %429, i64 0, i32 0
  store %struct.op* %444, %struct.op** %op_next1146, align 8, !tbaa !42
  %op_flags1147 = getelementptr inbounds %struct.op* %433, i64 0, i32 6
  %445 = load i8* %op_flags1147, align 1, !tbaa !14
  %op_flags1148 = getelementptr inbounds %struct.op* %429, i64 0, i32 6
  store i8 %445, i8* %op_flags1148, align 1, !tbaa !14
  %tobool1149 = icmp eq %struct.op* %gvop.0, null
  %enter.1.in.gvop.0 = select i1 %tobool1149, %struct.op* %enter.1.in, %struct.op* %gvop.0
  store %struct.op* %enter.1.in.gvop.0, %struct.op** %op_next1112, align 8, !tbaa !42
  %call.i1573 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %433) #4
  %446 = load i16* %op_type1103, align 2, !tbaa !12
  %conv3.i1574 = zext i16 %446 to i64
  %op_targ.i1575 = getelementptr inbounds %struct.op* %433, i64 0, i32 3
  store i64 %conv3.i1574, i64* %op_targ.i1575, align 8, !tbaa !13
  store i16 0, i16* %op_type1103, align 2, !tbaa !12
  %447 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i1576 = getelementptr inbounds %struct.op* %433, i64 0, i32 2
  store %struct.op* ()* %447, %struct.op* ()** %op_ppaddr.i1576, align 8, !tbaa !41
  %448 = load i16* %op_type, align 2, !tbaa !12
  %cmp.i1580 = icmp eq i16 %448, 0
  br i1 %cmp.i1580, label %Perl_op_null.exit1586, label %if.end.i1585

if.end.i1585:                                     ; preds = %Perl_op_null.exit1578
  %call.i1581 = call i32 (%struct.op*, ...)* bitcast (i32 (...)* @op_clear to i32 (%struct.op*, ...)*)(%struct.op* %1) #4
  %449 = load i16* %op_type, align 2, !tbaa !12
  %conv3.i1582 = zext i16 %449 to i64
  %op_targ.i1583 = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  store i64 %conv3.i1582, i64* %op_targ.i1583, align 8, !tbaa !13
  store i16 0, i16* %op_type, align 2, !tbaa !12
  %450 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !6
  %op_ppaddr.i1584 = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %450, %struct.op* ()** %op_ppaddr.i1584, align 8, !tbaa !41
  br label %Perl_op_null.exit1586

Perl_op_null.exit1586:                            ; preds = %Perl_op_null.exit1578, %if.end.i1585
  %451 = getelementptr inbounds %struct.op* %enter.1.in, i64 0, i32 7
  %452 = load i8* %451, align 1, !tbaa !186
  %or1157 = or i8 %452, 4
  store i8 %or1157, i8* %451, align 1, !tbaa !186
  %op_private1159 = getelementptr inbounds %struct.op* %415, i64 0, i32 7
  %453 = load i8* %op_private1159, align 1, !tbaa !11
  %or1161 = or i8 %453, 4
  store i8 %or1161, i8* %op_private1159, align 1, !tbaa !11
  br label %for.inc1165

sw.default:                                       ; preds = %if.end12
  %inc1163 = add i16 %4, 1
  store i16 %inc1163, i16* @PL_op_seqmax, align 2, !tbaa !100
  store i16 %4, i16* %op_seq3, align 2, !tbaa !8
  br label %for.inc1165

for.inc1165.critedge:                             ; preds = %if.end669
  store i16 125, i16* %267, align 2, !tbaa !56
  %454 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 125), align 8, !tbaa !6
  %455 = getelementptr inbounds %struct.op* %266, i64 0, i32 2
  store %struct.op* ()* %454, %struct.op* ()** %455, align 8, !tbaa !57
  store i16 128, i16* %op_type, align 2, !tbaa !12
  %456 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 128), align 8, !tbaa !6
  %op_ppaddr690.c = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %456, %struct.op* ()** %op_ppaddr690.c, align 8, !tbaa !41
  br label %for.inc1165

for.inc1165:                                      ; preds = %for.body676, %if.end761, %for.inc1165.critedge, %if.end686, %if.end867, %sw.bb, %if.end20, %ignore_optimization, %if.then60, %if.end94, %if.end207, %if.end321, %while.end, %while.end372, %while.end389, %if.end608, %Perl_op_null.exit1570, %Perl_op_null.exit1586, %sw.default, %if.then455, %land.lhs.true425, %lor.lhs.false414, %if.end503, %sw.bb613, %lor.lhs.false843, %lor.lhs.false889, %sw.bb1003, %if.end1039, %if.end1045, %lor.lhs.false1048, %if.end1054, %lor.lhs.false1057, %lor.lhs.false1062, %if.end1067, %lor.lhs.false1070, %lor.lhs.false1075, %if.end1080, %if.end1085, %lor.lhs.false1088, %if.end1094, %if.end1099, %lor.lhs.false1102, %if.end1108, %lor.lhs.false1111, %if.then1024, %if.then1033, %if.then1014, %sw.bb769, %lor.lhs.false772, %if.end814, %if.end827, %lor.lhs.false839, %if.end849, %lor.lhs.false852, %if.end858, %lor.lhs.false861, %if.end877, %if.end895, %lor.lhs.false898, %if.end904, %lor.lhs.false907, %lor.lhs.false912, %if.end919, %lor.lhs.false922, %if.end928, %lor.lhs.false931, %if.end937, %if.else970, %lor.lhs.false975, %if.then947, %lor.lhs.false952, %lor.lhs.false955, %lor.lhs.false961, %lor.lhs.false629, %if.end637, %lor.lhs.false643, %if.end650, %if.end658, %lor.lhs.false663, %sw.bb462, %if.end509, %lor.lhs.false514, %if.end521, %if.end529, %lor.lhs.false533, %land.lhs.true418, %land.lhs.true422, %if.then431, %if.end77, %land.lhs.true79, %land.lhs.true434, %land.lhs.true434, %land.lhs.true434, %lor.lhs.false829, %lor.lhs.false879, %if.then91, %if.then82
  %oldop.1 = phi %struct.op* [ %oldop.01622, %if.then91 ], [ %oldop.01622, %if.then82 ], [ %1, %lor.lhs.false879 ], [ %1, %lor.lhs.false829 ], [ %1, %land.lhs.true434 ], [ %1, %land.lhs.true434 ], [ %1, %land.lhs.true434 ], [ %1, %land.lhs.true79 ], [ %1, %if.end77 ], [ %1, %if.then431 ], [ %1, %land.lhs.true422 ], [ %1, %land.lhs.true418 ], [ %1, %lor.lhs.false533 ], [ %1, %if.end529 ], [ %1, %if.end521 ], [ %1, %lor.lhs.false514 ], [ %1, %if.end509 ], [ %1, %sw.bb462 ], [ %1, %lor.lhs.false663 ], [ %1, %if.end658 ], [ %1, %if.end650 ], [ %1, %lor.lhs.false643 ], [ %1, %if.end637 ], [ %1, %lor.lhs.false629 ], [ %1, %lor.lhs.false961 ], [ %1, %lor.lhs.false955 ], [ %1, %lor.lhs.false952 ], [ %1, %if.then947 ], [ %1, %lor.lhs.false975 ], [ %1, %if.else970 ], [ %1, %if.end937 ], [ %1, %lor.lhs.false931 ], [ %1, %if.end928 ], [ %1, %lor.lhs.false922 ], [ %1, %if.end919 ], [ %1, %lor.lhs.false912 ], [ %1, %lor.lhs.false907 ], [ %1, %if.end904 ], [ %1, %lor.lhs.false898 ], [ %1, %if.end895 ], [ %1, %if.end877 ], [ %1, %lor.lhs.false861 ], [ %1, %if.end858 ], [ %1, %lor.lhs.false852 ], [ %1, %if.end849 ], [ %1, %lor.lhs.false839 ], [ %1, %if.end827 ], [ %1, %if.end814 ], [ %1, %lor.lhs.false772 ], [ %1, %sw.bb769 ], [ %1, %if.then1014 ], [ %1, %if.then1033 ], [ %1, %if.then1024 ], [ %1, %lor.lhs.false1111 ], [ %1, %if.end1108 ], [ %1, %lor.lhs.false1102 ], [ %1, %if.end1099 ], [ %1, %if.end1094 ], [ %1, %lor.lhs.false1088 ], [ %1, %if.end1085 ], [ %1, %if.end1080 ], [ %1, %lor.lhs.false1075 ], [ %1, %lor.lhs.false1070 ], [ %1, %if.end1067 ], [ %1, %lor.lhs.false1062 ], [ %1, %lor.lhs.false1057 ], [ %1, %if.end1054 ], [ %1, %lor.lhs.false1048 ], [ %1, %if.end1045 ], [ %1, %if.end1039 ], [ %1, %sw.bb1003 ], [ %1, %lor.lhs.false889 ], [ %1, %lor.lhs.false843 ], [ %1, %sw.bb613 ], [ %1, %if.end503 ], [ %1, %lor.lhs.false414 ], [ %1, %land.lhs.true425 ], [ %1, %if.then455 ], [ %1, %sw.default ], [ %1, %Perl_op_null.exit1586 ], [ %1, %Perl_op_null.exit1570 ], [ %1, %if.end608 ], [ %1, %while.end389 ], [ %1, %while.end372 ], [ %1, %while.end ], [ %1, %if.end321 ], [ %1, %if.end207 ], [ %1, %if.end94 ], [ %1, %if.then60 ], [ %1, %ignore_optimization ], [ %1, %if.end20 ], [ %1, %sw.bb ], [ %1, %if.end867 ], [ %1, %if.end686 ], [ %1, %for.inc1165.critedge ], [ %1, %if.end761 ], [ %1, %for.body676 ]
  %op_next1166 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %457 = load %struct.op** %op_next1166, align 8, !tbaa !42
  %tobool2 = icmp eq %struct.op* %457, null
  br i1 %tobool2, label %for.end1167, label %for.body

for.end1167:                                      ; preds = %for.inc1165, %for.body
  call void @Perl_pop_scope() #4
  br label %return

return:                                           ; preds = %lor.lhs.false, %entry, %for.end1167
  ret void
}

declare i32 @save_op(...) #2

declare void @Perl_save_vptr(i8*) #2

declare %struct.gv* @Perl_gv_AVadd(%struct.gv*) #2

declare i32 @peep(...) #2

; Function Attrs: nounwind uwtable
define i8* @Perl_custom_op_name(%struct.op* nocapture readonly %o) #0 {
entry:
  %0 = load %struct.hv** @PL_custom_op_names, align 8, !tbaa !6
  %tobool = icmp eq %struct.hv* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_name, i64 0, i64 351), align 8, !tbaa !6
  br label %return

if.end:                                           ; preds = %entry
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  %2 = load %struct.op* ()** %op_ppaddr, align 8, !tbaa !41
  %3 = ptrtoint %struct.op* ()* %2 to i64
  %call = tail call %struct.sv* @Perl_newSViv(i64 %3) #4
  %call1 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call) #4
  %4 = load %struct.hv** @PL_custom_op_names, align 8, !tbaa !6
  %call2 = tail call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %4, %struct.sv* %call1, i64 0, i64 0) #4
  %tobool3 = icmp eq %struct.he* %call2, null
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %5 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_name, i64 0, i64 351), align 8, !tbaa !6
  br label %return

if.end5:                                          ; preds = %if.end
  %hent_val = getelementptr inbounds %struct.he* %call2, i64 0, i32 2
  %6 = load %struct.sv** %hent_val, align 8, !tbaa !49
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i64* %sv_flags, align 8, !tbaa !34
  %and = and i64 %7, 262144
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end5
  %sv_any = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !36
  %xpv_pv = bitcast i8* %8 to i8**
  %9 = load i8** %xpv_pv, align 8, !tbaa !39
  br label %return

cond.false:                                       ; preds = %if.end5
  %call8 = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %6) #4
  br label %return

return:                                           ; preds = %cond.true, %cond.false, %if.then4, %if.then
  %retval.0 = phi i8* [ %5, %if.then4 ], [ %1, %if.then ], [ %9, %cond.true ], [ %call8, %cond.false ]
  ret i8* %retval.0
}

declare %struct.he* @Perl_hv_fetch_ent(%struct.hv*, %struct.sv*, i64, i64) #2

; Function Attrs: nounwind readonly
declare i8* @memchr(i8*, i32, i64) #6

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #4

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #4

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readnone uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind }
attributes #5 = { nounwind readonly uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readonly }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5 (trunk)"}
!1 = metadata !{metadata !2, metadata !2, i64 0}
!2 = metadata !{metadata !"long", metadata !3, i64 0}
!3 = metadata !{metadata !"omnipotent char", metadata !4, i64 0}
!4 = metadata !{metadata !"Simple C/C++ TBAA"}
!5 = metadata !{metadata !3, metadata !3, i64 0}
!6 = metadata !{metadata !7, metadata !7, i64 0}
!7 = metadata !{metadata !"any pointer", metadata !3, i64 0}
!8 = metadata !{metadata !9, metadata !10, i64 34}
!9 = metadata !{metadata !"op", metadata !7, i64 0, metadata !7, i64 8, metadata !7, i64 16, metadata !2, i64 24, metadata !10, i64 32, metadata !10, i64 34, metadata !3, i64 36, metadata !3, i64 37}
!10 = metadata !{metadata !"short", metadata !3, i64 0}
!11 = metadata !{metadata !9, metadata !3, i64 37}
!12 = metadata !{metadata !9, metadata !10, i64 32}
!13 = metadata !{metadata !9, metadata !2, i64 24}
!14 = metadata !{metadata !9, metadata !3, i64 36}
!15 = metadata !{metadata !16, metadata !7, i64 40}
!16 = metadata !{metadata !"unop", metadata !7, i64 0, metadata !7, i64 8, metadata !7, i64 16, metadata !2, i64 24, metadata !10, i64 32, metadata !10, i64 34, metadata !3, i64 36, metadata !3, i64 37, metadata !7, i64 40}
!17 = metadata !{metadata !9, metadata !7, i64 8}
!18 = metadata !{metadata !19, metadata !7, i64 40}
!19 = metadata !{metadata !"svop", metadata !7, i64 0, metadata !7, i64 8, metadata !7, i64 16, metadata !2, i64 24, metadata !10, i64 32, metadata !10, i64 34, metadata !3, i64 36, metadata !3, i64 37, metadata !7, i64 40}
!20 = metadata !{metadata !21, metadata !7, i64 40}
!21 = metadata !{metadata !"pvop", metadata !7, i64 0, metadata !7, i64 8, metadata !7, i64 16, metadata !2, i64 24, metadata !10, i64 32, metadata !10, i64 34, metadata !3, i64 36, metadata !3, i64 37, metadata !7, i64 40}
!22 = metadata !{metadata !23, metadata !7, i64 112}
!23 = metadata !{metadata !"pmop", metadata !7, i64 0, metadata !7, i64 8, metadata !7, i64 16, metadata !2, i64 24, metadata !10, i64 32, metadata !10, i64 34, metadata !3, i64 36, metadata !3, i64 37, metadata !7, i64 40, metadata !7, i64 48, metadata !7, i64 56, metadata !7, i64 64, metadata !7, i64 72, metadata !7, i64 80, metadata !2, i64 88, metadata !2, i64 96, metadata !3, i64 104, metadata !7, i64 112}
!24 = metadata !{metadata !25, metadata !2, i64 8}
!25 = metadata !{metadata !"hv", metadata !7, i64 0, metadata !2, i64 8, metadata !2, i64 16}
!26 = metadata !{metadata !25, metadata !7, i64 0}
!27 = metadata !{metadata !23, metadata !7, i64 72}
!28 = metadata !{metadata !29, metadata !7, i64 72}
!29 = metadata !{metadata !"xpvhv", metadata !7, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !2, i64 24, metadata !30, i64 32, metadata !7, i64 40, metadata !7, i64 48, metadata !2, i64 56, metadata !7, i64 64, metadata !7, i64 72, metadata !7, i64 80}
!30 = metadata !{metadata !"double", metadata !3, i64 0}
!31 = metadata !{metadata !23, metadata !7, i64 56}
!32 = metadata !{metadata !23, metadata !7, i64 80}
!33 = metadata !{metadata !19, metadata !3, i64 37}
!34 = metadata !{metadata !35, metadata !2, i64 16}
!35 = metadata !{metadata !"sv", metadata !7, i64 0, metadata !2, i64 8, metadata !2, i64 16}
!36 = metadata !{metadata !35, metadata !7, i64 0}
!37 = metadata !{metadata !38, metadata !2, i64 8}
!38 = metadata !{metadata !"xpv", metadata !7, i64 0, metadata !2, i64 8, metadata !2, i64 16}
!39 = metadata !{metadata !38, metadata !7, i64 0}
!40 = metadata !{metadata !35, metadata !2, i64 8}
!41 = metadata !{metadata !9, metadata !7, i64 16}
!42 = metadata !{metadata !9, metadata !7, i64 0}
!43 = metadata !{metadata !44, metadata !7, i64 40}
!44 = metadata !{metadata !"binop", metadata !7, i64 0, metadata !7, i64 8, metadata !7, i64 16, metadata !2, i64 24, metadata !10, i64 32, metadata !10, i64 34, metadata !3, i64 36, metadata !3, i64 37, metadata !7, i64 40, metadata !7, i64 48}
!45 = metadata !{metadata !46, metadata !7, i64 40}
!46 = metadata !{metadata !"listop", metadata !7, i64 0, metadata !7, i64 8, metadata !7, i64 16, metadata !2, i64 24, metadata !10, i64 32, metadata !10, i64 34, metadata !3, i64 36, metadata !3, i64 37, metadata !7, i64 40, metadata !7, i64 48}
!47 = metadata !{metadata !48, metadata !7, i64 88}
!48 = metadata !{metadata !"cop", metadata !7, i64 0, metadata !7, i64 8, metadata !7, i64 16, metadata !2, i64 24, metadata !10, i64 32, metadata !10, i64 34, metadata !3, i64 36, metadata !3, i64 37, metadata !7, i64 40, metadata !7, i64 48, metadata !7, i64 56, metadata !2, i64 64, metadata !2, i64 72, metadata !2, i64 80, metadata !7, i64 88, metadata !7, i64 96}
!49 = metadata !{metadata !50, metadata !7, i64 16}
!50 = metadata !{metadata !"he", metadata !7, i64 0, metadata !7, i64 8, metadata !7, i64 16}
!51 = metadata !{metadata !52, metadata !30, i64 32}
!52 = metadata !{metadata !"xpvnv", metadata !7, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !2, i64 24, metadata !30, i64 32}
!53 = metadata !{metadata !54, metadata !2, i64 24}
!54 = metadata !{metadata !"xpviv", metadata !7, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !2, i64 24}
!55 = metadata !{metadata !48, metadata !2, i64 72}
!56 = metadata !{metadata !16, metadata !10, i64 32}
!57 = metadata !{metadata !16, metadata !7, i64 16}
!58 = metadata !{metadata !16, metadata !7, i64 0}
!59 = metadata !{metadata !16, metadata !3, i64 37}
!60 = metadata !{metadata !61, metadata !7, i64 0}
!61 = metadata !{metadata !"gv", metadata !7, i64 0, metadata !2, i64 8, metadata !2, i64 16}
!62 = metadata !{metadata !63, metadata !7, i64 56}
!63 = metadata !{metadata !"xpvgv", metadata !7, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !2, i64 24, metadata !30, i64 32, metadata !7, i64 40, metadata !7, i64 48, metadata !7, i64 56, metadata !7, i64 64, metadata !2, i64 72, metadata !7, i64 80, metadata !3, i64 88}
!64 = metadata !{metadata !65, metadata !7, i64 56}
!65 = metadata !{metadata !"gp", metadata !7, i64 0, metadata !2, i64 8, metadata !7, i64 16, metadata !7, i64 24, metadata !7, i64 32, metadata !7, i64 40, metadata !7, i64 48, metadata !7, i64 56, metadata !2, i64 64, metadata !2, i64 72, metadata !2, i64 80, metadata !7, i64 88}
!66 = metadata !{metadata !67, metadata !7, i64 0}
!67 = metadata !{metadata !"cv", metadata !7, i64 0, metadata !2, i64 8, metadata !2, i64 16}
!68 = metadata !{metadata !69, metadata !10, i64 136}
!69 = metadata !{metadata !"xpvcv", metadata !7, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !2, i64 24, metadata !30, i64 32, metadata !7, i64 40, metadata !7, i64 48, metadata !7, i64 56, metadata !7, i64 64, metadata !7, i64 72, metadata !7, i64 80, metadata !3, i64 88, metadata !7, i64 96, metadata !7, i64 104, metadata !2, i64 112, metadata !7, i64 120, metadata !7, i64 128, metadata !10, i64 136, metadata !2, i64 144}
!70 = metadata !{metadata !46, metadata !7, i64 48}
!71 = metadata !{metadata !19, metadata !10, i64 32}
!72 = metadata !{metadata !19, metadata !7, i64 16}
!73 = metadata !{metadata !19, metadata !7, i64 0}
!74 = metadata !{metadata !19, metadata !3, i64 36}
!75 = metadata !{metadata !19, metadata !2, i64 24}
!76 = metadata !{metadata !44, metadata !10, i64 32}
!77 = metadata !{metadata !44, metadata !7, i64 16}
!78 = metadata !{metadata !44, metadata !3, i64 36}
!79 = metadata !{metadata !44, metadata !3, i64 37}
!80 = metadata !{metadata !44, metadata !7, i64 0}
!81 = metadata !{metadata !44, metadata !7, i64 48}
!82 = metadata !{metadata !16, metadata !3, i64 36}
!83 = metadata !{metadata !23, metadata !10, i64 32}
!84 = metadata !{metadata !23, metadata !7, i64 16}
!85 = metadata !{metadata !23, metadata !3, i64 36}
!86 = metadata !{metadata !23, metadata !3, i64 37}
!87 = metadata !{metadata !23, metadata !2, i64 96}
!88 = metadata !{metadata !23, metadata !2, i64 88}
!89 = metadata !{metadata !46, metadata !10, i64 32}
!90 = metadata !{metadata !46, metadata !7, i64 16}
!91 = metadata !{metadata !46, metadata !3, i64 36}
!92 = metadata !{metadata !93, metadata !93, i64 0}
!93 = metadata !{metadata !"int", metadata !3, i64 0}
!94 = metadata !{metadata !65, metadata !7, i64 40}
!95 = metadata !{metadata !48, metadata !7, i64 96}
!96 = metadata !{metadata !48, metadata !3, i64 37}
!97 = metadata !{metadata !48, metadata !7, i64 56}
!98 = metadata !{metadata !99, metadata !7, i64 0}
!99 = metadata !{metadata !"xrv", metadata !7, i64 0}
!100 = metadata !{metadata !10, metadata !10, i64 0}
!101 = metadata !{metadata !101, metadata !102, metadata !103}
!102 = metadata !{metadata !"llvm.vectorizer.width", i32 1}
!103 = metadata !{metadata !"llvm.vectorizer.unroll", i32 1}
!104 = metadata !{metadata !104, metadata !102, metadata !103}
!105 = metadata !{metadata !23, metadata !3, i64 104}
!106 = metadata !{metadata !107, metadata !7, i64 32}
!107 = metadata !{metadata !"regexp", metadata !7, i64 0, metadata !7, i64 8, metadata !7, i64 16, metadata !7, i64 24, metadata !7, i64 32, metadata !7, i64 40, metadata !7, i64 48, metadata !7, i64 56, metadata !2, i64 64, metadata !2, i64 72, metadata !2, i64 80, metadata !2, i64 88, metadata !2, i64 96, metadata !2, i64 104, metadata !2, i64 112, metadata !2, i64 120, metadata !3, i64 128}
!108 = metadata !{metadata !109, metadata !10, i64 32}
!109 = metadata !{metadata !"logop", metadata !7, i64 0, metadata !7, i64 8, metadata !7, i64 16, metadata !2, i64 24, metadata !10, i64 32, metadata !10, i64 34, metadata !3, i64 36, metadata !3, i64 37, metadata !7, i64 40, metadata !7, i64 48}
!110 = metadata !{metadata !109, metadata !7, i64 16}
!111 = metadata !{metadata !109, metadata !7, i64 40}
!112 = metadata !{metadata !109, metadata !3, i64 36}
!113 = metadata !{metadata !109, metadata !3, i64 37}
!114 = metadata !{metadata !109, metadata !7, i64 48}
!115 = metadata !{metadata !109, metadata !7, i64 0}
!116 = metadata !{metadata !48, metadata !2, i64 80}
!117 = metadata !{metadata !65, metadata !7, i64 48}
!118 = metadata !{metadata !63, metadata !7, i64 64}
!119 = metadata !{metadata !107, metadata !2, i64 120}
!120 = metadata !{metadata !23, metadata !7, i64 64}
!121 = metadata !{metadata !122, metadata !10, i64 32}
!122 = metadata !{metadata !"padop", metadata !7, i64 0, metadata !7, i64 8, metadata !7, i64 16, metadata !2, i64 24, metadata !10, i64 32, metadata !10, i64 34, metadata !3, i64 36, metadata !3, i64 37, metadata !2, i64 40}
!123 = metadata !{metadata !122, metadata !7, i64 16}
!124 = metadata !{metadata !122, metadata !2, i64 40}
!125 = metadata !{metadata !122, metadata !7, i64 0}
!126 = metadata !{metadata !122, metadata !3, i64 36}
!127 = metadata !{metadata !122, metadata !2, i64 24}
!128 = metadata !{metadata !21, metadata !10, i64 32}
!129 = metadata !{metadata !21, metadata !7, i64 16}
!130 = metadata !{metadata !21, metadata !7, i64 0}
!131 = metadata !{metadata !21, metadata !3, i64 36}
!132 = metadata !{metadata !21, metadata !2, i64 24}
!133 = metadata !{metadata !134, metadata !2, i64 24}
!134 = metadata !{metadata !"xpvuv", metadata !7, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !2, i64 24}
!135 = metadata !{metadata !65, metadata !7, i64 0}
!136 = metadata !{metadata !61, metadata !2, i64 16}
!137 = metadata !{metadata !65, metadata !2, i64 64}
!138 = metadata !{metadata !69, metadata !7, i64 72}
!139 = metadata !{metadata !69, metadata !7, i64 80}
!140 = metadata !{metadata !67, metadata !2, i64 16}
!141 = metadata !{metadata !63, metadata !3, i64 88}
!142 = metadata !{metadata !143, metadata !2, i64 32}
!143 = metadata !{metadata !"stackinfo", metadata !7, i64 0, metadata !7, i64 8, metadata !2, i64 16, metadata !2, i64 24, metadata !2, i64 32, metadata !7, i64 40, metadata !7, i64 48, metadata !2, i64 56}
!144 = metadata !{metadata !69, metadata !7, i64 64}
!145 = metadata !{metadata !69, metadata !7, i64 96}
!146 = metadata !{metadata !63, metadata !7, i64 80}
!147 = metadata !{metadata !69, metadata !7, i64 56}
!148 = metadata !{metadata !69, metadata !7, i64 128}
!149 = metadata !{metadata !69, metadata !2, i64 144}
!150 = metadata !{metadata !69, metadata !7, i64 120}
!151 = metadata !{metadata !69, metadata !7, i64 104}
!152 = metadata !{metadata !29, metadata !2, i64 8}
!153 = metadata !{metadata !48, metadata !10, i64 32}
!154 = metadata !{metadata !48, metadata !7, i64 16}
!155 = metadata !{metadata !48, metadata !3, i64 36}
!156 = metadata !{metadata !48, metadata !7, i64 0}
!157 = metadata !{metadata !48, metadata !7, i64 40}
!158 = metadata !{metadata !48, metadata !2, i64 64}
!159 = metadata !{metadata !48, metadata !7, i64 48}
!160 = metadata !{metadata !65, metadata !7, i64 32}
!161 = metadata !{metadata !162, metadata !7, i64 0}
!162 = metadata !{metadata !"av", metadata !7, i64 0, metadata !2, i64 8, metadata !2, i64 16}
!163 = metadata !{metadata !164, metadata !7, i64 0}
!164 = metadata !{metadata !"xpvav", metadata !7, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !2, i64 24, metadata !30, i64 32, metadata !7, i64 40, metadata !7, i64 48, metadata !7, i64 56, metadata !7, i64 64, metadata !3, i64 72}
!165 = metadata !{metadata !109, metadata !2, i64 24}
!166 = metadata !{metadata !167, metadata !10, i64 32}
!167 = metadata !{metadata !"loop", metadata !7, i64 0, metadata !7, i64 8, metadata !7, i64 16, metadata !2, i64 24, metadata !10, i64 32, metadata !10, i64 34, metadata !3, i64 36, metadata !3, i64 37, metadata !7, i64 40, metadata !7, i64 48, metadata !7, i64 56, metadata !7, i64 64, metadata !7, i64 72}
!168 = metadata !{metadata !167, metadata !7, i64 16}
!169 = metadata !{metadata !167, metadata !3, i64 37}
!170 = metadata !{metadata !167, metadata !7, i64 0}
!171 = metadata !{metadata !167, metadata !7, i64 56}
!172 = metadata !{metadata !167, metadata !7, i64 72}
!173 = metadata !{metadata !167, metadata !7, i64 64}
!174 = metadata !{metadata !46, metadata !7, i64 0}
!175 = metadata !{metadata !167, metadata !2, i64 24}
!176 = metadata !{metadata !69, metadata !2, i64 112}
!177 = metadata !{metadata !67, metadata !2, i64 8}
!178 = metadata !{metadata !29, metadata !7, i64 80}
!179 = metadata !{metadata !65, metadata !7, i64 24}
!180 = metadata !{metadata !63, metadata !2, i64 72}
!181 = metadata !{metadata !19, metadata !7, i64 8}
!182 = metadata !{metadata !183, metadata !7, i64 48}
!183 = metadata !{metadata !"xpvmg", metadata !7, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !2, i64 24, metadata !30, i64 32, metadata !7, i64 40, metadata !7, i64 48}
!184 = metadata !{metadata !16, metadata !7, i64 8}
!185 = metadata !{metadata !46, metadata !2, i64 24}
!186 = metadata !{metadata !46, metadata !3, i64 37}
