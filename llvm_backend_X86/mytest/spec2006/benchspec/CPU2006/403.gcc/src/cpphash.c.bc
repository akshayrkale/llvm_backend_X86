; ModuleID = 'cpphash.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.cpp_reader = type { %struct.cpp_buffer*, %struct.lexer_state, %struct.line_maps, %struct.line_map*, i32, i32, %struct._cpp_buff*, %struct._cpp_buff*, %struct._cpp_buff*, %struct.cpp_context, %struct.cpp_context*, %struct.directive*, %struct.cpp_hashnode*, %struct.cpp_hashnode*, i8, %struct.cpp_token*, %struct.tokenrun, %struct.tokenrun*, i32, i32, i32, i32, i32, i8*, i32, %struct.splay_tree_s*, i32, %struct.cpp_token, %struct.cpp_token, %struct.cpp_token, %struct.cpp_token, %struct.deps*, %struct.obstack, %struct.obstack, %struct.pragma_entry*, %struct.cpp_callbacks, %struct.ht*, %struct.cpp_options, %struct.spec_nodes, i8, i8 }
%struct.cpp_buffer = type { i8*, i8*, i8*, i8*, %struct.cpp_buffer*, i8*, %struct.include_file*, %struct.if_stack*, i32, i8, i8*, i8, i8, i8, i8, %struct.search_path }
%struct.include_file = type opaque
%struct.if_stack = type opaque
%struct.search_path = type { %struct.search_path*, i8*, i32, i64, i64, i32, %struct.file_name_map* }
%struct.file_name_map = type opaque
%struct.lexer_state = type { i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.line_maps = type { %struct.line_map*, i32, i32, i32, i32, i8 }
%struct.line_map = type { i8*, i32, i32, i32, i8, i8 }
%struct._cpp_buff = type { %struct._cpp_buff*, i8*, i8*, i8* }
%struct.cpp_context = type { %struct.cpp_context*, %struct.cpp_context*, %union.utoken, %union.utoken, %struct._cpp_buff*, %struct.cpp_hashnode*, i8 }
%union.utoken = type { %struct.cpp_token* }
%struct.directive = type opaque
%struct.cpp_hashnode = type { %struct.ht_identifier, i16, i8, i8, i8, i8, %union.anon.0 }
%struct.ht_identifier = type { i32, i8* }
%union.anon.0 = type { %struct.cpp_macro* }
%struct.cpp_macro = type opaque
%struct.tokenrun = type { %struct.tokenrun*, %struct.tokenrun*, %struct.cpp_token*, %struct.cpp_token* }
%struct.splay_tree_s = type opaque
%struct.cpp_token = type { i32, i16, i8, i8, %union.anon }
%union.anon = type { %struct.cpp_string }
%struct.cpp_string = type { i32, i8* }
%struct.deps = type opaque
%struct.obstack = type { i64, %struct._obstack_chunk*, i8*, i8*, i8*, i64, i32, %struct._obstack_chunk* (i8*, i64)*, void (i8*, %struct._obstack_chunk*)*, i8*, i8 }
%struct._obstack_chunk = type { i8*, %struct._obstack_chunk*, [4 x i8] }
%struct.pragma_entry = type opaque
%struct.cpp_callbacks = type { void (%struct.cpp_reader*, %struct.cpp_token*, i32)*, void (%struct.cpp_reader*, %struct.line_map*)*, void (%struct.cpp_reader*, i32, i8*, %struct.cpp_token*)*, void (%struct.cpp_reader*, i32, %struct.cpp_hashnode*)*, void (%struct.cpp_reader*, i32, %struct.cpp_hashnode*)*, void (%struct.cpp_reader*, i32, %struct.cpp_string*)*, void (%struct.cpp_reader*, i32)* }
%struct.cpp_options = type { i8*, i8*, i32, %struct.cpp_pending*, i8*, %struct.search_path*, %struct.search_path*, %struct.file_name_map_list*, i8*, i32, i8*, i32, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.cpp_pending = type opaque
%struct.file_name_map_list = type opaque
%struct.spec_nodes = type { %struct.cpp_hashnode*, %struct.cpp_hashnode*, %struct.cpp_hashnode*, %struct.cpp_hashnode*, %struct.cpp_hashnode* }
%struct.ht = type { %struct.obstack, %struct.ht_identifier**, %struct.ht_identifier* (%struct.ht*)*, i32, i32, %struct.cpp_reader*, i32, i32 }

@.str = private unnamed_addr constant [8 x i8] c"defined\00", align 1
@.str1 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str2 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@.str3 = private unnamed_addr constant [16 x i8] c"__STRICT_ANSI__\00", align 1
@.str4 = private unnamed_addr constant [12 x i8] c"__VA_ARGS__\00", align 1

; Function Attrs: nounwind uwtable
define void @_cpp_init_hashtable(%struct.cpp_reader* %pfile, %struct.ht* %table) #0 {
entry:
  %cmp = icmp eq %struct.ht* %table, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %our_hashtable = getelementptr inbounds %struct.cpp_reader* %pfile, i64 0, i32 40
  store i8 1, i8* %our_hashtable, align 1, !tbaa !1
  %call = tail call %struct.ht* @ht_create(i32 13) #2
  %alloc_node = getelementptr inbounds %struct.ht* %call, i64 0, i32 2
  store %struct.ht_identifier* (%struct.ht*)* bitcast (%struct.cpp_hashnode* (%struct.ht*)* @alloc_node to %struct.ht_identifier* (%struct.ht*)*), %struct.ht_identifier* (%struct.ht*)** %alloc_node, align 8, !tbaa !19
  %hash_ob = getelementptr inbounds %struct.cpp_reader* %pfile, i64 0, i32 32
  tail call void @gcc_obstack_init(%struct.obstack* %hash_ob) #2
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %table.addr.0 = phi %struct.ht* [ %call, %if.then ], [ %table, %entry ]
  %pfile1 = getelementptr inbounds %struct.ht* %table.addr.0, i64 0, i32 5
  store %struct.cpp_reader* %pfile, %struct.cpp_reader** %pfile1, align 8, !tbaa !21
  %hash_table = getelementptr inbounds %struct.cpp_reader* %pfile, i64 0, i32 36
  store %struct.ht* %table.addr.0, %struct.ht** %hash_table, align 8, !tbaa !22
  tail call void @_cpp_init_directives(%struct.cpp_reader* %pfile) #2
  tail call void @_cpp_init_internal_pragmas(%struct.cpp_reader* %pfile) #2
  %0 = load %struct.ht** %hash_table, align 8, !tbaa !22
  %call.i = tail call %struct.ht_identifier* @ht_lookup(%struct.ht* %0, i8* getelementptr inbounds ([8 x i8]* @.str, i64 0, i64 0), i32 7, i32 1) #2
  %1 = bitcast %struct.ht_identifier* %call.i to %struct.cpp_hashnode*
  %n_defined = getelementptr inbounds %struct.cpp_reader* %pfile, i64 0, i32 38, i32 0
  store %struct.cpp_hashnode* %1, %struct.cpp_hashnode** %n_defined, align 8, !tbaa !23
  %2 = load %struct.ht** %hash_table, align 8, !tbaa !22
  %call.i29 = tail call %struct.ht_identifier* @ht_lookup(%struct.ht* %2, i8* getelementptr inbounds ([5 x i8]* @.str1, i64 0, i64 0), i32 4, i32 1) #2
  %3 = bitcast %struct.ht_identifier* %call.i29 to %struct.cpp_hashnode*
  %n_true = getelementptr inbounds %struct.cpp_reader* %pfile, i64 0, i32 38, i32 1
  store %struct.cpp_hashnode* %3, %struct.cpp_hashnode** %n_true, align 8, !tbaa !24
  %4 = load %struct.ht** %hash_table, align 8, !tbaa !22
  %call.i31 = tail call %struct.ht_identifier* @ht_lookup(%struct.ht* %4, i8* getelementptr inbounds ([6 x i8]* @.str2, i64 0, i64 0), i32 5, i32 1) #2
  %5 = bitcast %struct.ht_identifier* %call.i31 to %struct.cpp_hashnode*
  %n_false = getelementptr inbounds %struct.cpp_reader* %pfile, i64 0, i32 38, i32 2
  store %struct.cpp_hashnode* %5, %struct.cpp_hashnode** %n_false, align 8, !tbaa !25
  %6 = load %struct.ht** %hash_table, align 8, !tbaa !22
  %call.i33 = tail call %struct.ht_identifier* @ht_lookup(%struct.ht* %6, i8* getelementptr inbounds ([16 x i8]* @.str3, i64 0, i64 0), i32 15, i32 1) #2
  %7 = bitcast %struct.ht_identifier* %call.i33 to %struct.cpp_hashnode*
  %n__STRICT_ANSI__ = getelementptr inbounds %struct.cpp_reader* %pfile, i64 0, i32 38, i32 3
  store %struct.cpp_hashnode* %7, %struct.cpp_hashnode** %n__STRICT_ANSI__, align 8, !tbaa !26
  %8 = load %struct.ht** %hash_table, align 8, !tbaa !22
  %call.i35 = tail call %struct.ht_identifier* @ht_lookup(%struct.ht* %8, i8* getelementptr inbounds ([12 x i8]* @.str4, i64 0, i64 0), i32 11, i32 1) #2
  %9 = bitcast %struct.ht_identifier* %call.i35 to %struct.cpp_hashnode*
  %n__VA_ARGS__ = getelementptr inbounds %struct.cpp_reader* %pfile, i64 0, i32 38, i32 4
  store %struct.cpp_hashnode* %9, %struct.cpp_hashnode** %n__VA_ARGS__, align 8, !tbaa !27
  %flags = getelementptr inbounds %struct.cpp_hashnode* %9, i64 0, i32 5
  %10 = load i8* %flags, align 1, !tbaa !28
  %or = or i8 %10, 8
  store i8 %or, i8* %flags, align 1, !tbaa !28
  ret void
}

declare %struct.ht* @ht_create(i32) #1

; Function Attrs: nounwind uwtable
define internal %struct.cpp_hashnode* @alloc_node(%struct.ht* nocapture readonly %table) #0 {
entry:
  %pfile = getelementptr inbounds %struct.ht* %table, i64 0, i32 5
  %0 = load %struct.cpp_reader** %pfile, align 8, !tbaa !21
  %chunk_limit = getelementptr inbounds %struct.cpp_reader* %0, i64 0, i32 32, i32 4
  %1 = load i8** %chunk_limit, align 8, !tbaa !31
  %next_free = getelementptr inbounds %struct.cpp_reader* %0, i64 0, i32 32, i32 3
  %2 = load i8** %next_free, align 8, !tbaa !32
  %sub.ptr.lhs.cast = ptrtoint i8* %1 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp slt i64 %sub.ptr.sub, 32
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %hash_ob = getelementptr inbounds %struct.cpp_reader* %0, i64 0, i32 32
  tail call void @_obstack_newchunk(%struct.obstack* %hash_ob, i32 32) #2
  %.pre = load i8** %next_free, align 8, !tbaa !32
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = phi i8* [ %.pre, %if.then ], [ %2, %entry ]
  %add.ptr = getelementptr inbounds i8* %3, i64 32
  store i8* %add.ptr, i8** %next_free, align 8, !tbaa !32
  %object_base = getelementptr inbounds %struct.cpp_reader* %0, i64 0, i32 32, i32 2
  %4 = load i8** %object_base, align 8, !tbaa !33
  %cmp6 = icmp eq i8* %add.ptr, %4
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  %maybe_empty_object = getelementptr inbounds %struct.cpp_reader* %0, i64 0, i32 32, i32 10
  %bf.load = load i8* %maybe_empty_object, align 8
  %bf.set = or i8 %bf.load, 2
  store i8 %bf.set, i8* %maybe_empty_object, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end
  %sub.ptr.lhs.cast11 = ptrtoint i8* %add.ptr to i64
  %alignment_mask = getelementptr inbounds %struct.cpp_reader* %0, i64 0, i32 32, i32 6
  %5 = load i32* %alignment_mask, align 4, !tbaa !34
  %conv13 = sext i32 %5 to i64
  %add = add nsw i64 %conv13, %sub.ptr.lhs.cast11
  %neg = xor i32 %5, -1
  %conv15 = sext i32 %neg to i64
  %and = and i64 %add, %conv15
  %add.ptr16 = getelementptr inbounds i8* null, i64 %and
  store i8* %add.ptr16, i8** %next_free, align 8, !tbaa !32
  %chunk = getelementptr inbounds %struct.cpp_reader* %0, i64 0, i32 32, i32 1
  %6 = load %struct._obstack_chunk** %chunk, align 8, !tbaa !35
  %sub.ptr.lhs.cast19 = ptrtoint i8* %add.ptr16 to i64
  %sub.ptr.rhs.cast20 = ptrtoint %struct._obstack_chunk* %6 to i64
  %sub.ptr.sub21 = sub i64 %sub.ptr.lhs.cast19, %sub.ptr.rhs.cast20
  %7 = load i8** %chunk_limit, align 8, !tbaa !31
  %sub.ptr.lhs.cast24 = ptrtoint i8* %7 to i64
  %sub.ptr.sub26 = sub i64 %sub.ptr.lhs.cast24, %sub.ptr.rhs.cast20
  %cmp27 = icmp sgt i64 %sub.ptr.sub21, %sub.ptr.sub26
  br i1 %cmp27, label %if.then29, label %if.end32

if.then29:                                        ; preds = %if.end9
  store i8* %7, i8** %next_free, align 8, !tbaa !32
  br label %if.end32

if.end32:                                         ; preds = %if.then29, %if.end9
  %8 = phi i8* [ %7, %if.then29 ], [ %add.ptr16, %if.end9 ]
  store i8* %8, i8** %object_base, align 8, !tbaa !33
  %9 = bitcast i8* %4 to %struct.cpp_hashnode*
  tail call void @llvm.memset.p0i8.i64(i8* %4, i8 0, i64 32, i32 1, i1 false)
  ret %struct.cpp_hashnode* %9
}

declare void @gcc_obstack_init(%struct.obstack*) #1

declare void @_cpp_init_directives(%struct.cpp_reader*) #1

declare void @_cpp_init_internal_pragmas(%struct.cpp_reader*) #1

; Function Attrs: nounwind uwtable
define %struct.cpp_hashnode* @cpp_lookup(%struct.cpp_reader* nocapture readonly %pfile, i8* %str, i32 %len) #0 {
entry:
  %hash_table = getelementptr inbounds %struct.cpp_reader* %pfile, i64 0, i32 36
  %0 = load %struct.ht** %hash_table, align 8, !tbaa !22
  %call = tail call %struct.ht_identifier* @ht_lookup(%struct.ht* %0, i8* %str, i32 %len, i32 1) #2
  %1 = bitcast %struct.ht_identifier* %call to %struct.cpp_hashnode*
  ret %struct.cpp_hashnode* %1
}

; Function Attrs: nounwind uwtable
define void @_cpp_destroy_hashtable(%struct.cpp_reader* %pfile) #0 {
entry:
  %our_hashtable = getelementptr inbounds %struct.cpp_reader* %pfile, i64 0, i32 40
  %0 = load i8* %our_hashtable, align 1, !tbaa !1
  %tobool = icmp eq i8 %0, 0
  br i1 %tobool, label %if.end3, label %if.then

if.then:                                          ; preds = %entry
  %hash_table = getelementptr inbounds %struct.cpp_reader* %pfile, i64 0, i32 36
  %1 = load %struct.ht** %hash_table, align 8, !tbaa !22
  tail call void @ht_destroy(%struct.ht* %1) #2
  %hash_ob = getelementptr inbounds %struct.cpp_reader* %pfile, i64 0, i32 32
  tail call void @obstack_free(%struct.obstack* %hash_ob, i8* null) #2
  br label %if.end3

if.end3:                                          ; preds = %entry, %if.then
  ret void
}

declare void @ht_destroy(%struct.ht*) #1

declare void @obstack_free(%struct.obstack*, i8*) #1

declare %struct.ht_identifier* @ht_lookup(%struct.ht*, i8*, i32, i32) #1

; Function Attrs: nounwind uwtable
define i32 @cpp_defined(%struct.cpp_reader* nocapture readonly %pfile, i8* %str, i32 %len) #0 {
entry:
  %hash_table = getelementptr inbounds %struct.cpp_reader* %pfile, i64 0, i32 36
  %0 = load %struct.ht** %hash_table, align 8, !tbaa !22
  %call = tail call %struct.ht_identifier* @ht_lookup(%struct.ht* %0, i8* %str, i32 %len, i32 0) #2
  %tobool = icmp eq %struct.ht_identifier* %call, null
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %1 = bitcast %struct.ht_identifier* %call to %struct.cpp_hashnode*
  %type = getelementptr inbounds %struct.cpp_hashnode* %1, i64 0, i32 4
  %bf.load = load i8* %type, align 4
  %cmp = icmp eq i8 %bf.load, 1
  br label %land.end

land.end:                                         ; preds = %entry, %land.rhs
  %2 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  %land.ext = zext i1 %2 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define void @cpp_forall_identifiers(%struct.cpp_reader* nocapture readonly %pfile, i32 (%struct.cpp_reader*, %struct.cpp_hashnode*, i8*)* %cb, i8* %v) #0 {
entry:
  %hash_table = getelementptr inbounds %struct.cpp_reader* %pfile, i64 0, i32 36
  %0 = load %struct.ht** %hash_table, align 8, !tbaa !22
  %1 = bitcast i32 (%struct.cpp_reader*, %struct.cpp_hashnode*, i8*)* %cb to i32 (%struct.cpp_reader*, %struct.ht_identifier*, i8*)*
  tail call void @ht_forall(%struct.ht* %0, i32 (%struct.cpp_reader*, %struct.ht_identifier*, i8*)* %1, i8* %v) #2
  ret void
}

declare void @ht_forall(%struct.ht*, i32 (%struct.cpp_reader*, %struct.ht_identifier*, i8*)*, i8*) #1

declare void @_obstack_newchunk(%struct.obstack*, i32) #1

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #2

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5 (trunk)"}
!1 = metadata !{metadata !2, metadata !4, i64 825}
!2 = metadata !{metadata !"cpp_reader", metadata !3, i64 0, metadata !6, i64 8, metadata !7, i64 24, metadata !3, i64 56, metadata !8, i64 64, metadata !8, i64 68, metadata !3, i64 72, metadata !3, i64 80, metadata !3, i64 88, metadata !10, i64 96, metadata !3, i64 152, metadata !3, i64 160, metadata !3, i64 168, metadata !3, i64 176, metadata !9, i64 184, metadata !3, i64 192, metadata !11, i64 200, metadata !3, i64 232, metadata !8, i64 240, metadata !8, i64 244, metadata !8, i64 248, metadata !8, i64 252, metadata !8, i64 256, metadata !3, i64 264, metadata !8, i64 272, metadata !3, i64 280, metadata !8, i64 288, metadata !12, i64 296, metadata !12, i64 320, metadata !12, i64 344, metadata !12, i64 368, metadata !3, i64 392, metadata !14, i64 400, metadata !14, i64 488, metadata !3, i64 576, metadata !16, i64 584, metadata !3, i64 640, metadata !17, i64 648, metadata !18, i64 784, metadata !4, i64 824, metadata !4, i64 825}
!3 = metadata !{metadata !"any pointer", metadata !4, i64 0}
!4 = metadata !{metadata !"omnipotent char", metadata !5, i64 0}
!5 = metadata !{metadata !"Simple C/C++ TBAA"}
!6 = metadata !{metadata !"lexer_state", metadata !4, i64 0, metadata !4, i64 1, metadata !4, i64 2, metadata !4, i64 3, metadata !4, i64 4, metadata !4, i64 5, metadata !4, i64 6, metadata !4, i64 7, metadata !4, i64 8}
!7 = metadata !{metadata !"line_maps", metadata !3, i64 0, metadata !8, i64 8, metadata !8, i64 12, metadata !8, i64 16, metadata !8, i64 20, metadata !9, i64 24}
!8 = metadata !{metadata !"int", metadata !4, i64 0}
!9 = metadata !{metadata !"_Bool", metadata !4, i64 0}
!10 = metadata !{metadata !"cpp_context", metadata !3, i64 0, metadata !3, i64 8, metadata !4, i64 16, metadata !4, i64 24, metadata !3, i64 32, metadata !3, i64 40, metadata !9, i64 48}
!11 = metadata !{metadata !"tokenrun", metadata !3, i64 0, metadata !3, i64 8, metadata !3, i64 16, metadata !3, i64 24}
!12 = metadata !{metadata !"cpp_token", metadata !8, i64 0, metadata !13, i64 4, metadata !4, i64 6, metadata !4, i64 7, metadata !4, i64 8}
!13 = metadata !{metadata !"short", metadata !4, i64 0}
!14 = metadata !{metadata !"obstack", metadata !15, i64 0, metadata !3, i64 8, metadata !3, i64 16, metadata !3, i64 24, metadata !3, i64 32, metadata !15, i64 40, metadata !8, i64 48, metadata !3, i64 56, metadata !3, i64 64, metadata !3, i64 72, metadata !8, i64 80, metadata !8, i64 80, metadata !8, i64 80}
!15 = metadata !{metadata !"long", metadata !4, i64 0}
!16 = metadata !{metadata !"cpp_callbacks", metadata !3, i64 0, metadata !3, i64 8, metadata !3, i64 16, metadata !3, i64 24, metadata !3, i64 32, metadata !3, i64 40, metadata !3, i64 48}
!17 = metadata !{metadata !"cpp_options", metadata !3, i64 0, metadata !3, i64 8, metadata !8, i64 16, metadata !3, i64 24, metadata !3, i64 32, metadata !3, i64 40, metadata !3, i64 48, metadata !3, i64 56, metadata !3, i64 64, metadata !8, i64 72, metadata !3, i64 80, metadata !4, i64 88, metadata !4, i64 92, metadata !4, i64 93, metadata !4, i64 94, metadata !4, i64 95, metadata !4, i64 96, metadata !4, i64 97, metadata !4, i64 98, metadata !4, i64 99, metadata !4, i64 100, metadata !4, i64 101, metadata !4, i64 102, metadata !4, i64 103, metadata !4, i64 104, metadata !4, i64 105, metadata !4, i64 106, metadata !4, i64 107, metadata !4, i64 108, metadata !4, i64 109, metadata !4, i64 110, metadata !4, i64 111, metadata !4, i64 112, metadata !4, i64 113, metadata !4, i64 114, metadata !4, i64 115, metadata !4, i64 116, metadata !4, i64 117, metadata !4, i64 118, metadata !4, i64 119, metadata !4, i64 120, metadata !4, i64 121, metadata !4, i64 122, metadata !4, i64 123, metadata !4, i64 124, metadata !4, i64 125, metadata !4, i64 126, metadata !4, i64 127, metadata !4, i64 128, metadata !4, i64 129, metadata !4, i64 130}
!18 = metadata !{metadata !"spec_nodes", metadata !3, i64 0, metadata !3, i64 8, metadata !3, i64 16, metadata !3, i64 24, metadata !3, i64 32}
!19 = metadata !{metadata !20, metadata !3, i64 96}
!20 = metadata !{metadata !"ht", metadata !14, i64 0, metadata !3, i64 88, metadata !3, i64 96, metadata !8, i64 104, metadata !8, i64 108, metadata !3, i64 112, metadata !8, i64 120, metadata !8, i64 124}
!21 = metadata !{metadata !20, metadata !3, i64 112}
!22 = metadata !{metadata !2, metadata !3, i64 640}
!23 = metadata !{metadata !18, metadata !3, i64 0}
!24 = metadata !{metadata !18, metadata !3, i64 8}
!25 = metadata !{metadata !18, metadata !3, i64 16}
!26 = metadata !{metadata !18, metadata !3, i64 24}
!27 = metadata !{metadata !18, metadata !3, i64 32}
!28 = metadata !{metadata !29, metadata !4, i64 21}
!29 = metadata !{metadata !"cpp_hashnode", metadata !30, i64 0, metadata !13, i64 16, metadata !4, i64 18, metadata !4, i64 19, metadata !4, i64 20, metadata !4, i64 21, metadata !4, i64 24}
!30 = metadata !{metadata !"ht_identifier", metadata !8, i64 0, metadata !3, i64 8}
!31 = metadata !{metadata !14, metadata !3, i64 32}
!32 = metadata !{metadata !14, metadata !3, i64 24}
!33 = metadata !{metadata !14, metadata !3, i64 16}
!34 = metadata !{metadata !14, metadata !8, i64 48}
!35 = metadata !{metadata !14, metadata !3, i64 8}
