Args: /var/services/homes/akale/llvm523/llvm_backend/build_523/Debug+Asserts/bin/llc -soft-float -march=cse523 -O3 classic.c.bc -o classic.c.S -debug 
Subtarget features: SSELevel 0, 3DNowLevel 0, 64bit 1
LoopSimplify: Creating pre-header for.body.preheader
LoopSimplify: Creating dedicated exit block for.end.loopexit
********** Constant Hoisting **********
********** Function: quantum_ipow
MERGING MOSTLY EMPTY BLOCKS - BEFORE:

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %r.05 = phi i32 [ %mul, %for.body ], [ 1, %for.body.preheader ]
  %i.04 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %mul = mul nsw i32 %r.05, %a
  %inc = add nsw i32 %i.04, 1
  %exitcond = icmp eq i32 %inc, %b
  br i1 %exitcond, label %for.end.loopexit, label %for.body
AFTER:

for.body:                                         ; preds = %entry, %for.body
  %r.05 = phi i32 [ %mul, %for.body ], [ 1, %entry ]
  %i.04 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %mul = mul nsw i32 %r.05, %a
  %inc = add nsw i32 %i.04, 1
  %exitcond = icmp eq i32 %inc, %b
  br i1 %exitcond, label %for.end.loopexit, label %for.body



MERGING MOSTLY EMPTY BLOCKS - BEFORE:

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %r.0.lcssa = phi i32 [ 1, %entry ], [ %mul, %for.end.loopexit ]
  ret i32 %r.0.lcssa
AFTER:

for.end:                                          ; preds = %for.body, %entry
  %r.0.lcssa = phi i32 [ 1, %entry ], [ %mul, %for.body ]
  ret i32 %r.0.lcssa



---- Branch Probability Info : quantum_ipow ----

Computing probabilities for for.end
Computing probabilities for for.body
set edge for.body -> 1 successor weight to 124
set edge for.body -> 0 successor weight to 4
Computing probabilities for entry
set edge entry -> 0 successor weight to 20
set edge entry -> 1 successor weight to 12



=== quantum_ipow
Initial selection DAG: BB#0 'quantum_ipow:entry'
SelectionDAG has 28 nodes:
  0x219b660: ch = EntryToken

    0x219b660: <multiple use>
    0x21c5c20: i64 = Register %vreg5

  0x21c5d20: i64,ch = CopyFromReg 0x219b660, 0x21c5c20 [ORD=1]

    0x219b660: <multiple use>
    0x21c5e20: i64 = Register %vreg6

  0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1]

    0x21c5d20: <multiple use>
  0x21c6020: i32 = truncate 0x21c5d20 [ORD=1]

  0x21c6920: i32 = Constant<1>

          0x219b660: <multiple use>
          0x21c6120: i64 = Register %vreg7

          0x21c5d20: <multiple use>
        0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1]

          0x219b660: <multiple use>
          0x21c6420: i64 = Register %vreg8

          0x21c5f20: <multiple use>
        0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1]

          0x219b660: <multiple use>
          0x21c7e60: i64 = Register %vreg9

          0x21c6a20: i64 = Constant<1>

        0x21c7f60: ch = CopyToReg 0x219b660, 0x21c7e60, 0x21c6a20 [ORD=2]

          0x219b660: <multiple use>
          0x21c8160: i64 = Register %vreg10

          0x21c8060: i64 = Constant<0>

        0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2]

      0x21c8660: ch = TokenFactor 0x21c6220, 0x21c6520, 0x21c7f60, 0x21c8260 [ORD=3]

            0x21c5f20: <multiple use>
          0x21c6320: i32 = truncate 0x21c5f20 [ORD=1]

          0x21c6620: i32 = Constant<0>

          0x21c6720: ch = setgt

        0x21c6820: i1 = setcc 0x21c6320, 0x21c6620, 0x21c6720 [ORD=2]

        0x21c8360: i1 = Constant<-1>

      0x21c8460: i1 = xor 0x21c6820, 0x21c8360 [ORD=3]

      0x21c8560: ch = BasicBlock<for.end 0x21c02f0>

    0x21c8760: ch = brcond 0x21c8660, 0x21c8460, 0x21c8560 [ORD=3]

    0x21c8860: ch = BasicBlock<for.body 0x21c0180>

  0x21c8960: ch = br 0x21c8760, 0x21c8860 [ORD=3]



Replacing.3 0x21c8460: i1 = xor 0x21c6820, 0x21c8360 [ORD=3]

With: 0x21c8b60: i1 = setcc 0x21c6320, 0x21c6620, 0x21c8a60 [ORD=3]


Replacing.3 0x21c8b60: i1 = setcc 0x21c6320, 0x21c6620, 0x21c8a60 [ORD=3]

With: 0x21c6820: i1 = setcc 0x21c6320, 0x21c6920, 0x21c6720 [ORD=3]

Optimized lowered selection DAG: BB#0 'quantum_ipow:entry'
SelectionDAG has 24 nodes:
  0x219b660: ch = EntryToken

    0x219b660: <multiple use>
    0x21c5e20: i64 = Register %vreg6

  0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1]

          0x219b660: <multiple use>
          0x21c6120: i64 = Register %vreg7

            0x219b660: <multiple use>
            0x21c5c20: i64 = Register %vreg5

          0x21c5d20: i64,ch = CopyFromReg 0x219b660, 0x21c5c20 [ORD=1]

        0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1]

          0x219b660: <multiple use>
          0x21c6420: i64 = Register %vreg8

          0x21c5f20: <multiple use>
        0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1]

          0x219b660: <multiple use>
          0x21c7e60: i64 = Register %vreg9

          0x21c6a20: i64 = Constant<1>

        0x21c7f60: ch = CopyToReg 0x219b660, 0x21c7e60, 0x21c6a20 [ORD=2]

          0x219b660: <multiple use>
          0x21c8160: i64 = Register %vreg10

          0x21c8060: i64 = Constant<0>

        0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2]

      0x21c8660: ch = TokenFactor 0x21c6220, 0x21c6520, 0x21c7f60, 0x21c8260 [ORD=3]

          0x21c5f20: <multiple use>
        0x21c6320: i32 = truncate 0x21c5f20 [ORD=1]

        0x21c6920: i32 = Constant<1>

        0x21c6720: ch = setlt

      0x21c6820: i1 = setcc 0x21c6320, 0x21c6920, 0x21c6720 [ORD=3]

      0x21c8560: ch = BasicBlock<for.end 0x21c02f0>

    0x21c8760: ch = brcond 0x21c8660, 0x21c6820, 0x21c8560 [ORD=3]

    0x21c8860: ch = BasicBlock<for.body 0x21c0180>

  0x21c8960: ch = br 0x21c8760, 0x21c8860 [ORD=3]


Legally typed node: 0x21c6720: ch = setlt [ID=0]

Legally typed node: 0x21c8860: ch = BasicBlock<for.body 0x21c0180> [ID=0]

Legally typed node: 0x21c8560: ch = BasicBlock<for.end 0x21c02f0> [ID=0]

Legally typed node: 0x21c8160: i64 = Register %vreg10 [ID=0]

Legally typed node: 0x21c8060: i64 = Constant<0> [ID=0]

Legally typed node: 0x21c7e60: i64 = Register %vreg9 [ID=0]

Legally typed node: 0x21c6a20: i64 = Constant<1> [ID=0]

Promote integer result: 0x21c6920: i32 = Constant<1> [ID=0]

Legally typed node: 0x21c6420: i64 = Register %vreg8 [ID=0]

Legally typed node: 0x21c6120: i64 = Register %vreg7 [ID=0]

Legally typed node: 0x21c5e20: i64 = Register %vreg6 [ID=0]

Legally typed node: 0x21c5c20: i64 = Register %vreg5 [ID=0]

Legally typed node: 0x219b660: ch = EntryToken [ID=0]

Legally typed node: 0x21c5d20: i64,ch = CopyFromReg 0x219b660, 0x21c5c20 [ORD=1] [ID=0]

Legally typed node: 0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=0]

Legally typed node: 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1] [ID=0]

Promote integer result: 0x21c6320: i32 = truncate 0x21c5f20 [ORD=1] [ID=0]

Promote integer result: 0x21c6820: i1 = setcc 0x21c6320, 0x21c6920, 0x21c6720 [ORD=3] [ID=0]

Promote integer operand: 0x21c6020: i64 = setcc 0x21c6320, 0x21c6920, 0x21c6720 [ORD=3] [ID=0]

Legally typed node: 0x21c6620: ch = ValueType:i32 [ID=0]

Legally typed node: 0x21c8a60: i64 = sign_extend_inreg 0x21c5f20, 0x21c6620 [ORD=1] [ID=0]

Legally typed node: 0x21c6020: i64 = setcc 0x21c8a60, 0x21c6a20, 0x21c6720 [ORD=3] [ID=0]

Legally typed node: 0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=0]

Legally typed node: 0x21c7f60: ch = CopyToReg 0x219b660, 0x21c7e60, 0x21c6a20 [ORD=2] [ID=0]

Legally typed node: 0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2] [ID=0]

Legally typed node: 0x21c8660: ch = TokenFactor 0x21c6220, 0x21c6520, 0x21c7f60, 0x21c8260 [ORD=3] [ID=0]

Promote integer operand: 0x21c8760: ch = brcond 0x21c8660, 0x21c6820, 0x21c8560 [ORD=3] [ID=0]

Promote integer operand: 0x21c8b60: i64 = zero_extend 0x21c6820 [ORD=3] [ID=0]

Legally typed node: 0x21c8360: i64 = and 0x21c6020, 0x21c6a20 [ORD=3] [ID=0]

Legally typed node: 0x21c8760: ch = brcond 0x21c8660, 0x21c8360, 0x21c8560 [ORD=3] [ID=0]

Legally typed node: 0x21c8960: ch = br 0x21c8760, 0x21c8860 [ORD=3] [ID=0]

Legally typed node: 0x7fff16596d20: ch = handlenode 0x21c8960 [ID=0]

Type-legalized selection DAG: BB#0 'quantum_ipow:entry'
SelectionDAG has 25 nodes:
  0x219b660: ch = EntryToken [ID=-3]

    0x219b660: <multiple use>
    0x21c5e20: i64 = Register %vreg6 [ID=-3]

  0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1] [ID=-3]

  0x21c6a20: i64 = Constant<1> [ID=-3]

          0x219b660: <multiple use>
          0x21c6120: i64 = Register %vreg7 [ID=-3]

            0x219b660: <multiple use>
            0x21c5c20: i64 = Register %vreg5 [ID=-3]

          0x21c5d20: i64,ch = CopyFromReg 0x219b660, 0x21c5c20 [ORD=1] [ID=-3]

        0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=-3]

          0x219b660: <multiple use>
          0x21c6420: i64 = Register %vreg8 [ID=-3]

          0x21c5f20: <multiple use>
        0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=-3]

          0x219b660: <multiple use>
          0x21c7e60: i64 = Register %vreg9 [ID=-3]

          0x21c6a20: <multiple use>
        0x21c7f60: ch = CopyToReg 0x219b660, 0x21c7e60, 0x21c6a20 [ORD=2] [ID=-3]

          0x219b660: <multiple use>
          0x21c8160: i64 = Register %vreg10 [ID=-3]

          0x21c8060: i64 = Constant<0> [ID=-3]

        0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2] [ID=-3]

      0x21c8660: ch = TokenFactor 0x21c6220, 0x21c6520, 0x21c7f60, 0x21c8260 [ORD=3] [ID=-3]

            0x21c5f20: <multiple use>
            0x21c6620: ch = ValueType:i32 [ID=-3]

          0x21c8a60: i64 = sign_extend_inreg 0x21c5f20, 0x21c6620 [ORD=1] [ID=-3]

          0x21c6a20: <multiple use>
          0x21c6720: ch = setlt [ID=-3]

        0x21c6020: i64 = setcc 0x21c8a60, 0x21c6a20, 0x21c6720 [ORD=3] [ID=-3]

        0x21c6a20: <multiple use>
      0x21c8360: i64 = and 0x21c6020, 0x21c6a20 [ORD=3] [ID=-3]

      0x21c8560: ch = BasicBlock<for.end 0x21c02f0> [ID=-3]

    0x21c8760: ch = brcond 0x21c8660, 0x21c8360, 0x21c8560 [ORD=3] [ID=-3]

    0x21c8860: ch = BasicBlock<for.body 0x21c0180> [ID=-3]

  0x21c8960: ch = br 0x21c8760, 0x21c8860 [ORD=3] [ID=-3]



Replacing.2 0x21c8360: i64 = and 0x21c6020, 0x21c6a20 [ORD=3] [ID=-3]

With: 0x21c6020: i64 = setcc 0x21c8a60, 0x21c6a20, 0x21c6720 [ORD=3] [ID=-3]

Optimized type-legalized selection DAG: BB#0 'quantum_ipow:entry'
SelectionDAG has 24 nodes:
  0x219b660: ch = EntryToken [ID=-3]

    0x219b660: <multiple use>
    0x21c5e20: i64 = Register %vreg6 [ID=-3]

  0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1] [ID=-3]

  0x21c6a20: i64 = Constant<1> [ID=-3]

          0x219b660: <multiple use>
          0x21c6120: i64 = Register %vreg7 [ID=-3]

            0x219b660: <multiple use>
            0x21c5c20: i64 = Register %vreg5 [ID=-3]

          0x21c5d20: i64,ch = CopyFromReg 0x219b660, 0x21c5c20 [ORD=1] [ID=-3]

        0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=-3]

          0x219b660: <multiple use>
          0x21c6420: i64 = Register %vreg8 [ID=-3]

          0x21c5f20: <multiple use>
        0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=-3]

          0x219b660: <multiple use>
          0x21c7e60: i64 = Register %vreg9 [ID=-3]

          0x21c6a20: <multiple use>
        0x21c7f60: ch = CopyToReg 0x219b660, 0x21c7e60, 0x21c6a20 [ORD=2] [ID=-3]

          0x219b660: <multiple use>
          0x21c8160: i64 = Register %vreg10 [ID=-3]

          0x21c8060: i64 = Constant<0> [ID=-3]

        0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2] [ID=-3]

      0x21c8660: ch = TokenFactor 0x21c6220, 0x21c6520, 0x21c7f60, 0x21c8260 [ORD=3] [ID=-3]

          0x21c5f20: <multiple use>
          0x21c6620: ch = ValueType:i32 [ID=-3]

        0x21c8a60: i64 = sign_extend_inreg 0x21c5f20, 0x21c6620 [ORD=1] [ID=-3]

        0x21c6a20: <multiple use>
        0x21c6720: ch = setlt [ID=-3]

      0x21c6020: i64 = setcc 0x21c8a60, 0x21c6a20, 0x21c6720 [ORD=3] [ID=-3]

      0x21c8560: ch = BasicBlock<for.end 0x21c02f0> [ID=-3]

    0x21c8760: ch = brcond 0x21c8660, 0x21c6020, 0x21c8560 [ORD=3] [ID=-3]

    0x21c8860: ch = BasicBlock<for.body 0x21c0180> [ID=-3]

  0x21c8960: ch = br 0x21c8760, 0x21c8860 [ORD=3] [ID=-3]


Legalized selection DAG: BB#0 'quantum_ipow:entry'
SelectionDAG has 25 nodes:
  0x219b660: ch = EntryToken [ID=0]

  0x21c8060: i64 = Constant<0> [ID=7]

    0x219b660: <multiple use>
    0x21c5e20: i64 = Register %vreg6 [ID=2]

  0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1] [ID=14]

  0x21c6720: i64 = Constant<32>

          0x219b660: <multiple use>
          0x21c6120: i64 = Register %vreg7 [ID=3]

            0x219b660: <multiple use>
            0x21c5c20: i64 = Register %vreg5 [ID=1]

          0x21c5d20: i64,ch = CopyFromReg 0x219b660, 0x21c5c20 [ORD=1] [ID=13]

        0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=17]

          0x219b660: <multiple use>
          0x21c6420: i64 = Register %vreg8 [ID=4]

          0x21c5f20: <multiple use>
        0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=19]

          0x219b660: <multiple use>
          0x21c7e60: i64 = Register %vreg9 [ID=6]

          0x21c6a20: i64 = Constant<1> [ID=5]

        0x21c7f60: ch = CopyToReg 0x219b660, 0x21c7e60, 0x21c6a20 [ORD=2] [ID=15]

          0x219b660: <multiple use>
          0x21c8160: i64 = Register %vreg10 [ID=8]

          0x21c8060: <multiple use>
        0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2] [ID=16]

      0x21c8660: ch = TokenFactor 0x21c6220, 0x21c6520, 0x21c7f60, 0x21c8260 [ORD=3] [ID=21]

      0x21c8560: ch = BasicBlock<for.end 0x21c02f0> [ID=9]

      0x21c6320: i64 = Constant<8>

            0x21c5f20: <multiple use>
            0x21c6720: <multiple use>
          0x21c6020: i64 = shl 0x21c5f20, 0x21c6720 [ORD=1]

          0x21c6720: <multiple use>
        0x21c8760: i64 = sra 0x21c6020, 0x21c6720 [ORD=1]

        0x21c8060: <multiple use>
      0x21c8360: i64 = Cse523ISD::CMP 0x21c8760, 0x21c8060 [ORD=1]

    0x21c6820: ch = Cse523ISD::BRCOND 0x21c8660, 0x21c8560, 0x21c6320, 0x21c8360 [ORD=3]

    0x21c8860: ch = BasicBlock<for.body 0x21c0180> [ID=10]

  0x21c8960: ch = br 0x21c6820, 0x21c8860 [ORD=3] [ID=23]


Optimized legalized selection DAG: BB#0 'quantum_ipow:entry'
SelectionDAG has 25 nodes:
  0x219b660: ch = EntryToken [ID=0]

  0x21c8060: i64 = Constant<0> [ID=7]

    0x219b660: <multiple use>
    0x21c5e20: i64 = Register %vreg6 [ID=2]

  0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1] [ID=14]

  0x21c6720: i64 = Constant<32>

          0x219b660: <multiple use>
          0x21c6120: i64 = Register %vreg7 [ID=3]

            0x219b660: <multiple use>
            0x21c5c20: i64 = Register %vreg5 [ID=1]

          0x21c5d20: i64,ch = CopyFromReg 0x219b660, 0x21c5c20 [ORD=1] [ID=13]

        0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=17]

          0x219b660: <multiple use>
          0x21c6420: i64 = Register %vreg8 [ID=4]

          0x21c5f20: <multiple use>
        0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=19]

          0x219b660: <multiple use>
          0x21c7e60: i64 = Register %vreg9 [ID=6]

          0x21c6a20: i64 = Constant<1> [ID=5]

        0x21c7f60: ch = CopyToReg 0x219b660, 0x21c7e60, 0x21c6a20 [ORD=2] [ID=15]

          0x219b660: <multiple use>
          0x21c8160: i64 = Register %vreg10 [ID=8]

          0x21c8060: <multiple use>
        0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2] [ID=16]

      0x21c8660: ch = TokenFactor 0x21c6220, 0x21c6520, 0x21c7f60, 0x21c8260 [ORD=3] [ID=21]

      0x21c8560: ch = BasicBlock<for.end 0x21c02f0> [ID=9]

      0x21c6320: i64 = Constant<8>

            0x21c5f20: <multiple use>
            0x21c6720: <multiple use>
          0x21c6020: i64 = shl 0x21c5f20, 0x21c6720 [ORD=1]

          0x21c6720: <multiple use>
        0x21c8760: i64 = sra 0x21c6020, 0x21c6720 [ORD=1]

        0x21c8060: <multiple use>
      0x21c8360: i64 = Cse523ISD::CMP 0x21c8760, 0x21c8060 [ORD=1]

    0x21c6820: ch = Cse523ISD::BRCOND 0x21c8660, 0x21c8560, 0x21c6320, 0x21c8360 [ORD=3]

    0x21c8860: ch = BasicBlock<for.body 0x21c0180> [ID=10]

  0x21c8960: ch = br 0x21c6820, 0x21c8860 [ORD=3] [ID=23]


===== Instruction selection begins: BB#0 'entry'
Selecting:Opcode[146] 0x21c8960: ch = br 0x21c6820, 0x21c8860 [ORD=3] [ID=24]

ISEL: Starting pattern match on root node: 0x21c8960: ch = br 0x21c6820, 0x21c8860 [ORD=3] [ID=24]

  Morphed node: 0x21c8960: ch = JMP_4 0x21c8860, 0x21c6820 [ORD=3]

ISEL: Match complete!
=> 0x21c8960: ch = JMP_4 0x21c8860, 0x21c6820 [ORD=3]

Selecting:Opcode[210] 0x21c6820: ch = Cse523ISD::BRCOND 0x21c8660, 0x21c8560, 0x21c6320, 0x21c8360 [ORD=3] [ID=23]

ISEL: Starting pattern match on root node: 0x21c6820: ch = Cse523ISD::BRCOND 0x21c8660, 0x21c8560, 0x21c6320, 0x21c8360 [ORD=3] [ID=23]

  Initial Opcode index to 4241
  Skipped scope entry (due to false predicate) at index 4251, continuing at 4265
  Skipped scope entry (due to false predicate) at index 4266, continuing at 4280
  Skipped scope entry (due to false predicate) at index 4281, continuing at 4295
  Skipped scope entry (due to false predicate) at index 4296, continuing at 4310
  Skipped scope entry (due to false predicate) at index 4311, continuing at 4325
  Skipped scope entry (due to false predicate) at index 4326, continuing at 4340
  Skipped scope entry (due to false predicate) at index 4341, continuing at 4355
  Skipped scope entry (due to false predicate) at index 4356, continuing at 4370
  Skipped scope entry (due to false predicate) at index 4371, continuing at 4385
  Skipped scope entry (due to false predicate) at index 4386, continuing at 4400
  Skipped scope entry (due to false predicate) at index 4401, continuing at 4415
  Skipped scope entry (due to false predicate) at index 4416, continuing at 4430
  Skipped scope entry (due to false predicate) at index 4431, continuing at 4445
  Skipped scope entry (due to false predicate) at index 4446, continuing at 4460
  Morphed node: 0x21c6820: ch = JLE_4 0x21c8560, 0x21c6620, 0x21c6620:1 [ORD=3]

ISEL: Match complete!
=> 0x21c6820: ch = JLE_4 0x21c8560, 0x21c6620, 0x21c6620:1 [ORD=3]

Selecting:Opcode[200] 0x21c8360: i64 = Cse523ISD::CMP 0x21c8760, 0x21c8060 [ORD=1] [ID=22]

ISEL: Starting pattern match on root node: 0x21c8360: i64 = Cse523ISD::CMP 0x21c8760, 0x21c8060 [ORD=1] [ID=22]

  Initial Opcode index to 1961
  Match failed at index 1966
  Continuing at 2135
  Morphed node: 0x21c8360: i64 = TEST64rr 0x21c8760, 0x21c8760 [ORD=1]

ISEL: Match complete!
=> 0x21c8360: i64 = TEST64rr 0x21c8760, 0x21c8760 [ORD=1]

Selecting:Opcode[2] 0x21c8660: ch = TokenFactor 0x21c6220, 0x21c6520, 0x21c7f60, 0x21c8260 [ORD=3] [ID=21]

=> 0x21c8660: ch = TokenFactor 0x21c6220, 0x21c6520, 0x21c7f60, 0x21c8260 [ORD=3]

Selecting:Opcode[89] 0x21c8760: i64 = sra 0x21c6020, 0x21c6720 [ORD=1] [ID=20]

ISEL: Starting pattern match on root node: 0x21c8760: i64 = sra 0x21c6020, 0x21c6720 [ORD=1] [ID=20]

  Initial Opcode index to 4560
  Skipped scope entry (due to false predicate) at index 4563, continuing at 4578
  Match failed at index 4587
  Continuing at 4604
  Morphed node: 0x21c8760: i64,i64 = SAR64rCL 0x21c6020, 0x21c8a60:1 [ORD=1]

ISEL: Match complete!
=> 0x21c8760: i64,i64 = SAR64rCL 0x21c6020, 0x21c8a60:1 [ORD=1]

Selecting:Opcode[39] 0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=19]

=> 0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1]

Selecting:Opcode[88] 0x21c6020: i64 = shl 0x21c5f20, 0x21c6720 [ORD=1] [ID=18]

ISEL: Starting pattern match on root node: 0x21c6020: i64 = shl 0x21c5f20, 0x21c6720 [ORD=1] [ID=18]

  Initial Opcode index to 3829
MatchAddress: Cse523ISelAddressMode 0x7fff16596820
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV <commented> nul CP nul
ES nul JT-1 Align0
  Match failed at index 3834
  Continuing at 3849
  Match failed at index 3855
  Continuing at 3884
  Match failed at index 3885
  Continuing at 3901
  Match failed at index 3910
  Continuing at 3927
  Morphed node: 0x21c6020: i64,i64 = SHL64rCL 0x21c5f20, 0x21c8c60:1 [ORD=1]

ISEL: Match complete!
=> 0x21c6020: i64,i64 = SHL64rCL 0x21c5f20, 0x21c8c60:1 [ORD=1]

Selecting:Opcode[39] 0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=17]

=> 0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1]

Selecting:Opcode[39] 0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2] [ID=16]

=> 0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2]

Selecting:Opcode[39] 0x21c7f60: ch = CopyToReg 0x219b660, 0x21c7e60, 0x21c6a20 [ORD=2] [ID=15]

=> 0x21c7f60: ch = CopyToReg 0x219b660, 0x21c7e60, 0x21c6a20 [ORD=2]

Selecting:Opcode[40] 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1] [ID=14]

=> 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1]

Selecting:Opcode[40] 0x21c5d20: i64,ch = CopyFromReg 0x219b660, 0x21c5c20 [ORD=1] [ID=13]

=> 0x21c5d20: i64,ch = CopyFromReg 0x219b660, 0x21c5c20 [ORD=1]

Selecting:Opcode[10] 0x21c6720: i64 = Constant<32> [ID=12]

ISEL: Starting pattern match on root node: 0x21c6720: i64 = Constant<32> [ID=12]

  Initial Opcode index to 5298
  Skipped scope entry (due to false predicate) at index 5302, continuing at 5312
  Morphed node: 0x21c6720: i64 = MOV64ri32 0x21ca480

ISEL: Match complete!
=> 0x21c6720: i64 = MOV64ri32 0x21ca480

Selecting:Opcode[5] 0x21c8860: ch = BasicBlock<for.body 0x21c0180> [ID=10]

=> 0x21c8860: ch = BasicBlock<for.body 0x21c0180>

Selecting:Opcode[5] 0x21c8560: ch = BasicBlock<for.end 0x21c02f0> [ID=9]

=> 0x21c8560: ch = BasicBlock<for.end 0x21c02f0>

Selecting:Opcode[8] 0x21c8160: i64 = Register %vreg10 [ID=8]

=> 0x21c8160: i64 = Register %vreg10

Selecting:Opcode[10] 0x21c8060: i64 = Constant<0> [ID=7]

ISEL: Starting pattern match on root node: 0x21c8060: i64 = Constant<0> [ID=7]

  Initial Opcode index to 5298
  Morphed node: 0x21c8060: i64,i64 = MOV64r0

ISEL: Match complete!
=> 0x21c8060: i64,i64 = MOV64r0

Selecting:Opcode[8] 0x21c7e60: i64 = Register %vreg9 [ID=6]

=> 0x21c7e60: i64 = Register %vreg9

Selecting:Opcode[10] 0x21c6a20: i64 = Constant<1> [ID=5]

ISEL: Starting pattern match on root node: 0x21c6a20: i64 = Constant<1> [ID=5]

  Initial Opcode index to 5298
  Skipped scope entry (due to false predicate) at index 5302, continuing at 5312
  Morphed node: 0x21c6a20: i64 = MOV64ri32 0x21ca580

ISEL: Match complete!
=> 0x21c6a20: i64 = MOV64ri32 0x21ca580

Selecting:Opcode[8] 0x21c6420: i64 = Register %vreg8 [ID=4]

=> 0x21c6420: i64 = Register %vreg8

Selecting:Opcode[8] 0x21c6120: i64 = Register %vreg7 [ID=3]

=> 0x21c6120: i64 = Register %vreg7

Selecting:Opcode[8] 0x21c5e20: i64 = Register %vreg6 [ID=2]

=> 0x21c5e20: i64 = Register %vreg6

Selecting:Opcode[8] 0x21c5c20: i64 = Register %vreg5 [ID=1]

=> 0x21c5c20: i64 = Register %vreg5

Selecting:Opcode[1] 0x219b660: ch = EntryToken [ID=0]

=> 0x219b660: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'quantum_ipow:entry'
SelectionDAG has 33 nodes:
  0x219b660: ch = EntryToken

    0x21ca480: i64 = TargetConstant<32>

  0x21c6720: i64 = MOV64ri32 0x21ca480

    0x219b660: <multiple use>
    0x21c5e20: i64 = Register %vreg6

  0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1]

      0x21c5f20: <multiple use>
        0x219b660: <multiple use>
        0x21c6320: <multiple use>
        0x21c6720: <multiple use>
      0x21c8c60: ch,glue = CopyToReg 0x219b660, 0x21c6320, 0x21c6720 [ORD=1]

    0x21c6020: i64,i64 = SHL64rCL 0x21c5f20, 0x21c8c60:1 [ORD=1]

      0x219b660: <multiple use>
      0x21c6320: <multiple use>
      0x21c6720: <multiple use>
    0x21c8a60: ch,glue = CopyToReg 0x219b660, 0x21c6320, 0x21c6720 [ORD=1]

  0x21c8760: i64,i64 = SAR64rCL 0x21c6020, 0x21c8a60:1 [ORD=1]

        0x219b660: <multiple use>
        0x21c6120: i64 = Register %vreg7

          0x219b660: <multiple use>
          0x21c5c20: i64 = Register %vreg5

        0x21c5d20: i64,ch = CopyFromReg 0x219b660, 0x21c5c20 [ORD=1]

      0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1]

        0x219b660: <multiple use>
        0x21c6420: i64 = Register %vreg8

        0x21c5f20: <multiple use>
      0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1]

        0x219b660: <multiple use>
        0x21c7e60: i64 = Register %vreg9

          0x21ca580: i64 = TargetConstant<1>

        0x21c6a20: i64 = MOV64ri32 0x21ca580

      0x21c7f60: ch = CopyToReg 0x219b660, 0x21c7e60, 0x21c6a20 [ORD=2]

        0x219b660: <multiple use>
        0x21c8160: i64 = Register %vreg10

        0x21c8060: i64,i64 = MOV64r0

      0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2]

    0x21c8660: ch = TokenFactor 0x21c6220, 0x21c6520, 0x21c7f60, 0x21c8260 [ORD=3]

    0x21c6920: i64 = Register %EFLAGS

      0x21c8760: <multiple use>
      0x21c8760: <multiple use>
    0x21c8360: i64 = TEST64rr 0x21c8760, 0x21c8760 [ORD=1]

  0x21c6620: ch,glue = CopyToReg 0x21c8660, 0x21c6920, 0x21c8360 [ORD=3]

  0x21c6320: i64 = Register %RCX

  0x21c8b60: i32 = Register %noreg

  0x21c8460: i64 = Register %noreg

    0x21c8860: ch = BasicBlock<for.body 0x21c0180>

      0x21c8560: ch = BasicBlock<for.end 0x21c02f0>

      0x21c6620: <multiple use>
      0x21c6620: <multiple use>
    0x21c6820: ch = JLE_4 0x21c8560, 0x21c6620, 0x21c6620:1 [ORD=3]

  0x21c8960: ch = JMP_4 0x21c8860, 0x21c6820 [ORD=3]


********** List Scheduling BB#0 'entry' **********
SU(0): 0x21c8960: ch = JMP_4 0x21c8860, 0x21c6820 [ORD=3] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x21c6820: ch = JLE_4 0x21c8560, 0x21c6620, 0x21c6620:1 [ORD=3] [ID=1]

    0x21c6620: ch,glue = CopyToReg 0x21c8660, 0x21c6920, 0x21c8360 [ORD=3] [ID=1]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
   ch  SU(7): Latency=0
   val SU(2): Latency=1 Reg=%EFLAGS
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x21c8360: i64 = TEST64rr 0x21c8760, 0x21c8760 [ORD=1] [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1 Reg=%EFLAGS

SU(3): 0x21c8760: i64,i64 = SAR64rCL 0x21c6020, 0x21c8a60:1 [ORD=1] [ID=3]

    0x21c8a60: ch,glue = CopyToReg 0x219b660, 0x21c6320, 0x21c6720 [ORD=1] [ID=3]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
   val SU(5): Latency=1
   val SU(4): Latency=1
  Successors:
   val SU(2): Latency=1

SU(4): 0x21c6720: i64 = MOV64ri32 0x21ca480 [ID=4]

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
   val SU(3): Latency=1
   val SU(5): Latency=1

SU(5): 0x21c6020: i64,i64 = SHL64rCL 0x21c5f20, 0x21c8c60:1 [ORD=1] [ID=5]

    0x21c8c60: ch,glue = CopyToReg 0x219b660, 0x21c6320, 0x21c6720 [ORD=1] [ID=5]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
   val SU(6): Latency=1
   val SU(4): Latency=1
  Successors:
   val SU(3): Latency=1

SU(6): 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1] [ID=6]

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
   val SU(5): Latency=1
   val SU(12): Latency=1

SU(7): 0x21c8660: ch = TokenFactor 0x21c6220, 0x21c6520, 0x21c7f60, 0x21c8260 [ORD=3] [ID=7]

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 1
  Predecessors:
   ch  SU(13): Latency=1
   ch  SU(12): Latency=1
   ch  SU(10): Latency=1
   ch  SU(8): Latency=1
  Successors:
   ch  SU(1): Latency=0

SU(8): 0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2] [ID=8]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(9): Latency=1
  Successors:
   ch  SU(7): Latency=1

SU(9): 0x21c8060: i64,i64 = MOV64r0 [ID=9]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(8): Latency=1

SU(10): 0x21c7f60: ch = CopyToReg 0x219b660, 0x21c7e60, 0x21c6a20 [ORD=2] [ID=10]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(11): Latency=1
  Successors:
   ch  SU(7): Latency=1

SU(11): 0x21c6a20: i64 = MOV64ri32 0x21ca580 [ID=11]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(10): Latency=1

SU(12): 0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=12]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(6): Latency=1
  Successors:
   ch  SU(7): Latency=1

SU(13): 0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=13]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(14): Latency=1
  Successors:
   ch  SU(7): Latency=1

SU(14): 0x21c5d20: i64,ch = CopyFromReg 0x219b660, 0x21c5c20 [ORD=1] [ID=14]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(13): Latency=1


Examining Available:
Height 0: SU(0): 0x21c8960: ch = JMP_4 0x21c8860, 0x21c6820 [ORD=3] [ID=0]


*** Scheduling [0]: SU(0): 0x21c8960: ch = JMP_4 0x21c8860, 0x21c6820 [ORD=3] [ID=0]


Examining Available:
Height 1: SU(1): 0x21c6820: ch = JLE_4 0x21c8560, 0x21c6620, 0x21c6620:1 [ORD=3] [ID=1]

    0x21c6620: ch,glue = CopyToReg 0x21c8660, 0x21c6920, 0x21c8360 [ORD=3] [ID=1]


*** Scheduling [1]: SU(1): 0x21c6820: ch = JLE_4 0x21c8560, 0x21c6620, 0x21c6620:1 [ORD=3] [ID=1]

    0x21c6620: ch,glue = CopyToReg 0x21c8660, 0x21c6920, 0x21c8360 [ORD=3] [ID=1]


Examining Available:
Height 1: SU(7): 0x21c8660: ch = TokenFactor 0x21c6220, 0x21c6520, 0x21c7f60, 0x21c8260 [ORD=3] [ID=7]

Height 2: SU(2): 0x21c8360: i64 = TEST64rr 0x21c8760, 0x21c8760 [ORD=1] [ID=2]


*** Scheduling [2]: SU(7): 0x21c8660: ch = TokenFactor 0x21c6220, 0x21c6520, 0x21c7f60, 0x21c8260 [ORD=3] [ID=7]


Examining Available:
  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg
Height 3: SU(10): 0x21c7f60: ch = CopyToReg 0x219b660, 0x21c7e60, 0x21c6a20 [ORD=2] [ID=10]

  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg
Height 3: SU(8): 0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2] [ID=8]

  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg
Height 2: SU(2): 0x21c8360: i64 = TEST64rr 0x21c8760, 0x21c8760 [ORD=1] [ID=2]

Height 3: SU(13): 0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=13]

Height 3: SU(12): 0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=12]

  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg

*** Scheduling [3]: SU(10): 0x21c7f60: ch = CopyToReg 0x219b660, 0x21c7e60, 0x21c6a20 [ORD=2] [ID=10]


Examining Available:
  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg
Height 4: SU(11): 0x21c6a20: i64 = MOV64ri32 0x21ca580 [ID=11]

  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg
Height 3: SU(8): 0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2] [ID=8]

  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg
Height 2: SU(2): 0x21c8360: i64 = TEST64rr 0x21c8760, 0x21c8760 [ORD=1] [ID=2]

Height 3: SU(13): 0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=13]

Height 3: SU(12): 0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=12]

  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg

*** Scheduling [4]: SU(11): 0x21c6a20: i64 = MOV64ri32 0x21ca580 [ID=11]


Examining Available:
  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg
Height 3: SU(8): 0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2] [ID=8]

  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg
Height 2: SU(2): 0x21c8360: i64 = TEST64rr 0x21c8760, 0x21c8760 [ORD=1] [ID=2]

Height 3: SU(13): 0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=13]

Height 3: SU(12): 0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=12]

  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg

*** Scheduling [5]: SU(8): 0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2] [ID=8]


Examining Available:
  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg
Height 6: SU(9): 0x21c8060: i64,i64 = MOV64r0 [ID=9]

  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg
Height 2: SU(2): 0x21c8360: i64 = TEST64rr 0x21c8760, 0x21c8760 [ORD=1] [ID=2]

Height 3: SU(13): 0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=13]

Height 3: SU(12): 0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=12]

  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg
    Interfering reg EFLAGS SU #9
  SU (2)  defines a physreg SU(13)  has no physreg
  SU (2)  defines a physreg SU(12)  has no physreg

*** Scheduling [6]: SU(2): 0x21c8360: i64 = TEST64rr 0x21c8760, 0x21c8760 [ORD=1] [ID=2]

    Repushing SU #9

Examining Available:
Height 6: SU(9): 0x21c8060: i64,i64 = MOV64r0 [ID=9]

Height 3: SU(13): 0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=13]

Height 3: SU(12): 0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=12]

Height 7: SU(3): 0x21c8760: i64,i64 = SAR64rCL 0x21c6020, 0x21c8a60:1 [ORD=1] [ID=3]

    0x21c8a60: ch,glue = CopyToReg 0x219b660, 0x21c6320, 0x21c6720 [ORD=1] [ID=3]


*** Scheduling [7]: SU(9): 0x21c8060: i64,i64 = MOV64r0 [ID=9]


Examining Available:
Height 3: SU(13): 0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=13]

Height 3: SU(12): 0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=12]

Height 7: SU(3): 0x21c8760: i64,i64 = SAR64rCL 0x21c6020, 0x21c8a60:1 [ORD=1] [ID=3]

    0x21c8a60: ch,glue = CopyToReg 0x219b660, 0x21c6320, 0x21c6720 [ORD=1] [ID=3]


*** Scheduling [8]: SU(13): 0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=13]


Examining Available:
Height 9: SU(14): 0x21c5d20: i64,ch = CopyFromReg 0x219b660, 0x21c5c20 [ORD=1] [ID=14]

Height 3: SU(12): 0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=12]

Height 7: SU(3): 0x21c8760: i64,i64 = SAR64rCL 0x21c6020, 0x21c8a60:1 [ORD=1] [ID=3]

    0x21c8a60: ch,glue = CopyToReg 0x219b660, 0x21c6320, 0x21c6720 [ORD=1] [ID=3]


*** Scheduling [9]: SU(14): 0x21c5d20: i64,ch = CopyFromReg 0x219b660, 0x21c5c20 [ORD=1] [ID=14]


Examining Available:
Height 3: SU(12): 0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=12]

Height 7: SU(3): 0x21c8760: i64,i64 = SAR64rCL 0x21c6020, 0x21c8a60:1 [ORD=1] [ID=3]

    0x21c8a60: ch,glue = CopyToReg 0x219b660, 0x21c6320, 0x21c6720 [ORD=1] [ID=3]


*** Scheduling [10]: SU(12): 0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=12]


Examining Available:
Height 7: SU(3): 0x21c8760: i64,i64 = SAR64rCL 0x21c6020, 0x21c8a60:1 [ORD=1] [ID=3]

    0x21c8a60: ch,glue = CopyToReg 0x219b660, 0x21c6320, 0x21c6720 [ORD=1] [ID=3]


*** Scheduling [11]: SU(3): 0x21c8760: i64,i64 = SAR64rCL 0x21c6020, 0x21c8a60:1 [ORD=1] [ID=3]

    0x21c8a60: ch,glue = CopyToReg 0x219b660, 0x21c6320, 0x21c6720 [ORD=1] [ID=3]


Examining Available:
Height 12: SU(5): 0x21c6020: i64,i64 = SHL64rCL 0x21c5f20, 0x21c8c60:1 [ORD=1] [ID=5]

    0x21c8c60: ch,glue = CopyToReg 0x219b660, 0x21c6320, 0x21c6720 [ORD=1] [ID=5]


*** Scheduling [12]: SU(5): 0x21c6020: i64,i64 = SHL64rCL 0x21c5f20, 0x21c8c60:1 [ORD=1] [ID=5]

    0x21c8c60: ch,glue = CopyToReg 0x219b660, 0x21c6320, 0x21c6720 [ORD=1] [ID=5]


Examining Available:
Height 13: SU(4): 0x21c6720: i64 = MOV64ri32 0x21ca480 [ID=4]

Height 13: SU(6): 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1] [ID=6]


*** Scheduling [13]: SU(4): 0x21c6720: i64 = MOV64ri32 0x21ca480 [ID=4]


Examining Available:
Height 13: SU(6): 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1] [ID=6]


*** Scheduling [14]: SU(6): 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1] [ID=6]

*** Final schedule ***
SU(6): 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c5e20 [ORD=1] [ID=6]

SU(4): 0x21c6720: i64 = MOV64ri32 0x21ca480 [ID=4]

SU(5): 0x21c6020: i64,i64 = SHL64rCL 0x21c5f20, 0x21c8c60:1 [ORD=1] [ID=5]

    0x21c8c60: ch,glue = CopyToReg 0x219b660, 0x21c6320, 0x21c6720 [ORD=1] [ID=5]

SU(3): 0x21c8760: i64,i64 = SAR64rCL 0x21c6020, 0x21c8a60:1 [ORD=1] [ID=3]

    0x21c8a60: ch,glue = CopyToReg 0x219b660, 0x21c6320, 0x21c6720 [ORD=1] [ID=3]

SU(12): 0x21c6520: ch = CopyToReg 0x219b660, 0x21c6420, 0x21c5f20 [ORD=1] [ID=12]

SU(14): 0x21c5d20: i64,ch = CopyFromReg 0x219b660, 0x21c5c20 [ORD=1] [ID=14]

SU(13): 0x21c6220: ch = CopyToReg 0x219b660, 0x21c6120, 0x21c5d20 [ORD=1] [ID=13]

SU(9): 0x21c8060: i64,i64 = MOV64r0 [ID=9]

SU(2): 0x21c8360: i64 = TEST64rr 0x21c8760, 0x21c8760 [ORD=1] [ID=2]

SU(8): 0x21c8260: ch = CopyToReg 0x219b660, 0x21c8160, 0x21c8060 [ORD=2] [ID=8]

SU(11): 0x21c6a20: i64 = MOV64ri32 0x21ca580 [ID=11]

SU(10): 0x21c7f60: ch = CopyToReg 0x219b660, 0x21c7e60, 0x21c6a20 [ORD=2] [ID=10]

SU(7): 0x21c8660: ch = TokenFactor 0x21c6220, 0x21c6520, 0x21c7f60, 0x21c8260 [ORD=3] [ID=7]

SU(1): 0x21c6820: ch = JLE_4 0x21c8560, 0x21c6620, 0x21c6620:1 [ORD=3] [ID=1]

    0x21c6620: ch,glue = CopyToReg 0x21c8660, 0x21c6920, 0x21c8360 [ORD=3] [ID=1]

SU(0): 0x21c8960: ch = JMP_4 0x21c8860, 0x21c6820 [ORD=3] [ID=0]


Total amount of phi nodes to update: 3
Node 0 : (0x21c0230, 2147483657)
Node 1 : (0x21c0290, 2147483658)
Node 2 : (0x21c03a0, 2147483657)
Initial selection DAG: BB#1 'quantum_ipow:for.body'
SelectionDAG has 31 nodes:
  0x219b660: ch = EntryToken

        0x219b660: <multiple use>
        0x21c6820: i64 = Register %vreg1

      0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3]

    0x21c8660: i32 = truncate 0x21c8360 [ORD=3]

    0x21c8760: i32 = Constant<1>

  0x21c6520: i32 = add 0x21c8660, 0x21c8760 [ORD=3]

          0x219b660: <multiple use>
          0x21c6920: i64 = Register %vreg2

                  0x219b660: <multiple use>
                  0x21ca580: i64 = Register %vreg0

                0x21ca480: i64,ch = CopyFromReg 0x219b660, 0x21ca580 [ORD=2]

              0x21c8c60: i32 = truncate 0x21ca480 [ORD=2]

                  0x219b660: <multiple use>
                  0x21c8460: i64 = Register %vreg7

                0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2]

              0x21c8a60: i32 = truncate 0x21c8b60 [ORD=2]

            0x21c6320: i32 = mul 0x21c8c60, 0x21c8a60 [ORD=2]

          0x21c6620: i64 = any_extend 0x21c6320 [ORD=2]

        0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c6620 [ORD=2]

          0x219b660: <multiple use>
          0x21c6220: i64 = Register %vreg3

            0x21c6520: <multiple use>
          0x21c6020: i64 = any_extend 0x21c6520 [ORD=3]

        0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c6020 [ORD=3]

      0x21c7e60: ch = TokenFactor 0x21c8960, 0x21c8260 [ORD=5]

          0x21c6520: <multiple use>
              0x219b660: <multiple use>
              0x21c7f60: i64 = Register %vreg8

            0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c7f60 [ORD=4]

          0x21c5d20: i32 = truncate 0x21c5f20 [ORD=4]

          0x21c6720: ch = seteq

        0x21c8860: i1 = setcc 0x21c6520, 0x21c5d20, 0x21c6720 [ORD=4]

        0x21c8560: i1 = Constant<-1>

      0x21c8160: i1 = xor 0x21c8860, 0x21c8560 [ORD=5]

      0x21c8060: ch = BasicBlock<for.body 0x21c0180>

    0x21c6a20: ch = brcond 0x21c7e60, 0x21c8160, 0x21c8060 [ORD=5]

    0x21c6420: ch = BasicBlock<for.end 0x21c02f0>

  0x21c6120: ch = br 0x21c6a20, 0x21c6420 [ORD=5]



Replacing.3 0x21c8160: i1 = xor 0x21c8860, 0x21c8560 [ORD=5]

With: 0x21c5c20: i1 = setcc 0x21c6520, 0x21c5d20, 0x21c5e20 [ORD=5]

Optimized lowered selection DAG: BB#1 'quantum_ipow:for.body'
SelectionDAG has 29 nodes:
  0x219b660: ch = EntryToken

        0x219b660: <multiple use>
        0x21c6820: i64 = Register %vreg1

      0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3]

    0x21c8660: i32 = truncate 0x21c8360 [ORD=3]

    0x21c8760: i32 = Constant<1>

  0x21c6520: i32 = add 0x21c8660, 0x21c8760 [ORD=3]

          0x219b660: <multiple use>
          0x21c6920: i64 = Register %vreg2

                  0x219b660: <multiple use>
                  0x21ca580: i64 = Register %vreg0

                0x21ca480: i64,ch = CopyFromReg 0x219b660, 0x21ca580 [ORD=2]

              0x21c8c60: i32 = truncate 0x21ca480 [ORD=2]

                  0x219b660: <multiple use>
                  0x21c8460: i64 = Register %vreg7

                0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2]

              0x21c8a60: i32 = truncate 0x21c8b60 [ORD=2]

            0x21c6320: i32 = mul 0x21c8c60, 0x21c8a60 [ORD=2]

          0x21c6620: i64 = any_extend 0x21c6320 [ORD=2]

        0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c6620 [ORD=2]

          0x219b660: <multiple use>
          0x21c6220: i64 = Register %vreg3

            0x21c6520: <multiple use>
          0x21c6020: i64 = any_extend 0x21c6520 [ORD=3]

        0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c6020 [ORD=3]

      0x21c7e60: ch = TokenFactor 0x21c8960, 0x21c8260 [ORD=5]

        0x21c6520: <multiple use>
            0x219b660: <multiple use>
            0x21c7f60: i64 = Register %vreg8

          0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c7f60 [ORD=4]

        0x21c5d20: i32 = truncate 0x21c5f20 [ORD=4]

        0x21c5e20: ch = setne

      0x21c5c20: i1 = setcc 0x21c6520, 0x21c5d20, 0x21c5e20 [ORD=5]

      0x21c8060: ch = BasicBlock<for.body 0x21c0180>

    0x21c6a20: ch = brcond 0x21c7e60, 0x21c5c20, 0x21c8060 [ORD=5]

    0x21c6420: ch = BasicBlock<for.end 0x21c02f0>

  0x21c6120: ch = br 0x21c6a20, 0x21c6420 [ORD=5]


Legally typed node: 0x21c5e20: ch = setne [ID=0]

Legally typed node: 0x21c6420: ch = BasicBlock<for.end 0x21c02f0> [ID=0]

Legally typed node: 0x21c8060: ch = BasicBlock<for.body 0x21c0180> [ID=0]

Legally typed node: 0x21c7f60: i64 = Register %vreg8 [ID=0]

Legally typed node: 0x21c6220: i64 = Register %vreg3 [ID=0]

Promote integer result: 0x21c8760: i32 = Constant<1> [ID=0]

Legally typed node: 0x21c6720: i64 = Constant<1> [ID=0]

Legally typed node: 0x21c6820: i64 = Register %vreg1 [ID=0]

Legally typed node: 0x21c6920: i64 = Register %vreg2 [ID=0]

Legally typed node: 0x21c8460: i64 = Register %vreg7 [ID=0]

Legally typed node: 0x21ca580: i64 = Register %vreg0 [ID=0]

Legally typed node: 0x219b660: ch = EntryToken [ID=0]

Legally typed node: 0x21ca480: i64,ch = CopyFromReg 0x219b660, 0x21ca580 [ORD=2] [ID=0]

Promote integer result: 0x21c8c60: i32 = truncate 0x21ca480 [ORD=2] [ID=0]

Legally typed node: 0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2] [ID=0]

Promote integer result: 0x21c8a60: i32 = truncate 0x21c8b60 [ORD=2] [ID=0]

Promote integer result: 0x21c6320: i32 = mul 0x21c8c60, 0x21c8a60 [ORD=2] [ID=0]

Promote integer operand: 0x21c6620: i64 = any_extend 0x21c6320 [ORD=2] [ID=0]

Legally typed node: 0x21c8860: i64 = mul 0x21ca480, 0x21c8b60 [ORD=2] [ID=0]

Legally typed node: 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=0]

Legally typed node: 0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3] [ID=0]

Promote integer result: 0x21c8660: i32 = truncate 0x21c8360 [ORD=3] [ID=0]

Promote integer result: 0x21c6520: i32 = add 0x21c8660, 0x21c8760 [ORD=3] [ID=0]

Promote integer operand: 0x21c6020: i64 = any_extend 0x21c6520 [ORD=3] [ID=0]

Legally typed node: 0x21c8560: i64 = add 0x21c8360, 0x21c6720 [ORD=3] [ID=0]

Legally typed node: 0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3] [ID=0]

Legally typed node: 0x21c7e60: ch = TokenFactor 0x21c8960, 0x21c8260 [ORD=5] [ID=0]

Legally typed node: 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c7f60 [ORD=4] [ID=0]

Promote integer result: 0x21c5d20: i32 = truncate 0x21c5f20 [ORD=4] [ID=0]

Promote integer result: 0x21c5c20: i1 = setcc 0x21c6520, 0x21c5d20, 0x21c5e20 [ORD=5] [ID=0]

Promote integer operand: 0x21c6a20: ch = brcond 0x21c7e60, 0x21c5c20, 0x21c8060 [ORD=5] [ID=0]

Promote integer operand: 0x21ca680: i64 = zero_extend 0x21c5c20 [ORD=5] [ID=0]

Promote integer operand: 0x21c8160: i64 = setcc 0x21c6520, 0x21c5d20, 0x21c5e20 [ORD=5] [ID=0]

Legally typed node: 0x21ca880: i64 = Constant<4294967295> [ID=0]

Legally typed node: 0x21ca980: i64 = and 0x21c8560, 0x21ca880 [ORD=3] [ID=0]

Legally typed node: 0x21caa80: i64 = and 0x21c5f20, 0x21ca880 [ORD=4] [ID=0]

Legally typed node: 0x21c8160: i64 = setcc 0x21ca980, 0x21caa80, 0x21c5e20 [ORD=5] [ID=0]

Legally typed node: 0x21ca780: i64 = and 0x21c8160, 0x21c6720 [ORD=5] [ID=0]

Legally typed node: 0x21c6a20: ch = brcond 0x21c7e60, 0x21ca780, 0x21c8060 [ORD=5] [ID=0]

Legally typed node: 0x21c6120: ch = br 0x21c6a20, 0x21c6420 [ORD=5] [ID=0]

Legally typed node: 0x7fff16596d20: ch = handlenode 0x21c6120 [ID=0]

Type-legalized selection DAG: BB#1 'quantum_ipow:for.body'
SelectionDAG has 27 nodes:
  0x219b660: ch = EntryToken [ID=-3]

  0x21c6720: i64 = Constant<1> [ID=-3]

      0x219b660: <multiple use>
      0x21c6820: i64 = Register %vreg1 [ID=-3]

    0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3] [ID=-3]

    0x21c6720: <multiple use>
  0x21c8560: i64 = add 0x21c8360, 0x21c6720 [ORD=3] [ID=-3]

  0x21ca880: i64 = Constant<4294967295> [ID=-3]

          0x219b660: <multiple use>
          0x21c6920: i64 = Register %vreg2 [ID=-3]

              0x219b660: <multiple use>
              0x21ca580: i64 = Register %vreg0 [ID=-3]

            0x21ca480: i64,ch = CopyFromReg 0x219b660, 0x21ca580 [ORD=2] [ID=-3]

              0x219b660: <multiple use>
              0x21c8460: i64 = Register %vreg7 [ID=-3]

            0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2] [ID=-3]

          0x21c8860: i64 = mul 0x21ca480, 0x21c8b60 [ORD=2] [ID=-3]

        0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=-3]

          0x219b660: <multiple use>
          0x21c6220: i64 = Register %vreg3 [ID=-3]

          0x21c8560: <multiple use>
        0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3] [ID=-3]

      0x21c7e60: ch = TokenFactor 0x21c8960, 0x21c8260 [ORD=5] [ID=-3]

            0x21c8560: <multiple use>
            0x21ca880: <multiple use>
          0x21ca980: i64 = and 0x21c8560, 0x21ca880 [ORD=3] [ID=-3]

              0x219b660: <multiple use>
              0x21c7f60: i64 = Register %vreg8 [ID=-3]

            0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c7f60 [ORD=4] [ID=-3]

            0x21ca880: <multiple use>
          0x21caa80: i64 = and 0x21c5f20, 0x21ca880 [ORD=4] [ID=-3]

          0x21c5e20: ch = setne [ID=-3]

        0x21c8160: i64 = setcc 0x21ca980, 0x21caa80, 0x21c5e20 [ORD=5] [ID=-3]

        0x21c6720: <multiple use>
      0x21ca780: i64 = and 0x21c8160, 0x21c6720 [ORD=5] [ID=-3]

      0x21c8060: ch = BasicBlock<for.body 0x21c0180> [ID=-3]

    0x21c6a20: ch = brcond 0x21c7e60, 0x21ca780, 0x21c8060 [ORD=5] [ID=-3]

    0x21c6420: ch = BasicBlock<for.end 0x21c02f0> [ID=-3]

  0x21c6120: ch = br 0x21c6a20, 0x21c6420 [ORD=5] [ID=-3]



Replacing.2 0x21ca780: i64 = and 0x21c8160, 0x21c6720 [ORD=5] [ID=-3]

With: 0x21c8160: i64 = setcc 0x21ca980, 0x21caa80, 0x21c5e20 [ORD=5] [ID=-3]

Optimized type-legalized selection DAG: BB#1 'quantum_ipow:for.body'
SelectionDAG has 26 nodes:
  0x219b660: ch = EntryToken [ID=-3]

      0x219b660: <multiple use>
      0x21c6820: i64 = Register %vreg1 [ID=-3]

    0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3] [ID=-3]

    0x21c6720: i64 = Constant<1> [ID=-3]

  0x21c8560: i64 = add 0x21c8360, 0x21c6720 [ORD=3] [ID=-3]

  0x21ca880: i64 = Constant<4294967295> [ID=-3]

          0x219b660: <multiple use>
          0x21c6920: i64 = Register %vreg2 [ID=-3]

              0x219b660: <multiple use>
              0x21ca580: i64 = Register %vreg0 [ID=-3]

            0x21ca480: i64,ch = CopyFromReg 0x219b660, 0x21ca580 [ORD=2] [ID=-3]

              0x219b660: <multiple use>
              0x21c8460: i64 = Register %vreg7 [ID=-3]

            0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2] [ID=-3]

          0x21c8860: i64 = mul 0x21ca480, 0x21c8b60 [ORD=2] [ID=-3]

        0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=-3]

          0x219b660: <multiple use>
          0x21c6220: i64 = Register %vreg3 [ID=-3]

          0x21c8560: <multiple use>
        0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3] [ID=-3]

      0x21c7e60: ch = TokenFactor 0x21c8960, 0x21c8260 [ORD=5] [ID=-3]

          0x21c8560: <multiple use>
          0x21ca880: <multiple use>
        0x21ca980: i64 = and 0x21c8560, 0x21ca880 [ORD=3] [ID=-3]

            0x219b660: <multiple use>
            0x21c7f60: i64 = Register %vreg8 [ID=-3]

          0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c7f60 [ORD=4] [ID=-3]

          0x21ca880: <multiple use>
        0x21caa80: i64 = and 0x21c5f20, 0x21ca880 [ORD=4] [ID=-3]

        0x21c5e20: ch = setne [ID=-3]

      0x21c8160: i64 = setcc 0x21ca980, 0x21caa80, 0x21c5e20 [ORD=5] [ID=-3]

      0x21c8060: ch = BasicBlock<for.body 0x21c0180> [ID=-3]

    0x21c6a20: ch = brcond 0x21c7e60, 0x21c8160, 0x21c8060 [ORD=5] [ID=-3]

    0x21c6420: ch = BasicBlock<for.end 0x21c02f0> [ID=-3]

  0x21c6120: ch = br 0x21c6a20, 0x21c6420 [ORD=5] [ID=-3]


Legalized selection DAG: BB#1 'quantum_ipow:for.body'
SelectionDAG has 26 nodes:
  0x219b660: ch = EntryToken [ID=0]

  0x21ca880: i64 = Constant<4294967295> [ID=11]

      0x219b660: <multiple use>
      0x21c6820: i64 = Register %vreg1 [ID=4]

    0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3] [ID=14]

    0x21c6720: i64 = Constant<1> [ID=10]

  0x21c8560: i64 = add 0x21c8360, 0x21c6720 [ORD=3] [ID=17]

          0x219b660: <multiple use>
          0x21c6920: i64 = Register %vreg2 [ID=3]

              0x219b660: <multiple use>
              0x21ca580: i64 = Register %vreg0 [ID=1]

            0x21ca480: i64,ch = CopyFromReg 0x219b660, 0x21ca580 [ORD=2] [ID=12]

              0x219b660: <multiple use>
              0x21c8460: i64 = Register %vreg7 [ID=2]

            0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2] [ID=13]

          0x21c8860: i64 = mul 0x21ca480, 0x21c8b60 [ORD=2] [ID=16]

        0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=19]

          0x219b660: <multiple use>
          0x21c6220: i64 = Register %vreg3 [ID=5]

          0x21c8560: <multiple use>
        0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3] [ID=21]

      0x21c7e60: ch = TokenFactor 0x21c8960, 0x21c8260 [ORD=5] [ID=23]

      0x21c8060: ch = BasicBlock<for.body 0x21c0180> [ID=7]

      0x21c8c60: i64 = Constant<9>

          0x21c8560: <multiple use>
          0x21ca880: <multiple use>
        0x21ca980: i64 = and 0x21c8560, 0x21ca880 [ORD=3] [ID=20]

            0x219b660: <multiple use>
            0x21c7f60: i64 = Register %vreg8 [ID=6]

          0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c7f60 [ORD=4] [ID=15]

          0x21ca880: <multiple use>
        0x21caa80: i64 = and 0x21c5f20, 0x21ca880 [ORD=4] [ID=18]

      0x21ca780: i64,i64 = Cse523ISD::SUB 0x21ca980, 0x21caa80 [ORD=3]

    0x21c6320: ch = Cse523ISD::BRCOND 0x21c7e60, 0x21c8060, 0x21c8c60, 0x21ca780:1 [ORD=5]

    0x21c6420: ch = BasicBlock<for.end 0x21c02f0> [ID=8]

  0x21c6120: ch = br 0x21c6320, 0x21c6420 [ORD=5] [ID=25]


Optimized legalized selection DAG: BB#1 'quantum_ipow:for.body'
SelectionDAG has 26 nodes:
  0x219b660: ch = EntryToken [ID=0]

  0x21ca880: i64 = Constant<4294967295> [ID=11]

      0x219b660: <multiple use>
      0x21c6820: i64 = Register %vreg1 [ID=4]

    0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3] [ID=14]

    0x21c6720: i64 = Constant<1> [ID=10]

  0x21c8560: i64 = add 0x21c8360, 0x21c6720 [ORD=3] [ID=17]

          0x219b660: <multiple use>
          0x21c6920: i64 = Register %vreg2 [ID=3]

              0x219b660: <multiple use>
              0x21ca580: i64 = Register %vreg0 [ID=1]

            0x21ca480: i64,ch = CopyFromReg 0x219b660, 0x21ca580 [ORD=2] [ID=12]

              0x219b660: <multiple use>
              0x21c8460: i64 = Register %vreg7 [ID=2]

            0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2] [ID=13]

          0x21c8860: i64 = mul 0x21ca480, 0x21c8b60 [ORD=2] [ID=16]

        0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=19]

          0x219b660: <multiple use>
          0x21c6220: i64 = Register %vreg3 [ID=5]

          0x21c8560: <multiple use>
        0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3] [ID=21]

      0x21c7e60: ch = TokenFactor 0x21c8960, 0x21c8260 [ORD=5] [ID=23]

      0x21c8060: ch = BasicBlock<for.body 0x21c0180> [ID=7]

      0x21c8c60: i64 = Constant<9>

          0x21c8560: <multiple use>
          0x21ca880: <multiple use>
        0x21ca980: i64 = and 0x21c8560, 0x21ca880 [ORD=3] [ID=20]

            0x219b660: <multiple use>
            0x21c7f60: i64 = Register %vreg8 [ID=6]

          0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c7f60 [ORD=4] [ID=15]

          0x21ca880: <multiple use>
        0x21caa80: i64 = and 0x21c5f20, 0x21ca880 [ORD=4] [ID=18]

      0x21ca780: i64,i64 = Cse523ISD::SUB 0x21ca980, 0x21caa80 [ORD=3]

    0x21c6320: ch = Cse523ISD::BRCOND 0x21c7e60, 0x21c8060, 0x21c8c60, 0x21ca780:1 [ORD=5]

    0x21c6420: ch = BasicBlock<for.end 0x21c02f0> [ID=8]

  0x21c6120: ch = br 0x21c6320, 0x21c6420 [ORD=5] [ID=25]


===== Instruction selection begins: BB#1 'for.body'
Selecting:Opcode[146] 0x21c6120: ch = br 0x21c6320, 0x21c6420 [ORD=5] [ID=25]

ISEL: Starting pattern match on root node: 0x21c6120: ch = br 0x21c6320, 0x21c6420 [ORD=5] [ID=25]

  Initial Opcode index to 5420
  Morphed node: 0x21c6120: ch = JMP_4 0x21c6420, 0x21c6320 [ORD=5]

ISEL: Match complete!
=> 0x21c6120: ch = JMP_4 0x21c6420, 0x21c6320 [ORD=5]

Selecting:Opcode[210] 0x21c6320: ch = Cse523ISD::BRCOND 0x21c7e60, 0x21c8060, 0x21c8c60, 0x21ca780:1 [ORD=5] [ID=24]

ISEL: Starting pattern match on root node: 0x21c6320: ch = Cse523ISD::BRCOND 0x21c7e60, 0x21c8060, 0x21c8c60, 0x21ca780:1 [ORD=5] [ID=24]

  Initial Opcode index to 4241
  Skipped scope entry (due to false predicate) at index 4251, continuing at 4265
  Skipped scope entry (due to false predicate) at index 4266, continuing at 4280
  Skipped scope entry (due to false predicate) at index 4281, continuing at 4295
  Skipped scope entry (due to false predicate) at index 4296, continuing at 4310
  Skipped scope entry (due to false predicate) at index 4311, continuing at 4325
  Morphed node: 0x21c6320: ch = JNE_4 0x21c8060, 0x21c5e20, 0x21c5e20:1 [ORD=5]

ISEL: Match complete!
=> 0x21c6320: ch = JNE_4 0x21c8060, 0x21c5e20, 0x21c5e20:1 [ORD=5]

Selecting:Opcode[2] 0x21c7e60: ch = TokenFactor 0x21c8960, 0x21c8260 [ORD=5] [ID=23]

=> 0x21c7e60: ch = TokenFactor 0x21c8960, 0x21c8260 [ORD=5]

Selecting:Opcode[275] 0x21ca780: i64,i64 = Cse523ISD::SUB 0x21ca980, 0x21caa80 [ORD=3] [ID=22]

ISEL: Starting pattern match on root node: 0x21ca780: i64,i64 = Cse523ISD::SUB 0x21ca980, 0x21caa80 [ORD=3] [ID=22]

  Initial Opcode index to 4142
  Skipped scope entry (due to false predicate) at index 4144, continuing at 4158
  Match failed at index 4165
  Continuing at 4185
  Morphed node: 0x21ca780: i64,i64 = SUB64rr 0x21ca980, 0x21caa80 [ORD=3]

ISEL: Match complete!
=> 0x21ca780: i64,i64 = SUB64rr 0x21ca980, 0x21caa80 [ORD=3]

Selecting:Opcode[39] 0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3] [ID=21]

=> 0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3]

Selecting:Opcode[85] 0x21ca980: i64 = and 0x21c8560, 0x21ca880 [ORD=3] [ID=20]

ISEL: Starting pattern match on root node: 0x21ca980: i64 = and 0x21c8560, 0x21ca880 [ORD=3] [ID=20]

  Initial Opcode index to 4949
  Match failed at index 4958
  Continuing at 4975
  Morphed node: 0x21ca980: i64,i64 = AND64rr 0x21c8560, 0x21ca880 [ORD=3]

ISEL: Match complete!
=> 0x21ca980: i64,i64 = AND64rr 0x21c8560, 0x21ca880 [ORD=3]

Selecting:Opcode[39] 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=19]

=> 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2]

Selecting:Opcode[85] 0x21caa80: i64 = and 0x21c5f20, 0x21ca880 [ORD=4] [ID=18]

ISEL: Starting pattern match on root node: 0x21caa80: i64 = and 0x21c5f20, 0x21ca880 [ORD=4] [ID=18]

  Initial Opcode index to 4949
  Match failed at index 4958
  Continuing at 4975
  Morphed node: 0x21caa80: i64,i64 = AND64rr 0x21c5f20, 0x21ca880 [ORD=4]

ISEL: Match complete!
=> 0x21caa80: i64,i64 = AND64rr 0x21c5f20, 0x21ca880 [ORD=4]

Selecting:Opcode[45] 0x21c8560: i64 = add 0x21c8360, 0x21c6720 [ORD=3] [ID=17]

ISEL: Starting pattern match on root node: 0x21c8560: i64 = add 0x21c8360, 0x21c6720 [ORD=3] [ID=17]

  Initial Opcode index to 3325
MatchAddress: Cse523ISelAddressMode 0x7fff16596820
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV <commented> nul CP nul
ES nul JT-1 Align0
MatchAddress: Cse523ISelAddressMode 0x7fff16596820
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV <commented> nul CP nul
ES nul JT-1 Align0
MatchAddress: Cse523ISelAddressMode 0x7fff16596820
Base_Reg 0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3] [ID=14]
 Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV <commented> nul CP nul
ES nul JT-1 Align0
  Match failed at index 3330
  Continuing at 3345
  Match failed at index 3349
  Continuing at 3459
  Match failed at index 3462
  Continuing at 3578
  Morphed node: 0x21c8560: i64,i64 = INC64r 0x21c8360 [ORD=3]

ISEL: Match complete!
=> 0x21c8560: i64,i64 = INC64r 0x21c8360 [ORD=3]

Selecting:Opcode[47] 0x21c8860: i64 = mul 0x21ca480, 0x21c8b60 [ORD=2] [ID=16]

ISEL: Starting pattern match on root node: 0x21c8860: i64 = mul 0x21ca480, 0x21c8b60 [ORD=2] [ID=16]

  Initial Opcode index to 3743
MatchAddress: Cse523ISelAddressMode 0x7fff16596820
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV <commented> nul CP nul
ES nul JT-1 Align0
  Match failed at index 3748
  Continuing at 3763
  Match failed at index 3770
  Continuing at 3790
  Morphed node: 0x21c8860: i64,i64 = IMUL64rr 0x21ca480, 0x21c8b60 [ORD=2]

ISEL: Match complete!
=> 0x21c8860: i64,i64 = IMUL64rr 0x21ca480, 0x21c8b60 [ORD=2]

Selecting:Opcode[40] 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c7f60 [ORD=4] [ID=15]

=> 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c7f60 [ORD=4]

Selecting:Opcode[40] 0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3] [ID=14]

=> 0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3]

Selecting:Opcode[40] 0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2] [ID=13]

=> 0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2]

Selecting:Opcode[40] 0x21ca480: i64,ch = CopyFromReg 0x219b660, 0x21ca580 [ORD=2] [ID=12]

=> 0x21ca480: i64,ch = CopyFromReg 0x219b660, 0x21ca580 [ORD=2]

Selecting:Opcode[10] 0x21ca880: i64 = Constant<4294967295> [ID=10]

ISEL: Starting pattern match on root node: 0x21ca880: i64 = Constant<4294967295> [ID=10]

  Initial Opcode index to 5298
  Skipped scope entry (due to false predicate) at index 5302, continuing at 5312
  Skipped scope entry (due to false predicate) at index 5316, continuing at 5328
  Morphed node: 0x21ca880: i64 = MOV64ri 0x21c6720

ISEL: Match complete!
=> 0x21ca880: i64 = MOV64ri 0x21c6720

Selecting:Opcode[5] 0x21c6420: ch = BasicBlock<for.end 0x21c02f0> [ID=8]

=> 0x21c6420: ch = BasicBlock<for.end 0x21c02f0>

Selecting:Opcode[5] 0x21c8060: ch = BasicBlock<for.body 0x21c0180> [ID=7]

=> 0x21c8060: ch = BasicBlock<for.body 0x21c0180>

Selecting:Opcode[8] 0x21c7f60: i64 = Register %vreg8 [ID=6]

=> 0x21c7f60: i64 = Register %vreg8

Selecting:Opcode[8] 0x21c6220: i64 = Register %vreg3 [ID=5]

=> 0x21c6220: i64 = Register %vreg3

Selecting:Opcode[8] 0x21c6820: i64 = Register %vreg1 [ID=4]

=> 0x21c6820: i64 = Register %vreg1

Selecting:Opcode[8] 0x21c6920: i64 = Register %vreg2 [ID=3]

=> 0x21c6920: i64 = Register %vreg2

Selecting:Opcode[8] 0x21c8460: i64 = Register %vreg7 [ID=2]

=> 0x21c8460: i64 = Register %vreg7

Selecting:Opcode[8] 0x21ca580: i64 = Register %vreg0 [ID=1]

=> 0x21ca580: i64 = Register %vreg0

Selecting:Opcode[1] 0x219b660: ch = EntryToken [ID=0]

=> 0x219b660: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#1 'quantum_ipow:for.body'
SelectionDAG has 29 nodes:
  0x219b660: ch = EntryToken

    0x21c6720: i64 = TargetConstant<4294967295>

  0x21ca880: i64 = MOV64ri 0x21c6720

      0x219b660: <multiple use>
      0x21c6820: i64 = Register %vreg1

    0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3]

  0x21c8560: i64,i64 = INC64r 0x21c8360 [ORD=3]

        0x219b660: <multiple use>
        0x21c6920: i64 = Register %vreg2

            0x219b660: <multiple use>
            0x21ca580: i64 = Register %vreg0

          0x21ca480: i64,ch = CopyFromReg 0x219b660, 0x21ca580 [ORD=2]

            0x219b660: <multiple use>
            0x21c8460: i64 = Register %vreg7

          0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2]

        0x21c8860: i64,i64 = IMUL64rr 0x21ca480, 0x21c8b60 [ORD=2]

      0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2]

        0x219b660: <multiple use>
        0x21c6220: i64 = Register %vreg3

        0x21c8560: <multiple use>
      0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3]

    0x21c7e60: ch = TokenFactor 0x21c8960, 0x21c8260 [ORD=5]

    0x21c8a60: i64 = Register %EFLAGS

        0x21c8560: <multiple use>
        0x21ca880: <multiple use>
      0x21ca980: i64,i64 = AND64rr 0x21c8560, 0x21ca880 [ORD=3]

          0x219b660: <multiple use>
          0x21c7f60: i64 = Register %vreg8

        0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c7f60 [ORD=4]

        0x21ca880: <multiple use>
      0x21caa80: i64,i64 = AND64rr 0x21c5f20, 0x21ca880 [ORD=4]

    0x21ca780: i64,i64 = SUB64rr 0x21ca980, 0x21caa80 [ORD=3]

  0x21c5e20: ch,glue = CopyToReg 0x21c7e60, 0x21c8a60, 0x21ca780:1 [ORD=5]

  0x21c8c60: i32 = Register %noreg

  0x21c8160: i64 = Register %noreg

    0x21c6420: ch = BasicBlock<for.end 0x21c02f0>

      0x21c8060: ch = BasicBlock<for.body 0x21c0180>

      0x21c5e20: <multiple use>
      0x21c5e20: <multiple use>
    0x21c6320: ch = JNE_4 0x21c8060, 0x21c5e20, 0x21c5e20:1 [ORD=5]

  0x21c6120: ch = JMP_4 0x21c6420, 0x21c6320 [ORD=5]


********** List Scheduling BB#1 'for.body' **********
SU(0): 0x21c6120: ch = JMP_4 0x21c6420, 0x21c6320 [ORD=5] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x21c6320: ch = JNE_4 0x21c8060, 0x21c5e20, 0x21c5e20:1 [ORD=5] [ID=1]

    0x21c5e20: ch,glue = CopyToReg 0x21c7e60, 0x21c8a60, 0x21ca780:1 [ORD=5] [ID=1]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
   ch  SU(9): Latency=0
   val SU(2): Latency=1 Reg=%EFLAGS
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x21ca780: i64,i64 = SUB64rr 0x21ca980, 0x21caa80 [ORD=3] [ID=2]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
   val SU(6): Latency=1
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1 Reg=%EFLAGS

SU(3): 0x21caa80: i64,i64 = AND64rr 0x21c5f20, 0x21ca880 [ORD=4] [ID=3]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
   val SU(5): Latency=1
   val SU(4): Latency=1
  Successors:
   val SU(2): Latency=1

SU(4): 0x21ca880: i64 = MOV64ri 0x21c6720 [ID=4]

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(3): Latency=1
   val SU(6): Latency=1

SU(5): 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c7f60 [ORD=4] [ID=5]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(3): Latency=1

SU(6): 0x21ca980: i64,i64 = AND64rr 0x21c8560, 0x21ca880 [ORD=3] [ID=6]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
   val SU(7): Latency=1
   val SU(4): Latency=1
  Successors:
   val SU(2): Latency=1

SU(7): 0x21c8560: i64,i64 = INC64r 0x21c8360 [ORD=3] [ID=7]

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
   val SU(8): Latency=1
  Successors:
   val SU(6): Latency=1
   val SU(10): Latency=1

SU(8): 0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3] [ID=8]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
   val SU(7): Latency=1

SU(9): 0x21c7e60: ch = TokenFactor 0x21c8960, 0x21c8260 [ORD=5] [ID=9]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 1
  Predecessors:
   ch  SU(11): Latency=1
   ch  SU(10): Latency=1
  Successors:
   ch  SU(1): Latency=0

SU(10): 0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3] [ID=10]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
   val SU(7): Latency=1
  Successors:
   ch  SU(9): Latency=1

SU(11): 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=11]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
   val SU(12): Latency=1
  Successors:
   ch  SU(9): Latency=1

SU(12): 0x21c8860: i64,i64 = IMUL64rr 0x21ca480, 0x21c8b60 [ORD=2] [ID=12]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
   val SU(14): Latency=1
   val SU(13): Latency=1
  Successors:
   val SU(11): Latency=1

SU(13): 0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2] [ID=13]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(12): Latency=1

SU(14): 0x21ca480: i64,ch = CopyFromReg 0x219b660, 0x21ca580 [ORD=2] [ID=14]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(12): Latency=1

VRegCycle: SU(12)

Examining Available:
Height 0: SU(0): 0x21c6120: ch = JMP_4 0x21c6420, 0x21c6320 [ORD=5] [ID=0]


*** Scheduling [0]: SU(0): 0x21c6120: ch = JMP_4 0x21c6420, 0x21c6320 [ORD=5] [ID=0]


Examining Available:
Height 1: SU(1): 0x21c6320: ch = JNE_4 0x21c8060, 0x21c5e20, 0x21c5e20:1 [ORD=5] [ID=1]

    0x21c5e20: ch,glue = CopyToReg 0x21c7e60, 0x21c8a60, 0x21ca780:1 [ORD=5] [ID=1]


*** Scheduling [1]: SU(1): 0x21c6320: ch = JNE_4 0x21c8060, 0x21c5e20, 0x21c5e20:1 [ORD=5] [ID=1]

    0x21c5e20: ch,glue = CopyToReg 0x21c7e60, 0x21c8a60, 0x21ca780:1 [ORD=5] [ID=1]


Examining Available:
Height 1: SU(9): 0x21c7e60: ch = TokenFactor 0x21c8960, 0x21c8260 [ORD=5] [ID=9]

Height 2: SU(2): 0x21ca780: i64,i64 = SUB64rr 0x21ca980, 0x21caa80 [ORD=3] [ID=2]


*** Scheduling [2]: SU(9): 0x21c7e60: ch = TokenFactor 0x21c8960, 0x21c8260 [ORD=5] [ID=9]


Examining Available:
  SU (2)  defines a physreg SU(10)  has no physreg
Height 2: SU(2): 0x21ca780: i64,i64 = SUB64rr 0x21ca980, 0x21caa80 [ORD=3] [ID=2]

Height 3: SU(10): 0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3] [ID=10]

Height 3: SU(11): 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=11]

  SU (2)  defines a physreg SU(10)  has no physreg

*** Scheduling [3]: SU(2): 0x21ca780: i64,i64 = SUB64rr 0x21ca980, 0x21caa80 [ORD=3] [ID=2]


Examining Available:
Height 4: SU(3): 0x21caa80: i64,i64 = AND64rr 0x21c5f20, 0x21ca880 [ORD=4] [ID=3]

Height 3: SU(10): 0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3] [ID=10]

Height 4: SU(6): 0x21ca980: i64,i64 = AND64rr 0x21c8560, 0x21ca880 [ORD=3] [ID=6]

Height 3: SU(11): 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=11]


*** Scheduling [4]: SU(3): 0x21caa80: i64,i64 = AND64rr 0x21c5f20, 0x21ca880 [ORD=4] [ID=3]


Examining Available:
Height 5: SU(5): 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c7f60 [ORD=4] [ID=5]

Height 3: SU(10): 0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3] [ID=10]

Height 4: SU(6): 0x21ca980: i64,i64 = AND64rr 0x21c8560, 0x21ca880 [ORD=3] [ID=6]

Height 3: SU(11): 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=11]


*** Scheduling [5]: SU(5): 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c7f60 [ORD=4] [ID=5]


Examining Available:
Height 3: SU(10): 0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3] [ID=10]

Height 4: SU(6): 0x21ca980: i64,i64 = AND64rr 0x21c8560, 0x21ca880 [ORD=3] [ID=6]

Height 3: SU(11): 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=11]


*** Scheduling [6]: SU(10): 0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3] [ID=10]


Examining Available:
Height 4: SU(6): 0x21ca980: i64,i64 = AND64rr 0x21c8560, 0x21ca880 [ORD=3] [ID=6]

Height 3: SU(11): 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=11]


*** Scheduling [7]: SU(6): 0x21ca980: i64,i64 = AND64rr 0x21c8560, 0x21ca880 [ORD=3] [ID=6]


Examining Available:
Height 8: SU(4): 0x21ca880: i64 = MOV64ri 0x21c6720 [ID=4]

Height 8: SU(7): 0x21c8560: i64,i64 = INC64r 0x21c8360 [ORD=3] [ID=7]

Height 3: SU(11): 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=11]


*** Scheduling [8]: SU(4): 0x21ca880: i64 = MOV64ri 0x21c6720 [ID=4]


Examining Available:
Height 8: SU(7): 0x21c8560: i64,i64 = INC64r 0x21c8360 [ORD=3] [ID=7]

Height 3: SU(11): 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=11]


*** Scheduling [9]: SU(7): 0x21c8560: i64,i64 = INC64r 0x21c8360 [ORD=3] [ID=7]


Examining Available:
Height 10: SU(8): 0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3] [ID=8]

Height 3: SU(11): 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=11]


*** Scheduling [10]: SU(8): 0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3] [ID=8]


Examining Available:
Height 3: SU(11): 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=11]


*** Scheduling [11]: SU(11): 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=11]


Examining Available:
Height 12: SU(12): 0x21c8860: i64,i64 = IMUL64rr 0x21ca480, 0x21c8b60 [ORD=2] [ID=12]


*** Scheduling [12]: SU(12): 0x21c8860: i64,i64 = IMUL64rr 0x21ca480, 0x21c8b60 [ORD=2] [ID=12]


Examining Available:
Height 13: SU(14): 0x21ca480: i64,ch = CopyFromReg 0x219b660, 0x21ca580 [ORD=2] [ID=14]

Height 13: SU(13): 0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2] [ID=13]


*** Scheduling [13]: SU(14): 0x21ca480: i64,ch = CopyFromReg 0x219b660, 0x21ca580 [ORD=2] [ID=14]


Examining Available:
Height 13: SU(13): 0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2] [ID=13]


*** Scheduling [14]: SU(13): 0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2] [ID=13]

*** Final schedule ***
SU(13): 0x21c8b60: i64,ch = CopyFromReg 0x219b660, 0x21c8460 [ORD=2] [ID=13]

SU(14): 0x21ca480: i64,ch = CopyFromReg 0x219b660, 0x21ca580 [ORD=2] [ID=14]

SU(12): 0x21c8860: i64,i64 = IMUL64rr 0x21ca480, 0x21c8b60 [ORD=2] [ID=12]

SU(11): 0x21c8960: ch = CopyToReg 0x219b660, 0x21c6920, 0x21c8860 [ORD=2] [ID=11]

SU(8): 0x21c8360: i64,ch = CopyFromReg 0x219b660, 0x21c6820 [ORD=3] [ID=8]

SU(7): 0x21c8560: i64,i64 = INC64r 0x21c8360 [ORD=3] [ID=7]

SU(4): 0x21ca880: i64 = MOV64ri 0x21c6720 [ID=4]

SU(6): 0x21ca980: i64,i64 = AND64rr 0x21c8560, 0x21ca880 [ORD=3] [ID=6]

SU(10): 0x21c8260: ch = CopyToReg 0x219b660, 0x21c6220, 0x21c8560 [ORD=3] [ID=10]

SU(5): 0x21c5f20: i64,ch = CopyFromReg 0x219b660, 0x21c7f60 [ORD=4] [ID=5]

SU(3): 0x21caa80: i64,i64 = AND64rr 0x21c5f20, 0x21ca880 [ORD=4] [ID=3]

SU(2): 0x21ca780: i64,i64 = SUB64rr 0x21ca980, 0x21caa80 [ORD=3] [ID=2]

SU(9): 0x21c7e60: ch = TokenFactor 0x21c8960, 0x21c8260 [ORD=5] [ID=9]

SU(1): 0x21c6320: ch = JNE_4 0x21c8060, 0x21c5e20, 0x21c5e20:1 [ORD=5] [ID=1]

    0x21c5e20: ch,glue = CopyToReg 0x21c7e60, 0x21c8a60, 0x21ca780:1 [ORD=5] [ID=1]

SU(0): 0x21c6120: ch = JMP_4 0x21c6420, 0x21c6320 [ORD=5] [ID=0]


Total amount of phi nodes to update: 3
Node 0 : (0x21c03a0, 2147483650)
Node 1 : (0x21c0230, 2147483650)
Node 2 : (0x21c0290, 2147483651)
Initial selection DAG: BB#2 'quantum_ipow:for.end'
SelectionDAG has 8 nodes:
  0x219b660: ch = EntryToken

    0x219b660: <multiple use>
    0x21c6720: i64 = Register %vreg4

  0x21c8160: i64,ch = CopyFromReg 0x219b660, 0x21c6720 [ORD=2]

    0x21c8160: <multiple use>
  0x21c8c60: i32 = truncate 0x21c8160 [ORD=2]

  0x21c8a60: i64 = Register %RAX

    0x219b660: <multiple use>
    0x21c8a60: <multiple use>
    0x21c8160: <multiple use>
  0x21c6120: ch,glue = CopyToReg 0x219b660, 0x21c8a60, 0x21c8160 [ORD=2]

    0x21c6120: <multiple use>
    0x21c5e20: i64 = TargetConstant<0>

    0x21c8a60: <multiple use>
    0x21c6120: <multiple use>
  0x21c6320: ch = Cse523ISD::RET_FLAG 0x21c6120, 0x21c5e20, 0x21c8a60, 0x21c6120:1 [ORD=2]


Optimized lowered selection DAG: BB#2 'quantum_ipow:for.end'
SelectionDAG has 7 nodes:
  0x219b660: ch = EntryToken

  0x21c8a60: i64 = Register %RAX

    0x219b660: <multiple use>
    0x21c8a60: <multiple use>
      0x219b660: <multiple use>
      0x21c6720: i64 = Register %vreg4

    0x21c8160: i64,ch = CopyFromReg 0x219b660, 0x21c6720 [ORD=2]

  0x21c6120: ch,glue = CopyToReg 0x219b660, 0x21c8a60, 0x21c8160 [ORD=2]

    0x21c6120: <multiple use>
    0x21c5e20: i64 = TargetConstant<0>

    0x21c8a60: <multiple use>
    0x21c6120: <multiple use>
  0x21c6320: ch = Cse523ISD::RET_FLAG 0x21c6120, 0x21c5e20, 0x21c8a60, 0x21c6120:1 [ORD=2]


Legally typed node: 0x21c8a60: i64 = Register %RAX [ID=0]

Legally typed node: 0x21c5e20: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x21c6720: i64 = Register %vreg4 [ID=0]

Legally typed node: 0x219b660: ch = EntryToken [ID=0]

Legally typed node: 0x21c8160: i64,ch = CopyFromReg 0x219b660, 0x21c6720 [ORD=2] [ID=0]

Legally typed node: 0x21c6120: ch,glue = CopyToReg 0x219b660, 0x21c8a60, 0x21c8160 [ORD=2] [ID=0]

Legally typed node: 0x21c6320: ch = Cse523ISD::RET_FLAG 0x21c6120, 0x21c5e20, 0x21c8a60, 0x21c6120:1 [ORD=2] [ID=0]

Legally typed node: 0x7fff16596d20: ch = handlenode 0x21c6320 [ID=0]

Type-legalized selection DAG: BB#2 'quantum_ipow:for.end'
SelectionDAG has 7 nodes:
  0x219b660: ch = EntryToken [ID=-3]

  0x21c8a60: i64 = Register %RAX [ID=-3]

    0x219b660: <multiple use>
    0x21c8a60: <multiple use>
      0x219b660: <multiple use>
      0x21c6720: i64 = Register %vreg4 [ID=-3]

    0x21c8160: i64,ch = CopyFromReg 0x219b660, 0x21c6720 [ORD=2] [ID=-3]

  0x21c6120: ch,glue = CopyToReg 0x219b660, 0x21c8a60, 0x21c8160 [ORD=2] [ID=-3]

    0x21c6120: <multiple use>
    0x21c5e20: i64 = TargetConstant<0> [ID=-3]

    0x21c8a60: <multiple use>
    0x21c6120: <multiple use>
  0x21c6320: ch = Cse523ISD::RET_FLAG 0x21c6120, 0x21c5e20, 0x21c8a60, 0x21c6120:1 [ORD=2] [ID=-3]


Legalized selection DAG: BB#2 'quantum_ipow:for.end'
SelectionDAG has 7 nodes:
  0x219b660: ch = EntryToken [ID=0]

  0x21c8a60: i64 = Register %RAX [ID=3]

    0x219b660: <multiple use>
    0x21c8a60: <multiple use>
      0x219b660: <multiple use>
      0x21c6720: i64 = Register %vreg4 [ID=1]

    0x21c8160: i64,ch = CopyFromReg 0x219b660, 0x21c6720 [ORD=2] [ID=4]

  0x21c6120: ch,glue = CopyToReg 0x219b660, 0x21c8a60, 0x21c8160 [ORD=2] [ID=5]

    0x21c6120: <multiple use>
    0x21c5e20: i64 = TargetConstant<0> [ID=2]

    0x21c8a60: <multiple use>
    0x21c6120: <multiple use>
  0x21c6320: ch = Cse523ISD::RET_FLAG 0x21c6120, 0x21c5e20, 0x21c8a60, 0x21c6120:1 [ORD=2] [ID=6]


Optimized legalized selection DAG: BB#2 'quantum_ipow:for.end'
SelectionDAG has 7 nodes:
  0x219b660: ch = EntryToken [ID=0]

  0x21c8a60: i64 = Register %RAX [ID=3]

    0x219b660: <multiple use>
    0x21c8a60: <multiple use>
      0x219b660: <multiple use>
      0x21c6720: i64 = Register %vreg4 [ID=1]

    0x21c8160: i64,ch = CopyFromReg 0x219b660, 0x21c6720 [ORD=2] [ID=4]

  0x21c6120: ch,glue = CopyToReg 0x219b660, 0x21c8a60, 0x21c8160 [ORD=2] [ID=5]

    0x21c6120: <multiple use>
    0x21c5e20: i64 = TargetConstant<0> [ID=2]

    0x21c8a60: <multiple use>
    0x21c6120: <multiple use>
  0x21c6320: ch = Cse523ISD::RET_FLAG 0x21c6120, 0x21c5e20, 0x21c8a60, 0x21c6120:1 [ORD=2] [ID=6]


===== Instruction selection begins: BB#2 'for.end'
Selecting:Opcode[211] 0x21c6320: ch = Cse523ISD::RET_FLAG 0x21c6120, 0x21c5e20, 0x21c8a60, 0x21c6120:1 [ORD=2] [ID=6]

ISEL: Starting pattern match on root node: 0x21c6320: ch = Cse523ISD::RET_FLAG 0x21c6120, 0x21c5e20, 0x21c8a60, 0x21c6120:1 [ORD=2] [ID=6]

  Initial Opcode index to 4203
  Morphed node: 0x21c6320: ch = RETQ 0x21c8a60, 0x21c6120, 0x21c6120:1 [ORD=2]

ISEL: Match complete!
=> 0x21c6320: ch = RETQ 0x21c8a60, 0x21c6120, 0x21c6120:1 [ORD=2]

Selecting:Opcode[39] 0x21c6120: ch,glue = CopyToReg 0x219b660, 0x21c8a60, 0x21c8160 [ORD=2] [ID=5]

=> 0x21c6120: ch,glue = CopyToReg 0x219b660, 0x21c8a60, 0x21c8160 [ORD=2]

Selecting:Opcode[40] 0x21c8160: i64,ch = CopyFromReg 0x219b660, 0x21c6720 [ORD=2] [ID=4]

=> 0x21c8160: i64,ch = CopyFromReg 0x219b660, 0x21c6720 [ORD=2]

Selecting:Opcode[8] 0x21c8a60: i64 = Register %RAX [ID=3]

=> 0x21c8a60: i64 = Register %RAX

Selecting:Opcode[8] 0x21c6720: i64 = Register %vreg4 [ID=1]

=> 0x21c6720: i64 = Register %vreg4

Selecting:Opcode[1] 0x219b660: ch = EntryToken [ID=0]

=> 0x219b660: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#2 'quantum_ipow:for.end'
SelectionDAG has 6 nodes:
  0x219b660: ch = EntryToken

  0x21c8a60: i64 = Register %RAX

    0x219b660: <multiple use>
    0x21c8a60: <multiple use>
      0x219b660: <multiple use>
      0x21c6720: i64 = Register %vreg4

    0x21c8160: i64,ch = CopyFromReg 0x219b660, 0x21c6720 [ORD=2]

  0x21c6120: ch,glue = CopyToReg 0x219b660, 0x21c8a60, 0x21c8160 [ORD=2]

    0x21c8a60: <multiple use>
    0x21c6120: <multiple use>
    0x21c6120: <multiple use>
  0x21c6320: ch = RETQ 0x21c8a60, 0x21c6120, 0x21c6120:1 [ORD=2]


********** List Scheduling BB#2 'for.end' **********
SU(0): 0x21c6320: ch = RETQ 0x21c8a60, 0x21c6120, 0x21c6120:1 [ORD=2] [ID=0]

    0x21c6120: ch,glue = CopyToReg 0x219b660, 0x21c8a60, 0x21c8160 [ORD=2] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
   val SU(1): Latency=1

SU(1): 0x21c8160: i64,ch = CopyFromReg 0x219b660, 0x21c6720 [ORD=2] [ID=1]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(0): Latency=1


Examining Available:
Height 0: SU(0): 0x21c6320: ch = RETQ 0x21c8a60, 0x21c6120, 0x21c6120:1 [ORD=2] [ID=0]

    0x21c6120: ch,glue = CopyToReg 0x219b660, 0x21c8a60, 0x21c8160 [ORD=2] [ID=0]


*** Scheduling [0]: SU(0): 0x21c6320: ch = RETQ 0x21c8a60, 0x21c6120, 0x21c6120:1 [ORD=2] [ID=0]

    0x21c6120: ch,glue = CopyToReg 0x219b660, 0x21c8a60, 0x21c8160 [ORD=2] [ID=0]


Examining Available:
Height 1: SU(1): 0x21c8160: i64,ch = CopyFromReg 0x219b660, 0x21c6720 [ORD=2] [ID=1]


*** Scheduling [1]: SU(1): 0x21c8160: i64,ch = CopyFromReg 0x219b660, 0x21c6720 [ORD=2] [ID=1]

*** Final schedule ***
SU(1): 0x21c8160: i64,ch = CopyFromReg 0x219b660, 0x21c6720 [ORD=2] [ID=1]

SU(0): 0x21c6320: ch = RETQ 0x21c8a60, 0x21c6120, 0x21c6120:1 [ORD=2] [ID=0]

    0x21c6120: ch,glue = CopyToReg 0x219b660, 0x21c8a60, 0x21c8160 [ORD=2] [ID=0]


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function quantum_ipow: SSA
Function Live Ins: %RDI in %vreg5, %RSI in %vreg6

BB#0: derived from LLVM BB %entry
    Live Ins: %RDI %RSI
	%vreg6<def> = COPY %RSI; GR64:%vreg6
	%vreg5<def> = COPY %RDI; GR64:%vreg5
	%vreg11<def> = MOV64ri32 32; GR64:%vreg11
	%RCX<def> = COPY %vreg11; GR64:%vreg11
	%vreg12<def,tied1> = SHL64rCL %vreg6<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg12,%vreg6
	%RCX<def> = COPY %vreg11; GR64:%vreg11
	%vreg13<def,tied1> = SAR64rCL %vreg12<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg13,%vreg12
	%vreg8<def> = COPY %vreg6; GR64:%vreg8,%vreg6
	%vreg7<def> = COPY %vreg5; GR64:%vreg7,%vreg5
	%vreg10<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg10
	TEST64rr %vreg13, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
	%vreg9<def> = MOV64ri32 1; GR64:%vreg9
	JLE_4 <BB#2>, %EFLAGS<imp-use>
	JMP_4 <BB#1>
    Successors according to CFG: BB#1(20) BB#2(12)

BB#1: derived from LLVM BB %for.body
    Predecessors according to CFG: BB#0 BB#1
	%vreg0<def> = PHI %vreg9, <BB#0>, %vreg2, <BB#1>; GR64:%vreg0,%vreg9,%vreg2
	%vreg1<def> = PHI %vreg10, <BB#0>, %vreg3, <BB#1>; GR64:%vreg1,%vreg10,%vreg3
	%vreg2<def,tied1> = IMUL64rr %vreg0<tied0>, %vreg7, %EFLAGS<imp-def,dead>; GR64:%vreg2,%vreg0,%vreg7
	%vreg3<def,tied1> = INC64r %vreg1<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg3,%vreg1
	%vreg14<def> = MOV64ri 4294967295; GR64:%vreg14
	%vreg15<def,tied1> = AND64rr %vreg3<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg3,%vreg14
	%vreg16<def,tied1> = AND64rr %vreg8<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg8,%vreg14
	%vreg17<def,tied1> = SUB64rr %vreg15<tied0>, %vreg16<kill>, %EFLAGS<imp-def>; GR64:%vreg17,%vreg15,%vreg16
	JNE_4 <BB#1>, %EFLAGS<imp-use>
	JMP_4 <BB#2>
    Successors according to CFG: BB#2(4) BB#1(124)

BB#2: derived from LLVM BB %for.end
    Predecessors according to CFG: BB#0 BB#1
	%vreg4<def> = PHI %vreg9, <BB#0>, %vreg2, <BB#1>; GR64:%vreg4,%vreg9,%vreg2
	%RAX<def> = COPY %vreg4; GR64:%vreg4
	RETQ %RAX

# End machine code for function quantum_ipow.

# Machine code for function quantum_ipow: SSA
Function Live Ins: %RDI in %vreg5, %RSI in %vreg6

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI %RSI
16B		%vreg6<def> = COPY %RSI; GR64:%vreg6
32B		%vreg5<def> = COPY %RDI; GR64:%vreg5
48B		%vreg11<def> = MOV64ri32 32; GR64:%vreg11
64B		%RCX<def> = COPY %vreg11; GR64:%vreg11
80B		%vreg12<def,tied1> = SHL64rCL %vreg6<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg12,%vreg6
96B		%RCX<def> = COPY %vreg11; GR64:%vreg11
112B		%vreg13<def,tied1> = SAR64rCL %vreg12<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg13,%vreg12
128B		%vreg8<def> = COPY %vreg6; GR64:%vreg8,%vreg6
144B		%vreg7<def> = COPY %vreg5; GR64:%vreg7,%vreg5
160B		%vreg10<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg10
176B		TEST64rr %vreg13, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
192B		%vreg9<def> = MOV64ri32 1; GR64:%vreg9
208B		JLE_4 <BB#2>, %EFLAGS<imp-use>
224B		JMP_4 <BB#1>
	    Successors according to CFG: BB#1(20) BB#2(12)

240B	BB#1: derived from LLVM BB %for.body
	    Predecessors according to CFG: BB#0 BB#1
256B		%vreg0<def> = PHI %vreg9, <BB#0>, %vreg2, <BB#1>; GR64:%vreg0,%vreg9,%vreg2
272B		%vreg1<def> = PHI %vreg10, <BB#0>, %vreg3, <BB#1>; GR64:%vreg1,%vreg10,%vreg3
288B		%vreg2<def,tied1> = IMUL64rr %vreg0<tied0>, %vreg7, %EFLAGS<imp-def,dead>; GR64:%vreg2,%vreg0,%vreg7
304B		%vreg3<def,tied1> = INC64r %vreg1<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg3,%vreg1
320B		%vreg14<def> = MOV64ri 4294967295; GR64:%vreg14
336B		%vreg15<def,tied1> = AND64rr %vreg3<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg3,%vreg14
352B		%vreg16<def,tied1> = AND64rr %vreg8<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg8,%vreg14
368B		%vreg17<def,tied1> = SUB64rr %vreg15<tied0>, %vreg16<kill>, %EFLAGS<imp-def>; GR64:%vreg17,%vreg15,%vreg16
384B		JNE_4 <BB#1>, %EFLAGS<imp-use>
400B		JMP_4 <BB#2>
	    Successors according to CFG: BB#2(4) BB#1(124)

416B	BB#2: derived from LLVM BB %for.end
	    Predecessors according to CFG: BB#0 BB#1
432B		%vreg4<def> = PHI %vreg9, <BB#0>, %vreg2, <BB#1>; GR64:%vreg4,%vreg9,%vreg2
448B		%RAX<def> = COPY %vreg4; GR64:%vreg4
464B		RETQ %RAX

# End machine code for function quantum_ipow.

********** Stack Coloring **********
********** Function: quantum_ipow
******** Pre-regalloc Machine LICM: quantum_ipow ********
Splitting critical edge: BB#0 -- BB#3 -- BB#1
Entering: for.body
Hoisting %vreg14<def> = MOV64ri 4294967295; GR64:%vreg14
 from MachineBasicBlock for.body
Hoist non-reg-pressure: %vreg16<def,tied1> = AND64rr %vreg8<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg8,%vreg14
Hoisting %vreg16<def,tied1> = AND64rr %vreg8<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg8,%vreg14
 from MachineBasicBlock for.body
Exiting: for.body
Entering: entry
Entering: (null)
Coalescing: %vreg8<def> = COPY %vreg6; GR64:%vreg8,%vreg6
***     to: %vreg16<def,tied1> = AND64rr %vreg8<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg8,%vreg14
Entering: for.body
Coalescing: %vreg7<def> = COPY %vreg5; GR64:%vreg7,%vreg5
***     to: %vreg2<def,tied1> = IMUL64rr %vreg0<tied0>, %vreg7, %EFLAGS<imp-def,dead>; GR64:%vreg2,%vreg0,%vreg7
Exiting: for.body
Exiting: (null)
Entering: for.end
Exiting: for.end
Exiting: entry
******** Machine Sinking ********
Sink instr %vreg10<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg10
	into block BB#3: 
    Predecessors according to CFG: BB#0
	%vreg14<def> = MOV64ri 4294967295; GR64:%vreg14
	%vreg16<def,tied1> = AND64rr %vreg6<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg6,%vreg14
    Successors according to CFG: BB#1
********** PEEPHOLE OPTIMIZER **********
********** Function: quantum_ipow
********** PROCESS IMPLICIT DEFS **********
********** Function: quantum_ipow
%vreg9 live-out before critical edge BB#0 -> BB#3: %vreg4<def> = PHI %vreg9, <BB#0>, %vreg2, <BB#2>; GR64:%vreg4,%vreg9,%vreg2
Splitting critical edge: BB#0 -- BB#4 -- BB#3
Removing terminator kill: JLE_4 <BB#3>, %EFLAGS<imp-use,kill>
Restored terminator kill: JG_4 <BB#1>, %EFLAGS<imp-use,kill>
********** REWRITING TWO-ADDR INSTRS **********
********** Function: quantum_ipow
	%vreg12<def,tied1> = SHL64rCL %vreg6<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg12,%vreg6
		prepend:	%vreg12<def> = COPY %vreg6; GR64:%vreg12,%vreg6
		rewrite to:	%vreg12<def,tied1> = SHL64rCL %vreg12<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg12
	%vreg13<def,tied1> = SAR64rCL %vreg12<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13,%vreg12
		prepend:	%vreg13<def> = COPY %vreg12; GR64:%vreg13,%vreg12
		rewrite to:	%vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
	%vreg16<def,tied1> = AND64rr %vreg6<kill,tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg6,%vreg14
		prepend:	%vreg16<def> = COPY %vreg6; GR64:%vreg16,%vreg6
		rewrite to:	%vreg16<def,tied1> = AND64rr %vreg16<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg14
	%vreg2<def,tied1> = IMUL64rr %vreg0<kill,tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg2,%vreg0,%vreg5
		prepend:	%vreg2<def> = COPY %vreg0; GR64:%vreg2,%vreg0
		rewrite to:	%vreg2<def,tied1> = IMUL64rr %vreg2<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg2,%vreg5
	%vreg3<def,tied1> = INC64r %vreg1<kill,tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg3,%vreg1
		prepend:	%vreg3<def> = COPY %vreg1; GR64:%vreg3,%vreg1
		rewrite to:	%vreg3<def,tied1> = INC64r %vreg3<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg3
	%vreg15<def,tied1> = AND64rr %vreg3<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg3,%vreg14
		prepend:	%vreg15<def> = COPY %vreg3; GR64:%vreg15,%vreg3
		rewrite to:	%vreg15<def,tied1> = AND64rr %vreg15<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg14
# Machine code for function quantum_ipow: Post SSA
Function Live Ins: %RDI in %vreg5, %RSI in %vreg6

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI %RSI
16B		%vreg6<def> = COPY %RSI<kill>; GR64:%vreg6
32B		%vreg5<def> = COPY %RDI<kill>; GR64:%vreg5
48B		%vreg11<def> = MOV64ri32 32; GR64:%vreg11
64B		%RCX<def> = COPY %vreg11; GR64:%vreg11
80B		%vreg12<def> = COPY %vreg6; GR64:%vreg12,%vreg6
96B		%vreg12<def,tied1> = SHL64rCL %vreg12<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg12
112B		%RCX<def> = COPY %vreg11<kill>; GR64:%vreg11
128B		%vreg13<def> = COPY %vreg12<kill>; GR64:%vreg13,%vreg12
144B		%vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
160B		TEST64rr %vreg13<kill>, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
176B		%vreg9<def> = MOV64ri32 1; GR64:%vreg9
192B		JG_4 <BB#1>, %EFLAGS<imp-use,kill>
	    Successors according to CFG: BB#1(20) BB#4(12)

208B	BB#4: 
	    Predecessors according to CFG: BB#0
224B		%vreg20<def> = COPY %vreg9<kill>; GR64:%vreg20,%vreg9
240B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3

256B	BB#1: 
	    Predecessors according to CFG: BB#0
272B		%vreg10<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg10
288B		%vreg14<def> = MOV64ri 4294967295; GR64:%vreg14
304B		%vreg16<def> = COPY %vreg6<kill>; GR64:%vreg16,%vreg6
320B		%vreg16<def,tied1> = AND64rr %vreg16<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg14
336B		%vreg18<def> = COPY %vreg9<kill>; GR64:%vreg18,%vreg9
352B		%vreg19<def> = COPY %vreg10<kill>; GR64:%vreg19,%vreg10
	    Successors according to CFG: BB#2

368B	BB#2: derived from LLVM BB %for.body
	    Predecessors according to CFG: BB#2 BB#1
384B		%vreg1<def> = COPY %vreg19<kill>; GR64:%vreg1,%vreg19
400B		%vreg0<def> = COPY %vreg18<kill>; GR64:%vreg0,%vreg18
416B		%vreg2<def> = COPY %vreg0<kill>; GR64:%vreg2,%vreg0
432B		%vreg2<def,tied1> = IMUL64rr %vreg2<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg2,%vreg5
448B		%vreg3<def> = COPY %vreg1<kill>; GR64:%vreg3,%vreg1
464B		%vreg3<def,tied1> = INC64r %vreg3<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg3
480B		%vreg15<def> = COPY %vreg3; GR64:%vreg15,%vreg3
496B		%vreg15<def,tied1> = AND64rr %vreg15<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg14
512B		CMP64rr %vreg15<kill>, %vreg16, %EFLAGS<imp-def>; GR64:%vreg15,%vreg16
528B		%vreg18<def> = COPY %vreg2; GR64:%vreg18,%vreg2
544B		%vreg19<def> = COPY %vreg3<kill>; GR64:%vreg19,%vreg3
560B		%vreg20<def> = COPY %vreg2<kill>; GR64:%vreg20,%vreg2
576B		JNE_4 <BB#2>, %EFLAGS<imp-use,kill>
592B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3(4) BB#2(124)

608B	BB#3: derived from LLVM BB %for.end
	    Predecessors according to CFG: BB#2 BB#4
624B		%vreg4<def> = COPY %vreg20<kill>; GR64:%vreg4,%vreg20
640B		%RAX<def> = COPY %vreg4<kill>; GR64:%vreg4
656B		RETQ %RAX<kill>

# End machine code for function quantum_ipow.

Computing live-in reg-units in ABI blocks.
0B	BB#0 RDI#0 RSI#0
Created 2 new intervals.
********** INTERVALS **********
RDI [0B,32r:0)  0@0B-phi
RSI [0B,16r:0)  0@0B-phi
%vreg0 [400r,416r:0)  0@400r
%vreg1 [384r,448r:0)  0@384r
%vreg2 [416r,432r:0)[432r,560r:1)  0@416r 1@432r
%vreg3 [448r,464r:0)[464r,544r:1)  0@448r 1@464r
%vreg4 [624r,640r:0)  0@624r
%vreg5 [32r,208B:0)[256B,608B:0)  0@32r
%vreg6 [16r,208B:0)[256B,304r:0)  0@16r
%vreg9 [176r,224r:0)[256B,336r:0)  0@176r
%vreg10 [272r,352r:0)  0@272r
%vreg11 [48r,112r:0)  0@48r
%vreg12 [80r,96r:0)[96r,128r:1)  0@80r 1@96r
%vreg13 [128r,144r:0)[144r,160r:1)  0@128r 1@144r
%vreg14 [288r,608B:0)  0@288r
%vreg15 [480r,496r:0)[496r,512r:1)  0@480r 1@496r
%vreg16 [304r,320r:0)[320r,608B:1)  0@304r 1@320r
%vreg18 [336r,368B:0)[368B,400r:2)[528r,608B:1)  0@336r 1@528r 2@368B-phi
%vreg19 [352r,368B:0)[368B,384r:2)[544r,608B:1)  0@352r 1@544r 2@368B-phi
%vreg20 [224r,256B:0)[560r,608B:1)[608B,624r:2)  0@224r 1@560r 2@608B-phi
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function quantum_ipow: Post SSA
Function Live Ins: %RDI in %vreg5, %RSI in %vreg6

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI %RSI
16B		%vreg6<def> = COPY %RSI; GR64:%vreg6
32B		%vreg5<def> = COPY %RDI; GR64:%vreg5
48B		%vreg11<def> = MOV64ri32 32; GR64:%vreg11
64B		%RCX<def> = COPY %vreg11; GR64:%vreg11
80B		%vreg12<def> = COPY %vreg6; GR64:%vreg12,%vreg6
96B		%vreg12<def,tied1> = SHL64rCL %vreg12<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg12
112B		%RCX<def> = COPY %vreg11; GR64:%vreg11
128B		%vreg13<def> = COPY %vreg12; GR64:%vreg13,%vreg12
144B		%vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
160B		TEST64rr %vreg13, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
176B		%vreg9<def> = MOV64ri32 1; GR64:%vreg9
192B		JG_4 <BB#1>, %EFLAGS<imp-use,kill>
	    Successors according to CFG: BB#1(20) BB#4(12)

208B	BB#4: 
	    Predecessors according to CFG: BB#0
224B		%vreg20<def> = COPY %vreg9; GR64:%vreg20,%vreg9
240B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3

256B	BB#1: 
	    Predecessors according to CFG: BB#0
272B		%vreg10<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg10
288B		%vreg14<def> = MOV64ri 4294967295; GR64:%vreg14
304B		%vreg16<def> = COPY %vreg6; GR64:%vreg16,%vreg6
320B		%vreg16<def,tied1> = AND64rr %vreg16<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg14
336B		%vreg18<def> = COPY %vreg9; GR64:%vreg18,%vreg9
352B		%vreg19<def> = COPY %vreg10; GR64:%vreg19,%vreg10
	    Successors according to CFG: BB#2

368B	BB#2: derived from LLVM BB %for.body
	    Predecessors according to CFG: BB#2 BB#1
384B		%vreg1<def> = COPY %vreg19; GR64:%vreg1,%vreg19
400B		%vreg0<def> = COPY %vreg18; GR64:%vreg0,%vreg18
416B		%vreg2<def> = COPY %vreg0; GR64:%vreg2,%vreg0
432B		%vreg2<def,tied1> = IMUL64rr %vreg2<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg2,%vreg5
448B		%vreg3<def> = COPY %vreg1; GR64:%vreg3,%vreg1
464B		%vreg3<def,tied1> = INC64r %vreg3<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg3
480B		%vreg15<def> = COPY %vreg3; GR64:%vreg15,%vreg3
496B		%vreg15<def,tied1> = AND64rr %vreg15<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg14
512B		CMP64rr %vreg15, %vreg16, %EFLAGS<imp-def>; GR64:%vreg15,%vreg16
528B		%vreg18<def> = COPY %vreg2; GR64:%vreg18,%vreg2
544B		%vreg19<def> = COPY %vreg3; GR64:%vreg19,%vreg3
560B		%vreg20<def> = COPY %vreg2; GR64:%vreg20,%vreg2
576B		JNE_4 <BB#2>, %EFLAGS<imp-use,kill>
592B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3(4) BB#2(124)

608B	BB#3: derived from LLVM BB %for.end
	    Predecessors according to CFG: BB#2 BB#4
624B		%vreg4<def> = COPY %vreg20; GR64:%vreg4,%vreg20
640B		%RAX<def> = COPY %vreg4; GR64:%vreg4
656B		RETQ %RAX<kill>

# End machine code for function quantum_ipow.

********** SIMPLE REGISTER COALESCING **********
********** Function: quantum_ipow
********** JOINING INTERVALS ***********
for.body:
384B	%vreg1<def> = COPY %vreg19; GR64:%vreg1,%vreg19
	Considering merging to GR64 with %vreg19 in %vreg1
		RHS = %vreg1 [384r,448r:0)  0@384r
		LHS = %vreg19 [352r,368B:0)[368B,384r:2)[544r,608B:1)  0@352r 1@544r 2@368B-phi
		merge %vreg1:0@384r into %vreg19:2@368B --> @368B
		erased:	384r	%vreg1<def> = COPY %vreg19; GR64:%vreg1,%vreg19
AllocationOrder(GR64) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 ]
		updated: 448B	%vreg3<def> = COPY %vreg19; GR64:%vreg3,%vreg19
	Joined. Result = %vreg19 [352r,368B:0)[368B,448r:2)[544r,608B:1)  0@352r 1@544r 2@368B-phi
400B	%vreg0<def> = COPY %vreg18; GR64:%vreg0,%vreg18
	Considering merging to GR64 with %vreg18 in %vreg0
		RHS = %vreg0 [400r,416r:0)  0@400r
		LHS = %vreg18 [336r,368B:0)[368B,400r:2)[528r,608B:1)  0@336r 1@528r 2@368B-phi
		merge %vreg0:0@400r into %vreg18:2@368B --> @368B
		erased:	400r	%vreg0<def> = COPY %vreg18; GR64:%vreg0,%vreg18
		updated: 416B	%vreg2<def> = COPY %vreg18; GR64:%vreg2,%vreg18
	Joined. Result = %vreg18 [336r,368B:0)[368B,416r:2)[528r,608B:1)  0@336r 1@528r 2@368B-phi
416B	%vreg2<def> = COPY %vreg18; GR64:%vreg2,%vreg18
	Considering merging to GR64 with %vreg18 in %vreg2
		RHS = %vreg2 [416r,432r:0)[432r,560r:1)  0@416r 1@432r
		LHS = %vreg18 [336r,368B:0)[368B,416r:2)[528r,608B:1)  0@336r 1@528r 2@368B-phi
		merge %vreg18:1@528r into %vreg2:1@432r --> @432r
		merge %vreg2:0@416r into %vreg18:2@368B --> @368B
		erased:	528r	%vreg18<def> = COPY %vreg2; GR64:%vreg18,%vreg2
		erased:	416r	%vreg2<def> = COPY %vreg18; GR64:%vreg2,%vreg18
		updated: 432B	%vreg18<def,tied1> = IMUL64rr %vreg18<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg18,%vreg5
		updated: 560B	%vreg20<def> = COPY %vreg18; GR64:%vreg20,%vreg18
	Joined. Result = %vreg18 [336r,368B:0)[368B,432r:2)[432r,608B:1)  0@336r 1@432r 2@368B-phi
448B	%vreg3<def> = COPY %vreg19; GR64:%vreg3,%vreg19
	Considering merging to GR64 with %vreg19 in %vreg3
		RHS = %vreg3 [448r,464r:0)[464r,544r:1)  0@448r 1@464r
		LHS = %vreg19 [352r,368B:0)[368B,448r:2)[544r,608B:1)  0@352r 1@544r 2@368B-phi
		merge %vreg19:1@544r into %vreg3:1@464r --> @464r
		merge %vreg3:0@448r into %vreg19:2@368B --> @368B
		erased:	544r	%vreg19<def> = COPY %vreg3; GR64:%vreg19,%vreg3
		erased:	448r	%vreg3<def> = COPY %vreg19; GR64:%vreg3,%vreg19
		updated: 464B	%vreg19<def,tied1> = INC64r %vreg19<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg19
		updated: 480B	%vreg15<def> = COPY %vreg19; GR64:%vreg15,%vreg19
	Joined. Result = %vreg19 [352r,368B:0)[368B,464r:2)[464r,608B:1)  0@352r 1@464r 2@368B-phi
480B	%vreg15<def> = COPY %vreg19; GR64:%vreg15,%vreg19
	Considering merging to GR64 with %vreg19 in %vreg15
		RHS = %vreg15 [480r,496r:0)[496r,512r:1)  0@480r 1@496r
		LHS = %vreg19 [352r,368B:0)[368B,464r:2)[464r,608B:1)  0@352r 1@464r 2@368B-phi
		merge %vreg15:0@480r into %vreg19:1@464r --> @464r
		interference at %vreg15:1@496r
	Interference!
560B	%vreg20<def> = COPY %vreg18; GR64:%vreg20,%vreg18
	Considering merging to GR64 with %vreg18 in %vreg20
		RHS = %vreg18 [336r,368B:0)[368B,432r:2)[432r,608B:1)  0@336r 1@432r 2@368B-phi
		LHS = %vreg20 [224r,256B:0)[560r,608B:1)[608B,624r:2)  0@224r 1@560r 2@608B-phi
		merge %vreg20:1@560r into %vreg18:1@432r --> @432r
		erased:	560r	%vreg20<def> = COPY %vreg18; GR64:%vreg20,%vreg18
		updated: 432B	%vreg20<def,tied1> = IMUL64rr %vreg20<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg20,%vreg5
		updated: 336B	%vreg20<def> = COPY %vreg9; GR64:%vreg20,%vreg9
	Joined. Result = %vreg20 [224r,256B:0)[336r,368B:3)[368B,432r:4)[432r,608B:1)[608B,624r:2)  0@224r 1@432r 2@608B-phi 3@336r 4@368B-phi
entry:
16B	%vreg6<def> = COPY %RSI; GR64:%vreg6
	Considering merging %vreg6 with %RSI
	Can only merge into reserved registers.
32B	%vreg5<def> = COPY %RDI; GR64:%vreg5
	Considering merging %vreg5 with %RDI
	Can only merge into reserved registers.
64B	%RCX<def> = COPY %vreg11; GR64:%vreg11
	Considering merging %vreg11 with %RCX
	Can only merge into reserved registers.
Remat: %RCX<def> = MOV64ri32 32
Shrink: %vreg11 [48r,112r:0)  0@48r
Shrunk: %vreg11 [48r,112r:0)  0@48r
112B	%RCX<def> = COPY %vreg11; GR64:%vreg11
	Considering merging %vreg11 with %RCX
	Can only merge into reserved registers.
Remat: %RCX<def> = MOV64ri32 32
Shrink: %vreg11 [48r,112r:0)  0@48r
All defs dead: 48r	%vreg11<def,dead> = MOV64ri32 32; GR64:%vreg11
Shrunk: %vreg11 [48r,48d:0)  0@48r
Deleting dead def 48r	%vreg11<def,dead> = MOV64ri32 32; GR64:%vreg11
(null):
304B	%vreg16<def> = COPY %vreg6; GR64:%vreg16,%vreg6
	Considering merging to GR64 with %vreg6 in %vreg16
		RHS = %vreg6 [16r,208B:0)[256B,304r:0)  0@16r
		LHS = %vreg16 [304r,320r:0)[320r,608B:1)  0@304r 1@320r
		merge %vreg16:0@304r into %vreg6:0@16r --> @16r
		erased:	304r	%vreg16<def> = COPY %vreg6; GR64:%vreg16,%vreg6
		updated: 16B	%vreg16<def> = COPY %RSI; GR64:%vreg16
		updated: 80B	%vreg12<def> = COPY %vreg16; GR64:%vreg12,%vreg16
	Joined. Result = %vreg16 [16r,208B:0)[256B,320r:0)[320r,608B:1)  0@16r 1@320r
336B	%vreg20<def> = COPY %vreg9; GR64:%vreg20,%vreg9
	Considering merging to GR64 with %vreg9 in %vreg20
		RHS = %vreg9 [176r,224r:0)[256B,336r:0)  0@176r
		LHS = %vreg20 [224r,256B:0)[336r,368B:3)[368B,432r:4)[432r,608B:1)[608B,624r:2)  0@224r 1@432r 2@608B-phi 3@336r 4@368B-phi
		merge %vreg20:0@224r into %vreg9:0@176r --> @176r
		merge %vreg20:3@336r into %vreg9:0@176r --> @176r
		erased:	224r	%vreg20<def> = COPY %vreg9; GR64:%vreg20,%vreg9
		erased:	336r	%vreg20<def> = COPY %vreg9; GR64:%vreg20,%vreg9
		updated: 176B	%vreg20<def> = MOV64ri32 1; GR64:%vreg20
	Joined. Result = %vreg20 [176r,368B:0)[368B,432r:3)[432r,608B:1)[608B,624r:2)  0@176r 1@432r 2@608B-phi 3@368B-phi
for.end:
640B	%RAX<def> = COPY %vreg4; GR64:%vreg4
	Considering merging %vreg4 with %RAX
	Can only merge into reserved registers.
(null):
80B	%vreg12<def> = COPY %vreg16; GR64:%vreg12,%vreg16
	Considering merging to GR64 with %vreg16 in %vreg12
		RHS = %vreg12 [80r,96r:0)[96r,128r:1)  0@80r 1@96r
		LHS = %vreg16 [16r,208B:0)[256B,320r:0)[320r,608B:1)  0@16r 1@320r
		merge %vreg12:0@80r into %vreg16:0@16r --> @16r
		interference at %vreg12:1@96r
	Interference!
128B	%vreg13<def> = COPY %vreg12; GR64:%vreg13,%vreg12
	Considering merging to GR64 with %vreg12 in %vreg13
		RHS = %vreg12 [80r,96r:0)[96r,128r:1)  0@80r 1@96r
		LHS = %vreg13 [128r,144r:0)[144r,160r:1)  0@128r 1@144r
		merge %vreg13:0@128r into %vreg12:1@96r --> @96r
		erased:	128r	%vreg13<def> = COPY %vreg12; GR64:%vreg13,%vreg12
		updated: 80B	%vreg13<def> = COPY %vreg16; GR64:%vreg13,%vreg16
		updated: 96B	%vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
	Joined. Result = %vreg13 [80r,96r:2)[96r,144r:0)[144r,160r:1)  0@96r 1@144r 2@80r
352B	%vreg19<def> = COPY %vreg10; GR64:%vreg19,%vreg10
	Considering merging to GR64 with %vreg10 in %vreg19
		RHS = %vreg10 [272r,352r:0)  0@272r
		LHS = %vreg19 [352r,368B:0)[368B,464r:2)[464r,608B:1)  0@352r 1@464r 2@368B-phi
		merge %vreg19:0@352r into %vreg10:0@272r --> @272r
		erased:	352r	%vreg19<def> = COPY %vreg10; GR64:%vreg19,%vreg10
		updated: 272B	%vreg19<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg19
	Joined. Result = %vreg19 [272r,368B:0)[368B,464r:2)[464r,608B:1)  0@272r 1@464r 2@368B-phi
624B	%vreg4<def> = COPY %vreg20; GR64:%vreg4,%vreg20
	Considering merging to GR64 with %vreg20 in %vreg4
		RHS = %vreg4 [624r,640r:0)  0@624r
		LHS = %vreg20 [176r,368B:0)[368B,432r:3)[432r,608B:1)[608B,624r:2)  0@176r 1@432r 2@608B-phi 3@368B-phi
		merge %vreg4:0@624r into %vreg20:2@608B --> @608B
		erased:	624r	%vreg4<def> = COPY %vreg20; GR64:%vreg4,%vreg20
		updated: 640B	%RAX<def> = COPY %vreg20; GR64:%vreg20
	Joined. Result = %vreg20 [176r,368B:0)[368B,432r:3)[432r,608B:1)[608B,640r:2)  0@176r 1@432r 2@608B-phi 3@368B-phi
480B	%vreg15<def> = COPY %vreg19; GR64:%vreg15,%vreg19
	Considering merging to GR64 with %vreg19 in %vreg15
		RHS = %vreg15 [480r,496r:0)[496r,512r:1)  0@480r 1@496r
		LHS = %vreg19 [272r,368B:0)[368B,464r:2)[464r,608B:1)  0@272r 1@464r 2@368B-phi
		merge %vreg15:0@480r into %vreg19:1@464r --> @464r
		interference at %vreg15:1@496r
	Interference!
640B	%RAX<def> = COPY %vreg20; GR64:%vreg20
	Considering merging %vreg20 with %RAX
	Can only merge into reserved registers.
80B	%vreg13<def> = COPY %vreg16; GR64:%vreg13,%vreg16
	Considering merging to GR64 with %vreg16 in %vreg13
		RHS = %vreg16 [16r,208B:0)[256B,320r:0)[320r,608B:1)  0@16r 1@320r
		LHS = %vreg13 [80r,96r:2)[96r,144r:0)[144r,160r:1)  0@96r 1@144r 2@80r
		interference at %vreg13:0@96r
	Interference!
Trying to inflate 0 regs.
********** INTERVALS **********
RDI [0B,32r:0)  0@0B-phi
RSI [0B,16r:0)  0@0B-phi
%vreg5 [32r,208B:0)[256B,608B:0)  0@32r
%vreg13 [80r,96r:2)[96r,144r:0)[144r,160r:1)  0@96r 1@144r 2@80r
%vreg14 [288r,608B:0)  0@288r
%vreg15 [480r,496r:0)[496r,512r:1)  0@480r 1@496r
%vreg16 [16r,208B:0)[256B,320r:0)[320r,608B:1)  0@16r 1@320r
%vreg19 [272r,368B:0)[368B,464r:2)[464r,608B:1)  0@272r 1@464r 2@368B-phi
%vreg20 [176r,368B:0)[368B,432r:3)[432r,608B:1)[608B,640r:2)  0@176r 1@432r 2@608B-phi 3@368B-phi
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function quantum_ipow: Post SSA
Function Live Ins: %RDI in %vreg5, %RSI in %vreg6

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI %RSI
16B		%vreg16<def> = COPY %RSI; GR64:%vreg16
32B		%vreg5<def> = COPY %RDI; GR64:%vreg5
64B		%RCX<def> = MOV64ri32 32
80B		%vreg13<def> = COPY %vreg16; GR64:%vreg13,%vreg16
96B		%vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
112B		%RCX<def> = MOV64ri32 32
144B		%vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
160B		TEST64rr %vreg13, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
176B		%vreg20<def> = MOV64ri32 1; GR64:%vreg20
192B		JG_4 <BB#1>, %EFLAGS<imp-use,kill>
	    Successors according to CFG: BB#1(20) BB#4(12)

208B	BB#4: 
	    Predecessors according to CFG: BB#0
240B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3

256B	BB#1: 
	    Predecessors according to CFG: BB#0
272B		%vreg19<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg19
288B		%vreg14<def> = MOV64ri 4294967295; GR64:%vreg14
320B		%vreg16<def,tied1> = AND64rr %vreg16<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg14
	    Successors according to CFG: BB#2

368B	BB#2: derived from LLVM BB %for.body
	    Predecessors according to CFG: BB#2 BB#1
432B		%vreg20<def,tied1> = IMUL64rr %vreg20<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg20,%vreg5
464B		%vreg19<def,tied1> = INC64r %vreg19<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg19
480B		%vreg15<def> = COPY %vreg19; GR64:%vreg15,%vreg19
496B		%vreg15<def,tied1> = AND64rr %vreg15<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg14
512B		CMP64rr %vreg15, %vreg16, %EFLAGS<imp-def>; GR64:%vreg15,%vreg16
576B		JNE_4 <BB#2>, %EFLAGS<imp-use,kill>
592B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3(4) BB#2(124)

608B	BB#3: derived from LLVM BB %for.end
	    Predecessors according to CFG: BB#2 BB#4
640B		%RAX<def> = COPY %vreg20; GR64:%vreg20
656B		RETQ %RAX<kill>

# End machine code for function quantum_ipow.

Before MISsched:
# Machine code for function quantum_ipow: Post SSA
Function Live Ins: %RDI in %vreg5, %RSI in %vreg6

BB#0: derived from LLVM BB %entry
    Live Ins: %RDI %RSI
	%vreg16<def> = COPY %RSI; GR64:%vreg16
	%vreg5<def> = COPY %RDI; GR64:%vreg5
	%RCX<def> = MOV64ri32 32
	%vreg13<def> = COPY %vreg16; GR64:%vreg13,%vreg16
	%vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
	%RCX<def> = MOV64ri32 32
	%vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
	TEST64rr %vreg13, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
	%vreg20<def> = MOV64ri32 1; GR64:%vreg20
	JG_4 <BB#1>, %EFLAGS<imp-use,kill>
    Successors according to CFG: BB#1(20) BB#4(12)

BB#4: 
    Predecessors according to CFG: BB#0
	JMP_4 <BB#3>
    Successors according to CFG: BB#3

BB#1: 
    Predecessors according to CFG: BB#0
	%vreg19<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg19
	%vreg14<def> = MOV64ri 4294967295; GR64:%vreg14
	%vreg16<def,tied1> = AND64rr %vreg16<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg14
    Successors according to CFG: BB#2

BB#2: derived from LLVM BB %for.body
    Predecessors according to CFG: BB#2 BB#1
	%vreg20<def,tied1> = IMUL64rr %vreg20<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg20,%vreg5
	%vreg19<def,tied1> = INC64r %vreg19<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg19
	%vreg15<def> = COPY %vreg19; GR64:%vreg15,%vreg19
	%vreg15<def,tied1> = AND64rr %vreg15<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg14
	CMP64rr %vreg15, %vreg16, %EFLAGS<imp-def>; GR64:%vreg15,%vreg16
	JNE_4 <BB#2>, %EFLAGS<imp-use,kill>
	JMP_4 <BB#3>
    Successors according to CFG: BB#3(4) BB#2(124)

BB#3: derived from LLVM BB %for.end
    Predecessors according to CFG: BB#2 BB#4
	%RAX<def> = COPY %vreg20; GR64:%vreg20
	RETQ %RAX<kill>

# End machine code for function quantum_ipow.

********** MI Scheduling **********
quantum_ipow:BB#0 entry
  From: %vreg16<def> = COPY %RSI; GR64:%vreg16
    To: JG_4 <BB#1>, %EFLAGS<imp-use,kill>
 RegionInstrs: 9 Remaining: 0
Max Pressure: GR64_ABCD=1
GR64_NOREX=2
GR64_NOREX+GR64_TC=2
GR64=4
Live In: %RCX %RIZ 
Live Out: %vreg20 %vreg16 %vreg5 
Live Thru: 
  LiveReg: %vreg20
  LiveReg: %vreg16
  UpdateRegP: SU(3) %vreg13<def> = COPY %vreg16; GR64:%vreg13,%vreg16
  LiveReg: %vreg5
AllocationOrder(GR64) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 ]
AllocationOrder(GR64_ABCD) = [ %RAX %RCX %RDX %RBX ] (sub-class)
AllocationOrder(SEGMENT_REG) = [ ]
AllocationOrder(DEBUG_REG) = [ %DR0 %DR1 %DR2 %DR3 %DR4 %DR5 %DR6 %DR7 ]
AllocationOrder(GR64_NOREX) = [ %RAX %RCX %RDX %RSI %RDI %RBX ] (sub-class)
AllocationOrder(GR64_NOREX) = [ %RAX %RCX %RDX %RSI %RDI %RBX ] (sub-class)
AllocationOrder(CONTROL_REG) = [ %CR0 %CR1 %CR2 %CR3 %CR4 %CR5 %CR6 %CR7 %CR8 %CR9 %CR10 %CR11 %CR12 %CR13 %CR14 %CR15 ]
AllocationOrder(GR64) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 ]
Excess PSets: 
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %vreg16<def> = COPY %RSI; GR64:%vreg16
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 3
  Successors:
   val SU(3): Latency=0 Reg=%vreg16

SU(1):   %vreg5<def> = COPY %RDI; GR64:%vreg5
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0

SU(2):   %RCX<def> = MOV64ri32 32
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   out SU(5): Latency=1
   val SU(4): Latency=1 Reg=%RCX

SU(3):   %vreg13<def> = COPY %vreg16; GR64:%vreg13,%vreg16
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 3
  Predecessors:
   val SU(0): Latency=0 Reg=%vreg16
  Successors:
   val SU(4): Latency=0 Reg=%vreg13
   out SU(4): Latency=1

SU(4):   %vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  # preds left       : 3
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(3): Latency=0 Reg=%vreg13
   out SU(3): Latency=1
   val SU(2): Latency=1 Reg=%RCX
  Successors:
   val SU(6): Latency=1 Reg=%vreg13
   out SU(6): Latency=1
   out SU(7): Latency=1
   antiSU(5): Latency=0

SU(5):   %RCX<def> = MOV64ri32 32
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   antiSU(4): Latency=0
   out SU(2): Latency=1
  Successors:
   val SU(6): Latency=1 Reg=%RCX

SU(6):   %vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
   val SU(4): Latency=1 Reg=%vreg13
   val SU(5): Latency=1 Reg=%RCX
   out SU(4): Latency=1
  Successors:
   val SU(7): Latency=1 Reg=%vreg13
   out SU(7): Latency=1

SU(7):   TEST64rr %vreg13, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
   val SU(6): Latency=1 Reg=%vreg13
   out SU(6): Latency=1
   out SU(4): Latency=1

SU(8):   %vreg20<def> = MOV64ri32 1; GR64:%vreg20
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Critical Path: 3
BotQ.A: 8 7 1 
  SU(8) ORDER                              
Pick Bot PREG-COPY
Scheduling SU(8) %vreg20<def> = MOV64ri32 1; GR64:%vreg20
  Ready @0c
  *** Max MOps 1 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
BotQ.A: 1 7 
  SU(1) ORDER                              
  SU(7) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(7) TEST64rr %vreg13, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
  LiveReg: %vreg13
  UpdateRegP: SU(7) TEST64rr %vreg13, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
  UpdateRegP: SU(6) %vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  UpdateRegP: SU(4) %vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  Ready @1c
  BotQ.A TopLatency SU(7) 3c
  *** Max MOps 1 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 2
  Executed: 2c
  Critical: 2c, 2 MOps
  ExpectedLatency: 0c
  - Latency limited.
BotQ.A: 1 6 
  SU(1) ORDER                              
  SU(6) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(6) %vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  LiveReg: %vreg13
  UpdateRegP: SU(7) TEST64rr %vreg13, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
  UpdateRegP: SU(6) %vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  UpdateRegP: SU(4) %vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  LiveReg: RCX
  Ready @2c
  BotQ.A BotLatency SU(6) 1c
  *** Max MOps 1 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 3
  Executed: 3c
  Critical: 3c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 1 5 
  SU(1) ORDER                              
  SU(5) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(5) %RCX<def> = MOV64ri32 32
  Ready @3c
  BotQ.A BotLatency SU(5) 2c
  *** Max MOps 1 at cycle 3
Cycle: 4 BotQ.A
BotQ.A @4c
  Retired: 4
  Executed: 4c
  Critical: 4c, 4 MOps
  ExpectedLatency: 2c
  - Latency limited.
BotQ.A: 1 4 
  SU(1) ORDER                              
  SU(4) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(4) %vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  LiveReg: %vreg13
  UpdateRegP: SU(7) TEST64rr %vreg13, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
  UpdateRegP: SU(6) %vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  UpdateRegP: SU(4) %vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  LiveReg: RCX
  Ready @4c
  BotQ.A TopLatency SU(4) 1c
  *** Max MOps 1 at cycle 4
Cycle: 5 BotQ.A
BotQ.A @5c
  Retired: 5
  Executed: 5c
  Critical: 5c, 5 MOps
  ExpectedLatency: 2c
  - Latency limited.
BotQ.A: 1 3 2 
  SU(1) ORDER                              
  SU(3) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(3) %vreg13<def> = COPY %vreg16; GR64:%vreg13,%vreg16
  Ready @5c
  BotQ.A BotLatency SU(3) 3c
BotQ.A @5c
  Retired: 5
  Executed: 5c
  Critical: 5c, 5 MOps
  ExpectedLatency: 3c
  - Latency limited.
BotQ.A: 1 2 0 
  SU(1) ORDER                              
  SU(2) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(2) %RCX<def> = MOV64ri32 32
  Ready @5c
  *** Max MOps 1 at cycle 5
Cycle: 6 BotQ.A
BotQ.A @6c
  Retired: 6
  Executed: 6c
  Critical: 6c, 6 MOps
  ExpectedLatency: 3c
  - Latency limited.
BotQ.A: 1 0 
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %vreg5<def> = COPY %RDI; GR64:%vreg5
  LiveReg: RDI
  Ready @6c
BotQ.A @6c
  Retired: 6
  Executed: 6c
  Critical: 6c, 6 MOps
  ExpectedLatency: 3c
  - Latency limited.
Scheduling SU(0) %vreg16<def> = COPY %RSI; GR64:%vreg16
  LiveReg: RSI
  Ready @6c
BotQ.A @6c
  Retired: 6
  Executed: 6c
  Critical: 6c, 6 MOps
  ExpectedLatency: 3c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg16<def> = COPY %RSI; GR64:%vreg16
SU(1):   %vreg5<def> = COPY %RDI; GR64:%vreg5
SU(2):   %RCX<def> = MOV64ri32 32
SU(3):   %vreg13<def> = COPY %vreg16; GR64:%vreg13,%vreg16
SU(4):   %vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
SU(5):   %RCX<def> = MOV64ri32 32
SU(6):   %vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
SU(7):   TEST64rr %vreg13, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
SU(8):   %vreg20<def> = MOV64ri32 1; GR64:%vreg20

********** MI Scheduling **********
quantum_ipow:BB#1 (null)
  From: %vreg19<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg19
    To: End RegionInstrs: 3 Remaining: 0
Max Pressure: GR64=3
Live In: %vreg16 
Live Out: %vreg16 %vreg14 %vreg19 
Live Thru: GR64=1
  LiveReg: %vreg16
  UpdateRegP: SU(2) %vreg16<def,tied1> = AND64rr %vreg16<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg14
  LiveReg: %vreg14
  UpdateRegP: SU(2) %vreg16<def,tied1> = AND64rr %vreg16<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg14
  LiveReg: %vreg19
AllocationOrder(SEGMENT_REG) = [ ]
Excess PSets: 
SU(0):   %vreg19<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg19
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

SU(1):   %vreg14<def> = MOV64ri 4294967295; GR64:%vreg14
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(2): Latency=1 Reg=%vreg14

SU(2):   %vreg16<def,tied1> = AND64rr %vreg16<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg14
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
   val SU(1): Latency=1 Reg=%vreg14

Critical Path: 1
BotQ.A: 2 0 
  SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %vreg16<def,tied1> = AND64rr %vreg16<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg14
  LiveReg: %vreg16
  UpdateRegP: SU(2) %vreg16<def,tied1> = AND64rr %vreg16<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg14
  Ready @0c
  BotQ.A TopLatency SU(2) 1c
  *** Max MOps 1 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %vreg14<def> = MOV64ri 4294967295; GR64:%vreg14
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
  *** Max MOps 1 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 2
  Executed: 2c
  Critical: 2c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg19<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg19
  Ready @2c
  *** Max MOps 1 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 3
  Executed: 3c
  Critical: 3c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#1 ***
SU(0):   %vreg19<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg19
SU(1):   %vreg14<def> = MOV64ri 4294967295; GR64:%vreg14
SU(2):   %vreg16<def,tied1> = AND64rr %vreg16<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg14

********** MI Scheduling **********
quantum_ipow:BB#2 for.body
  From: %vreg20<def,tied1> = IMUL64rr %vreg20<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg20,%vreg5
    To: JNE_4 <BB#2>, %EFLAGS<imp-use,kill>
 RegionInstrs: 5 Remaining: 0
Max Pressure: GR64=6
Live In: %vreg5 %vreg14 %vreg16 %vreg19 %vreg20 
Live Out: %vreg16 %vreg14 %vreg19 %vreg20 %vreg5 
Live Thru: GR64=5
  LiveReg: %vreg16
  UpdateRegP: SU(4) CMP64rr %vreg15, %vreg16, %EFLAGS<imp-def>; GR64:%vreg15,%vreg16
  LiveReg: %vreg14
  UpdateRegP: SU(3) %vreg15<def,tied1> = AND64rr %vreg15<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg14
  LiveReg: %vreg19
  UpdateRegP: SU(2) %vreg15<def> = COPY %vreg19; GR64:%vreg15,%vreg19
  UpdateRegP: SU(1) %vreg19<def,tied1> = INC64r %vreg19<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg19
  LiveReg: %vreg20
  UpdateRegP: SU(0) %vreg20<def,tied1> = IMUL64rr %vreg20<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg20,%vreg5
  LiveReg: %vreg5
  UpdateRegP: SU(0) %vreg20<def,tied1> = IMUL64rr %vreg20<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg20,%vreg5
AllocationOrder(SEGMENT_REG) = [ ]
Excess PSets: 
SU(0):   %vreg20<def,tied1> = IMUL64rr %vreg20<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg20,%vreg5
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   out SU(4): Latency=1

SU(1):   %vreg19<def,tied1> = INC64r %vreg19<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg19
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(2): Latency=1 Reg=%vreg19
   out SU(4): Latency=1

SU(2):   %vreg15<def> = COPY %vreg19; GR64:%vreg15,%vreg19
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(1): Latency=1 Reg=%vreg19
  Successors:
   val SU(3): Latency=0 Reg=%vreg15
   out SU(3): Latency=1

SU(3):   %vreg15<def,tied1> = AND64rr %vreg15<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg14
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
   val SU(2): Latency=0 Reg=%vreg15
   out SU(2): Latency=1
  Successors:
   val SU(4): Latency=1 Reg=%vreg15
   out SU(4): Latency=1

SU(4):   CMP64rr %vreg15, %vreg16, %EFLAGS<imp-def>; GR64:%vreg15,%vreg16
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
   val SU(3): Latency=1 Reg=%vreg15
   out SU(3): Latency=1
   out SU(1): Latency=1
   out SU(0): Latency=1

Critical Path: 3
Cyclic Path: SU(1) -> SU(1) = 1c
Cyclic Path: SU(0) -> SU(0) = 1c
Cyclic Critical Path: 1c
IssueCycles=0c IterCycles=1c NumIters=3 InFlight=0m BufferLim=0m
Scheduling SU(4) CMP64rr %vreg15, %vreg16, %EFLAGS<imp-def>; GR64:%vreg15,%vreg16
  LiveReg: %vreg15
  UpdateRegP: SU(4) CMP64rr %vreg15, %vreg16, %EFLAGS<imp-def>; GR64:%vreg15,%vreg16
  UpdateRegP: SU(3) %vreg15<def,tied1> = AND64rr %vreg15<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg14
  Ready @0c
  BotQ.A TopLatency SU(4) 3c
  *** Max MOps 1 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
BotQ.A: 3 0 
  SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %vreg15<def,tied1> = AND64rr %vreg15<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg14
  LiveReg: %vreg15
  UpdateRegP: SU(4) CMP64rr %vreg15, %vreg16, %EFLAGS<imp-def>; GR64:%vreg15,%vreg16
  UpdateRegP: SU(3) %vreg15<def,tied1> = AND64rr %vreg15<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg14
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
  *** Max MOps 1 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 2
  Executed: 2c
  Critical: 2c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 2 
  SU(0) ORDER                              
  SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %vreg15<def> = COPY %vreg19; GR64:%vreg15,%vreg19
  Ready @2c
  BotQ.A BotLatency SU(2) 2c
BotQ.A @2c
  Retired: 2
  Executed: 2c
  Critical: 2c, 2 MOps
  ExpectedLatency: 2c
  - Latency limited.
Scheduling SU(0) %vreg20<def,tied1> = IMUL64rr %vreg20<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg20,%vreg5
handleMove 432B -> 472B: %vreg20<def,tied1> = IMUL64rr %vreg20<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg20,%vreg5
     %vreg20:	[176r,368B:0)[368B,432r:3)[432r,608B:1)[608B,640r:2)  0@176r 1@432r 2@608B-phi 3@368B-phi
        -->	[176r,368B:0)[368B,472r:3)[472r,608B:1)[608B,640r:2)  0@176r 1@472r 2@608B-phi 3@368B-phi
     %vreg5:	[32r,208B:0)[256B,608B:0)  0@32r
        -->	[32r,208B:0)[256B,608B:0)  0@32r
     EFLAGS:	[96r,96d:8)[144r,144d:7)[160r,192r:5)[272r,272d:6)[320r,320d:1)[464r,464d:3)[472r,472d:4)[496r,496d:2)[512r,576r:0)  0@512r 1@320r 2@496r 3@464r 4@472r 5@160r 6@272r 7@144r 8@96r
        -->	[96r,96d:8)[144r,144d:7)[160r,192r:5)[272r,272d:6)[320r,320d:1)[464r,464d:3)[472r,472d:4)[496r,496d:2)[512r,576r:0)  0@512r 1@320r 2@496r 3@464r 4@472r 5@160r 6@272r 7@144r 8@96r
  LiveReg: %vreg20
  UpdateRegP: SU(0) %vreg20<def,tied1> = IMUL64rr %vreg20<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg20,%vreg5
  Ready @2c
  *** Max MOps 1 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 3
  Executed: 3c
  Critical: 3c, 3 MOps
  ExpectedLatency: 2c
  - Latency limited.
Scheduling SU(1) %vreg19<def,tied1> = INC64r %vreg19<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg19
  LiveReg: %vreg19
  UpdateRegP: SU(2) %vreg15<def> = COPY %vreg19; GR64:%vreg15,%vreg19
  UpdateRegP: SU(1) %vreg19<def,tied1> = INC64r %vreg19<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg19
  Ready @3c
  BotQ.A BotLatency SU(1) 3c
  *** Max MOps 1 at cycle 3
Cycle: 4 BotQ.A
BotQ.A @4c
  Retired: 4
  Executed: 4c
  Critical: 4c, 4 MOps
  ExpectedLatency: 3c
  - Latency limited.
*** Final schedule for BB#2 ***
SU(1):   %vreg19<def,tied1> = INC64r %vreg19<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg19
SU(0):   %vreg20<def,tied1> = IMUL64rr %vreg20<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg20,%vreg5
SU(2):   %vreg15<def> = COPY %vreg19; GR64:%vreg15,%vreg19
SU(3):   %vreg15<def,tied1> = AND64rr %vreg15<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg14
SU(4):   CMP64rr %vreg15, %vreg16, %EFLAGS<imp-def>; GR64:%vreg15,%vreg16

********** INTERVALS **********
EFLAGS [96r,96d:8)[144r,144d:7)[160r,192r:5)[272r,272d:6)[320r,320d:1)[464r,464d:3)[472r,472d:4)[496r,496d:2)[512r,576r:0)  0@512r 1@320r 2@496r 3@464r 4@472r 5@160r 6@272r 7@144r 8@96r
RDI [0B,32r:0)  0@0B-phi
RSI [0B,16r:0)  0@0B-phi
%vreg5 [32r,208B:0)[256B,608B:0)  0@32r
%vreg13 [80r,96r:2)[96r,144r:0)[144r,160r:1)  0@96r 1@144r 2@80r
%vreg14 [288r,608B:0)  0@288r
%vreg15 [480r,496r:0)[496r,512r:1)  0@480r 1@496r
%vreg16 [16r,208B:0)[256B,320r:0)[320r,608B:1)  0@16r 1@320r
%vreg19 [272r,368B:0)[368B,464r:2)[464r,608B:1)  0@272r 1@464r 2@368B-phi
%vreg20 [176r,368B:0)[368B,472r:3)[472r,608B:1)[608B,640r:2)  0@176r 1@472r 2@608B-phi 3@368B-phi
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function quantum_ipow: Post SSA
Function Live Ins: %RDI in %vreg5, %RSI in %vreg6

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI %RSI
16B		%vreg16<def> = COPY %RSI; GR64:%vreg16
32B		%vreg5<def> = COPY %RDI; GR64:%vreg5
64B		%RCX<def> = MOV64ri32 32
80B		%vreg13<def> = COPY %vreg16; GR64:%vreg13,%vreg16
96B		%vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
112B		%RCX<def> = MOV64ri32 32
144B		%vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
160B		TEST64rr %vreg13, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
176B		%vreg20<def> = MOV64ri32 1; GR64:%vreg20
192B		JG_4 <BB#1>, %EFLAGS<imp-use>
	    Successors according to CFG: BB#1(20) BB#4(12)

208B	BB#4: 
	    Predecessors according to CFG: BB#0
240B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3

256B	BB#1: 
	    Predecessors according to CFG: BB#0
272B		%vreg19<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg19
288B		%vreg14<def> = MOV64ri 4294967295; GR64:%vreg14
320B		%vreg16<def,tied1> = AND64rr %vreg16<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg14
	    Successors according to CFG: BB#2

368B	BB#2: derived from LLVM BB %for.body
	    Predecessors according to CFG: BB#2 BB#1
464B		%vreg19<def,tied1> = INC64r %vreg19<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg19
472B		%vreg20<def,tied1> = IMUL64rr %vreg20<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg20,%vreg5
480B		%vreg15<def> = COPY %vreg19; GR64:%vreg15,%vreg19
496B		%vreg15<def,tied1> = AND64rr %vreg15<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg14
512B		CMP64rr %vreg15, %vreg16, %EFLAGS<imp-def>; GR64:%vreg15,%vreg16
576B		JNE_4 <BB#2>, %EFLAGS<imp-use>
592B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3(4) BB#2(124)

608B	BB#3: derived from LLVM BB %for.end
	    Predecessors according to CFG: BB#2 BB#4
640B		%RAX<def> = COPY %vreg20; GR64:%vreg20
656B		RETQ %RAX<kill>

# End machine code for function quantum_ipow.

RPO[BB#0 derived from LLVM BB entry] = 1
RPO[BB#4] = 2
RPO[BB#1] = 3
RPO[BB#2 derived from LLVM BB for.body] = 4
RPO[BB#3 derived from LLVM BB for.end] = 5
POT: BB#3 derived from LLVM BB for.end
POT: BB#2 derived from LLVM BB for.body
doLoop(BB#2 derived from LLVM BB for.body, BB#2 derived from LLVM BB for.body)
doBlock(BB#2 derived from LLVM BB for.body)
Frequency(BB#2 derived from LLVM BB for.body) = 0.0
Frequency(BB#2 derived from LLVM BB for.body) = 1.0
LoopExitProb[BB#2 derived from LLVM BB for.body] = 512 / 16384 = 3.125% from 1 - 0.96875 / 1.0.
POT: BB#1
POT: BB#4
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#3 derived from LLVM BB for.end)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
doBlock(BB#4)
Frequency(BB#4) = 0.0
Frequency(BB#4) = 0.375
doBlock(BB#1)
Frequency(BB#1) = 0.0
Frequency(BB#1) = 0.625
doBlock(BB#2 derived from LLVM BB for.body)
Frequency(BB#2 derived from LLVM BB for.body) = 0.0
Frequency(BB#2 derived from LLVM BB for.body) += 0.625 --> 0.625
Loop header scaled to 20.0.
doBlock(BB#3 derived from LLVM BB for.end)
Frequency(BB#3 derived from LLVM BB for.end) = 0.0
Frequency(BB#3 derived from LLVM BB for.end) += 0.625 --> 0.625
Frequency(BB#3 derived from LLVM BB for.end) += 0.375 --> 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** COMPUTING LIVE DEBUG VARIABLES: quantum_ipow **********
********** DEBUG VARIABLES **********
********** GREEDY REGISTER ALLOCATION **********
********** Function: quantum_ipow
********** Compute Spill Weights **********
********** Function: quantum_ipow
********** INTERVALS **********
EFLAGS [96r,96d:8)[144r,144d:7)[160r,192r:5)[272r,272d:6)[320r,320d:1)[464r,464d:3)[472r,472d:4)[496r,496d:2)[512r,576r:0)  0@512r 1@320r 2@496r 3@464r 4@472r 5@160r 6@272r 7@144r 8@96r
RDI [0B,32r:0)  0@0B-phi
RSI [0B,16r:0)  0@0B-phi
%vreg5 [32r,208B:0)[256B,608B:0)  0@32r
%vreg13 [80r,96r:2)[96r,144r:0)[144r,160r:1)  0@96r 1@144r 2@80r
%vreg14 [288r,608B:0)  0@288r
%vreg15 [480r,496r:0)[496r,512r:1)  0@480r 1@496r
%vreg16 [16r,208B:0)[256B,320r:0)[320r,608B:1)  0@16r 1@320r
%vreg19 [272r,368B:0)[368B,464r:2)[464r,608B:1)  0@272r 1@464r 2@368B-phi
%vreg20 [176r,368B:0)[368B,472r:3)[472r,608B:1)[608B,640r:2)  0@176r 1@472r 2@608B-phi 3@368B-phi
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function quantum_ipow: Post SSA
Function Live Ins: %RDI in %vreg5, %RSI in %vreg6

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI %RSI
16B		%vreg16<def> = COPY %RSI; GR64:%vreg16
32B		%vreg5<def> = COPY %RDI; GR64:%vreg5
64B		%RCX<def> = MOV64ri32 32
80B		%vreg13<def> = COPY %vreg16; GR64:%vreg13,%vreg16
96B		%vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
112B		%RCX<def> = MOV64ri32 32
144B		%vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
160B		TEST64rr %vreg13, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
176B		%vreg20<def> = MOV64ri32 1; GR64:%vreg20
192B		JG_4 <BB#1>, %EFLAGS<imp-use>
	    Successors according to CFG: BB#1(20) BB#4(12)

208B	BB#4: 
	    Predecessors according to CFG: BB#0
240B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3

256B	BB#1: 
	    Predecessors according to CFG: BB#0
272B		%vreg19<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg19
288B		%vreg14<def> = MOV64ri 4294967295; GR64:%vreg14
320B		%vreg16<def,tied1> = AND64rr %vreg16<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg14
	    Successors according to CFG: BB#2

368B	BB#2: derived from LLVM BB %for.body
	    Predecessors according to CFG: BB#2 BB#1
464B		%vreg19<def,tied1> = INC64r %vreg19<tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg19
472B		%vreg20<def,tied1> = IMUL64rr %vreg20<tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg20,%vreg5
480B		%vreg15<def> = COPY %vreg19; GR64:%vreg15,%vreg19
496B		%vreg15<def,tied1> = AND64rr %vreg15<tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg14
512B		CMP64rr %vreg15, %vreg16, %EFLAGS<imp-def>; GR64:%vreg15,%vreg16
576B		JNE_4 <BB#2>, %EFLAGS<imp-use>
592B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3(4) BB#2(124)

608B	BB#3: derived from LLVM BB %for.end
	    Predecessors according to CFG: BB#2 BB#4
640B		%RAX<def> = COPY %vreg20; GR64:%vreg20
656B		RETQ %RAX<kill>

# End machine code for function quantum_ipow.


selectOrSplit GR64:%vreg16 [16r,208B:0)[256B,320r:0)[320r,608B:1)  0@16r 1@320r w=2.492834e-02
AllocationOrder(GR64) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 ]
hints: %RSI
assigning %vreg16 to %RSI: RSI

selectOrSplit GR64:%vreg5 [32r,208B:0)[256B,608B:0)  0@32r w=2.290497e-02
hints: %RDI
assigning %vreg5 to %RDI: RDI

selectOrSplit GR64:%vreg20 [176r,368B:0)[368B,472r:3)[472r,608B:1)[608B,640r:2)  0@176r 1@472r 2@608B-phi 3@368B-phi w=1.426157e-01
hints: %RAX
assigning %vreg20 to %RAX: RAX

selectOrSplit GR64:%vreg19 [272r,368B:0)[368B,464r:2)[464r,608B:1)  0@272r 1@464r 2@368B-phi w=1.935031e-01
assigning %vreg19 to %RCX: RCX

selectOrSplit GR64:%vreg14 [288r,608B:0)  0@288r w=1.479805e-02
assigning %vreg14 to %RDX: RDX

selectOrSplit GR64:%vreg13 [80r,96r:2)[96r,144r:0)[144r,160r:1)  0@96r 1@144r 2@80r w=1.262500e-02
hints: %RSI
assigning %vreg13 to %RAX: RAX

selectOrSplit GR64:%vreg15 [480r,496r:0)[496r,512r:1)  0@480r 1@496r w=inf
hints: %RCX
%R8 is available at cost 1
Only trying the first 10 regs.
evicting %RCX interference: Cascade 1
unassigning %vreg19 from %RCX: RCX
assigning %vreg15 to %RCX: RCX
queuing new interval: %vreg19 [272r,368B:0)[368B,464r:2)[464r,608B:1)  0@272r 1@464r 2@368B-phi

selectOrSplit GR64:%vreg19 [272r,368B:0)[368B,464r:2)[464r,608B:1)  0@272r 1@464r 2@368B-phi w=1.935031e-01
hints: %RCX
%R8 is available at cost 1
Only trying the first 10 regs.
should evict: %vreg14 [288r,608B:0)  0@288r w= 1.479805e-02
%RBX would clobber CSR %RBX
evicting %RDX interference: Cascade 1
unassigning %vreg14 from %RDX: RDX
assigning %vreg19 to %RDX: RDX
queuing new interval: %vreg14 [288r,608B:0)  0@288r

selectOrSplit GR64:%vreg14 [288r,608B:0)  0@288r w=1.479805e-02
%R8 is available at cost 1
Only trying the first 10 regs.
%RBX would clobber CSR %RBX
assigning %vreg14 to %R8: R8
********** REWRITE VIRTUAL REGISTERS **********
********** Function: quantum_ipow
********** REGISTER MAP **********
[%vreg5 -> %RDI] GR64
[%vreg13 -> %RAX] GR64
[%vreg14 -> %R8] GR64
[%vreg15 -> %RCX] GR64
[%vreg16 -> %RSI] GR64
[%vreg19 -> %RDX] GR64
[%vreg20 -> %RAX] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI %RSI
16B		%vreg16<def> = COPY %RSI; GR64:%vreg16
32B		%vreg5<def> = COPY %RDI; GR64:%vreg5
64B		%RCX<def> = MOV64ri32 32
80B		%vreg13<def> = COPY %vreg16; GR64:%vreg13,%vreg16
96B		%vreg13<def,tied1> = SHL64rCL %vreg13<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg13
112B		%RCX<def> = MOV64ri32 32
144B		%vreg13<def,tied1> = SAR64rCL %vreg13<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg13
160B		TEST64rr %vreg13<kill>, %vreg13, %EFLAGS<imp-def>; GR64:%vreg13
176B		%vreg20<def> = MOV64ri32 1; GR64:%vreg20
192B		JG_4 <BB#1>, %EFLAGS<imp-use>
	    Successors according to CFG: BB#1(20) BB#4(12)
> %RSI<def> = COPY %RSI
Deleting identity copy.
> %RDI<def> = COPY %RDI
Deleting identity copy.
> %RCX<def> = MOV64ri32 32
> %RAX<def> = COPY %RSI
> %RAX<def,tied1> = SHL64rCL %RAX<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>
> %RCX<def> = MOV64ri32 32
> %RAX<def,tied1> = SAR64rCL %RAX<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>
> TEST64rr %RAX<kill>, %RAX, %EFLAGS<imp-def>
> %RAX<def> = MOV64ri32 1
> JG_4 <BB#1>, %EFLAGS<imp-use>
208B	BB#4: 
	    Live Ins: %RAX
	    Predecessors according to CFG: BB#0
240B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3
> JMP_4 <BB#3>
256B	BB#1: 
	    Live Ins: %RDI %RSI %RAX
	    Predecessors according to CFG: BB#0
272B		%vreg19<def> = MOV64r0 %EFLAGS<imp-def,dead>; GR64:%vreg19
288B		%vreg14<def> = MOV64ri 4294967295; GR64:%vreg14
320B		%vreg16<def,tied1> = AND64rr %vreg16<kill,tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg16,%vreg14
	    Successors according to CFG: BB#2
> %RDX<def> = MOV64r0 %EFLAGS<imp-def,dead>
> %R8<def> = MOV64ri 4294967295
> %RSI<def,tied1> = AND64rr %RSI<kill,tied0>, %R8, %EFLAGS<imp-def,dead>
368B	BB#2: derived from LLVM BB %for.body
	    Live Ins: %RDI %R8 %RSI %RDX %RAX
	    Predecessors according to CFG: BB#2 BB#1
464B		%vreg19<def,tied1> = INC64r %vreg19<kill,tied0>, %EFLAGS<imp-def,dead>; GR64:%vreg19
472B		%vreg20<def,tied1> = IMUL64rr %vreg20<kill,tied0>, %vreg5, %EFLAGS<imp-def,dead>; GR64:%vreg20,%vreg5
480B		%vreg15<def> = COPY %vreg19; GR64:%vreg15,%vreg19
496B		%vreg15<def,tied1> = AND64rr %vreg15<kill,tied0>, %vreg14, %EFLAGS<imp-def,dead>; GR64:%vreg15,%vreg14
512B		CMP64rr %vreg15<kill>, %vreg16, %EFLAGS<imp-def>; GR64:%vreg15,%vreg16
576B		JNE_4 <BB#2>, %EFLAGS<imp-use>
592B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3(4) BB#2(124)
> %RDX<def,tied1> = INC64r %RDX<kill,tied0>, %EFLAGS<imp-def,dead>
> %RAX<def,tied1> = IMUL64rr %RAX<kill,tied0>, %RDI, %EFLAGS<imp-def,dead>
> %RCX<def> = COPY %RDX
> %RCX<def,tied1> = AND64rr %RCX<kill,tied0>, %R8, %EFLAGS<imp-def,dead>
> CMP64rr %RCX<kill>, %RSI, %EFLAGS<imp-def>
> JNE_4 <BB#2>, %EFLAGS<imp-use>
> JMP_4 <BB#3>
608B	BB#3: derived from LLVM BB %for.end
	    Live Ins: %RAX
	    Predecessors according to CFG: BB#2 BB#4
640B		%RAX<def> = COPY %vreg20<kill>; GR64:%vreg20
656B		RETQ %RAX
> %RAX<def> = COPY %RAX<kill>
Deleting identity copy.
> RETQ %RAX
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: quantum_ipow
******** Post-regalloc Machine LICM: quantum_ipow ********

TryTailMergeBlocks: BB#2, BB#4
  with successor BB#3
  which has fall-through from BB#2
Looking for common tails of at least 3 instructions

Removing MBB: BB#1: 
    Live Ins: %RAX
    Successors according to CFG: BB#4

TryTailMergeBlocks: BB#3, BB#0
  with successor BB#4
  which has fall-through from BB#3
Looking for common tails of at least 3 instructions

*** Tail-duplicating BB#3
MCP: CopyPropagateBlock entry
MCP: Copy is a deletion candidate:   %RAX<def> = COPY %RSI
MCP: Copy is used - not dead:   %RAX<def> = COPY %RSI
MCP: CopyPropagateBlock (null)
MCP: CopyPropagateBlock for.body
MCP: Copy is a deletion candidate:   %RCX<def> = COPY %RDX
MCP: Copy is used - not dead:   %RCX<def> = COPY %RDX
MCP: CopyPropagateBlock for.end
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: quantum_ipow
real copy:   %RAX<def> = COPY %RSI
replaced by: %RAX<def> = MOV64rr %RSI
real copy:   %RCX<def> = COPY %RDX
replaced by: %RCX<def> = MOV64rr %RDX
RPO[BB#0 derived from LLVM BB entry] = 1
RPO[BB#1] = 2
RPO[BB#2 derived from LLVM BB for.body] = 3
RPO[BB#3 derived from LLVM BB for.end] = 4
POT: BB#3 derived from LLVM BB for.end
POT: BB#2 derived from LLVM BB for.body
doLoop(BB#2 derived from LLVM BB for.body, BB#2 derived from LLVM BB for.body)
doBlock(BB#2 derived from LLVM BB for.body)
Frequency(BB#2 derived from LLVM BB for.body) = 0.0
Frequency(BB#2 derived from LLVM BB for.body) = 1.0
LoopExitProb[BB#2 derived from LLVM BB for.body] = 512 / 16384 = 3.125% from 1 - 0.96875 / 1.0.
POT: BB#1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#3 derived from LLVM BB for.end)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
doBlock(BB#1)
Frequency(BB#1) = 0.0
Frequency(BB#1) = 0.625
doBlock(BB#2 derived from LLVM BB for.body)
Frequency(BB#2 derived from LLVM BB for.body) = 0.0
Frequency(BB#2 derived from LLVM BB for.body) += 0.625 --> 0.625
Loop header scaled to 20.0.
doBlock(BB#3 derived from LLVM BB for.end)
Frequency(BB#3 derived from LLVM BB for.end) = 0.0
Frequency(BB#3 derived from LLVM BB for.end) += 0.625 --> 0.625
Frequency(BB#3 derived from LLVM BB for.end) += 0.375 --> 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
Finding best loop top for: BB#2 (derived from LLVM BB 'for.body')
    header pred: BB#2 (derived from LLVM BB 'for.body'), 2 successors, 20.0 freq
Finding best loop exit for: BB#2 (derived from LLVM BB 'for.body')
    exiting: BB#2 (derived from LLVM BB 'for.body') -> BB#3 (derived from LLVM BB 'for.end') [L:0] (0.625)
Attempting merge from: BB#2 (derived from LLVM BB 'for.body')
    BB#2 (derived from LLVM BB 'for.body') -> Already merged!
Finished forming chain for header block BB#2
          ... BB#2 (derived from LLVM BB 'for.body')
Attempting merge from: BB#0 (derived from LLVM BB 'entry')
    BB#1 (derived from LLVM BB '(null)') -> 20 / 32 = 62.5% (prob)
    BB#3 (derived from LLVM BB 'for.end') -> 12 / 32 = 37.5% (prob) (CFG conflict)
Merging from BB#0 to BB#1
Attempting merge from: BB#1 (derived from LLVM BB '(null)')
    BB#2 (derived from LLVM BB 'for.body') -> 16 / 16 = 100% (prob)
Merging from BB#1 to BB#2
Attempting merge from: BB#2 (derived from LLVM BB 'for.body')
    BB#3 (derived from LLVM BB 'for.end') -> 4 / 128 = 3.125% (prob)
    BB#2 (derived from LLVM BB 'for.body') -> Already merged!
Merging from BB#2 to BB#3
Attempting merge from: BB#3 (derived from LLVM BB 'for.end')
Finished forming chain for header block BB#0
Placing chain BB#0 (derived from LLVM BB 'entry')
          ... BB#1 (derived from LLVM BB '(null)')
          ... BB#2 (derived from LLVM BB 'for.body')
          ... BB#3 (derived from LLVM BB 'for.end')
LoopSimplify: Creating pre-header while.body.preheader
LoopSimplify: Creating dedicated exit block while.end.loopexit
********** Constant Hoisting **********
********** Function: quantum_gcd
MERGING MOSTLY EMPTY BLOCKS - BEFORE:

while.body.preheader:                             ; preds = %entry
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %while.body
  %u.addr.05 = phi i32 [ %v.addr.04, %while.body ], [ %u, %while.body.preheader ]
  %v.addr.04 = phi i32 [ %rem, %while.body ], [ %v, %while.body.preheader ]
  %rem = srem i32 %u.addr.05, %v.addr.04
  %tobool = icmp eq i32 %rem, 0
  br i1 %tobool, label %while.end.loopexit, label %while.body
AFTER:

while.body:                                       ; preds = %entry, %while.body
  %u.addr.05 = phi i32 [ %v.addr.04, %while.body ], [ %u, %entry ]
  %v.addr.04 = phi i32 [ %rem, %while.body ], [ %v, %entry ]
  %rem = srem i32 %u.addr.05, %v.addr.04
  %tobool = icmp eq i32 %rem, 0
  br i1 %tobool, label %while.end.loopexit, label %while.body



MERGING MOSTLY EMPTY BLOCKS - BEFORE:

while.end.loopexit:                               ; preds = %while.body
  br label %while.end

while.end:                                        ; preds = %while.end.loopexit, %entry
  %u.addr.0.lcssa = phi i32 [ %u, %entry ], [ %v.addr.04, %while.end.loopexit ]
  ret i32 %u.addr.0.lcssa
AFTER:

while.end:                                        ; preds = %while.body, %entry
  %u.addr.0.lcssa = phi i32 [ %u, %entry ], [ %v.addr.04, %while.body ]
  ret i32 %u.addr.0.lcssa



---- Branch Probability Info : quantum_gcd ----

Computing probabilities for while.end
Computing probabilities for while.body
set edge while.body -> 1 successor weight to 124
set edge while.body -> 0 successor weight to 4
Computing probabilities for entry
set edge entry -> 1 successor weight to 20
set edge entry -> 0 successor weight to 12



=== quantum_gcd
Initial selection DAG: BB#0 'quantum_gcd:entry'
SelectionDAG has 19 nodes:
  0x219b660: ch = EntryToken

    0x219b660: <multiple use>
    0x21c6320: i64 = Register %vreg4

  0x21c6120: i64,ch = CopyFromReg 0x219b660, 0x21c6320 [ORD=1]

    0x219b660: <multiple use>
    0x21c8160: i64 = Register %vreg5

  0x21c8a60: i64,ch = CopyFromReg 0x219b660, 0x21c8160 [ORD=1]

    0x21c6120: <multiple use>
  0x21c6720: i32 = truncate 0x21c6120 [ORD=1]

          0x219b660: <multiple use>
          0x21c5e20: i64 = Register %vreg6

          0x21c6120: <multiple use>
        0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1]

          0x219b660: <multiple use>
          0x21ca780: i64 = Register %vreg7

          0x21c8a60: <multiple use>
        0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1]

      0x21c8860: ch = TokenFactor 0x21c8c60, 0x21c8260 [ORD=3]

          0x21c8a60: <multiple use>
        0x21c7e60: i32 = truncate 0x21c8a60 [ORD=1]

        0x21ca980: i32 = Constant<0>

        0x21c8960: ch = seteq

      0x21caa80: i1 = setcc 0x21c7e60, 0x21ca980, 0x21c8960 [ORD=2]

      0x21c8560: ch = BasicBlock<while.end 0x21d0740>

    0x21c5f20: ch = brcond 0x21c8860, 0x21caa80, 0x21c8560 [ORD=3]

    0x21c8360: ch = BasicBlock<while.body 0x21d05d0>

  0x21c8b60: ch = br 0x21c5f20, 0x21c8360 [ORD=3]


Optimized lowered selection DAG: BB#0 'quantum_gcd:entry'
SelectionDAG has 18 nodes:
  0x219b660: ch = EntryToken

    0x219b660: <multiple use>
    0x21c8160: i64 = Register %vreg5

  0x21c8a60: i64,ch = CopyFromReg 0x219b660, 0x21c8160 [ORD=1]

          0x219b660: <multiple use>
          0x21c5e20: i64 = Register %vreg6

            0x219b660: <multiple use>
            0x21c6320: i64 = Register %vreg4

          0x21c6120: i64,ch = CopyFromReg 0x219b660, 0x21c6320 [ORD=1]

        0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1]

          0x219b660: <multiple use>
          0x21ca780: i64 = Register %vreg7

          0x21c8a60: <multiple use>
        0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1]

      0x21c8860: ch = TokenFactor 0x21c8c60, 0x21c8260 [ORD=3]

          0x21c8a60: <multiple use>
        0x21c7e60: i32 = truncate 0x21c8a60 [ORD=1]

        0x21ca980: i32 = Constant<0>

        0x21c8960: ch = seteq

      0x21caa80: i1 = setcc 0x21c7e60, 0x21ca980, 0x21c8960 [ORD=2]

      0x21c8560: ch = BasicBlock<while.end 0x21d0740>

    0x21c5f20: ch = brcond 0x21c8860, 0x21caa80, 0x21c8560 [ORD=3]

    0x21c8360: ch = BasicBlock<while.body 0x21d05d0>

  0x21c8b60: ch = br 0x21c5f20, 0x21c8360 [ORD=3]


Legally typed node: 0x21c8360: ch = BasicBlock<while.body 0x21d05d0> [ID=0]

Legally typed node: 0x21c8560: ch = BasicBlock<while.end 0x21d0740> [ID=0]

Legally typed node: 0x21c8960: ch = seteq [ID=0]

Promote integer result: 0x21ca980: i32 = Constant<0> [ID=0]

Legally typed node: 0x21c6720: i64 = Constant<0> [ID=0]

Legally typed node: 0x21ca780: i64 = Register %vreg7 [ID=0]

Legally typed node: 0x21c5e20: i64 = Register %vreg6 [ID=0]

Legally typed node: 0x21c8160: i64 = Register %vreg5 [ID=0]

Legally typed node: 0x21c6320: i64 = Register %vreg4 [ID=0]

Legally typed node: 0x219b660: ch = EntryToken [ID=0]

Legally typed node: 0x21c6120: i64,ch = CopyFromReg 0x219b660, 0x21c6320 [ORD=1] [ID=0]

Legally typed node: 0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1] [ID=0]

Legally typed node: 0x21c8a60: i64,ch = CopyFromReg 0x219b660, 0x21c8160 [ORD=1] [ID=0]

Promote integer result: 0x21c7e60: i32 = truncate 0x21c8a60 [ORD=1] [ID=0]

Promote integer result: 0x21caa80: i1 = setcc 0x21c7e60, 0x21ca980, 0x21c8960 [ORD=2] [ID=0]

Promote integer operand: 0x21ca480: i64 = setcc 0x21c7e60, 0x21ca980, 0x21c8960 [ORD=2] [ID=0]

Legally typed node: 0x21ca880: i64 = Constant<4294967295> [ID=0]

Legally typed node: 0x21c6420: i64 = and 0x21c8a60, 0x21ca880 [ORD=1] [ID=0]

Legally typed node: 0x21ca480: i64 = setcc 0x21c6420, 0x21c6720, 0x21c8960 [ORD=2] [ID=0]

Legally typed node: 0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1] [ID=0]

Legally typed node: 0x21c8860: ch = TokenFactor 0x21c8c60, 0x21c8260 [ORD=3] [ID=0]

Promote integer operand: 0x21c5f20: ch = brcond 0x21c8860, 0x21caa80, 0x21c8560 [ORD=3] [ID=0]

Promote integer operand: 0x21c8060: i64 = zero_extend 0x21caa80 [ORD=2] [ID=0]

Legally typed node: 0x21c7f60: i64 = Constant<1> [ID=0]

Legally typed node: 0x21c6220: i64 = and 0x21ca480, 0x21c7f60 [ORD=2] [ID=0]

Legally typed node: 0x21c5f20: ch = brcond 0x21c8860, 0x21c6220, 0x21c8560 [ORD=3] [ID=0]

Legally typed node: 0x21c8b60: ch = br 0x21c5f20, 0x21c8360 [ORD=3] [ID=0]

Legally typed node: 0x7fff16596d20: ch = handlenode 0x21c8b60 [ID=0]

Type-legalized selection DAG: BB#0 'quantum_gcd:entry'
SelectionDAG has 21 nodes:
  0x219b660: ch = EntryToken [ID=-3]

    0x219b660: <multiple use>
    0x21c8160: i64 = Register %vreg5 [ID=-3]

  0x21c8a60: i64,ch = CopyFromReg 0x219b660, 0x21c8160 [ORD=1] [ID=-3]

          0x219b660: <multiple use>
          0x21c5e20: i64 = Register %vreg6 [ID=-3]

            0x219b660: <multiple use>
            0x21c6320: i64 = Register %vreg4 [ID=-3]

          0x21c6120: i64,ch = CopyFromReg 0x219b660, 0x21c6320 [ORD=1] [ID=-3]

        0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1] [ID=-3]

          0x219b660: <multiple use>
          0x21ca780: i64 = Register %vreg7 [ID=-3]

          0x21c8a60: <multiple use>
        0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1] [ID=-3]

      0x21c8860: ch = TokenFactor 0x21c8c60, 0x21c8260 [ORD=3] [ID=-3]

            0x21c8a60: <multiple use>
            0x21ca880: i64 = Constant<4294967295> [ID=-3]

          0x21c6420: i64 = and 0x21c8a60, 0x21ca880 [ORD=1] [ID=-3]

          0x21c6720: i64 = Constant<0> [ID=-3]

          0x21c8960: ch = seteq [ID=-3]

        0x21ca480: i64 = setcc 0x21c6420, 0x21c6720, 0x21c8960 [ORD=2] [ID=-3]

        0x21c7f60: i64 = Constant<1> [ID=-3]

      0x21c6220: i64 = and 0x21ca480, 0x21c7f60 [ORD=2] [ID=-3]

      0x21c8560: ch = BasicBlock<while.end 0x21d0740> [ID=-3]

    0x21c5f20: ch = brcond 0x21c8860, 0x21c6220, 0x21c8560 [ORD=3] [ID=-3]

    0x21c8360: ch = BasicBlock<while.body 0x21d05d0> [ID=-3]

  0x21c8b60: ch = br 0x21c5f20, 0x21c8360 [ORD=3] [ID=-3]



Replacing.2 0x21c6220: i64 = and 0x21ca480, 0x21c7f60 [ORD=2] [ID=-3]

With: 0x21ca480: i64 = setcc 0x21c6420, 0x21c6720, 0x21c8960 [ORD=2] [ID=-3]

Optimized type-legalized selection DAG: BB#0 'quantum_gcd:entry'
SelectionDAG has 19 nodes:
  0x219b660: ch = EntryToken [ID=-3]

    0x219b660: <multiple use>
    0x21c8160: i64 = Register %vreg5 [ID=-3]

  0x21c8a60: i64,ch = CopyFromReg 0x219b660, 0x21c8160 [ORD=1] [ID=-3]

          0x219b660: <multiple use>
          0x21c5e20: i64 = Register %vreg6 [ID=-3]

            0x219b660: <multiple use>
            0x21c6320: i64 = Register %vreg4 [ID=-3]

          0x21c6120: i64,ch = CopyFromReg 0x219b660, 0x21c6320 [ORD=1] [ID=-3]

        0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1] [ID=-3]

          0x219b660: <multiple use>
          0x21ca780: i64 = Register %vreg7 [ID=-3]

          0x21c8a60: <multiple use>
        0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1] [ID=-3]

      0x21c8860: ch = TokenFactor 0x21c8c60, 0x21c8260 [ORD=3] [ID=-3]

          0x21c8a60: <multiple use>
          0x21ca880: i64 = Constant<4294967295> [ID=-3]

        0x21c6420: i64 = and 0x21c8a60, 0x21ca880 [ORD=1] [ID=-3]

        0x21c6720: i64 = Constant<0> [ID=-3]

        0x21c8960: ch = seteq [ID=-3]

      0x21ca480: i64 = setcc 0x21c6420, 0x21c6720, 0x21c8960 [ORD=2] [ID=-3]

      0x21c8560: ch = BasicBlock<while.end 0x21d0740> [ID=-3]

    0x21c5f20: ch = brcond 0x21c8860, 0x21ca480, 0x21c8560 [ORD=3] [ID=-3]

    0x21c8360: ch = BasicBlock<while.body 0x21d05d0> [ID=-3]

  0x21c8b60: ch = br 0x21c5f20, 0x21c8360 [ORD=3] [ID=-3]


Legalized selection DAG: BB#0 'quantum_gcd:entry'
SelectionDAG has 19 nodes:
  0x219b660: ch = EntryToken [ID=0]

    0x219b660: <multiple use>
    0x21c8160: i64 = Register %vreg5 [ID=2]

  0x21c8a60: i64,ch = CopyFromReg 0x219b660, 0x21c8160 [ORD=1] [ID=11]

          0x219b660: <multiple use>
          0x21c5e20: i64 = Register %vreg6 [ID=3]

            0x219b660: <multiple use>
            0x21c6320: i64 = Register %vreg4 [ID=1]

          0x21c6120: i64,ch = CopyFromReg 0x219b660, 0x21c6320 [ORD=1] [ID=10]

        0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1] [ID=12]

          0x219b660: <multiple use>
          0x21ca780: i64 = Register %vreg7 [ID=4]

          0x21c8a60: <multiple use>
        0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1] [ID=14]

      0x21c8860: ch = TokenFactor 0x21c8c60, 0x21c8260 [ORD=3] [ID=16]

      0x21c8560: ch = BasicBlock<while.end 0x21d0740> [ID=6]

      0x21c6220: i64 = Constant<4>

          0x21c8a60: <multiple use>
          0x21ca880: i64 = Constant<4294967295> [ID=9]

        0x21c6420: i64 = and 0x21c8a60, 0x21ca880 [ORD=1] [ID=13]

        0x21c6720: i64 = Constant<0> [ID=8]

      0x21c7f60: i64 = Cse523ISD::CMP 0x21c6420, 0x21c6720 [ORD=1]

    0x21ca980: ch = Cse523ISD::BRCOND 0x21c8860, 0x21c8560, 0x21c6220, 0x21c7f60 [ORD=3]

    0x21c8360: ch = BasicBlock<while.body 0x21d05d0> [ID=7]

  0x21c8b60: ch = br 0x21ca980, 0x21c8360 [ORD=3] [ID=18]


Optimized legalized selection DAG: BB#0 'quantum_gcd:entry'
SelectionDAG has 19 nodes:
  0x219b660: ch = EntryToken [ID=0]

    0x219b660: <multiple use>
    0x21c8160: i64 = Register %vreg5 [ID=2]

  0x21c8a60: i64,ch = CopyFromReg 0x219b660, 0x21c8160 [ORD=1] [ID=11]

          0x219b660: <multiple use>
          0x21c5e20: i64 = Register %vreg6 [ID=3]

            0x219b660: <multiple use>
            0x21c6320: i64 = Register %vreg4 [ID=1]

          0x21c6120: i64,ch = CopyFromReg 0x219b660, 0x21c6320 [ORD=1] [ID=10]

        0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1] [ID=12]

          0x219b660: <multiple use>
          0x21ca780: i64 = Register %vreg7 [ID=4]

          0x21c8a60: <multiple use>
        0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1] [ID=14]

      0x21c8860: ch = TokenFactor 0x21c8c60, 0x21c8260 [ORD=3] [ID=16]

      0x21c8560: ch = BasicBlock<while.end 0x21d0740> [ID=6]

      0x21c6220: i64 = Constant<4>

          0x21c8a60: <multiple use>
          0x21ca880: i64 = Constant<4294967295> [ID=9]

        0x21c6420: i64 = and 0x21c8a60, 0x21ca880 [ORD=1] [ID=13]

        0x21c6720: i64 = Constant<0> [ID=8]

      0x21c7f60: i64 = Cse523ISD::CMP 0x21c6420, 0x21c6720 [ORD=1]

    0x21ca980: ch = Cse523ISD::BRCOND 0x21c8860, 0x21c8560, 0x21c6220, 0x21c7f60 [ORD=3]

    0x21c8360: ch = BasicBlock<while.body 0x21d05d0> [ID=7]

  0x21c8b60: ch = br 0x21ca980, 0x21c8360 [ORD=3] [ID=18]


===== Instruction selection begins: BB#0 'entry'
Selecting:Opcode[146] 0x21c8b60: ch = br 0x21ca980, 0x21c8360 [ORD=3] [ID=18]

ISEL: Starting pattern match on root node: 0x21c8b60: ch = br 0x21ca980, 0x21c8360 [ORD=3] [ID=18]

  Initial Opcode index to 5420
  Morphed node: 0x21c8b60: ch = JMP_4 0x21c8360, 0x21ca980 [ORD=3]

ISEL: Match complete!
=> 0x21c8b60: ch = JMP_4 0x21c8360, 0x21ca980 [ORD=3]

Selecting:Opcode[210] 0x21ca980: ch = Cse523ISD::BRCOND 0x21c8860, 0x21c8560, 0x21c6220, 0x21c7f60 [ORD=3] [ID=17]

ISEL: Starting pattern match on root node: 0x21ca980: ch = Cse523ISD::BRCOND 0x21c8860, 0x21c8560, 0x21c6220, 0x21c7f60 [ORD=3] [ID=17]

  Initial Opcode index to 4241
  Skipped scope entry (due to false predicate) at index 4251, continuing at 4265
  Skipped scope entry (due to false predicate) at index 4266, continuing at 4280
  Skipped scope entry (due to false predicate) at index 4281, continuing at 4295
  Skipped scope entry (due to false predicate) at index 4296, continuing at 4310
  Morphed node: 0x21ca980: ch = JE_4 0x21c8560, 0x21c8960, 0x21c8960:1 [ORD=3]

ISEL: Match complete!
=> 0x21ca980: ch = JE_4 0x21c8560, 0x21c8960, 0x21c8960:1 [ORD=3]

Selecting:Opcode[2] 0x21c8860: ch = TokenFactor 0x21c8c60, 0x21c8260 [ORD=3] [ID=16]

=> 0x21c8860: ch = TokenFactor 0x21c8c60, 0x21c8260 [ORD=3]

Selecting:Opcode[200] 0x21c7f60: i64 = Cse523ISD::CMP 0x21c6420, 0x21c6720 [ORD=1] [ID=15]

ISEL: Starting pattern match on root node: 0x21c7f60: i64 = Cse523ISD::CMP 0x21c6420, 0x21c6720 [ORD=1] [ID=15]

  Initial Opcode index to 1961
  OpcodeSwitch from 1966 to 1970
  Match failed at index 1974
  Continuing at 2021
  Match failed at index 2031
  Continuing at 2052
  Morphed node: 0x21c7f60: i64 = TEST64rr 0x21c8a60, 0x21ca880 [ORD=1]

ISEL: Match complete!
=> 0x21c7f60: i64 = TEST64rr 0x21c8a60, 0x21ca880 [ORD=1]

Selecting:Opcode[39] 0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1] [ID=14]

=> 0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1]

Selecting:Opcode[39] 0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1] [ID=12]

=> 0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1]

Selecting:Opcode[40] 0x21c8a60: i64,ch = CopyFromReg 0x219b660, 0x21c8160 [ORD=1] [ID=11]

=> 0x21c8a60: i64,ch = CopyFromReg 0x219b660, 0x21c8160 [ORD=1]

Selecting:Opcode[40] 0x21c6120: i64,ch = CopyFromReg 0x219b660, 0x21c6320 [ORD=1] [ID=10]

=> 0x21c6120: i64,ch = CopyFromReg 0x219b660, 0x21c6320 [ORD=1]

Selecting:Opcode[10] 0x21ca880: i64 = Constant<4294967295> [ID=8]

ISEL: Starting pattern match on root node: 0x21ca880: i64 = Constant<4294967295> [ID=8]

  Initial Opcode index to 5298
  Skipped scope entry (due to false predicate) at index 5302, continuing at 5312
  Skipped scope entry (due to false predicate) at index 5316, continuing at 5328
  Morphed node: 0x21ca880: i64 = MOV64ri 0x21c6420

ISEL: Match complete!
=> 0x21ca880: i64 = MOV64ri 0x21c6420

Selecting:Opcode[5] 0x21c8360: ch = BasicBlock<while.body 0x21d05d0> [ID=6]

=> 0x21c8360: ch = BasicBlock<while.body 0x21d05d0>

Selecting:Opcode[5] 0x21c8560: ch = BasicBlock<while.end 0x21d0740> [ID=5]

=> 0x21c8560: ch = BasicBlock<while.end 0x21d0740>

Selecting:Opcode[8] 0x21ca780: i64 = Register %vreg7 [ID=4]

=> 0x21ca780: i64 = Register %vreg7

Selecting:Opcode[8] 0x21c5e20: i64 = Register %vreg6 [ID=3]

=> 0x21c5e20: i64 = Register %vreg6

Selecting:Opcode[8] 0x21c8160: i64 = Register %vreg5 [ID=2]

=> 0x21c8160: i64 = Register %vreg5

Selecting:Opcode[8] 0x21c6320: i64 = Register %vreg4 [ID=1]

=> 0x21c6320: i64 = Register %vreg4

Selecting:Opcode[1] 0x219b660: ch = EntryToken [ID=0]

=> 0x219b660: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'quantum_gcd:entry'
SelectionDAG has 19 nodes:
  0x219b660: ch = EntryToken

    0x219b660: <multiple use>
    0x21c8160: i64 = Register %vreg5

  0x21c8a60: i64,ch = CopyFromReg 0x219b660, 0x21c8160 [ORD=1]

        0x219b660: <multiple use>
        0x21c5e20: i64 = Register %vreg6

          0x219b660: <multiple use>
          0x21c6320: i64 = Register %vreg4

        0x21c6120: i64,ch = CopyFromReg 0x219b660, 0x21c6320 [ORD=1]

      0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1]

        0x219b660: <multiple use>
        0x21ca780: i64 = Register %vreg7

        0x21c8a60: <multiple use>
      0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1]

    0x21c8860: ch = TokenFactor 0x21c8c60, 0x21c8260 [ORD=3]

    0x21c7e60: i64 = Register %EFLAGS

      0x21c8a60: <multiple use>
        0x21c6420: i64 = TargetConstant<4294967295>

      0x21ca880: i64 = MOV64ri 0x21c6420

    0x21c7f60: i64 = TEST64rr 0x21c8a60, 0x21ca880 [ORD=1]

  0x21c8960: ch,glue = CopyToReg 0x21c8860, 0x21c7e60, 0x21c7f60 [ORD=3]

    0x21c8360: ch = BasicBlock<while.body 0x21d05d0>

      0x21c8560: ch = BasicBlock<while.end 0x21d0740>

      0x21c8960: <multiple use>
      0x21c8960: <multiple use>
    0x21ca980: ch = JE_4 0x21c8560, 0x21c8960, 0x21c8960:1 [ORD=3]

  0x21c8b60: ch = JMP_4 0x21c8360, 0x21ca980 [ORD=3]


********** List Scheduling BB#0 'entry' **********
SU(0): 0x21c8b60: ch = JMP_4 0x21c8360, 0x21ca980 [ORD=3] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x21ca980: ch = JE_4 0x21c8560, 0x21c8960, 0x21c8960:1 [ORD=3] [ID=1]

    0x21c8960: ch,glue = CopyToReg 0x21c8860, 0x21c7e60, 0x21c7f60 [ORD=3] [ID=1]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
   ch  SU(5): Latency=0
   val SU(2): Latency=1 Reg=%EFLAGS
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x21c7f60: i64 = TEST64rr 0x21c8a60, 0x21ca880 [ORD=1] [ID=2]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(4): Latency=1
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1 Reg=%EFLAGS

SU(3): 0x21ca880: i64 = MOV64ri 0x21c6420 [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(2): Latency=1

SU(4): 0x21c8a60: i64,ch = CopyFromReg 0x219b660, 0x21c8160 [ORD=1] [ID=4]

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(2): Latency=1
   val SU(6): Latency=1

SU(5): 0x21c8860: ch = TokenFactor 0x21c8c60, 0x21c8260 [ORD=3] [ID=5]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 1
  Predecessors:
   ch  SU(7): Latency=1
   ch  SU(6): Latency=1
  Successors:
   ch  SU(1): Latency=0

SU(6): 0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1] [ID=6]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(4): Latency=1
  Successors:
   ch  SU(5): Latency=1

SU(7): 0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1] [ID=7]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(8): Latency=1
  Successors:
   ch  SU(5): Latency=1

SU(8): 0x21c6120: i64,ch = CopyFromReg 0x219b660, 0x21c6320 [ORD=1] [ID=8]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(7): Latency=1


Examining Available:
Height 0: SU(0): 0x21c8b60: ch = JMP_4 0x21c8360, 0x21ca980 [ORD=3] [ID=0]


*** Scheduling [0]: SU(0): 0x21c8b60: ch = JMP_4 0x21c8360, 0x21ca980 [ORD=3] [ID=0]


Examining Available:
Height 1: SU(1): 0x21ca980: ch = JE_4 0x21c8560, 0x21c8960, 0x21c8960:1 [ORD=3] [ID=1]

    0x21c8960: ch,glue = CopyToReg 0x21c8860, 0x21c7e60, 0x21c7f60 [ORD=3] [ID=1]


*** Scheduling [1]: SU(1): 0x21ca980: ch = JE_4 0x21c8560, 0x21c8960, 0x21c8960:1 [ORD=3] [ID=1]

    0x21c8960: ch,glue = CopyToReg 0x21c8860, 0x21c7e60, 0x21c7f60 [ORD=3] [ID=1]


Examining Available:
Height 1: SU(5): 0x21c8860: ch = TokenFactor 0x21c8c60, 0x21c8260 [ORD=3] [ID=5]

Height 2: SU(2): 0x21c7f60: i64 = TEST64rr 0x21c8a60, 0x21ca880 [ORD=1] [ID=2]


*** Scheduling [2]: SU(5): 0x21c8860: ch = TokenFactor 0x21c8c60, 0x21c8260 [ORD=3] [ID=5]


Examining Available:
  SU (2)  defines a physreg SU(7)  has no physreg
  SU (2)  defines a physreg SU(6)  has no physreg
Height 2: SU(2): 0x21c7f60: i64 = TEST64rr 0x21c8a60, 0x21ca880 [ORD=1] [ID=2]

Height 3: SU(7): 0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1] [ID=7]

Height 3: SU(6): 0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1] [ID=6]

  SU (2)  defines a physreg SU(7)  has no physreg
  SU (2)  defines a physreg SU(6)  has no physreg

*** Scheduling [3]: SU(2): 0x21c7f60: i64 = TEST64rr 0x21c8a60, 0x21ca880 [ORD=1] [ID=2]


Examining Available:
Height 4: SU(3): 0x21ca880: i64 = MOV64ri 0x21c6420 [ID=3]

Height 3: SU(7): 0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1] [ID=7]

Height 3: SU(6): 0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1] [ID=6]


*** Scheduling [4]: SU(3): 0x21ca880: i64 = MOV64ri 0x21c6420 [ID=3]


Examining Available:
Height 3: SU(7): 0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1] [ID=7]

Height 3: SU(6): 0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1] [ID=6]


*** Scheduling [5]: SU(7): 0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1] [ID=7]


Examining Available:
Height 6: SU(8): 0x21c6120: i64,ch = CopyFromReg 0x219b660, 0x21c6320 [ORD=1] [ID=8]

Height 3: SU(6): 0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1] [ID=6]


*** Scheduling [6]: SU(8): 0x21c6120: i64,ch = CopyFromReg 0x219b660, 0x21c6320 [ORD=1] [ID=8]


Examining Available:
Height 3: SU(6): 0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1] [ID=6]


*** Scheduling [7]: SU(6): 0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1] [ID=6]


Examining Available:
Height 8: SU(4): 0x21c8a60: i64,ch = CopyFromReg 0x219b660, 0x21c8160 [ORD=1] [ID=4]


*** Scheduling [8]: SU(4): 0x21c8a60: i64,ch = CopyFromReg 0x219b660, 0x21c8160 [ORD=1] [ID=4]

*** Final schedule ***
SU(4): 0x21c8a60: i64,ch = CopyFromReg 0x219b660, 0x21c8160 [ORD=1] [ID=4]

SU(6): 0x21c8260: ch = CopyToReg 0x219b660, 0x21ca780, 0x21c8a60 [ORD=1] [ID=6]

SU(8): 0x21c6120: i64,ch = CopyFromReg 0x219b660, 0x21c6320 [ORD=1] [ID=8]

SU(7): 0x21c8c60: ch = CopyToReg 0x219b660, 0x21c5e20, 0x21c6120 [ORD=1] [ID=7]

SU(3): 0x21ca880: i64 = MOV64ri 0x21c6420 [ID=3]

SU(2): 0x21c7f60: i64 = TEST64rr 0x21c8a60, 0x21ca880 [ORD=1] [ID=2]

SU(5): 0x21c8860: ch = TokenFactor 0x21c8c60, 0x21c8260 [ORD=3] [ID=5]

SU(1): 0x21ca980: ch = JE_4 0x21c8560, 0x21c8960, 0x21c8960:1 [ORD=3] [ID=1]

    0x21c8960: ch,glue = CopyToReg 0x21c8860, 0x21c7e60, 0x21c7f60 [ORD=3] [ID=1]

SU(0): 0x21c8b60: ch = JMP_4 0x21c8360, 0x21ca980 [ORD=3] [ID=0]


Total amount of phi nodes to update: 3
Node 0 : (0x21d07f0, 2147483654)
Node 1 : (0x21d0680, 2147483654)
Node 2 : (0x21d06e0, 2147483655)
Initial selection DAG: BB#1 'quantum_gcd:while.body'
SelectionDAG has 20 nodes:
  0x219b660: ch = EntryToken

        0x219b660: <multiple use>
        0x21c6420: i64 = Register %vreg0

      0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2]

    0x21c7e60: i32 = truncate 0x21c8960 [ORD=2]

        0x219b660: <multiple use>
        0x21c8b60: i64 = Register %vreg1

      0x21ca980: i64,ch = CopyFromReg 0x219b660, 0x21c8b60 [ORD=2]

    0x21c8860: i32 = truncate 0x21ca980 [ORD=2]

  0x21c7f60: i32 = srem 0x21c7e60, 0x21c8860 [ORD=2]

        0x219b660: <multiple use>
        0x21c8c60: i64 = Register %vreg2

          0x21c7f60: <multiple use>
        0x21c8260: i64 = any_extend 0x21c7f60 [ORD=2]

      0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c8260 [ORD=2]

          0x21c7f60: <multiple use>
          0x21c6120: i32 = Constant<0>

          0x21ca880: ch = seteq

        0x21c8360: i1 = setcc 0x21c7f60, 0x21c6120, 0x21ca880 [ORD=3]

        0x21c8560: i1 = Constant<-1>

      0x21ca780: i1 = xor 0x21c8360, 0x21c8560 [ORD=4]

      0x21c5e20: ch = BasicBlock<while.body 0x21d05d0>

    0x21c8160: ch = brcond 0x21c8a60, 0x21ca780, 0x21c5e20 [ORD=4]

    0x21c6320: ch = BasicBlock<while.end 0x21d0740>

  0x21c6720: ch = br 0x21c8160, 0x21c6320 [ORD=4]



Replacing.3 0x21ca780: i1 = xor 0x21c8360, 0x21c8560 [ORD=4]

With: 0x21ca480: i1 = setcc 0x21c7f60, 0x21c6120, 0x21c6220 [ORD=4]

Optimized lowered selection DAG: BB#1 'quantum_gcd:while.body'
SelectionDAG has 18 nodes:
  0x219b660: ch = EntryToken

        0x219b660: <multiple use>
        0x21c6420: i64 = Register %vreg0

      0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2]

    0x21c7e60: i32 = truncate 0x21c8960 [ORD=2]

        0x219b660: <multiple use>
        0x21c8b60: i64 = Register %vreg1

      0x21ca980: i64,ch = CopyFromReg 0x219b660, 0x21c8b60 [ORD=2]

    0x21c8860: i32 = truncate 0x21ca980 [ORD=2]

  0x21c7f60: i32 = srem 0x21c7e60, 0x21c8860 [ORD=2]

        0x219b660: <multiple use>
        0x21c8c60: i64 = Register %vreg2

          0x21c7f60: <multiple use>
        0x21c8260: i64 = any_extend 0x21c7f60 [ORD=2]

      0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c8260 [ORD=2]

        0x21c7f60: <multiple use>
        0x21c6120: i32 = Constant<0>

        0x21c6220: ch = setne

      0x21ca480: i1 = setcc 0x21c7f60, 0x21c6120, 0x21c6220 [ORD=4]

      0x21c5e20: ch = BasicBlock<while.body 0x21d05d0>

    0x21c8160: ch = brcond 0x21c8a60, 0x21ca480, 0x21c5e20 [ORD=4]

    0x21c6320: ch = BasicBlock<while.end 0x21d0740>

  0x21c6720: ch = br 0x21c8160, 0x21c6320 [ORD=4]


Legally typed node: 0x21c6220: ch = setne [ID=0]

Legally typed node: 0x21c6320: ch = BasicBlock<while.end 0x21d0740> [ID=0]

Legally typed node: 0x21c5e20: ch = BasicBlock<while.body 0x21d05d0> [ID=0]

Promote integer result: 0x21c6120: i32 = Constant<0> [ID=0]

Legally typed node: 0x21ca880: i64 = Constant<0> [ID=0]

Legally typed node: 0x21c8c60: i64 = Register %vreg2 [ID=0]

Legally typed node: 0x21c8b60: i64 = Register %vreg1 [ID=0]

Legally typed node: 0x21c6420: i64 = Register %vreg0 [ID=0]

Legally typed node: 0x219b660: ch = EntryToken [ID=0]

Legally typed node: 0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2] [ID=0]

Promote integer result: 0x21c7e60: i32 = truncate 0x21c8960 [ORD=2] [ID=0]

Legally typed node: 0x21ca980: i64,ch = CopyFromReg 0x219b660, 0x21c8b60 [ORD=2] [ID=0]

Promote integer result: 0x21c8860: i32 = truncate 0x21ca980 [ORD=2] [ID=0]

Promote integer result: 0x21c7f60: i32 = srem 0x21c7e60, 0x21c8860 [ORD=2] [ID=0]

Promote integer operand: 0x21c8260: i64 = any_extend 0x21c7f60 [ORD=2] [ID=0]

Promote integer result: 0x21ca480: i1 = setcc 0x21c7f60, 0x21c6120, 0x21c6220 [ORD=4] [ID=0]

Promote integer operand: 0x21caa80: i64 = setcc 0x21c7f60, 0x21c6120, 0x21c6220 [ORD=4] [ID=0]

Legally typed node: 0x21c8060: i64 = Constant<4294967295> [ID=0]

Legally typed node: 0x21c8360: ch = ValueType:i32 [ID=0]

Legally typed node: 0x21c8560: i64 = sign_extend_inreg 0x21c8960, 0x21c8360 [ORD=2] [ID=0]

Legally typed node: 0x21ca780: i64 = sign_extend_inreg 0x21ca980, 0x21c8360 [ORD=2] [ID=0]

Legally typed node: 0x21c5f20: i64 = srem 0x21c8560, 0x21ca780 [ORD=2] [ID=0]

Legally typed node: 0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c5f20 [ORD=2] [ID=0]

Promote integer operand: 0x21c8160: ch = brcond 0x21c8a60, 0x21ca480, 0x21c5e20 [ORD=4] [ID=0]

Promote integer operand: 0x21c6920: i64 = zero_extend 0x21ca480 [ORD=4] [ID=0]

Legally typed node: 0x21c8460: i64 = Constant<1> [ID=0]

Legally typed node: 0x21c6820: i64 = and 0x21c5f20, 0x21c8060 [ORD=2] [ID=0]

Legally typed node: 0x21caa80: i64 = setcc 0x21c6820, 0x21ca880, 0x21c6220 [ORD=4] [ID=0]

Legally typed node: 0x21ca580: i64 = and 0x21caa80, 0x21c8460 [ORD=4] [ID=0]

Legally typed node: 0x21c8160: ch = brcond 0x21c8a60, 0x21ca580, 0x21c5e20 [ORD=4] [ID=0]

Legally typed node: 0x21c6720: ch = br 0x21c8160, 0x21c6320 [ORD=4] [ID=0]

Legally typed node: 0x7fff16596d20: ch = handlenode 0x21c6720 [ID=0]

Type-legalized selection DAG: BB#1 'quantum_gcd:while.body'
SelectionDAG has 22 nodes:
  0x219b660: ch = EntryToken [ID=-3]

  0x21c8360: ch = ValueType:i32 [ID=-3]

        0x219b660: <multiple use>
        0x21c6420: i64 = Register %vreg0 [ID=-3]

      0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2] [ID=-3]

      0x21c8360: <multiple use>
    0x21c8560: i64 = sign_extend_inreg 0x21c8960, 0x21c8360 [ORD=2] [ID=-3]

        0x219b660: <multiple use>
        0x21c8b60: i64 = Register %vreg1 [ID=-3]

      0x21ca980: i64,ch = CopyFromReg 0x219b660, 0x21c8b60 [ORD=2] [ID=-3]

      0x21c8360: <multiple use>
    0x21ca780: i64 = sign_extend_inreg 0x21ca980, 0x21c8360 [ORD=2] [ID=-3]

  0x21c5f20: i64 = srem 0x21c8560, 0x21ca780 [ORD=2] [ID=-3]

        0x219b660: <multiple use>
        0x21c8c60: i64 = Register %vreg2 [ID=-3]

        0x21c5f20: <multiple use>
      0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c5f20 [ORD=2] [ID=-3]

            0x21c5f20: <multiple use>
            0x21c8060: i64 = Constant<4294967295> [ID=-3]

          0x21c6820: i64 = and 0x21c5f20, 0x21c8060 [ORD=2] [ID=-3]

          0x21ca880: i64 = Constant<0> [ID=-3]

          0x21c6220: ch = setne [ID=-3]

        0x21caa80: i64 = setcc 0x21c6820, 0x21ca880, 0x21c6220 [ORD=4] [ID=-3]

        0x21c8460: i64 = Constant<1> [ID=-3]

      0x21ca580: i64 = and 0x21caa80, 0x21c8460 [ORD=4] [ID=-3]

      0x21c5e20: ch = BasicBlock<while.body 0x21d05d0> [ID=-3]

    0x21c8160: ch = brcond 0x21c8a60, 0x21ca580, 0x21c5e20 [ORD=4] [ID=-3]

    0x21c6320: ch = BasicBlock<while.end 0x21d0740> [ID=-3]

  0x21c6720: ch = br 0x21c8160, 0x21c6320 [ORD=4] [ID=-3]



Replacing.2 0x21ca580: i64 = and 0x21caa80, 0x21c8460 [ORD=4] [ID=-3]

With: 0x21caa80: i64 = setcc 0x21c6820, 0x21ca880, 0x21c6220 [ORD=4] [ID=-3]

Optimized type-legalized selection DAG: BB#1 'quantum_gcd:while.body'
SelectionDAG has 20 nodes:
  0x219b660: ch = EntryToken [ID=-3]

  0x21c8360: ch = ValueType:i32 [ID=-3]

        0x219b660: <multiple use>
        0x21c6420: i64 = Register %vreg0 [ID=-3]

      0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2] [ID=-3]

      0x21c8360: <multiple use>
    0x21c8560: i64 = sign_extend_inreg 0x21c8960, 0x21c8360 [ORD=2] [ID=-3]

        0x219b660: <multiple use>
        0x21c8b60: i64 = Register %vreg1 [ID=-3]

      0x21ca980: i64,ch = CopyFromReg 0x219b660, 0x21c8b60 [ORD=2] [ID=-3]

      0x21c8360: <multiple use>
    0x21ca780: i64 = sign_extend_inreg 0x21ca980, 0x21c8360 [ORD=2] [ID=-3]

  0x21c5f20: i64 = srem 0x21c8560, 0x21ca780 [ORD=2] [ID=-3]

        0x219b660: <multiple use>
        0x21c8c60: i64 = Register %vreg2 [ID=-3]

        0x21c5f20: <multiple use>
      0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c5f20 [ORD=2] [ID=-3]

          0x21c5f20: <multiple use>
          0x21c8060: i64 = Constant<4294967295> [ID=-3]

        0x21c6820: i64 = and 0x21c5f20, 0x21c8060 [ORD=2] [ID=-3]

        0x21ca880: i64 = Constant<0> [ID=-3]

        0x21c6220: ch = setne [ID=-3]

      0x21caa80: i64 = setcc 0x21c6820, 0x21ca880, 0x21c6220 [ORD=4] [ID=-3]

      0x21c5e20: ch = BasicBlock<while.body 0x21d05d0> [ID=-3]

    0x21c8160: ch = brcond 0x21c8a60, 0x21caa80, 0x21c5e20 [ORD=4] [ID=-3]

    0x21c6320: ch = BasicBlock<while.end 0x21d0740> [ID=-3]

  0x21c6720: ch = br 0x21c8160, 0x21c6320 [ORD=4] [ID=-3]


Legalized selection DAG: BB#1 'quantum_gcd:while.body'
SelectionDAG has 22 nodes:
  0x219b660: ch = EntryToken [ID=0]

          0x219b660: <multiple use>
          0x21c6420: i64 = Register %vreg0 [ID=1]

        0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2] [ID=10]

        0x21c5f20: <multiple use>
      0x21ca780: i64 = shl 0x21c8960, 0x21c5f20 [ORD=2]

      0x21c5f20: <multiple use>
    0x21c7f60: i64 = sra 0x21ca780, 0x21c5f20 [ORD=2]

          0x219b660: <multiple use>
          0x21c8b60: i64 = Register %vreg1 [ID=2]

        0x21ca980: i64,ch = CopyFromReg 0x219b660, 0x21c8b60 [ORD=2] [ID=11]

        0x21c5f20: <multiple use>
      0x21caa80: i64 = shl 0x21ca980, 0x21c5f20 [ORD=2]

      0x21c5f20: <multiple use>
    0x21c8160: i64 = sra 0x21caa80, 0x21c5f20 [ORD=2]

  0x21c6220: i64,i64 = sdivrem 0x21c7f60, 0x21c8160 [ORD=2]

  0x21c5f20: i64 = Constant<32>

        0x219b660: <multiple use>
        0x21c8c60: i64 = Register %vreg2 [ID=3]

        0x21c6220: <multiple use>
      0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c6220:1 [ORD=2] [ID=16]

      0x21c5e20: ch = BasicBlock<while.body 0x21d05d0> [ID=4]

      0x21ca580: i64 = Constant<9>

          0x21c6220: <multiple use>
          0x21c8060: i64 = Constant<4294967295> [ID=9]

        0x21c6820: i64 = and 0x21c6220:1, 0x21c8060 [ORD=2] [ID=15]

        0x21ca880: i64 = Constant<0> [ID=7]

      0x21c8460: i64 = Cse523ISD::CMP 0x21c6820, 0x21ca880 [ORD=2]

    0x21c8860: ch = Cse523ISD::BRCOND 0x21c8a60, 0x21c5e20, 0x21ca580, 0x21c8460 [ORD=4]

    0x21c6320: ch = BasicBlock<while.end 0x21d0740> [ID=5]

  0x21c6720: ch = br 0x21c8860, 0x21c6320 [ORD=4] [ID=19]


Optimized legalized selection DAG: BB#1 'quantum_gcd:while.body'
SelectionDAG has 22 nodes:
  0x219b660: ch = EntryToken [ID=0]

          0x219b660: <multiple use>
          0x21c6420: i64 = Register %vreg0 [ID=1]

        0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2] [ID=10]

        0x21c5f20: <multiple use>
      0x21ca780: i64 = shl 0x21c8960, 0x21c5f20 [ORD=2]

      0x21c5f20: <multiple use>
    0x21c7f60: i64 = sra 0x21ca780, 0x21c5f20 [ORD=2]

          0x219b660: <multiple use>
          0x21c8b60: i64 = Register %vreg1 [ID=2]

        0x21ca980: i64,ch = CopyFromReg 0x219b660, 0x21c8b60 [ORD=2] [ID=11]

        0x21c5f20: <multiple use>
      0x21caa80: i64 = shl 0x21ca980, 0x21c5f20 [ORD=2]

      0x21c5f20: <multiple use>
    0x21c8160: i64 = sra 0x21caa80, 0x21c5f20 [ORD=2]

  0x21c6220: i64,i64 = sdivrem 0x21c7f60, 0x21c8160 [ORD=2]

  0x21c5f20: i64 = Constant<32>

        0x219b660: <multiple use>
        0x21c8c60: i64 = Register %vreg2 [ID=3]

        0x21c6220: <multiple use>
      0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c6220:1 [ORD=2] [ID=16]

      0x21c5e20: ch = BasicBlock<while.body 0x21d05d0> [ID=4]

      0x21ca580: i64 = Constant<9>

          0x21c6220: <multiple use>
          0x21c8060: i64 = Constant<4294967295> [ID=9]

        0x21c6820: i64 = and 0x21c6220:1, 0x21c8060 [ORD=2] [ID=15]

        0x21ca880: i64 = Constant<0> [ID=7]

      0x21c8460: i64 = Cse523ISD::CMP 0x21c6820, 0x21ca880 [ORD=2]

    0x21c8860: ch = Cse523ISD::BRCOND 0x21c8a60, 0x21c5e20, 0x21ca580, 0x21c8460 [ORD=4]

    0x21c6320: ch = BasicBlock<while.end 0x21d0740> [ID=5]

  0x21c6720: ch = br 0x21c8860, 0x21c6320 [ORD=4] [ID=19]


===== Instruction selection begins: BB#1 'while.body'
Selecting:Opcode[146] 0x21c6720: ch = br 0x21c8860, 0x21c6320 [ORD=4] [ID=21]

ISEL: Starting pattern match on root node: 0x21c6720: ch = br 0x21c8860, 0x21c6320 [ORD=4] [ID=21]

  Initial Opcode index to 5420
  Morphed node: 0x21c6720: ch = JMP_4 0x21c6320, 0x21c8860 [ORD=4]

ISEL: Match complete!
=> 0x21c6720: ch = JMP_4 0x21c6320, 0x21c8860 [ORD=4]

Selecting:Opcode[210] 0x21c8860: ch = Cse523ISD::BRCOND 0x21c8a60, 0x21c5e20, 0x21ca580, 0x21c8460 [ORD=4] [ID=20]

ISEL: Starting pattern match on root node: 0x21c8860: ch = Cse523ISD::BRCOND 0x21c8a60, 0x21c5e20, 0x21ca580, 0x21c8460 [ORD=4] [ID=20]

  Initial Opcode index to 4241
  Skipped scope entry (due to false predicate) at index 4251, continuing at 4265
  Skipped scope entry (due to false predicate) at index 4266, continuing at 4280
  Skipped scope entry (due to false predicate) at index 4281, continuing at 4295
  Skipped scope entry (due to false predicate) at index 4296, continuing at 4310
  Skipped scope entry (due to false predicate) at index 4311, continuing at 4325
  Morphed node: 0x21c8860: ch = JNE_4 0x21c5e20, 0x21c8360, 0x21c8360:1 [ORD=4]

ISEL: Match complete!
=> 0x21c8860: ch = JNE_4 0x21c5e20, 0x21c8360, 0x21c8360:1 [ORD=4]

Selecting:Opcode[200] 0x21c8460: i64 = Cse523ISD::CMP 0x21c6820, 0x21ca880 [ORD=2] [ID=19]

ISEL: Starting pattern match on root node: 0x21c8460: i64 = Cse523ISD::CMP 0x21c6820, 0x21ca880 [ORD=2] [ID=19]

  Initial Opcode index to 1961
  OpcodeSwitch from 1966 to 1970
  Match failed at index 1974
  Continuing at 2021
  Match failed at index 2031
  Continuing at 2052
  Morphed node: 0x21c8460: i64 = TEST64rr 0x21c6220:1, 0x21c8060 [ORD=2]

ISEL: Match complete!
=> 0x21c8460: i64 = TEST64rr 0x21c6220:1, 0x21c8060 [ORD=2]

Selecting:Opcode[39] 0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c6220:1 [ORD=2] [ID=17]

=> 0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c6220:1 [ORD=2]

Selecting:Opcode[54] 0x21c6220: i64,i64 = sdivrem 0x21c7f60, 0x21c8160 [ORD=2] [ID=16]

=> 0x21c6120: i64,ch,glue = CopyFromReg 0x219b660, 0x21c8260, 0x21c8560 [ORD=2]

Selecting:Opcode[89] 0x21c8160: i64 = sra 0x21caa80, 0x21c5f20 [ORD=2] [ID=15]

ISEL: Starting pattern match on root node: 0x21c8160: i64 = sra 0x21caa80, 0x21c5f20 [ORD=2] [ID=15]

  Initial Opcode index to 4560
  Skipped scope entry (due to false predicate) at index 4563, continuing at 4578
  Match failed at index 4587
  Continuing at 4604
  Morphed node: 0x21c8160: i64,i64 = SAR64rCL 0x21caa80, 0x21ca480:1 [ORD=2]

ISEL: Match complete!
=> 0x21c8160: i64,i64 = SAR64rCL 0x21caa80, 0x21ca480:1 [ORD=2]

Selecting:Opcode[89] 0x21c7f60: i64 = sra 0x21ca780, 0x21c5f20 [ORD=2] [ID=14]

ISEL: Starting pattern match on root node: 0x21c7f60: i64 = sra 0x21ca780, 0x21c5f20 [ORD=2] [ID=14]

  Initial Opcode index to 4560
  Skipped scope entry (due to false predicate) at index 4563, continuing at 4578
  Match failed at index 4587
  Continuing at 4604
  Morphed node: 0x21c7f60: i64,i64 = SAR64rCL 0x21ca780, 0x21c6920:1 [ORD=2]

ISEL: Match complete!
=> 0x21c7f60: i64,i64 = SAR64rCL 0x21ca780, 0x21c6920:1 [ORD=2]

Selecting:Opcode[88] 0x21caa80: i64 = shl 0x21ca980, 0x21c5f20 [ORD=2] [ID=13]

ISEL: Starting pattern match on root node: 0x21caa80: i64 = shl 0x21ca980, 0x21c5f20 [ORD=2] [ID=13]

  Initial Opcode index to 3829
MatchAddress: Cse523ISelAddressMode 0x7fff16596820
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV <commented> nul CP nul
ES nul JT-1 Align0
  Match failed at index 3834
  Continuing at 3849
  Match failed at index 3855
  Continuing at 3884
  Match failed at index 3885
  Continuing at 3901
  Match failed at index 3910
  Continuing at 3927
  Morphed node: 0x21caa80: i64,i64 = SHL64rCL 0x21ca980, 0x21c8660:1 [ORD=2]

ISEL: Match complete!
=> 0x21caa80: i64,i64 = SHL64rCL 0x21ca980, 0x21c8660:1 [ORD=2]

Selecting:Opcode[88] 0x21ca780: i64 = shl 0x21c8960, 0x21c5f20 [ORD=2] [ID=12]

ISEL: Starting pattern match on root node: 0x21ca780: i64 = shl 0x21c8960, 0x21c5f20 [ORD=2] [ID=12]

  Initial Opcode index to 3829
MatchAddress: Cse523ISelAddressMode 0x7fff16596820
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV <commented> nul CP nul
ES nul JT-1 Align0
  Match failed at index 3834
  Continuing at 3849
  Match failed at index 3855
  Continuing at 3884
  Match failed at index 3885
  Continuing at 3901
  Match failed at index 3910
  Continuing at 3927
  Morphed node: 0x21ca780: i64,i64 = SHL64rCL 0x21c8960, 0x21c8760:1 [ORD=2]

ISEL: Match complete!
=> 0x21ca780: i64,i64 = SHL64rCL 0x21c8960, 0x21c8760:1 [ORD=2]

Selecting:Opcode[40] 0x21ca980: i64,ch = CopyFromReg 0x219b660, 0x21c8b60 [ORD=2] [ID=11]

=> 0x21ca980: i64,ch = CopyFromReg 0x219b660, 0x21c8b60 [ORD=2]

Selecting:Opcode[40] 0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2] [ID=10]

=> 0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2]

Selecting:Opcode[10] 0x21c5f20: i64 = Constant<32> [ID=9]

ISEL: Starting pattern match on root node: 0x21c5f20: i64 = Constant<32> [ID=9]

  Initial Opcode index to 5298
  Skipped scope entry (due to false predicate) at index 5302, continuing at 5312
  Morphed node: 0x21c5f20: i64 = MOV64ri32 0x21c6520

ISEL: Match complete!
=> 0x21c5f20: i64 = MOV64ri32 0x21c6520

Selecting:Opcode[10] 0x21c8060: i64 = Constant<4294967295> [ID=7]

ISEL: Starting pattern match on root node: 0x21c8060: i64 = Constant<4294967295> [ID=7]

  Initial Opcode index to 5298
  Skipped scope entry (due to false predicate) at index 5302, continuing at 5312
  Skipped scope entry (due to false predicate) at index 5316, continuing at 5328
  Morphed node: 0x21c8060: i64 = MOV64ri 0x21c6020

ISEL: Match complete!
=> 0x21c8060: i64 = MOV64ri 0x21c6020

Selecting:Opcode[5] 0x21c6320: ch = BasicBlock<while.end 0x21d0740> [ID=5]

=> 0x21c6320: ch = BasicBlock<while.end 0x21d0740>

Selecting:Opcode[5] 0x21c5e20: ch = BasicBlock<while.body 0x21d05d0> [ID=4]

=> 0x21c5e20: ch = BasicBlock<while.body 0x21d05d0>

Selecting:Opcode[8] 0x21c8c60: i64 = Register %vreg2 [ID=3]

=> 0x21c8c60: i64 = Register %vreg2

Selecting:Opcode[8] 0x21c8b60: i64 = Register %vreg1 [ID=2]

=> 0x21c8b60: i64 = Register %vreg1

Selecting:Opcode[8] 0x21c6420: i64 = Register %vreg0 [ID=1]

=> 0x21c6420: i64 = Register %vreg0

Selecting:Opcode[1] 0x219b660: ch = EntryToken [ID=0]

=> 0x219b660: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#1 'quantum_gcd:while.body'
SelectionDAG has 35 nodes:
  0x219b660: ch = EntryToken

    0x21c6520: i64 = TargetConstant<32>

  0x21c5f20: i64 = MOV64ri32 0x21c6520

      0x219b660: <multiple use>
      0x21c8c60: i64 = Register %vreg2

      0x21c6120: <multiple use>
    0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c6120 [ORD=2]

    0x21c7e60: i64 = Register %EFLAGS

      0x21c6120: <multiple use>
        0x21c6020: i64 = TargetConstant<4294967295>

      0x21c8060: i64 = MOV64ri 0x21c6020

    0x21c8460: i64 = TEST64rr 0x21c6120, 0x21c8060 [ORD=2]

  0x21c8360: ch,glue = CopyToReg 0x21c8a60, 0x21c7e60, 0x21c8460 [ORD=4]

    0x219b660: <multiple use>
    0x21c8260: i64 = Register %RDX

            0x219b660: <multiple use>
            0x21c8b60: i64 = Register %vreg1

          0x21ca980: i64,ch = CopyFromReg 0x219b660, 0x21c8b60 [ORD=2]

            0x219b660: <multiple use>
            0x21c6220: <multiple use>
            0x21c5f20: <multiple use>
          0x21c8660: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2]

        0x21caa80: i64,i64 = SHL64rCL 0x21ca980, 0x21c8660:1 [ORD=2]

          0x219b660: <multiple use>
          0x21c6220: <multiple use>
          0x21c5f20: <multiple use>
        0x21ca480: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2]

      0x21c8160: i64,i64 = SAR64rCL 0x21caa80, 0x21ca480:1 [ORD=2]

          0x219b660: <multiple use>
          0x21c6820: i64 = Register %RAX

                0x219b660: <multiple use>
                0x21c6420: i64 = Register %vreg0

              0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2]

                0x219b660: <multiple use>
                0x21c6220: <multiple use>
                0x21c5f20: <multiple use>
              0x21c8760: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2]

            0x21ca780: i64,i64 = SHL64rCL 0x21c8960, 0x21c8760:1 [ORD=2]

              0x219b660: <multiple use>
              0x21c6220: <multiple use>
              0x21c5f20: <multiple use>
            0x21c6920: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2]

          0x21c7f60: i64,i64 = SAR64rCL 0x21ca780, 0x21c6920:1 [ORD=2]

        0x21ca880: ch,glue = CopyToReg 0x219b660, 0x21c6820, 0x21c7f60 [ORD=2]

      0x21ca580: glue = CQO 0x21ca880:1 [ORD=2]

    0x21c8560: glue = IDIV64r 0x21c8160, 0x21ca580 [ORD=2]

  0x21c6120: i64,ch,glue = CopyFromReg 0x219b660, 0x21c8260, 0x21c8560 [ORD=2]

  0x21c6220: i64 = Register %RCX

  0x21c6a20: i32 = Register %noreg

  0x21c6620: i64 = Register %noreg

    0x21c6320: ch = BasicBlock<while.end 0x21d0740>

      0x21c5e20: ch = BasicBlock<while.body 0x21d05d0>

      0x21c8360: <multiple use>
      0x21c8360: <multiple use>
    0x21c8860: ch = JNE_4 0x21c5e20, 0x21c8360, 0x21c8360:1 [ORD=4]

  0x21c6720: ch = JMP_4 0x21c6320, 0x21c8860 [ORD=4]


********** List Scheduling BB#1 'while.body' **********
SU(0): 0x21c6720: ch = JMP_4 0x21c6320, 0x21c8860 [ORD=4] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x21c8860: ch = JNE_4 0x21c5e20, 0x21c8360, 0x21c8360:1 [ORD=4] [ID=1]

    0x21c8360: ch,glue = CopyToReg 0x21c8a60, 0x21c7e60, 0x21c8460 [ORD=4] [ID=1]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
   ch  SU(12): Latency=1
   val SU(2): Latency=1 Reg=%EFLAGS
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x21c8460: i64 = TEST64rr 0x21c6120, 0x21c8060 [ORD=2] [ID=2]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
   val SU(4): Latency=1
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1 Reg=%EFLAGS

SU(3): 0x21c8060: i64 = MOV64ri 0x21c6020 [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(2): Latency=1

SU(4): 0x21c6120: i64,ch,glue = CopyFromReg 0x219b660, 0x21c8260, 0x21c8560 [ORD=2] [ID=4]

    0x21ca880: ch,glue = CopyToReg 0x219b660, 0x21c6820, 0x21c7f60 [ORD=2] [ID=4]

    0x21ca580: glue = CQO 0x21ca880:1 [ORD=2] [ID=4]

    0x21c8560: glue = IDIV64r 0x21c8160, 0x21ca580 [ORD=2] [ID=4]

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
   val SU(9): Latency=1
   val SU(5): Latency=1
  Successors:
   val SU(2): Latency=1
   val SU(12): Latency=1

SU(5): 0x21c7f60: i64,i64 = SAR64rCL 0x21ca780, 0x21c6920:1 [ORD=2] [ID=5]

    0x21c6920: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=5]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
   val SU(7): Latency=1
   val SU(6): Latency=1
  Successors:
   val SU(4): Latency=1

SU(6): 0x21c5f20: i64 = MOV64ri32 0x21c6520 [ID=6]

  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(5): Latency=1
   val SU(7): Latency=1
   val SU(9): Latency=1
   val SU(10): Latency=1

SU(7): 0x21ca780: i64,i64 = SHL64rCL 0x21c8960, 0x21c8760:1 [ORD=2] [ID=7]

    0x21c8760: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=7]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(8): Latency=1
   val SU(6): Latency=1
  Successors:
   val SU(5): Latency=1

SU(8): 0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2] [ID=8]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(7): Latency=1

SU(9): 0x21c8160: i64,i64 = SAR64rCL 0x21caa80, 0x21ca480:1 [ORD=2] [ID=9]

    0x21ca480: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=9]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
   val SU(10): Latency=1
   val SU(6): Latency=1
  Successors:
   val SU(4): Latency=1

SU(10): 0x21caa80: i64,i64 = SHL64rCL 0x21ca980, 0x21c8660:1 [ORD=2] [ID=10]

    0x21c8660: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=10]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(11): Latency=1
   val SU(6): Latency=1
  Successors:
   val SU(9): Latency=1

SU(11): 0x21ca980: i64,ch = CopyFromReg 0x219b660, 0x21c8b60 [ORD=2] [ID=11]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(10): Latency=1

SU(12): 0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c6120 [ORD=2] [ID=12]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
   val SU(4): Latency=1
  Successors:
   ch  SU(1): Latency=1


Examining Available:
Height 0: SU(0): 0x21c6720: ch = JMP_4 0x21c6320, 0x21c8860 [ORD=4] [ID=0]


*** Scheduling [0]: SU(0): 0x21c6720: ch = JMP_4 0x21c6320, 0x21c8860 [ORD=4] [ID=0]


Examining Available:
Height 1: SU(1): 0x21c8860: ch = JNE_4 0x21c5e20, 0x21c8360, 0x21c8360:1 [ORD=4] [ID=1]

    0x21c8360: ch,glue = CopyToReg 0x21c8a60, 0x21c7e60, 0x21c8460 [ORD=4] [ID=1]


*** Scheduling [1]: SU(1): 0x21c8860: ch = JNE_4 0x21c5e20, 0x21c8360, 0x21c8360:1 [ORD=4] [ID=1]

    0x21c8360: ch,glue = CopyToReg 0x21c8a60, 0x21c7e60, 0x21c8460 [ORD=4] [ID=1]


Examining Available:
  SU (12)  has no physreg SU(2)  defines a physreg
Height 2: SU(2): 0x21c8460: i64 = TEST64rr 0x21c6120, 0x21c8060 [ORD=2] [ID=2]

Height 2: SU(12): 0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c6120 [ORD=2] [ID=12]

  SU (12)  has no physreg SU(2)  defines a physreg

*** Scheduling [2]: SU(2): 0x21c8460: i64 = TEST64rr 0x21c6120, 0x21c8060 [ORD=2] [ID=2]


Examining Available:
Height 3: SU(3): 0x21c8060: i64 = MOV64ri 0x21c6020 [ID=3]

Height 2: SU(12): 0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c6120 [ORD=2] [ID=12]


*** Scheduling [3]: SU(3): 0x21c8060: i64 = MOV64ri 0x21c6020 [ID=3]


Examining Available:
Height 2: SU(12): 0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c6120 [ORD=2] [ID=12]


*** Scheduling [4]: SU(12): 0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c6120 [ORD=2] [ID=12]


Examining Available:
Height 5: SU(4): 0x21c6120: i64,ch,glue = CopyFromReg 0x219b660, 0x21c8260, 0x21c8560 [ORD=2] [ID=4]

    0x21ca880: ch,glue = CopyToReg 0x219b660, 0x21c6820, 0x21c7f60 [ORD=2] [ID=4]

    0x21ca580: glue = CQO 0x21ca880:1 [ORD=2] [ID=4]

    0x21c8560: glue = IDIV64r 0x21c8160, 0x21ca580 [ORD=2] [ID=4]


*** Scheduling [5]: SU(4): 0x21c6120: i64,ch,glue = CopyFromReg 0x219b660, 0x21c8260, 0x21c8560 [ORD=2] [ID=4]

    0x21ca880: ch,glue = CopyToReg 0x219b660, 0x21c6820, 0x21c7f60 [ORD=2] [ID=4]

    0x21ca580: glue = CQO 0x21ca880:1 [ORD=2] [ID=4]

    0x21c8560: glue = IDIV64r 0x21c8160, 0x21ca580 [ORD=2] [ID=4]


Examining Available:
Height 6: SU(9): 0x21c8160: i64,i64 = SAR64rCL 0x21caa80, 0x21ca480:1 [ORD=2] [ID=9]

    0x21ca480: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=9]

Height 6: SU(5): 0x21c7f60: i64,i64 = SAR64rCL 0x21ca780, 0x21c6920:1 [ORD=2] [ID=5]

    0x21c6920: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=5]


*** Scheduling [6]: SU(9): 0x21c8160: i64,i64 = SAR64rCL 0x21caa80, 0x21ca480:1 [ORD=2] [ID=9]

    0x21ca480: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=9]


Examining Available:
Height 7: SU(10): 0x21caa80: i64,i64 = SHL64rCL 0x21ca980, 0x21c8660:1 [ORD=2] [ID=10]

    0x21c8660: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=10]

Height 6: SU(5): 0x21c7f60: i64,i64 = SAR64rCL 0x21ca780, 0x21c6920:1 [ORD=2] [ID=5]

    0x21c6920: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=5]


*** Scheduling [7]: SU(10): 0x21caa80: i64,i64 = SHL64rCL 0x21ca980, 0x21c8660:1 [ORD=2] [ID=10]

    0x21c8660: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=10]


Examining Available:
Height 8: SU(11): 0x21ca980: i64,ch = CopyFromReg 0x219b660, 0x21c8b60 [ORD=2] [ID=11]

Height 6: SU(5): 0x21c7f60: i64,i64 = SAR64rCL 0x21ca780, 0x21c6920:1 [ORD=2] [ID=5]

    0x21c6920: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=5]


*** Scheduling [8]: SU(11): 0x21ca980: i64,ch = CopyFromReg 0x219b660, 0x21c8b60 [ORD=2] [ID=11]


Examining Available:
Height 6: SU(5): 0x21c7f60: i64,i64 = SAR64rCL 0x21ca780, 0x21c6920:1 [ORD=2] [ID=5]

    0x21c6920: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=5]


*** Scheduling [9]: SU(5): 0x21c7f60: i64,i64 = SAR64rCL 0x21ca780, 0x21c6920:1 [ORD=2] [ID=5]

    0x21c6920: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=5]


Examining Available:
Height 10: SU(7): 0x21ca780: i64,i64 = SHL64rCL 0x21c8960, 0x21c8760:1 [ORD=2] [ID=7]

    0x21c8760: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=7]


*** Scheduling [10]: SU(7): 0x21ca780: i64,i64 = SHL64rCL 0x21c8960, 0x21c8760:1 [ORD=2] [ID=7]

    0x21c8760: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=7]


Examining Available:
Height 11: SU(6): 0x21c5f20: i64 = MOV64ri32 0x21c6520 [ID=6]

Height 11: SU(8): 0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2] [ID=8]


*** Scheduling [11]: SU(6): 0x21c5f20: i64 = MOV64ri32 0x21c6520 [ID=6]


Examining Available:
Height 11: SU(8): 0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2] [ID=8]


*** Scheduling [12]: SU(8): 0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2] [ID=8]

*** Final schedule ***
SU(8): 0x21c8960: i64,ch = CopyFromReg 0x219b660, 0x21c6420 [ORD=2] [ID=8]

SU(6): 0x21c5f20: i64 = MOV64ri32 0x21c6520 [ID=6]

SU(7): 0x21ca780: i64,i64 = SHL64rCL 0x21c8960, 0x21c8760:1 [ORD=2] [ID=7]

    0x21c8760: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=7]

SU(5): 0x21c7f60: i64,i64 = SAR64rCL 0x21ca780, 0x21c6920:1 [ORD=2] [ID=5]

    0x21c6920: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=5]

SU(11): 0x21ca980: i64,ch = CopyFromReg 0x219b660, 0x21c8b60 [ORD=2] [ID=11]

SU(10): 0x21caa80: i64,i64 = SHL64rCL 0x21ca980, 0x21c8660:1 [ORD=2] [ID=10]

    0x21c8660: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=10]

SU(9): 0x21c8160: i64,i64 = SAR64rCL 0x21caa80, 0x21ca480:1 [ORD=2] [ID=9]

    0x21ca480: ch,glue = CopyToReg 0x219b660, 0x21c6220, 0x21c5f20 [ORD=2] [ID=9]

SU(4): 0x21c6120: i64,ch,glue = CopyFromReg 0x219b660, 0x21c8260, 0x21c8560 [ORD=2] [ID=4]

    0x21ca880: ch,glue = CopyToReg 0x219b660, 0x21c6820, 0x21c7f60 [ORD=2] [ID=4]

    0x21ca580: glue = CQO 0x21ca880:1 [ORD=2] [ID=4]

    0x21c8560: glue = IDIV64r 0x21c8160, 0x21ca580 [ORD=2] [ID=4]

SU(12): 0x21c8a60: ch = CopyToReg 0x219b660, 0x21c8c60, 0x21c6120 [ORD=2] [ID=12]

SU(3): 0x21c8060: i64 = MOV64ri 0x21c6020 [ID=3]

SU(2): 0x21c8460: i64 = TEST64rr 0x21c6120, 0x21c8060 [ORD=2] [ID=2]

SU(1): 0x21c8860: ch = JNE_4 0x21c5e20, 0x21c8360, 0x21c8360:1 [ORD=4] [ID=1]

    0x21c8360: ch,glue = CopyToReg 0x21c8a60, 0x21c7e60, 0x21c8460 [ORD=4] [ID=1]

SU(0): 0x21c6720: ch = JMP_4 0x21c6320, 0x21c8860 [ORD=4] [ID=0]


Total amount of phi nodes to update: 3
Node 0 : (0x21d07f0, 2147483649)
Node 1 : (0x21d0680, 2147483649)
Node 2 : (0x21d06e0, 2147483650)
Initial selection DAG: BB#2 'quantum_gcd:while.end'
SelectionDAG has 8 nodes:
  0x219b660: ch = EntryToken

    0x219b660: <multiple use>
    0x21c6020: i64 = Register %vreg3

  0x21c6520: i64,ch = CopyFromReg 0x219b660, 0x21c6020 [ORD=2]

    0x21c6520: <multiple use>
  0x21c8760: i32 = truncate 0x21c6520 [ORD=2]

  0x21c6620: i64 = Register %RAX

    0x219b660: <multiple use>
    0x21c6620: <multiple use>
    0x21c6520: <multiple use>
  0x21c6a20: ch,glue = CopyToReg 0x219b660, 0x21c6620, 0x21c6520 [ORD=2]

    0x21c6a20: <multiple use>
    0x21c8660: i64 = TargetConstant<0>

    0x21c6620: <multiple use>
    0x21c6a20: <multiple use>
  0x21c6920: ch = Cse523ISD::RET_FLAG 0x21c6a20, 0x21c8660, 0x21c6620, 0x21c6a20:1 [ORD=2]


Optimized lowered selection DAG: BB#2 'quantum_gcd:while.end'
SelectionDAG has 7 nodes:
  0x219b660: ch = EntryToken

  0x21c6620: i64 = Register %RAX

    0x219b660: <multiple use>
    0x21c6620: <multiple use>
      0x219b660: <multiple use>
      0x21c6020: i64 = Register %vreg3

    0x21c6520: i64,ch = CopyFromReg 0x219b660, 0x21c6020 [ORD=2]

  0x21c6a20: ch,glue = CopyToReg 0x219b660, 0x21c6620, 0x21c6520 [ORD=2]

    0x21c6a20: <multiple use>
    0x21c8660: i64 = TargetConstant<0>

    0x21c6620: <multiple use>
    0x21c6a20: <multiple use>
  0x21c6920: ch = Cse523ISD::RET_FLAG 0x21c6a20, 0x21c8660, 0x21c6620, 0x21c6a20:1 [ORD=2]


Legally typed node: 0x21c6620: i64 = Register %RAX [ID=0]

Legally typed node: 0x21c8660: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x21c6020: i64 = Register %vreg3 [ID=0]

Legally typed node: 0x219b660: ch = EntryToken [ID=0]

Legally typed node: 0x21c6520: i64,ch = CopyFromReg 0x219b660, 0x21c6020 [ORD=2] [ID=0]

Legally typed node: 0x21c6a20: ch,glue = CopyToReg 0x219b660, 0x21c6620, 0x21c6520 [ORD=2] [ID=0]

Legally typed node: 0x21c6920: ch = Cse523ISD::RET_FLAG 0x21c6a20, 0x21c8660, 0x21c6620, 0x21c6a20:1 [ORD=2] [ID=0]

Legally typed node: 0x7fff16596d20: ch = handlenode 0x21c6920 [ID=0]

Type-legalized selection DAG: BB#2 'quantum_gcd:while.end'
SelectionDAG has 7 nodes:
  0x219b660: ch = EntryToken [ID=-3]

  0x21c6620: i64 = Register %RAX [ID=-3]

    0x219b660: <multiple use>
    0x21c6620: <multiple use>
      0x219b660: <multiple use>
      0x21c6020: i64 = Register %vreg3 [ID=-3]

    0x21c6520: i64,ch = CopyFromReg 0x219b660, 0x21c6020 [ORD=2] [ID=-3]

  0x21c6a20: ch,glue = CopyToReg 0x219b660, 0x21c6620, 0x21c6520 [ORD=2] [ID=-3]

    0x21c6a20: <multiple use>
    0x21c8660: i64 = TargetConstant<0> [ID=-3]

    0x21c6620: <multiple use>
    0x21c6a20: <multiple use>
  0x21c6920: ch = Cse523ISD::RET_FLAG 0x21c6a20, 0x21c8660, 0x21c6620, 0x21c6a20:1 [ORD=2] [ID=-3]


Legalized selection DAG: BB#2 'quantum_gcd:while.end'
SelectionDAG has 7 nodes:
  0x219b660: ch = EntryToken [ID=0]

  0x21c6620: i64 = Register %RAX [ID=3]

    0x219b660: <multiple use>
    0x21c6620: <multiple use>
      0x219b660: <multiple use>
      0x21c6020: i64 = Register %vreg3 [ID=1]

    0x21c6520: i64,ch = CopyFromReg 0x219b660, 0x21c6020 [ORD=2] [ID=4]

  0x21c6a20: ch,glue = CopyToReg 0x219b660, 0x21c6620, 0x21c6520 [ORD=2] [ID=5]

    0x21c6a20: <multiple use>
    0x21c8660: i64 = TargetConstant<0> [ID=2]

    0x21c6620: <multiple use>
    0x21c6a20: <multiple use>
  0x21c6920: ch = Cse523ISD::RET_FLAG 0x21c6a20, 0x21c8660, 0x21c6620, 0x21c6a20:1 [ORD=2] [ID=6]


Optimized legalized selection DAG: BB#2 'quantum_gcd:while.end'
SelectionDAG has 7 nodes:
  0x219b660: ch = EntryToken [ID=0]

  0x21c6620: i64 = Register %RAX [ID=3]

    0x219b660: <multiple use>
    0x21c6620: <multiple use>
      0x219b660: <multiple use>
      0x21c6020: i64 = Register %vreg3 [ID=1]

    0x21c6520: i64,ch = CopyFromReg 0x219b660, 0x21c6020 [ORD=2] [ID=4]

  0x21c6a20: ch,glue = CopyToReg 0x219b660, 0x21c6620, 0x21c6520 [ORD=2] [ID=5]

    0x21c6a20: <multiple use>
    0x21c8660: i64 = TargetConstant<0> [ID=2]

    0x21c6620: <multiple use>
    0x21c6a20: <multiple use>
  0x21c6920: ch = Cse523ISD::RET_FLAG 0x21c6a20, 0x21c8660, 0x21c6620, 0x21c6a20:1 [ORD=2] [ID=6]


===== Instruction selection begins: BB#2 'while.end'
Selecting:Opcode[211] 0x21c6920: ch = Cse523ISD::RET_FLAG 0x21c6a20, 0x21c8660, 0x21c6620, 0x21c6a20:1 [ORD=2] [ID=6]

ISEL: Starting pattern match on root node: 0x21c6920: ch = Cse523ISD::RET_FLAG 0x21c6a20, 0x21c8660, 0x21c6620, 0x21c6a20:1 [ORD=2] [ID=6]

  Initial Opcode index to 4203
  Morphed node: 0x21c6920: ch = RETQ 0x21c6620, 0x21c6a20, 0x21c6a20:1 [ORD=2]

ISEL: Match complete!
=> 0x21c6920: ch = RETQ 0x21c6620, 0x21c6a20, 0x21c6a20:1 [ORD=2]

Selecting:Opcode[39] 0x21c6a20: ch,glue = CopyToReg 0x219b660, 0x21c6620, 0x21c6520 [ORD=2] [ID=5]

=> 0x21c6a20: ch,glue = CopyToReg 0x219b660, 0x21c6620, 0x21c6520 [ORD=2]

Selecting:Opcode[40] 0x21c6520: i64,ch = CopyFromReg 0x219b660, 0x21c6020 [ORD=2] [ID=4]

=> 0x21c6520: i64,ch = CopyFromReg 0x219b660, 0x21c6020 [ORD=2]

Selecting:Opcode[8] 0x21c6620: i64 = Register %RAX [ID=3]

=> 0x21c6620: i64 = Register %RAX

Selecting:Opcode[8] 0x21c6020: i64 = Register %vreg3 [ID=1]

=> 0x21c6020: i64 = Register %vreg3

Selecting:Opcode[1] 0x219b660: ch = EntryToken [ID=0]

=> 0x219b660: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#2 'quantum_gcd:while.end'
SelectionDAG has 6 nodes:
  0x219b660: ch = EntryToken

  0x21c6620: i64 = Register %RAX

    0x219b660: <multiple use>
    0x21c6620: <multiple use>
      0x219b660: <multiple use>
      0x21c6020: i64 = Register %vreg3

    0x21c6520: i64,ch = CopyFromReg 0x219b660, 0x21c6020 [ORD=2]

  0x21c6a20: ch,glue = CopyToReg 0x219b660, 0x21c6620, 0x21c6520 [ORD=2]

    0x21c6620: <multiple use>
    0x21c6a20: <multiple use>
    0x21c6a20: <multiple use>
  0x21c6920: ch = RETQ 0x21c6620, 0x21c6a20, 0x21c6a20:1 [ORD=2]


********** List Scheduling BB#2 'while.end' **********
SU(0): 0x21c6920: ch = RETQ 0x21c6620, 0x21c6a20, 0x21c6a20:1 [ORD=2] [ID=0]

    0x21c6a20: ch,glue = CopyToReg 0x219b660, 0x21c6620, 0x21c6520 [ORD=2] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
   val SU(1): Latency=1

SU(1): 0x21c6520: i64,ch = CopyFromReg 0x219b660, 0x21c6020 [ORD=2] [ID=1]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(0): Latency=1


Examining Available:
Height 0: SU(0): 0x21c6920: ch = RETQ 0x21c6620, 0x21c6a20, 0x21c6a20:1 [ORD=2] [ID=0]

    0x21c6a20: ch,glue = CopyToReg 0x219b660, 0x21c6620, 0x21c6520 [ORD=2] [ID=0]


*** Scheduling [0]: SU(0): 0x21c6920: ch = RETQ 0x21c6620, 0x21c6a20, 0x21c6a20:1 [ORD=2] [ID=0]

    0x21c6a20: ch,glue = CopyToReg 0x219b660, 0x21c6620, 0x21c6520 [ORD=2] [ID=0]


Examining Available:
Height 1: SU(1): 0x21c6520: i64,ch = CopyFromReg 0x219b660, 0x21c6020 [ORD=2] [ID=1]


*** Scheduling [1]: SU(1): 0x21c6520: i64,ch = CopyFromReg 0x219b660, 0x21c6020 [ORD=2] [ID=1]

*** Final schedule ***
SU(1): 0x21c6520: i64,ch = CopyFromReg 0x219b660, 0x21c6020 [ORD=2] [ID=1]

SU(0): 0x21c6920: ch = RETQ 0x21c6620, 0x21c6a20, 0x21c6a20:1 [ORD=2] [ID=0]

    0x21c6a20: ch,glue = CopyToReg 0x219b660, 0x21c6620, 0x21c6520 [ORD=2] [ID=0]


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function quantum_gcd: SSA
Function Live Ins: %RDI in %vreg4, %RSI in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %RDI %RSI
	%vreg5<def> = COPY %RSI; GR64:%vreg5
	%vreg4<def> = COPY %RDI; GR64:%vreg4
	%vreg7<def> = COPY %vreg5; GR64:%vreg7,%vreg5
	%vreg6<def> = COPY %vreg4; GR64:%vreg6,%vreg4
	%vreg8<def> = MOV64ri 4294967295; GR64:%vreg8
	TEST64rr %vreg5, %vreg8<kill>, %EFLAGS<imp-def>; GR64:%vreg5,%vreg8
	JE_4 <BB#2>, %EFLAGS<imp-use>
	JMP_4 <BB#1>
    Successors according to CFG: BB#2(12) BB#1(20)

BB#1: derived from LLVM BB %while.body
    Predecessors according to CFG: BB#0 BB#1
	%vreg0<def> = PHI %vreg6, <BB#0>, %vreg1, <BB#1>; GR64:%vreg0,%vreg6,%vreg1
	%vreg1<def> = PHI %vreg7, <BB#0>, %vreg2, <BB#1>; GR64:%vreg1,%vreg7,%vreg2
	%vreg9<def> = MOV64ri32 32; GR64:%vreg9
	%RCX<def> = COPY %vreg9; GR64:%vreg9
	%vreg10<def,tied1> = SHL64rCL %vreg0<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg10,%vreg0
	%RCX<def> = COPY %vreg9; GR64:%vreg9
	%vreg11<def,tied1> = SAR64rCL %vreg10<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg11,%vreg10
	%RCX<def> = COPY %vreg9; GR64:%vreg9
	%vreg12<def,tied1> = SHL64rCL %vreg1<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg12,%vreg1
	%RCX<def> = COPY %vreg9; GR64:%vreg9
	%vreg13<def,tied1> = SAR64rCL %vreg12<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg13,%vreg12
	%RAX<def> = COPY %vreg11; GR64:%vreg11
	CQO %RAX<imp-def>, %RDX<imp-def>, %RAX<imp-use>
	IDIV64r %vreg13<kill>, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use>, %RDX<imp-use>; GR64:%vreg13
	%vreg14<def> = COPY %RDX; GR64:%vreg14
	%vreg2<def> = COPY %vreg14; GR64:%vreg2,%vreg14
	%vreg15<def> = MOV64ri 4294967295; GR64:%vreg15
	TEST64rr %vreg14, %vreg15<kill>, %EFLAGS<imp-def>; GR64:%vreg14,%vreg15
	JNE_4 <BB#1>, %EFLAGS<imp-use>
	JMP_4 <BB#2>
    Successors according to CFG: BB#2(4) BB#1(124)

BB#2: derived from LLVM BB %while.end
    Predecessors according to CFG: BB#0 BB#1
	%vreg3<def> = PHI %vreg6, <BB#0>, %vreg1, <BB#1>; GR64:%vreg3,%vreg6,%vreg1
	%RAX<def> = COPY %vreg3; GR64:%vreg3
	RETQ %RAX

# End machine code for function quantum_gcd.

# Machine code for function quantum_gcd: SSA
Function Live Ins: %RDI in %vreg4, %RSI in %vreg5

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI %RSI
16B		%vreg5<def> = COPY %RSI; GR64:%vreg5
32B		%vreg4<def> = COPY %RDI; GR64:%vreg4
48B		%vreg7<def> = COPY %vreg5; GR64:%vreg7,%vreg5
64B		%vreg6<def> = COPY %vreg4; GR64:%vreg6,%vreg4
80B		%vreg8<def> = MOV64ri 4294967295; GR64:%vreg8
96B		TEST64rr %vreg5, %vreg8<kill>, %EFLAGS<imp-def>; GR64:%vreg5,%vreg8
112B		JE_4 <BB#2>, %EFLAGS<imp-use>
128B		JMP_4 <BB#1>
	    Successors according to CFG: BB#2(12) BB#1(20)

144B	BB#1: derived from LLVM BB %while.body
	    Predecessors according to CFG: BB#0 BB#1
160B		%vreg0<def> = PHI %vreg6, <BB#0>, %vreg1, <BB#1>; GR64:%vreg0,%vreg6,%vreg1
176B		%vreg1<def> = PHI %vreg7, <BB#0>, %vreg2, <BB#1>; GR64:%vreg1,%vreg7,%vreg2
192B		%vreg9<def> = MOV64ri32 32; GR64:%vreg9
208B		%RCX<def> = COPY %vreg9; GR64:%vreg9
224B		%vreg10<def,tied1> = SHL64rCL %vreg0<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg10,%vreg0
240B		%RCX<def> = COPY %vreg9; GR64:%vreg9
256B		%vreg11<def,tied1> = SAR64rCL %vreg10<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg11,%vreg10
272B		%RCX<def> = COPY %vreg9; GR64:%vreg9
288B		%vreg12<def,tied1> = SHL64rCL %vreg1<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg12,%vreg1
304B		%RCX<def> = COPY %vreg9; GR64:%vreg9
320B		%vreg13<def,tied1> = SAR64rCL %vreg12<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg13,%vreg12
336B		%RAX<def> = COPY %vreg11; GR64:%vreg11
352B		CQO %RAX<imp-def>, %RDX<imp-def>, %RAX<imp-use>
368B		IDIV64r %vreg13<kill>, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use>, %RDX<imp-use>; GR64:%vreg13
384B		%vreg14<def> = COPY %RDX; GR64:%vreg14
400B		%vreg2<def> = COPY %vreg14; GR64:%vreg2,%vreg14
416B		%vreg15<def> = MOV64ri 4294967295; GR64:%vreg15
432B		TEST64rr %vreg14, %vreg15<kill>, %EFLAGS<imp-def>; GR64:%vreg14,%vreg15
448B		JNE_4 <BB#1>, %EFLAGS<imp-use>
464B		JMP_4 <BB#2>
	    Successors according to CFG: BB#2(4) BB#1(124)

480B	BB#2: derived from LLVM BB %while.end
	    Predecessors according to CFG: BB#0 BB#1
496B		%vreg3<def> = PHI %vreg6, <BB#0>, %vreg1, <BB#1>; GR64:%vreg3,%vreg6,%vreg1
512B		%RAX<def> = COPY %vreg3; GR64:%vreg3
528B		RETQ %RAX

# End machine code for function quantum_gcd.

********** Stack Coloring **********
********** Function: quantum_gcd
******** Pre-regalloc Machine LICM: quantum_gcd ********
Splitting critical edge: BB#0 -- BB#3 -- BB#1
Entering: while.body
Hoisting %vreg9<def> = MOV64ri32 32; GR64:%vreg9
 from MachineBasicBlock while.body
Hoisting %vreg15<def> = MOV64ri 4294967295; GR64:%vreg15
 from MachineBasicBlock while.body
Exiting: while.body
Entering: entry
Entering: (null)
Examining: %vreg15<def> = MOV64ri 4294967295; GR64:%vreg15
*** Found a common subexpression: %vreg8<def> = MOV64ri 4294967295; GR64:%vreg8
Entering: while.body
Exiting: while.body
Exiting: (null)
Entering: while.end
Exiting: while.end
Exiting: entry
******** Machine Sinking ********
Sink instr %vreg7<def> = COPY %vreg5; GR64:%vreg7,%vreg5
	into block BB#3: 
    Predecessors according to CFG: BB#0
	%vreg9<def> = MOV64ri32 32; GR64:%vreg9
    Successors according to CFG: BB#1
********** PEEPHOLE OPTIMIZER **********
********** Function: quantum_gcd
********** PROCESS IMPLICIT DEFS **********
********** Function: quantum_gcd
%vreg6 live-out before critical edge BB#0 -> BB#3: %vreg3<def> = PHI %vreg6, <BB#0>, %vreg1, <BB#2>; GR64:%vreg3,%vreg6,%vreg1
Splitting critical edge: BB#0 -- BB#4 -- BB#3
Removing terminator kill: JE_4 <BB#3>, %EFLAGS<imp-use,kill>
Restored terminator kill: JNE_4 <BB#1>, %EFLAGS<imp-use,kill>
********** REWRITING TWO-ADDR INSTRS **********
********** Function: quantum_gcd
	%vreg10<def,tied1> = SHL64rCL %vreg0<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg10,%vreg0
		prepend:	%vreg10<def> = COPY %vreg0; GR64:%vreg10,%vreg0
		rewrite to:	%vreg10<def,tied1> = SHL64rCL %vreg10<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg10
	%vreg11<def,tied1> = SAR64rCL %vreg10<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg11,%vreg10
		prepend:	%vreg11<def> = COPY %vreg10; GR64:%vreg11,%vreg10
		rewrite to:	%vreg11<def,tied1> = SAR64rCL %vreg11<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg11
	%vreg12<def,tied1> = SHL64rCL %vreg1<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg12,%vreg1
		prepend:	%vreg12<def> = COPY %vreg1; GR64:%vreg12,%vreg1
		rewrite to:	%vreg12<def,tied1> = SHL64rCL %vreg12<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg12
	%vreg13<def,tied1> = SAR64rCL %vreg12<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13,%vreg12
		prepend:	%vreg13<def> = COPY %vreg12; GR64:%vreg13,%vreg12
		rewrite to:	%vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
# Machine code for function quantum_gcd: Post SSA
Function Live Ins: %RDI in %vreg4, %RSI in %vreg5

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI %RSI
16B		%vreg5<def> = COPY %RSI<kill>; GR64:%vreg5
32B		%vreg4<def> = COPY %RDI<kill>; GR64:%vreg4
48B		%vreg6<def> = COPY %vreg4<kill>; GR64:%vreg6,%vreg4
64B		%vreg8<def> = MOV64ri 4294967295; GR64:%vreg8
80B		TEST64rr %vreg5, %vreg8, %EFLAGS<imp-def>; GR64:%vreg5,%vreg8
96B		JNE_4 <BB#1>, %EFLAGS<imp-use,kill>
	    Successors according to CFG: BB#4(12) BB#1(20)

112B	BB#4: 
	    Predecessors according to CFG: BB#0
128B		%vreg18<def> = COPY %vreg6<kill>; GR64:%vreg18,%vreg6
144B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3

160B	BB#1: 
	    Predecessors according to CFG: BB#0
176B		%vreg7<def> = COPY %vreg5<kill>; GR64:%vreg7,%vreg5
192B		%vreg9<def> = MOV64ri32 32; GR64:%vreg9
208B		%vreg16<def> = COPY %vreg6<kill>; GR64:%vreg16,%vreg6
224B		%vreg17<def> = COPY %vreg7<kill>; GR64:%vreg17,%vreg7
	    Successors according to CFG: BB#2

240B	BB#2: derived from LLVM BB %while.body
	    Predecessors according to CFG: BB#2 BB#1
256B		%vreg1<def> = COPY %vreg17<kill>; GR64:%vreg1,%vreg17
272B		%vreg0<def> = COPY %vreg16<kill>; GR64:%vreg0,%vreg16
288B		%RCX<def> = COPY %vreg9; GR64:%vreg9
304B		%vreg10<def> = COPY %vreg0<kill>; GR64:%vreg10,%vreg0
320B		%vreg10<def,tied1> = SHL64rCL %vreg10<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg10
336B		%RCX<def> = COPY %vreg9; GR64:%vreg9
352B		%vreg11<def> = COPY %vreg10<kill>; GR64:%vreg11,%vreg10
368B		%vreg11<def,tied1> = SAR64rCL %vreg11<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg11
384B		%RCX<def> = COPY %vreg9; GR64:%vreg9
400B		%vreg12<def> = COPY %vreg1; GR64:%vreg12,%vreg1
416B		%vreg12<def,tied1> = SHL64rCL %vreg12<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg12
432B		%RCX<def> = COPY %vreg9; GR64:%vreg9
448B		%vreg13<def> = COPY %vreg12<kill>; GR64:%vreg13,%vreg12
464B		%vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
480B		%RAX<def> = COPY %vreg11<kill>; GR64:%vreg11
496B		CQO %RAX<imp-def>, %RDX<imp-def>, %RAX<imp-use,kill>
512B		IDIV64r %vreg13<kill>, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use,kill>, %RDX<imp-use,kill>; GR64:%vreg13
528B		%vreg14<def> = COPY %RDX<kill>; GR64:%vreg14
544B		%vreg2<def> = COPY %vreg14; GR64:%vreg2,%vreg14
560B		TEST64rr %vreg14<kill>, %vreg8, %EFLAGS<imp-def>; GR64:%vreg14,%vreg8
576B		%vreg16<def> = COPY %vreg1; GR64:%vreg16,%vreg1
592B		%vreg17<def> = COPY %vreg2<kill>; GR64:%vreg17,%vreg2
608B		%vreg18<def> = COPY %vreg1<kill>; GR64:%vreg18,%vreg1
624B		JNE_4 <BB#2>, %EFLAGS<imp-use,kill>
640B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3(4) BB#2(124)

656B	BB#3: derived from LLVM BB %while.end
	    Predecessors according to CFG: BB#2 BB#4
672B		%vreg3<def> = COPY %vreg18<kill>; GR64:%vreg3,%vreg18
688B		%RAX<def> = COPY %vreg3<kill>; GR64:%vreg3
704B		RETQ %RAX<kill>

# End machine code for function quantum_gcd.

Computing live-in reg-units in ABI blocks.
0B	BB#0 RDI#0 RSI#0
Created 2 new intervals.
********** INTERVALS **********
RDI [0B,32r:0)  0@0B-phi
RSI [0B,16r:0)  0@0B-phi
%vreg0 [272r,304r:0)  0@272r
%vreg1 [256r,608r:0)  0@256r
%vreg2 [544r,592r:0)  0@544r
%vreg3 [672r,688r:0)  0@672r
%vreg4 [32r,48r:0)  0@32r
%vreg5 [16r,112B:0)[160B,176r:0)  0@16r
%vreg6 [48r,128r:0)[160B,208r:0)  0@48r
%vreg7 [176r,224r:0)  0@176r
%vreg8 [64r,112B:0)[160B,656B:0)  0@64r
%vreg9 [192r,656B:0)  0@192r
%vreg10 [304r,320r:0)[320r,352r:1)  0@304r 1@320r
%vreg11 [352r,368r:0)[368r,480r:1)  0@352r 1@368r
%vreg12 [400r,416r:0)[416r,448r:1)  0@400r 1@416r
%vreg13 [448r,464r:0)[464r,512r:1)  0@448r 1@464r
%vreg14 [528r,560r:0)  0@528r
%vreg16 [208r,240B:0)[240B,272r:2)[576r,656B:1)  0@208r 1@576r 2@240B-phi
%vreg17 [224r,240B:0)[240B,256r:2)[592r,656B:1)  0@224r 1@592r 2@240B-phi
%vreg18 [128r,160B:0)[608r,656B:1)[656B,672r:2)  0@128r 1@608r 2@656B-phi
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function quantum_gcd: Post SSA
Function Live Ins: %RDI in %vreg4, %RSI in %vreg5

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI %RSI
16B		%vreg5<def> = COPY %RSI; GR64:%vreg5
32B		%vreg4<def> = COPY %RDI; GR64:%vreg4
48B		%vreg6<def> = COPY %vreg4; GR64:%vreg6,%vreg4
64B		%vreg8<def> = MOV64ri 4294967295; GR64:%vreg8
80B		TEST64rr %vreg5, %vreg8, %EFLAGS<imp-def>; GR64:%vreg5,%vreg8
96B		JNE_4 <BB#1>, %EFLAGS<imp-use,kill>
	    Successors according to CFG: BB#4(12) BB#1(20)

112B	BB#4: 
	    Predecessors according to CFG: BB#0
128B		%vreg18<def> = COPY %vreg6; GR64:%vreg18,%vreg6
144B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3

160B	BB#1: 
	    Predecessors according to CFG: BB#0
176B		%vreg7<def> = COPY %vreg5; GR64:%vreg7,%vreg5
192B		%vreg9<def> = MOV64ri32 32; GR64:%vreg9
208B		%vreg16<def> = COPY %vreg6; GR64:%vreg16,%vreg6
224B		%vreg17<def> = COPY %vreg7; GR64:%vreg17,%vreg7
	    Successors according to CFG: BB#2

240B	BB#2: derived from LLVM BB %while.body
	    Predecessors according to CFG: BB#2 BB#1
256B		%vreg1<def> = COPY %vreg17; GR64:%vreg1,%vreg17
272B		%vreg0<def> = COPY %vreg16; GR64:%vreg0,%vreg16
288B		%RCX<def> = COPY %vreg9; GR64:%vreg9
304B		%vreg10<def> = COPY %vreg0; GR64:%vreg10,%vreg0
320B		%vreg10<def,tied1> = SHL64rCL %vreg10<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg10
336B		%RCX<def> = COPY %vreg9; GR64:%vreg9
352B		%vreg11<def> = COPY %vreg10; GR64:%vreg11,%vreg10
368B		%vreg11<def,tied1> = SAR64rCL %vreg11<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg11
384B		%RCX<def> = COPY %vreg9; GR64:%vreg9
400B		%vreg12<def> = COPY %vreg1; GR64:%vreg12,%vreg1
416B		%vreg12<def,tied1> = SHL64rCL %vreg12<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg12
432B		%RCX<def> = COPY %vreg9; GR64:%vreg9
448B		%vreg13<def> = COPY %vreg12; GR64:%vreg13,%vreg12
464B		%vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
480B		%RAX<def> = COPY %vreg11; GR64:%vreg11
496B		CQO %RAX<imp-def>, %RDX<imp-def>, %RAX<imp-use,kill>
512B		IDIV64r %vreg13, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use,kill>, %RDX<imp-use,kill>; GR64:%vreg13
528B		%vreg14<def> = COPY %RDX<kill>; GR64:%vreg14
544B		%vreg2<def> = COPY %vreg14; GR64:%vreg2,%vreg14
560B		TEST64rr %vreg14, %vreg8, %EFLAGS<imp-def>; GR64:%vreg14,%vreg8
576B		%vreg16<def> = COPY %vreg1; GR64:%vreg16,%vreg1
592B		%vreg17<def> = COPY %vreg2; GR64:%vreg17,%vreg2
608B		%vreg18<def> = COPY %vreg1; GR64:%vreg18,%vreg1
624B		JNE_4 <BB#2>, %EFLAGS<imp-use,kill>
640B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3(4) BB#2(124)

656B	BB#3: derived from LLVM BB %while.end
	    Predecessors according to CFG: BB#2 BB#4
672B		%vreg3<def> = COPY %vreg18; GR64:%vreg3,%vreg18
688B		%RAX<def> = COPY %vreg3; GR64:%vreg3
704B		RETQ %RAX<kill>

# End machine code for function quantum_gcd.

********** SIMPLE REGISTER COALESCING **********
********** Function: quantum_gcd
********** JOINING INTERVALS ***********
while.body:
288B	%RCX<def> = COPY %vreg9; GR64:%vreg9
	Considering merging %vreg9 with %RCX
	Can only merge into reserved registers.
Remat: %RCX<def> = MOV64ri32 32
Shrink: %vreg9 [192r,656B:0)  0@192r
 live-in at 240B
Shrunk: %vreg9 [192r,656B:0)  0@192r
336B	%RCX<def> = COPY %vreg9; GR64:%vreg9
	Considering merging %vreg9 with %RCX
	Can only merge into reserved registers.
Remat: %RCX<def> = MOV64ri32 32
Shrink: %vreg9 [192r,656B:0)  0@192r
 live-in at 240B
Shrunk: %vreg9 [192r,656B:0)  0@192r
384B	%RCX<def> = COPY %vreg9; GR64:%vreg9
	Considering merging %vreg9 with %RCX
	Can only merge into reserved registers.
Remat: %RCX<def> = MOV64ri32 32
Shrink: %vreg9 [192r,656B:0)  0@192r
 live-in at 240B
Shrunk: %vreg9 [192r,656B:0)  0@192r
432B	%RCX<def> = COPY %vreg9; GR64:%vreg9
	Considering merging %vreg9 with %RCX
	Can only merge into reserved registers.
Remat: %RCX<def> = MOV64ri32 32
Shrink: %vreg9 [192r,656B:0)  0@192r
All defs dead: 192r	%vreg9<def,dead> = MOV64ri32 32; GR64:%vreg9
Shrunk: %vreg9 [192r,192d:0)  0@192r
Deleting dead def 192r	%vreg9<def,dead> = MOV64ri32 32; GR64:%vreg9
480B	%RAX<def> = COPY %vreg11; GR64:%vreg11
	Considering merging %vreg11 with %RAX
	Can only merge into reserved registers.
528B	%vreg14<def> = COPY %RDX<kill>; GR64:%vreg14
	Considering merging %vreg14 with %RDX
	Can only merge into reserved registers.
256B	%vreg1<def> = COPY %vreg17; GR64:%vreg1,%vreg17
	Considering merging to GR64 with %vreg17 in %vreg1
		RHS = %vreg1 [256r,608r:0)  0@256r
		LHS = %vreg17 [224r,240B:0)[240B,256r:2)[592r,656B:1)  0@224r 1@592r 2@240B-phi
		merge %vreg1:0@256r into %vreg17:2@240B --> @240B
		interference at %vreg17:1@592r
	Interference!
272B	%vreg0<def> = COPY %vreg16; GR64:%vreg0,%vreg16
	Considering merging to GR64 with %vreg16 in %vreg0
		RHS = %vreg0 [272r,304r:0)  0@272r
		LHS = %vreg16 [208r,240B:0)[240B,272r:2)[576r,656B:1)  0@208r 1@576r 2@240B-phi
		merge %vreg0:0@272r into %vreg16:2@240B --> @240B
		erased:	272r	%vreg0<def> = COPY %vreg16; GR64:%vreg0,%vreg16
		updated: 304B	%vreg10<def> = COPY %vreg16; GR64:%vreg10,%vreg16
	Joined. Result = %vreg16 [208r,240B:0)[240B,304r:2)[576r,656B:1)  0@208r 1@576r 2@240B-phi
304B	%vreg10<def> = COPY %vreg16; GR64:%vreg10,%vreg16
	Considering merging to GR64 with %vreg16 in %vreg10
		RHS = %vreg10 [304r,320r:0)[320r,352r:1)  0@304r 1@320r
		LHS = %vreg16 [208r,240B:0)[240B,304r:2)[576r,656B:1)  0@208r 1@576r 2@240B-phi
		merge %vreg10:0@304r into %vreg16:2@240B --> @240B
		erased:	304r	%vreg10<def> = COPY %vreg16; GR64:%vreg10,%vreg16
		updated: 320B	%vreg16<def,tied1> = SHL64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
		updated: 352B	%vreg11<def> = COPY %vreg16; GR64:%vreg11,%vreg16
	Joined. Result = %vreg16 [208r,240B:0)[240B,320r:2)[320r,352r:3)[576r,656B:1)  0@208r 1@576r 2@240B-phi 3@320r
352B	%vreg11<def> = COPY %vreg16; GR64:%vreg11,%vreg16
	Considering merging to GR64 with %vreg16 in %vreg11
		RHS = %vreg11 [352r,368r:0)[368r,480r:1)  0@352r 1@368r
		LHS = %vreg16 [208r,240B:0)[240B,320r:2)[320r,352r:3)[576r,656B:1)  0@208r 1@576r 2@240B-phi 3@320r
		merge %vreg11:0@352r into %vreg16:3@320r --> @320r
		erased:	352r	%vreg11<def> = COPY %vreg16; GR64:%vreg11,%vreg16
		updated: 368B	%vreg16<def,tied1> = SAR64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
		updated: 480B	%RAX<def> = COPY %vreg16; GR64:%vreg16
	Joined. Result = %vreg16 [208r,240B:0)[240B,320r:2)[320r,368r:3)[368r,480r:4)[576r,656B:1)  0@208r 1@576r 2@240B-phi 3@320r 4@368r
400B	%vreg12<def> = COPY %vreg1; GR64:%vreg12,%vreg1
	Considering merging to GR64 with %vreg1 in %vreg12
		RHS = %vreg1 [256r,608r:0)  0@256r
		LHS = %vreg12 [400r,416r:0)[416r,448r:1)  0@400r 1@416r
		merge %vreg12:0@400r into %vreg1:0@256r --> @256r
		interference at %vreg12:1@416r
	Interference!
448B	%vreg13<def> = COPY %vreg12; GR64:%vreg13,%vreg12
	Considering merging to GR64 with %vreg12 in %vreg13
		RHS = %vreg12 [400r,416r:0)[416r,448r:1)  0@400r 1@416r
		LHS = %vreg13 [448r,464r:0)[464r,512r:1)  0@448r 1@464r
		merge %vreg13:0@448r into %vreg12:1@416r --> @416r
		erased:	448r	%vreg13<def> = COPY %vreg12; GR64:%vreg13,%vreg12
		updated: 400B	%vreg13<def> = COPY %vreg1; GR64:%vreg13,%vreg1
		updated: 416B	%vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
	Joined. Result = %vreg13 [400r,416r:2)[416r,464r:0)[464r,512r:1)  0@416r 1@464r 2@400r
544B	%vreg2<def> = COPY %vreg14; GR64:%vreg2,%vreg14
	Considering merging to GR64 with %vreg14 in %vreg2
		RHS = %vreg14 [528r,560r:0)  0@528r
		LHS = %vreg2 [544r,592r:0)  0@544r
		merge %vreg2:0@544r into %vreg14:0@528r --> @528r
		erased:	544r	%vreg2<def> = COPY %vreg14; GR64:%vreg2,%vreg14
		updated: 528B	%vreg2<def> = COPY %RDX<kill>; GR64:%vreg2
		updated: 560B	TEST64rr %vreg2, %vreg8, %EFLAGS<imp-def>; GR64:%vreg2,%vreg8
	Joined. Result = %vreg2 [528r,592r:0)  0@528r
576B	%vreg16<def> = COPY %vreg1; GR64:%vreg16,%vreg1
	Considering merging to GR64 with %vreg1 in %vreg16
		RHS = %vreg1 [256r,608r:0)  0@256r
		LHS = %vreg16 [208r,240B:0)[240B,320r:2)[320r,368r:3)[368r,480r:4)[576r,656B:1)  0@208r 1@576r 2@240B-phi 3@320r 4@368r
		merge %vreg16:1@576r into %vreg1:0@256r --> @256r
		interference at %vreg16:3@320r
	Interference!
592B	%vreg17<def> = COPY %vreg2; GR64:%vreg17,%vreg2
	Considering merging to GR64 with %vreg2 in %vreg17
		RHS = %vreg2 [528r,592r:0)  0@528r
		LHS = %vreg17 [224r,240B:0)[240B,256r:2)[592r,656B:1)  0@224r 1@592r 2@240B-phi
		merge %vreg17:1@592r into %vreg2:0@528r --> @528r
		erased:	592r	%vreg17<def> = COPY %vreg2; GR64:%vreg17,%vreg2
		updated: 528B	%vreg17<def> = COPY %RDX<kill>; GR64:%vreg17
		updated: 560B	TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
	Joined. Result = %vreg17 [224r,240B:0)[240B,256r:2)[528r,656B:1)  0@224r 1@528r 2@240B-phi
608B	%vreg18<def> = COPY %vreg1; GR64:%vreg18,%vreg1
	Considering merging to GR64 with %vreg1 in %vreg18
		RHS = %vreg1 [256r,608r:0)  0@256r
		LHS = %vreg18 [128r,160B:0)[608r,656B:1)[656B,672r:2)  0@128r 1@608r 2@656B-phi
		merge %vreg18:1@608r into %vreg1:0@256r --> @256r
		erased:	608r	%vreg18<def> = COPY %vreg1; GR64:%vreg18,%vreg1
		updated: 256B	%vreg18<def> = COPY %vreg17; GR64:%vreg18,%vreg17
		updated: 576B	%vreg16<def> = COPY %vreg18; GR64:%vreg16,%vreg18
		updated: 400B	%vreg13<def> = COPY %vreg18; GR64:%vreg13,%vreg18
	Joined. Result = %vreg18 [128r,160B:0)[256r,656B:1)[656B,672r:2)  0@128r 1@256r 2@656B-phi
entry:
16B	%vreg5<def> = COPY %RSI; GR64:%vreg5
	Considering merging %vreg5 with %RSI
	Can only merge into reserved registers.
32B	%vreg4<def> = COPY %RDI; GR64:%vreg4
	Considering merging %vreg4 with %RDI
	Can only merge into reserved registers.
(null):
208B	%vreg16<def> = COPY %vreg6; GR64:%vreg16,%vreg6
	Considering merging to GR64 with %vreg6 in %vreg16
		RHS = %vreg6 [48r,128r:0)[160B,208r:0)  0@48r
		LHS = %vreg16 [208r,240B:0)[240B,320r:2)[320r,368r:3)[368r,480r:4)[576r,656B:1)  0@208r 1@576r 2@240B-phi 3@320r 4@368r
		merge %vreg16:0@208r into %vreg6:0@48r --> @48r
		erased:	208r	%vreg16<def> = COPY %vreg6; GR64:%vreg16,%vreg6
		updated: 48B	%vreg16<def> = COPY %vreg4; GR64:%vreg16,%vreg4
		updated: 128B	%vreg18<def> = COPY %vreg16; GR64:%vreg18,%vreg16
	Joined. Result = %vreg16 [48r,128r:0)[160B,240B:0)[240B,320r:2)[320r,368r:3)[368r,480r:4)[576r,656B:1)  0@48r 1@576r 2@240B-phi 3@320r 4@368r
while.end:
688B	%RAX<def> = COPY %vreg3; GR64:%vreg3
	Considering merging %vreg3 with %RAX
	Can only merge into reserved registers.
(null):
128B	%vreg18<def> = COPY %vreg16; GR64:%vreg18,%vreg16
	Considering merging to GR64 with %vreg16 in %vreg18
		RHS = %vreg18 [128r,160B:0)[256r,656B:1)[656B,672r:2)  0@128r 1@256r 2@656B-phi
		LHS = %vreg16 [48r,128r:0)[160B,240B:0)[240B,320r:2)[320r,368r:3)[368r,480r:4)[576r,656B:1)  0@48r 1@576r 2@240B-phi 3@320r 4@368r
		merge %vreg16:1@576r into %vreg18:1@256r --> @256r
		interference at %vreg16:3@320r
	Interference!
48B	%vreg16<def> = COPY %vreg4; GR64:%vreg16,%vreg4
	Considering merging to GR64 with %vreg4 in %vreg16
		RHS = %vreg4 [32r,48r:0)  0@32r
		LHS = %vreg16 [48r,128r:0)[160B,240B:0)[240B,320r:2)[320r,368r:3)[368r,480r:4)[576r,656B:1)  0@48r 1@576r 2@240B-phi 3@320r 4@368r
		merge %vreg16:0@48r into %vreg4:0@32r --> @32r
		erased:	48r	%vreg16<def> = COPY %vreg4; GR64:%vreg16,%vreg4
		updated: 32B	%vreg16<def> = COPY %RDI; GR64:%vreg16
	Joined. Result = %vreg16 [32r,128r:0)[160B,240B:0)[240B,320r:2)[320r,368r:3)[368r,480r:4)[576r,656B:1)  0@32r 1@576r 2@240B-phi 3@320r 4@368r
176B	%vreg7<def> = COPY %vreg5; GR64:%vreg7,%vreg5
	Considering merging to GR64 with %vreg5 in %vreg7
		RHS = %vreg7 [176r,224r:0)  0@176r
		LHS = %vreg5 [16r,112B:0)[160B,176r:0)  0@16r
		merge %vreg7:0@176r into %vreg5:0@16r --> @16r
		erased:	176r	%vreg7<def> = COPY %vreg5; GR64:%vreg7,%vreg5
		updated: 224B	%vreg17<def> = COPY %vreg5; GR64:%vreg17,%vreg5
	Joined. Result = %vreg5 [16r,112B:0)[160B,224r:0)  0@16r
224B	%vreg17<def> = COPY %vreg5; GR64:%vreg17,%vreg5
	Considering merging to GR64 with %vreg5 in %vreg17
		RHS = %vreg5 [16r,112B:0)[160B,224r:0)  0@16r
		LHS = %vreg17 [224r,240B:0)[240B,256r:2)[528r,656B:1)  0@224r 1@528r 2@240B-phi
		merge %vreg17:0@224r into %vreg5:0@16r --> @16r
		erased:	224r	%vreg17<def> = COPY %vreg5; GR64:%vreg17,%vreg5
		updated: 16B	%vreg17<def> = COPY %RSI; GR64:%vreg17
		updated: 80B	TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
	Joined. Result = %vreg17 [16r,112B:0)[160B,240B:0)[240B,256r:2)[528r,656B:1)  0@16r 1@528r 2@240B-phi
672B	%vreg3<def> = COPY %vreg18; GR64:%vreg3,%vreg18
	Considering merging to GR64 with %vreg18 in %vreg3
		RHS = %vreg3 [672r,688r:0)  0@672r
		LHS = %vreg18 [128r,160B:0)[256r,656B:1)[656B,672r:2)  0@128r 1@256r 2@656B-phi
		merge %vreg3:0@672r into %vreg18:2@656B --> @656B
		erased:	672r	%vreg3<def> = COPY %vreg18; GR64:%vreg3,%vreg18
		updated: 688B	%RAX<def> = COPY %vreg18; GR64:%vreg18
	Joined. Result = %vreg18 [128r,160B:0)[256r,656B:1)[656B,688r:2)  0@128r 1@256r 2@656B-phi
256B	%vreg18<def> = COPY %vreg17; GR64:%vreg18,%vreg17
	Considering merging to GR64 with %vreg17 in %vreg18
		RHS = %vreg18 [128r,160B:0)[256r,656B:1)[656B,688r:2)  0@128r 1@256r 2@656B-phi
		LHS = %vreg17 [16r,112B:0)[160B,240B:0)[240B,256r:2)[528r,656B:1)  0@16r 1@528r 2@240B-phi
		merge %vreg18:1@256r into %vreg17:2@240B --> @240B
		interference at %vreg17:1@528r
	Interference!
400B	%vreg13<def> = COPY %vreg18; GR64:%vreg13,%vreg18
	Considering merging to GR64 with %vreg18 in %vreg13
		RHS = %vreg18 [128r,160B:0)[256r,656B:1)[656B,688r:2)  0@128r 1@256r 2@656B-phi
		LHS = %vreg13 [400r,416r:2)[416r,464r:0)[464r,512r:1)  0@416r 1@464r 2@400r
		interference at %vreg13:0@416r
	Interference!
576B	%vreg16<def> = COPY %vreg18; GR64:%vreg16,%vreg18
	Considering merging to GR64 with %vreg18 in %vreg16
		RHS = %vreg18 [128r,160B:0)[256r,656B:1)[656B,688r:2)  0@128r 1@256r 2@656B-phi
		LHS = %vreg16 [32r,128r:0)[160B,240B:0)[240B,320r:2)[320r,368r:3)[368r,480r:4)[576r,656B:1)  0@32r 1@576r 2@240B-phi 3@320r 4@368r
		merge %vreg16:1@576r into %vreg18:1@256r --> @256r
		interference at %vreg16:3@320r
	Interference!
688B	%RAX<def> = COPY %vreg18; GR64:%vreg18
	Considering merging %vreg18 with %RAX
	Can only merge into reserved registers.
128B	%vreg18<def> = COPY %vreg16; GR64:%vreg18,%vreg16
	Considering merging to GR64 with %vreg16 in %vreg18
		RHS = %vreg18 [128r,160B:0)[256r,656B:1)[656B,688r:2)  0@128r 1@256r 2@656B-phi
		LHS = %vreg16 [32r,128r:0)[160B,240B:0)[240B,320r:2)[320r,368r:3)[368r,480r:4)[576r,656B:1)  0@32r 1@576r 2@240B-phi 3@320r 4@368r
		merge %vreg16:1@576r into %vreg18:1@256r --> @256r
		interference at %vreg16:3@320r
	Interference!
Trying to inflate 0 regs.
********** INTERVALS **********
RDI [0B,32r:0)  0@0B-phi
RSI [0B,16r:0)  0@0B-phi
%vreg8 [64r,112B:0)[160B,656B:0)  0@64r
%vreg13 [400r,416r:2)[416r,464r:0)[464r,512r:1)  0@416r 1@464r 2@400r
%vreg16 [32r,128r:0)[160B,240B:0)[240B,320r:2)[320r,368r:3)[368r,480r:4)[576r,656B:1)  0@32r 1@576r 2@240B-phi 3@320r 4@368r
%vreg17 [16r,112B:0)[160B,240B:0)[240B,256r:2)[528r,656B:1)  0@16r 1@528r 2@240B-phi
%vreg18 [128r,160B:0)[256r,656B:1)[656B,688r:2)  0@128r 1@256r 2@656B-phi
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function quantum_gcd: Post SSA
Function Live Ins: %RDI in %vreg4, %RSI in %vreg5

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI %RSI
16B		%vreg17<def> = COPY %RSI; GR64:%vreg17
32B		%vreg16<def> = COPY %RDI; GR64:%vreg16
64B		%vreg8<def> = MOV64ri 4294967295; GR64:%vreg8
80B		TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
96B		JNE_4 <BB#1>, %EFLAGS<imp-use,kill>
	    Successors according to CFG: BB#4(12) BB#1(20)

112B	BB#4: 
	    Predecessors according to CFG: BB#0
128B		%vreg18<def> = COPY %vreg16; GR64:%vreg18,%vreg16
144B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3

160B	BB#1: 
	    Predecessors according to CFG: BB#0
	    Successors according to CFG: BB#2

240B	BB#2: derived from LLVM BB %while.body
	    Predecessors according to CFG: BB#2 BB#1
256B		%vreg18<def> = COPY %vreg17; GR64:%vreg18,%vreg17
288B		%RCX<def> = MOV64ri32 32
320B		%vreg16<def,tied1> = SHL64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
336B		%RCX<def> = MOV64ri32 32
368B		%vreg16<def,tied1> = SAR64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
384B		%RCX<def> = MOV64ri32 32
400B		%vreg13<def> = COPY %vreg18; GR64:%vreg13,%vreg18
416B		%vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
432B		%RCX<def> = MOV64ri32 32
464B		%vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
480B		%RAX<def> = COPY %vreg16; GR64:%vreg16
496B		CQO %RAX<imp-def>, %RDX<imp-def>, %RAX<imp-use,kill>
512B		IDIV64r %vreg13, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use,kill>, %RDX<imp-use,kill>; GR64:%vreg13
528B		%vreg17<def> = COPY %RDX<kill>; GR64:%vreg17
560B		TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
576B		%vreg16<def> = COPY %vreg18; GR64:%vreg16,%vreg18
624B		JNE_4 <BB#2>, %EFLAGS<imp-use,kill>
640B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3(4) BB#2(124)

656B	BB#3: derived from LLVM BB %while.end
	    Predecessors according to CFG: BB#2 BB#4
688B		%RAX<def> = COPY %vreg18; GR64:%vreg18
704B		RETQ %RAX<kill>

# End machine code for function quantum_gcd.

Before MISsched:
# Machine code for function quantum_gcd: Post SSA
Function Live Ins: %RDI in %vreg4, %RSI in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %RDI %RSI
	%vreg17<def> = COPY %RSI; GR64:%vreg17
	%vreg16<def> = COPY %RDI; GR64:%vreg16
	%vreg8<def> = MOV64ri 4294967295; GR64:%vreg8
	TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
	JNE_4 <BB#1>, %EFLAGS<imp-use,kill>
    Successors according to CFG: BB#4(12) BB#1(20)

BB#4: 
    Predecessors according to CFG: BB#0
	%vreg18<def> = COPY %vreg16; GR64:%vreg18,%vreg16
	JMP_4 <BB#3>
    Successors according to CFG: BB#3

BB#1: 
    Predecessors according to CFG: BB#0
    Successors according to CFG: BB#2

BB#2: derived from LLVM BB %while.body
    Predecessors according to CFG: BB#2 BB#1
	%vreg18<def> = COPY %vreg17; GR64:%vreg18,%vreg17
	%RCX<def> = MOV64ri32 32
	%vreg16<def,tied1> = SHL64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
	%RCX<def> = MOV64ri32 32
	%vreg16<def,tied1> = SAR64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
	%RCX<def> = MOV64ri32 32
	%vreg13<def> = COPY %vreg18; GR64:%vreg13,%vreg18
	%vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
	%RCX<def> = MOV64ri32 32
	%vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
	%RAX<def> = COPY %vreg16; GR64:%vreg16
	CQO %RAX<imp-def>, %RDX<imp-def>, %RAX<imp-use,kill>
	IDIV64r %vreg13, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use,kill>, %RDX<imp-use,kill>; GR64:%vreg13
	%vreg17<def> = COPY %RDX<kill>; GR64:%vreg17
	TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
	%vreg16<def> = COPY %vreg18; GR64:%vreg16,%vreg18
	JNE_4 <BB#2>, %EFLAGS<imp-use,kill>
	JMP_4 <BB#3>
    Successors according to CFG: BB#3(4) BB#2(124)

BB#3: derived from LLVM BB %while.end
    Predecessors according to CFG: BB#2 BB#4
	%RAX<def> = COPY %vreg18; GR64:%vreg18
	RETQ %RAX<kill>

# End machine code for function quantum_gcd.

********** MI Scheduling **********
quantum_gcd:BB#0 entry
  From: %vreg17<def> = COPY %RSI; GR64:%vreg17
    To: JNE_4 <BB#1>, %EFLAGS<imp-use,kill>
 RegionInstrs: 4 Remaining: 0
Max Pressure: GR64_NOREX=2
GR64_NOREX+GR64_TC=2
GR64=3
Live In: %RCX %RIZ 
Live Out: %vreg17 %vreg8 %vreg16 
Live Thru: 
  LiveReg: %vreg17
  UpdateRegP: SU(3) TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
  LiveReg: %vreg8
  UpdateRegP: SU(3) TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
  LiveReg: %vreg16
AllocationOrder(SEGMENT_REG) = [ ]
Excess PSets: 
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %vreg17<def> = COPY %RSI; GR64:%vreg17
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
   val SU(3): Latency=0 Reg=%vreg17

SU(1):   %vreg16<def> = COPY %RDI; GR64:%vreg16
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0

SU(2):   %vreg8<def> = MOV64ri 4294967295; GR64:%vreg8
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(3): Latency=1 Reg=%vreg8

SU(3):   TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
   val SU(0): Latency=0 Reg=%vreg17
   val SU(2): Latency=1 Reg=%vreg8

Critical Path: 1
BotQ.A: 3 1 
  SU(3) ORDER                              
Pick Bot PREG-COPY
Scheduling SU(3) TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
  Ready @0c
  BotQ.A TopLatency SU(3) 1c
  *** Max MOps 1 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
BotQ.A: 1 0 2 
  SU(1) ORDER                              
  SU(2) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(2) %vreg8<def> = MOV64ri 4294967295; GR64:%vreg8
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
  *** Max MOps 1 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 2
  Executed: 2c
  Critical: 2c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 1 0 
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %vreg16<def> = COPY %RDI; GR64:%vreg16
  LiveReg: RDI
  Ready @2c
BotQ.A @2c
  Retired: 2
  Executed: 2c
  Critical: 2c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg17<def> = COPY %RSI; GR64:%vreg17
  LiveReg: RSI
  Ready @2c
BotQ.A @2c
  Retired: 2
  Executed: 2c
  Critical: 2c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg17<def> = COPY %RSI; GR64:%vreg17
SU(1):   %vreg16<def> = COPY %RDI; GR64:%vreg16
SU(2):   %vreg8<def> = MOV64ri 4294967295; GR64:%vreg8
SU(3):   TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8

********** MI Scheduling **********
quantum_gcd:BB#2 while.body
  From: %vreg18<def> = COPY %vreg17; GR64:%vreg18,%vreg17
    To: JNE_4 <BB#2>, %EFLAGS<imp-use,kill>
 RegionInstrs: 16 Remaining: 0
Max Pressure: GR64_ABCD=2
GR64_NOREX=2
GR64_NOREX+GR64_TC=2
GR64=5
Live In: %vreg8 %vreg16 %vreg17 
Live Out: %vreg16 %vreg18 %vreg17 %vreg8 
Live Thru: GR64=1
  LiveReg: %vreg16
  UpdateRegP: SU(10) %RAX<def> = COPY %vreg16; GR64:%vreg16
  UpdateRegP: SU(4) %vreg16<def,tied1> = SAR64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
  UpdateRegP: SU(2) %vreg16<def,tied1> = SHL64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
  LiveReg: %vreg18
  UpdateRegP: SU(15) %vreg16<def> = COPY %vreg18; GR64:%vreg16,%vreg18
  UpdateRegP: SU(6) %vreg13<def> = COPY %vreg18; GR64:%vreg13,%vreg18
  LiveReg: %vreg17
  UpdateRegP: SU(14) TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
  UpdateRegP: SU(0) %vreg18<def> = COPY %vreg17; GR64:%vreg18,%vreg17
  LiveReg: %vreg8
  UpdateRegP: SU(14) TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
AllocationOrder(SEGMENT_REG) = [ ]
Excess PSets: 
SU(0):   %vreg18<def> = COPY %vreg17; GR64:%vreg18,%vreg17
  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 4
  Successors:
   val SU(15): Latency=0 Reg=%vreg18
   val SU(6): Latency=0 Reg=%vreg18
   antiSU(13): Latency=0

SU(1):   %RCX<def> = MOV64ri32 32
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   out SU(3): Latency=1
   val SU(2): Latency=1 Reg=%RCX

SU(2):   %vreg16<def,tied1> = SHL64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
  # preds left       : 1
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(1): Latency=1 Reg=%RCX
  Successors:
   val SU(4): Latency=1 Reg=%vreg16
   out SU(4): Latency=1
   out SU(14): Latency=1
   antiSU(3): Latency=0

SU(3):   %RCX<def> = MOV64ri32 32
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   antiSU(2): Latency=0
   out SU(1): Latency=1
  Successors:
   out SU(5): Latency=1
   val SU(4): Latency=1 Reg=%RCX

SU(4):   %vreg16<def,tied1> = SAR64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
  # preds left       : 3
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
   val SU(2): Latency=1 Reg=%vreg16
   val SU(3): Latency=1 Reg=%RCX
   out SU(2): Latency=1
  Successors:
   val SU(10): Latency=1 Reg=%vreg16
   out SU(15): Latency=1
   out SU(14): Latency=1
   antiSU(5): Latency=0

SU(5):   %RCX<def> = MOV64ri32 32
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
   antiSU(4): Latency=0
   out SU(3): Latency=1
  Successors:
   out SU(8): Latency=1
   val SU(7): Latency=1 Reg=%RCX

SU(6):   %vreg13<def> = COPY %vreg18; GR64:%vreg13,%vreg18
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 4
  Predecessors:
   val SU(0): Latency=0 Reg=%vreg18
  Successors:
   val SU(7): Latency=0 Reg=%vreg13
   out SU(7): Latency=1

SU(7):   %vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  # preds left       : 3
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
   val SU(5): Latency=1 Reg=%RCX
   out SU(6): Latency=1
   val SU(6): Latency=0 Reg=%vreg13
  Successors:
   val SU(9): Latency=1 Reg=%vreg13
   out SU(9): Latency=1
   out SU(14): Latency=1
   antiSU(8): Latency=0

SU(8):   %RCX<def> = MOV64ri32 32
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
   antiSU(7): Latency=0
   out SU(5): Latency=1
  Successors:
   val SU(9): Latency=1 Reg=%RCX

SU(9):   %vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
   val SU(7): Latency=1 Reg=%vreg13
   val SU(8): Latency=1 Reg=%RCX
   out SU(7): Latency=1
  Successors:
   val SU(12): Latency=1 Reg=%vreg13
   out SU(14): Latency=1

SU(10):   %RAX<def> = COPY %vreg16; GR64:%vreg16
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 3
  Predecessors:
   val SU(4): Latency=1 Reg=%vreg16
  Successors:
   out SU(11): Latency=1
   val SU(11): Latency=0 Reg=%RAX
   antiSU(15): Latency=0

SU(11):   CQO %RAX<imp-def>, %RDX<imp-def>, %RAX<imp-use,kill>
  # preds left       : 2
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
   out SU(10): Latency=1
   val SU(10): Latency=0 Reg=%RAX
  Successors:
   out SU(12): Latency=1
   val SU(12): Latency=1 Reg=%RAX
   out SU(12): Latency=1
   val SU(12): Latency=1 Reg=%RDX

SU(12):   IDIV64r %vreg13, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use,kill>, %RDX<imp-use,kill>; GR64:%vreg13
  # preds left       : 5
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
   val SU(9): Latency=1 Reg=%vreg13
   out SU(11): Latency=1
   val SU(11): Latency=1 Reg=%RAX
   out SU(11): Latency=1
   val SU(11): Latency=1 Reg=%RDX
  Successors:
   val SU(13): Latency=1 Reg=%RDX
   out SU(14): Latency=1

SU(13):   %vreg17<def> = COPY %RDX<kill>; GR64:%vreg17
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 0
  Predecessors:
   val SU(12): Latency=1 Reg=%RDX
   antiSU(0): Latency=0
  Successors:
   val SU(14): Latency=0 Reg=%vreg17

SU(14):   TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
  # preds left       : 6
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
   val SU(13): Latency=0 Reg=%vreg17
   out SU(12): Latency=1
   out SU(9): Latency=1
   out SU(7): Latency=1
   out SU(4): Latency=1
   out SU(2): Latency=1

SU(15):   %vreg16<def> = COPY %vreg18; GR64:%vreg16,%vreg18
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
   val SU(0): Latency=0 Reg=%vreg18
   antiSU(10): Latency=0
   out SU(4): Latency=1

Critical Path: 6
Cyclic Path: SU(15) -> SU(2) = 2c
Cyclic Path: SU(13) -> SU(0) = 4c
Cyclic Critical Path: 4c
IssueCycles=0c IterCycles=4c NumIters=2 InFlight=0m BufferLim=0m
BotQ.A: 15 14 
  SU(15) ORDER                              
Pick Bot ORDER     
Scheduling SU(15) %vreg16<def> = COPY %vreg18; GR64:%vreg16,%vreg18
  Ready @0c
  BotQ.A TopLatency SU(15) 3c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
Scheduling SU(14) TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
  Ready @0c
  BotQ.A TopLatency SU(14) 6c
  *** Max MOps 1 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
Scheduling SU(13) %vreg17<def> = COPY %RDX<kill>; GR64:%vreg17
  LiveReg: RDX
  Ready @1c
  BotQ.A TopLatency SU(13) 6c
BotQ.A @1c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
Scheduling SU(12) IDIV64r %vreg13, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use,kill>, %RDX<imp-use,kill>; GR64:%vreg13
  GR64_ABCD: 2 > 4(+ 0 livethru)
  LiveReg: %vreg13
  UpdateRegP: SU(12) IDIV64r %vreg13, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use,kill>, %RDX<imp-use,kill>; GR64:%vreg13
  UpdateRegP: SU(9) %vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  UpdateRegP: SU(7) %vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  LiveReg: RAX
  LiveReg: RDX
  Ready @1c
  BotQ.A BotLatency SU(12) 1c
  *** Max MOps 1 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 2
  Executed: 2c
  Critical: 2c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 9 11 
  SU(9) ORDER                              
  SU(11) REG-MAX                            
Pick Bot REG-MAX   
Scheduling SU(11) CQO %RAX<imp-def>, %RDX<imp-def>, %RAX<imp-use,kill>
  GR64_ABCD: 2 > 4(+ 0 livethru)
  LiveReg: RAX
  Ready @2c
  BotQ.A BotLatency SU(11) 2c
  *** Max MOps 1 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 3
  Executed: 3c
  Critical: 3c, 3 MOps
  ExpectedLatency: 2c
  - Latency limited.
BotQ.A: 9 10 
  SU(9) ORDER                              
  SU(10) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(10) %RAX<def> = COPY %vreg16; GR64:%vreg16
  GR64_ABCD: 2 > 4(+ 0 livethru)
  LiveReg: %vreg16
  UpdateRegP: SU(10) %RAX<def> = COPY %vreg16; GR64:%vreg16
  UpdateRegP: SU(4) %vreg16<def,tied1> = SAR64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
  UpdateRegP: SU(2) %vreg16<def,tied1> = SHL64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
  Ready @3c
  BotQ.A BotLatency SU(10) 3c
BotQ.A @3c
  Retired: 3
  Executed: 3c
  Critical: 3c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
Scheduling SU(9) %vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  GR64_ABCD: 2 > 4(+ 0 livethru)
  LiveReg: %vreg13
  UpdateRegP: SU(12) IDIV64r %vreg13, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use,kill>, %RDX<imp-use,kill>; GR64:%vreg13
  UpdateRegP: SU(9) %vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  UpdateRegP: SU(7) %vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  LiveReg: RCX
  Ready @3c
  *** Max MOps 1 at cycle 3
Cycle: 4 BotQ.A
BotQ.A @4c
  Retired: 4
  Executed: 4c
  Critical: 4c, 4 MOps
  ExpectedLatency: 3c
  - Latency limited.
Scheduling SU(8) %RCX<def> = MOV64ri32 32
  GR64_ABCD: 2 > 4(+ 0 livethru)
  Ready @4c
  *** Max MOps 1 at cycle 4
Cycle: 5 BotQ.A
BotQ.A @5c
  Retired: 5
  Executed: 5c
  Critical: 5c, 5 MOps
  ExpectedLatency: 3c
  - Latency limited.
Scheduling SU(7) %vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  GR64_ABCD: 2 > 4(+ 0 livethru)
  LiveReg: %vreg13
  UpdateRegP: SU(12) IDIV64r %vreg13, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use,kill>, %RDX<imp-use,kill>; GR64:%vreg13
  UpdateRegP: SU(9) %vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  UpdateRegP: SU(7) %vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
  LiveReg: RCX
  Ready @5c
  BotQ.A TopLatency SU(7) 3c
  *** Max MOps 1 at cycle 5
Cycle: 6 BotQ.A
BotQ.A @6c
  Retired: 6
  Executed: 6c
  Critical: 6c, 6 MOps
  ExpectedLatency: 3c
  - Latency limited.
BotQ.A: 5 6 
  SU(5) ORDER                              
  SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %vreg13<def> = COPY %vreg18; GR64:%vreg13,%vreg18
  Ready @6c
  BotQ.A BotLatency SU(6) 4c
BotQ.A @6c
  Retired: 6
  Executed: 6c
  Critical: 6c, 6 MOps
  ExpectedLatency: 4c
  - Latency limited.
BotQ.A: 5 0 
  SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %RCX<def> = MOV64ri32 32
  GR64_ABCD: 2 > 4(+ 0 livethru)
  Ready @6c
  *** Max MOps 1 at cycle 6
Cycle: 7 BotQ.A
BotQ.A @7c
  Retired: 7
  Executed: 7c
  Critical: 7c, 7 MOps
  ExpectedLatency: 4c
  - Latency limited.
BotQ.A: 0 4 
  SU(0) ORDER                              
  SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %vreg16<def,tied1> = SAR64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
  GR64_ABCD: 2 > 4(+ 0 livethru)
  LiveReg: %vreg16
  UpdateRegP: SU(10) %RAX<def> = COPY %vreg16; GR64:%vreg16
  UpdateRegP: SU(4) %vreg16<def,tied1> = SAR64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
  UpdateRegP: SU(2) %vreg16<def,tied1> = SHL64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
  LiveReg: RCX
  Ready @7c
  BotQ.A TopLatency SU(4) 2c
  *** Max MOps 1 at cycle 7
Cycle: 8 BotQ.A
BotQ.A @8c
  Retired: 8
  Executed: 8c
  Critical: 8c, 8 MOps
  ExpectedLatency: 4c
  - Latency limited.
BotQ.A: 0 3 
  SU(0) ORDER                              
  SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %RCX<def> = MOV64ri32 32
  GR64_ABCD: 2 > 4(+ 0 livethru)
  Ready @8c
  BotQ.A BotLatency SU(3) 5c
  *** Max MOps 1 at cycle 8
Cycle: 9 BotQ.A
BotQ.A @9c
  Retired: 9
  Executed: 9c
  Critical: 9c, 9 MOps
  ExpectedLatency: 5c
  - Latency limited.
BotQ.A: 0 2 
  SU(0) ORDER                              
  SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %vreg16<def,tied1> = SHL64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
  GR64_ABCD: 2 > 4(+ 0 livethru)
  LiveReg: %vreg16
  UpdateRegP: SU(10) %RAX<def> = COPY %vreg16; GR64:%vreg16
  UpdateRegP: SU(4) %vreg16<def,tied1> = SAR64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
  UpdateRegP: SU(2) %vreg16<def,tied1> = SHL64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
  LiveReg: RCX
  Ready @9c
  BotQ.A TopLatency SU(2) 1c
  *** Max MOps 1 at cycle 9
Cycle: 10 BotQ.A
BotQ.A @10c
  Retired: 10
  Executed: 10c
  Critical: 10c, 10 MOps
  ExpectedLatency: 5c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %RCX<def> = MOV64ri32 32
  GR64_ABCD: 2 > 4(+ 0 livethru)
  Ready @10c
  BotQ.A BotLatency SU(1) 6c
  *** Max MOps 1 at cycle 10
Cycle: 11 BotQ.A
BotQ.A @11c
  Retired: 11
  Executed: 11c
  Critical: 11c, 11 MOps
  ExpectedLatency: 6c
  - Latency limited.
Scheduling SU(0) %vreg18<def> = COPY %vreg17; GR64:%vreg18,%vreg17
  LiveReg: %vreg17
  UpdateRegP: SU(14) TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
  UpdateRegP: SU(0) %vreg18<def> = COPY %vreg17; GR64:%vreg18,%vreg17
  Ready @11c
BotQ.A @11c
  Retired: 11
  Executed: 11c
  Critical: 11c, 11 MOps
  ExpectedLatency: 6c
  - Latency limited.
*** Final schedule for BB#2 ***
SU(0):   %vreg18<def> = COPY %vreg17; GR64:%vreg18,%vreg17
SU(1):   %RCX<def> = MOV64ri32 32
SU(2):   %vreg16<def,tied1> = SHL64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
SU(3):   %RCX<def> = MOV64ri32 32
SU(4):   %vreg16<def,tied1> = SAR64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
SU(5):   %RCX<def> = MOV64ri32 32
SU(6):   %vreg13<def> = COPY %vreg18; GR64:%vreg13,%vreg18
SU(7):   %vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
SU(8):   %RCX<def> = MOV64ri32 32
SU(9):   %vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
SU(10):   %RAX<def> = COPY %vreg16; GR64:%vreg16
SU(11):   CQO %RAX<imp-def>, %RDX<imp-def>, %RAX<imp-use,kill>
SU(12):   IDIV64r %vreg13, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use,kill>, %RDX<imp-use,kill>; GR64:%vreg13
SU(13):   %vreg17<def> = COPY %RDX<kill>; GR64:%vreg17
SU(14):   TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
SU(15):   %vreg16<def> = COPY %vreg18; GR64:%vreg16,%vreg18

********** INTERVALS **********
RDI [0B,32r:0)  0@0B-phi
RSI [0B,16r:0)  0@0B-phi
%vreg8 [64r,112B:0)[160B,656B:0)  0@64r
%vreg13 [400r,416r:2)[416r,464r:0)[464r,512r:1)  0@416r 1@464r 2@400r
%vreg16 [32r,128r:0)[160B,240B:0)[240B,320r:2)[320r,368r:3)[368r,480r:4)[576r,656B:1)  0@32r 1@576r 2@240B-phi 3@320r 4@368r
%vreg17 [16r,112B:0)[160B,240B:0)[240B,256r:2)[528r,656B:1)  0@16r 1@528r 2@240B-phi
%vreg18 [128r,160B:0)[256r,656B:1)[656B,688r:2)  0@128r 1@256r 2@656B-phi
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function quantum_gcd: Post SSA
Function Live Ins: %RDI in %vreg4, %RSI in %vreg5

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI %RSI
16B		%vreg17<def> = COPY %RSI; GR64:%vreg17
32B		%vreg16<def> = COPY %RDI; GR64:%vreg16
64B		%vreg8<def> = MOV64ri 4294967295; GR64:%vreg8
80B		TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
96B		JNE_4 <BB#1>, %EFLAGS<imp-use,kill>
	    Successors according to CFG: BB#4(12) BB#1(20)

112B	BB#4: 
	    Predecessors according to CFG: BB#0
128B		%vreg18<def> = COPY %vreg16; GR64:%vreg18,%vreg16
144B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3

160B	BB#1: 
	    Predecessors according to CFG: BB#0
	    Successors according to CFG: BB#2

240B	BB#2: derived from LLVM BB %while.body
	    Predecessors according to CFG: BB#2 BB#1
256B		%vreg18<def> = COPY %vreg17; GR64:%vreg18,%vreg17
288B		%RCX<def> = MOV64ri32 32
320B		%vreg16<def,tied1> = SHL64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
336B		%RCX<def> = MOV64ri32 32
368B		%vreg16<def,tied1> = SAR64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
384B		%RCX<def> = MOV64ri32 32
400B		%vreg13<def> = COPY %vreg18; GR64:%vreg13,%vreg18
416B		%vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
432B		%RCX<def> = MOV64ri32 32
464B		%vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
480B		%RAX<def> = COPY %vreg16; GR64:%vreg16
496B		CQO %RAX<imp-def>, %RDX<imp-def>, %RAX<imp-use,kill>
512B		IDIV64r %vreg13, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use,kill>, %RDX<imp-use,kill>; GR64:%vreg13
528B		%vreg17<def> = COPY %RDX<kill>; GR64:%vreg17
560B		TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
576B		%vreg16<def> = COPY %vreg18; GR64:%vreg16,%vreg18
624B		JNE_4 <BB#2>, %EFLAGS<imp-use,kill>
640B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3(4) BB#2(124)

656B	BB#3: derived from LLVM BB %while.end
	    Predecessors according to CFG: BB#2 BB#4
688B		%RAX<def> = COPY %vreg18; GR64:%vreg18
704B		RETQ %RAX<kill>

# End machine code for function quantum_gcd.

RPO[BB#0 derived from LLVM BB entry] = 1
RPO[BB#1] = 2
RPO[BB#2 derived from LLVM BB while.body] = 3
RPO[BB#4] = 4
RPO[BB#3 derived from LLVM BB while.end] = 5
POT: BB#3 derived from LLVM BB while.end
POT: BB#4
POT: BB#2 derived from LLVM BB while.body
doLoop(BB#2 derived from LLVM BB while.body, BB#2 derived from LLVM BB while.body)
doBlock(BB#2 derived from LLVM BB while.body)
Frequency(BB#2 derived from LLVM BB while.body) = 0.0
Frequency(BB#2 derived from LLVM BB while.body) = 1.0
LoopExitProb[BB#2 derived from LLVM BB while.body] = 512 / 16384 = 3.125% from 1 - 0.96875 / 1.0.
POT: BB#1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#3 derived from LLVM BB while.end)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
doBlock(BB#1)
Frequency(BB#1) = 0.0
Frequency(BB#1) = 0.625
doBlock(BB#2 derived from LLVM BB while.body)
Frequency(BB#2 derived from LLVM BB while.body) = 0.0
Frequency(BB#2 derived from LLVM BB while.body) += 0.625 --> 0.625
Loop header scaled to 20.0.
doBlock(BB#4)
Frequency(BB#4) = 0.0
Frequency(BB#4) = 0.375
doBlock(BB#3 derived from LLVM BB while.end)
Frequency(BB#3 derived from LLVM BB while.end) = 0.0
Frequency(BB#3 derived from LLVM BB while.end) += 0.625 --> 0.625
Frequency(BB#3 derived from LLVM BB while.end) += 0.375 --> 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** COMPUTING LIVE DEBUG VARIABLES: quantum_gcd **********
********** DEBUG VARIABLES **********
********** GREEDY REGISTER ALLOCATION **********
********** Function: quantum_gcd
********** Compute Spill Weights **********
********** Function: quantum_gcd
********** INTERVALS **********
RDI [0B,32r:0)  0@0B-phi
RSI [0B,16r:0)  0@0B-phi
%vreg8 [64r,112B:0)[160B,656B:0)  0@64r
%vreg13 [400r,416r:2)[416r,464r:0)[464r,512r:1)  0@416r 1@464r 2@400r
%vreg16 [32r,128r:0)[160B,240B:0)[240B,320r:2)[320r,368r:3)[368r,480r:4)[576r,656B:1)  0@32r 1@576r 2@240B-phi 3@320r 4@368r
%vreg17 [16r,112B:0)[160B,240B:0)[240B,256r:2)[528r,656B:1)  0@16r 1@528r 2@240B-phi
%vreg18 [128r,160B:0)[256r,656B:1)[656B,688r:2)  0@128r 1@256r 2@656B-phi
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function quantum_gcd: Post SSA
Function Live Ins: %RDI in %vreg4, %RSI in %vreg5

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI %RSI
16B		%vreg17<def> = COPY %RSI; GR64:%vreg17
32B		%vreg16<def> = COPY %RDI; GR64:%vreg16
64B		%vreg8<def> = MOV64ri 4294967295; GR64:%vreg8
80B		TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
96B		JNE_4 <BB#1>, %EFLAGS<imp-use,kill>
	    Successors according to CFG: BB#4(12) BB#1(20)

112B	BB#4: 
	    Predecessors according to CFG: BB#0
128B		%vreg18<def> = COPY %vreg16; GR64:%vreg18,%vreg16
144B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3

160B	BB#1: 
	    Predecessors according to CFG: BB#0
	    Successors according to CFG: BB#2

240B	BB#2: derived from LLVM BB %while.body
	    Predecessors according to CFG: BB#2 BB#1
256B		%vreg18<def> = COPY %vreg17; GR64:%vreg18,%vreg17
288B		%RCX<def> = MOV64ri32 32
320B		%vreg16<def,tied1> = SHL64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
336B		%RCX<def> = MOV64ri32 32
368B		%vreg16<def,tied1> = SAR64rCL %vreg16<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg16
384B		%RCX<def> = MOV64ri32 32
400B		%vreg13<def> = COPY %vreg18; GR64:%vreg13,%vreg18
416B		%vreg13<def,tied1> = SHL64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
432B		%RCX<def> = MOV64ri32 32
464B		%vreg13<def,tied1> = SAR64rCL %vreg13<tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use,kill>; GR64:%vreg13
480B		%RAX<def> = COPY %vreg16; GR64:%vreg16
496B		CQO %RAX<imp-def>, %RDX<imp-def>, %RAX<imp-use,kill>
512B		IDIV64r %vreg13, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use,kill>, %RDX<imp-use,kill>; GR64:%vreg13
528B		%vreg17<def> = COPY %RDX<kill>; GR64:%vreg17
560B		TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
576B		%vreg16<def> = COPY %vreg18; GR64:%vreg16,%vreg18
624B		JNE_4 <BB#2>, %EFLAGS<imp-use,kill>
640B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3(4) BB#2(124)

656B	BB#3: derived from LLVM BB %while.end
	    Predecessors according to CFG: BB#2 BB#4
688B		%RAX<def> = COPY %vreg18; GR64:%vreg18
704B		RETQ %RAX<kill>

# End machine code for function quantum_gcd.


selectOrSplit GR64:%vreg16 [32r,128r:0)[160B,240B:0)[240B,320r:2)[320r,368r:3)[368r,480r:4)[576r,656B:1)  0@32r 1@576r 2@240B-phi 3@320r 4@368r w=3.622642e-01
hints: %RAX
assigning %vreg16 to %RAX: RAX

selectOrSplit GR64:%vreg18 [128r,160B:0)[256r,656B:1)[656B,688r:2)  0@128r 1@256r 2@656B-phi w=1.187804e-01
hints: %RAX
missed hint %RAX
assigning %vreg18 to %RSI: RSI

selectOrSplit GR64:%vreg17 [16r,112B:0)[160B,240B:0)[240B,256r:2)[528r,656B:1)  0@16r 1@528r 2@240B-phi w=1.434819e-01
hints: %RDX
assigning %vreg17 to %RDX: RDX

selectOrSplit GR64:%vreg8 [64r,112B:0)[160B,656B:0)  0@64r w=1.167728e-02
assigning %vreg8 to %RDI: RDI

selectOrSplit GR64:%vreg13 [400r,416r:2)[416r,464r:0)[464r,512r:1)  0@416r 1@464r 2@400r w=2.367187e-01
hints: %RSI
%R8 is available at cost 1
Only trying the first 10 regs.
should evict: %vreg18 [128r,160B:0)[256r,656B:1)[656B,688r:2)  0@128r 1@256r 2@656B-phi w= 1.187804e-01
evicting %RSI interference: Cascade 1
unassigning %vreg18 from %RSI: RSI
assigning %vreg13 to %RSI: RSI
queuing new interval: %vreg18 [128r,160B:0)[256r,656B:1)[656B,688r:2)  0@128r 1@256r 2@656B-phi

selectOrSplit GR64:%vreg18 [128r,160B:0)[256r,656B:1)[656B,688r:2)  0@128r 1@256r 2@656B-phi w=1.187804e-01
hints: %RAX
missed hint %RAX
%R8 is available at cost 1
Only trying the first 10 regs.
should evict: %vreg8 [64r,112B:0)[160B,656B:0)  0@64r w= 1.167728e-02
%RBX would clobber CSR %RBX
evicting %RDI interference: Cascade 1
unassigning %vreg8 from %RDI: RDI
assigning %vreg18 to %RDI: RDI
queuing new interval: %vreg8 [64r,112B:0)[160B,656B:0)  0@64r

selectOrSplit GR64:%vreg8 [64r,112B:0)[160B,656B:0)  0@64r w=1.167728e-02
%R8 is available at cost 1
Only trying the first 10 regs.
%RBX would clobber CSR %RBX
assigning %vreg8 to %R8: R8
********** REWRITE VIRTUAL REGISTERS **********
********** Function: quantum_gcd
********** REGISTER MAP **********
[%vreg8 -> %R8] GR64
[%vreg13 -> %RSI] GR64
[%vreg16 -> %RAX] GR64
[%vreg17 -> %RDX] GR64
[%vreg18 -> %RDI] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %RDI %RSI
16B		%vreg17<def> = COPY %RSI; GR64:%vreg17
32B		%vreg16<def> = COPY %RDI; GR64:%vreg16
64B		%vreg8<def> = MOV64ri 4294967295; GR64:%vreg8
80B		TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
96B		JNE_4 <BB#1>, %EFLAGS<imp-use,kill>
	    Successors according to CFG: BB#4(12) BB#1(20)
> %RDX<def> = COPY %RSI
> %RAX<def> = COPY %RDI
> %R8<def> = MOV64ri 4294967295
> TEST64rr %RDX, %R8, %EFLAGS<imp-def>
> JNE_4 <BB#1>, %EFLAGS<imp-use,kill>
112B	BB#4: 
	    Live Ins: %RAX
	    Predecessors according to CFG: BB#0
128B		%vreg18<def> = COPY %vreg16<kill>; GR64:%vreg18,%vreg16
144B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3
> %RDI<def> = COPY %RAX<kill>
> JMP_4 <BB#3>
160B	BB#1: 
	    Live Ins: %R8 %RAX %RDX
	    Predecessors according to CFG: BB#0
	    Successors according to CFG: BB#2
240B	BB#2: derived from LLVM BB %while.body
	    Live Ins: %R8 %RAX %RDX
	    Predecessors according to CFG: BB#2 BB#1
256B		%vreg18<def> = COPY %vreg17<kill>; GR64:%vreg18,%vreg17
288B		%RCX<def> = MOV64ri32 32
320B		%vreg16<def,tied1> = SHL64rCL %vreg16<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg16
336B		%RCX<def> = MOV64ri32 32
368B		%vreg16<def,tied1> = SAR64rCL %vreg16<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg16
384B		%RCX<def> = MOV64ri32 32
400B		%vreg13<def> = COPY %vreg18; GR64:%vreg13,%vreg18
416B		%vreg13<def,tied1> = SHL64rCL %vreg13<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg13
432B		%RCX<def> = MOV64ri32 32
464B		%vreg13<def,tied1> = SAR64rCL %vreg13<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>; GR64:%vreg13
480B		%RAX<def> = COPY %vreg16<kill>; GR64:%vreg16
496B		CQO %RAX<imp-def>, %RDX<imp-def>, %RAX<imp-use>
512B		IDIV64r %vreg13<kill>, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use>, %RDX<imp-use>; GR64:%vreg13
528B		%vreg17<def> = COPY %RDX; GR64:%vreg17
560B		TEST64rr %vreg17, %vreg8, %EFLAGS<imp-def>; GR64:%vreg17,%vreg8
576B		%vreg16<def> = COPY %vreg18; GR64:%vreg16,%vreg18
624B		JNE_4 <BB#2>, %EFLAGS<imp-use,kill>
640B		JMP_4 <BB#3>
	    Successors according to CFG: BB#3(4) BB#2(124)
> %RDI<def> = COPY %RDX<kill>
> %RCX<def> = MOV64ri32 32
> %RAX<def,tied1> = SHL64rCL %RAX<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>
> %RCX<def> = MOV64ri32 32
> %RAX<def,tied1> = SAR64rCL %RAX<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>
> %RCX<def> = MOV64ri32 32
> %RSI<def> = COPY %RDI
> %RSI<def,tied1> = SHL64rCL %RSI<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>
> %RCX<def> = MOV64ri32 32
> %RSI<def,tied1> = SAR64rCL %RSI<kill,tied0>, %EFLAGS<imp-def,dead>, %RCX<imp-use>
> %RAX<def> = COPY %RAX<kill>
Deleting identity copy.
> CQO %RAX<imp-def>, %RDX<imp-def>, %RAX<imp-use>
> IDIV64r %RSI<kill>, %RAX<imp-def,dead>, %RDX<imp-def>, %EFLAGS<imp-def,dead>, %RAX<imp-use>, %RDX<imp-use>
> %RDX<def> = COPY %RDX
Deleting identity copy.
> TEST64rr %RDX, %R8, %EFLAGS<imp-def>
> %RAX<def> = COPY %RDI
> JNE_4 <BB#2>, %EFLAGS<imp-use,kill>
> JMP_4 <BB#3>
656B	BB#3: derived from LLVM BB %while.end
	    Live Ins: %RDI
	    Predecessors according to CFG: BB#2 BB#4
688B		%RAX<def> = COPY %vreg18<kill>; GR64:%vreg18
704B		RETQ %RAX
> %RAX<def> = COPY %RDI<kill>
> RETQ %RAX
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: quantum_gcd
******** Post-regalloc Machine LICM: quantum_gcd ********

TryTailMergeBlocks: BB#2, BB#4
  with successor BB#3
  which has fall-through from BB#2
Looking for common tails of at least 3 instructions

Removing MBB: BB#2: 
    Live Ins: %R8 %RAX %RDX
    Successors according to CFG: BB#3

TryTailMergeBlocks: BB#3, BB#1
  with successor BB#4
  which has fall-through from BB#3
Looking for common tails of at least 3 instructions

*** Tail-duplicating BB#1

*** Tail-duplicating BB#3

Tail-duplicating into PredBB: BB#1: 
    Live Ins: %RAX
    Predecessors according to CFG: BB#0
	%RDI<def> = COPY %RAX<kill>
	JMP_4 <BB#3>
    Successors according to CFG: BB#3
From Succ: BB#3: derived from LLVM BB %while.end
    Live Ins: %RDI
    Predecessors according to CFG: BB#2 BB#1
	%RAX<def> = COPY %RDI<kill>
	RETQ %RAX

*** Tail-duplicating BB#3
MCP: CopyPropagateBlock entry
MCP: Copy is a deletion candidate:   %RDX<def> = COPY %RSI
MCP: Copy is a deletion candidate:   %RAX<def> = COPY %RDI
MCP: Copy is used - not dead:   %RDX<def> = COPY %RSI
MCP: CopyPropagateBlock (null)
MCP: Copy is a deletion candidate:   %RDI<def> = COPY %RAX<kill>
MCP: copy is a NOP, removing:   %RAX<def> = COPY %RDI<kill>
MCP: CopyPropagateBlock while.body
MCP: Copy is a deletion candidate:   %RDI<def> = COPY %RDX<kill>
MCP: Copy is no longer dead:   %RDI<def> = COPY %RDX<kill>
MCP: Copy is a deletion candidate:   %RSI<def> = COPY %RDI
MCP: Copy is used - not dead:   %RSI<def> = COPY %RDI
MCP: Copy is no longer dead:   %RDI<def> = COPY %RDX<kill>
MCP: Copy is a deletion candidate:   %RAX<def> = COPY %RDI
MCP: CopyPropagateBlock while.end
MCP: Copy is a deletion candidate:   %RAX<def> = COPY %RDI<kill>
MCP: Copy is used - not dead:   %RAX<def> = COPY %RDI<kill>
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: quantum_gcd
real copy:   %RDX<def> = COPY %RSI
replaced by: %RDX<def> = MOV64rr %RSI
real copy:   %RAX<def> = COPY %RDI
replaced by: %RAX<def> = MOV64rr %RDI
real copy:   %RDI<def> = COPY %RDX<kill>
replaced by: %RDI<def> = MOV64rr %RDX<kill>
real copy:   %RSI<def> = COPY %RDI
replaced by: %RSI<def> = MOV64rr %RDI
real copy:   %RAX<def> = COPY %RDI
replaced by: %RAX<def> = MOV64rr %RDI
real copy:   %RAX<def> = COPY %RDI<kill>
replaced by: %RAX<def> = MOV64rr %RDI<kill>
RPO[BB#0 derived from LLVM BB entry] = 1
RPO[BB#2 derived from LLVM BB while.body] = 2
RPO[BB#3 derived from LLVM BB while.end] = 3
RPO[BB#1] = 4
POT: BB#1
POT: BB#3 derived from LLVM BB while.end
POT: BB#2 derived from LLVM BB while.body
doLoop(BB#2 derived from LLVM BB while.body, BB#2 derived from LLVM BB while.body)
doBlock(BB#2 derived from LLVM BB while.body)
Frequency(BB#2 derived from LLVM BB while.body) = 0.0
Frequency(BB#2 derived from LLVM BB while.body) = 1.0
LoopExitProb[BB#2 derived from LLVM BB while.body] = 512 / 16384 = 3.125% from 1 - 0.96875 / 1.0.
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#1)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
doBlock(BB#2 derived from LLVM BB while.body)
Frequency(BB#2 derived from LLVM BB while.body) = 0.0
Frequency(BB#2 derived from LLVM BB while.body) += 0.625 --> 0.625
Loop header scaled to 20.0.
doBlock(BB#3 derived from LLVM BB while.end)
Frequency(BB#3 derived from LLVM BB while.end) = 0.0
Frequency(BB#3 derived from LLVM BB while.end) = 0.625
doBlock(BB#1)
Frequency(BB#1) = 0.0
Frequency(BB#1) = 0.375
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
Finding best loop top for: BB#2 (derived from LLVM BB 'while.body')
    header pred: BB#2 (derived from LLVM BB 'while.body'), 2 successors, 20.0 freq
Finding best loop exit for: BB#2 (derived from LLVM BB 'while.body')
    exiting: BB#2 (derived from LLVM BB 'while.body') -> BB#3 (derived from LLVM BB 'while.end') [L:0] (0.625)
Attempting merge from: BB#2 (derived from LLVM BB 'while.body')
    BB#2 (derived from LLVM BB 'while.body') -> Already merged!
Finished forming chain for header block BB#2
          ... BB#2 (derived from LLVM BB 'while.body')
Attempting merge from: BB#0 (derived from LLVM BB 'entry')
    BB#1 (derived from LLVM BB '(null)') -> 12 / 32 = 37.5% (prob)
    BB#2 (derived from LLVM BB 'while.body') -> 20 / 32 = 62.5% (prob)
Merging from BB#0 to BB#2
Attempting merge from: BB#2 (derived from LLVM BB 'while.body')
    BB#3 (derived from LLVM BB 'while.end') -> 4 / 128 = 3.125% (prob)
    BB#2 (derived from LLVM BB 'while.body') -> Already merged!
Merging from BB#2 to BB#3
Attempting merge from: BB#3 (derived from LLVM BB 'while.end')
    BB#1 (derived from LLVM BB '(null)') -> 0.375 (freq)
Merging from BB#3 to BB#1
Attempting merge from: BB#1 (derived from LLVM BB '(null)')
Finished forming chain for header block BB#0
Placing chain BB#0 (derived from LLVM BB 'entry')
          ... BB#2 (derived from LLVM BB 'while.body')
          ... BB#3 (derived from LLVM BB 'while.end')
          ... BB#1 (derived from LLVM BB '(null)')
********** Constant Hoisting **********
********** Function: quantum_frac_approx
CGP: Found      local addrmode: [Base:%a]
CGP: Found      local addrmode: [Base:%b]
llc: /var/services/homes/akale/llvm523/llvm_backend/include/llvm/Target/TargetLowering.h:1527: llvm::TargetLoweringBase::LegalizeKind llvm::TargetLoweringBase::getTypeConversion(llvm::LLVMContext&, llvm::EVT) const: Assertion `(LA == TypeLegal || ValueTypeActions.getTypeAction(NVT) != TypePromoteInteger) && "Promote may not follow Expand or Promote"' failed.
0  llc             0x00000000010c9e9e llvm::sys::PrintStackTrace(_IO_FILE*) + 38
1  llc             0x00000000010ca11b
2  llc             0x00000000010c9b71
3  libpthread.so.0 0x00007f33e6c8a340
4  libc.so.6       0x00007f33e5ec7cc9 gsignal + 57
5  libc.so.6       0x00007f33e5ecb0d8 abort + 328
6  libc.so.6       0x00007f33e5ec0b86
7  libc.so.6       0x00007f33e5ec0c32
8  llc             0x00000000008508a5
9  llc             0x00000000008634d7
10 llc             0x0000000000a8fa5f
11 llc             0x0000000000a97323
12 llc             0x0000000000a9775c
13 llc             0x0000000000a8e508
14 llc             0x000000000104360a llvm::FPPassManager::runOnFunction(llvm::Function&) + 290
15 llc             0x000000000104377a llvm::FPPassManager::runOnModule(llvm::Module&) + 84
16 llc             0x0000000001043a98
17 llc             0x0000000001044082 llvm::legacy::PassManagerImpl::run(llvm::Module&) + 244
18 llc             0x000000000104428d llvm::legacy::PassManager::run(llvm::Module&) + 39
19 llc             0x0000000000764e1e
20 llc             0x00000000007640a9 main + 237
21 libc.so.6       0x00007f33e5eb2ec5 __libc_start_main + 245
22 llc             0x0000000000761bf9
Stack dump:
0.	Program arguments: /var/services/homes/akale/llvm523/llvm_backend/build_523/Debug+Asserts/bin/llc -soft-float -march=cse523 -O3 classic.c.bc -o classic.c.S -debug 
1.	Running pass 'Function Pass Manager' on module 'classic.c.bc'.
2.	Running pass 'CodeGen Prepare' on function '@quantum_frac_approx'
Aborted
Assembler messages:
Error: can't open classic.c.S for reading: No such file or directory
In file included from complex.c:29:
./lq_complex.h:30:8: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_conj(COMPLEX_FLOAT a);
       ^
./lq_complex.h:30:35: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_conj(COMPLEX_FLOAT a);
                                  ^
./lq_complex.h:32:28: error: unknown type name 'COMPLEX_FLOAT'
extern float quantum_prob (COMPLEX_FLOAT a);
                           ^
./lq_complex.h:33:8: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_cexp(float phi);
       ^
./lq_complex.h:38:14: error: unknown type name 'COMPLEX_FLOAT'
quantum_real(COMPLEX_FLOAT a)
             ^
./lq_complex.h:47:14: error: unknown type name 'COMPLEX_FLOAT'
quantum_imag(COMPLEX_FLOAT a)
             ^
./lq_complex.h:56:21: error: unknown type name 'COMPLEX_FLOAT'
quantum_prob_inline(COMPLEX_FLOAT a)
                    ^
complex.c:34:1: error: unknown type name 'COMPLEX_FLOAT'
COMPLEX_FLOAT
^
complex.c:35:14: error: unknown type name 'COMPLEX_FLOAT'
quantum_conj(COMPLEX_FLOAT a)
             ^
complex.c:42:14: error: use of undeclared identifier 'IMAGINARY'
  return r - IMAGINARY * i;
             ^
complex.c:48:14: error: unknown type name 'COMPLEX_FLOAT'
quantum_prob(COMPLEX_FLOAT a)
             ^
complex.c:55:1: error: unknown type name 'COMPLEX_FLOAT'
COMPLEX_FLOAT quantum_cexp(float phi)
^
complex.c:57:21: error: use of undeclared identifier 'IMAGINARY'
  return cos(phi) + IMAGINARY * sin(phi);
                    ^
13 errors generated.
Args: /var/services/homes/akale/llvm523/llvm_backend/build_523/Debug+Asserts/bin/llc -soft-float -march=cse523 -O3 complex.c.bc -o complex.c.S -debug 
/var/services/homes/akale/llvm523/llvm_backend/build_523/Debug+Asserts/bin/llc: complex.c.bc: error: Could not open input file: No such file or directory
Assembler messages:
Error: can't open complex.c.S for reading: No such file or directory
In file included from decoherence.c:32:
In file included from ./measure.h:28:
./matrix.h:35:3: error: unknown type name 'COMPLEX_FLOAT'
  COMPLEX_FLOAT *t;
  ^
In file included from decoherence.c:32:
In file included from ./measure.h:29:
./qureg.h:37:3: error: unknown type name 'COMPLEX_FLOAT'
  COMPLEX_FLOAT amplitude; /* alpha_j */
  ^
./qureg.h:38:3: error: unknown type name 'MAX_UNSIGNED'
  MAX_UNSIGNED state;      /* j */
  ^
./qureg.h:57:38: error: unknown type name 'MAX_UNSIGNED'
extern quantum_reg quantum_new_qureg(MAX_UNSIGNED initval, int width);
                                     ^
./qureg.h:75:8: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_dot_product(quantum_reg *reg1, quantum_reg *reg2);
       ^
./qureg.h:80:16: error: unknown type name 'MAX_UNSIGNED'
quantum_hash64(MAX_UNSIGNED key, int width)
               ^
./qureg.h:95:19: error: unknown type name 'MAX_UNSIGNED'
quantum_get_state(MAX_UNSIGNED a, quantum_reg reg)
                  ^
./qureg.h:117:18: error: unknown type name 'MAX_UNSIGNED'
quantum_add_hash(MAX_UNSIGNED a, int pos, quantum_reg *reg)
                 ^
In file included from decoherence.c:32:
./measure.h:34:8: error: unknown type name 'MAX_UNSIGNED'
extern MAX_UNSIGNED quantum_measure(quantum_reg reg);
       ^
In file included from decoherence.c:35:
./lq_complex.h:30:8: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_conj(COMPLEX_FLOAT a);
       ^
./lq_complex.h:30:35: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_conj(COMPLEX_FLOAT a);
                                  ^
./lq_complex.h:32:28: error: unknown type name 'COMPLEX_FLOAT'
extern float quantum_prob (COMPLEX_FLOAT a);
                           ^
./lq_complex.h:33:8: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_cexp(float phi);
       ^
./lq_complex.h:38:14: error: unknown type name 'COMPLEX_FLOAT'
quantum_real(COMPLEX_FLOAT a)
             ^
./lq_complex.h:47:14: error: unknown type name 'COMPLEX_FLOAT'
quantum_imag(COMPLEX_FLOAT a)
             ^
./lq_complex.h:56:21: error: unknown type name 'COMPLEX_FLOAT'
quantum_prob_inline(COMPLEX_FLOAT a)
                    ^
decoherence.c:122:34: error: use of undeclared identifier 'MAX_UNSIGNED'
              if(reg->node[i].state & ((MAX_UNSIGNED) 1 << j))
                                        ^
17 errors generated.
Args: /var/services/homes/akale/llvm523/llvm_backend/build_523/Debug+Asserts/bin/llc -soft-float -march=cse523 -O3 decoherence.c.bc -o decoherence.c.S -debug 
/var/services/homes/akale/llvm523/llvm_backend/build_523/Debug+Asserts/bin/llc: decoherence.c.bc: error: Could not open input file: No such file or directory
Assembler messages:
Error: can't open decoherence.c.S for reading: No such file or directory
In file included from expn.c:32:
In file included from ./gates.h:28:
./matrix.h:35:3: error: unknown type name 'COMPLEX_FLOAT'
  COMPLEX_FLOAT *t;
  ^
In file included from expn.c:32:
In file included from ./gates.h:29:
./qureg.h:37:3: error: unknown type name 'COMPLEX_FLOAT'
  COMPLEX_FLOAT amplitude; /* alpha_j */
  ^
./qureg.h:38:3: error: unknown type name 'MAX_UNSIGNED'
  MAX_UNSIGNED state;      /* j */
  ^
./qureg.h:57:38: error: unknown type name 'MAX_UNSIGNED'
extern quantum_reg quantum_new_qureg(MAX_UNSIGNED initval, int width);
                                     ^
./qureg.h:75:8: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_dot_product(quantum_reg *reg1, quantum_reg *reg2);
       ^
./qureg.h:80:16: error: unknown type name 'MAX_UNSIGNED'
quantum_hash64(MAX_UNSIGNED key, int width)
               ^
./qureg.h:95:19: error: unknown type name 'MAX_UNSIGNED'
quantum_get_state(MAX_UNSIGNED a, quantum_reg reg)
                  ^
./qureg.h:117:18: error: unknown type name 'MAX_UNSIGNED'
quantum_add_hash(MAX_UNSIGNED a, int pos, quantum_reg *reg)
                 ^
8 errors generated.
Args: /var/services/homes/akale/llvm523/llvm_backend/build_523/Debug+Asserts/bin/llc -soft-float -march=cse523 -O3 expn.c.bc -o expn.c.S -debug 
/var/services/homes/akale/llvm523/llvm_backend/build_523/Debug+Asserts/bin/llc: expn.c.bc: error: Could not open input file: No such file or directory
Assembler messages:
Error: can't open expn.c.S for reading: No such file or directory
In file included from gates.c:33:
./matrix.h:35:3: error: unknown type name 'COMPLEX_FLOAT'
  COMPLEX_FLOAT *t;
  ^
In file included from gates.c:35:
./lq_complex.h:30:8: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_conj(COMPLEX_FLOAT a);
       ^
./lq_complex.h:30:35: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_conj(COMPLEX_FLOAT a);
                                  ^
./lq_complex.h:32:28: error: unknown type name 'COMPLEX_FLOAT'
extern float quantum_prob (COMPLEX_FLOAT a);
                           ^
./lq_complex.h:33:8: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_cexp(float phi);
       ^
./lq_complex.h:38:14: error: unknown type name 'COMPLEX_FLOAT'
quantum_real(COMPLEX_FLOAT a)
             ^
./lq_complex.h:47:14: error: unknown type name 'COMPLEX_FLOAT'
quantum_imag(COMPLEX_FLOAT a)
             ^
./lq_complex.h:56:21: error: unknown type name 'COMPLEX_FLOAT'
quantum_prob_inline(COMPLEX_FLOAT a)
                    ^
In file included from gates.c:36:
./qureg.h:37:3: error: unknown type name 'COMPLEX_FLOAT'
  COMPLEX_FLOAT amplitude; /* alpha_j */
  ^
./qureg.h:38:3: error: unknown type name 'MAX_UNSIGNED'
  MAX_UNSIGNED state;      /* j */
  ^
./qureg.h:57:38: error: unknown type name 'MAX_UNSIGNED'
extern quantum_reg quantum_new_qureg(MAX_UNSIGNED initval, int width);
                                     ^
./qureg.h:75:8: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_dot_product(quantum_reg *reg1, quantum_reg *reg2);
       ^
./qureg.h:80:16: error: unknown type name 'MAX_UNSIGNED'
quantum_hash64(MAX_UNSIGNED key, int width)
               ^
./qureg.h:95:19: error: unknown type name 'MAX_UNSIGNED'
quantum_get_state(MAX_UNSIGNED a, quantum_reg reg)
                  ^
./qureg.h:117:18: error: unknown type name 'MAX_UNSIGNED'
quantum_add_hash(MAX_UNSIGNED a, int pos, quantum_reg *reg)
                 ^
In file included from gates.c:39:
./objcode.h:56:8: error: unknown type name 'MAX_UNSIGNED'
extern MAX_UNSIGNED quantum_char2mu(unsigned char *buf);
       ^
gates.c:65:31: error: use of undeclared identifier 'MAX_UNSIGNED'
          if((reg->node[i].state & ((MAX_UNSIGNED) 1 << control)))
                                     ^
gates.c:66:30: error: use of undeclared identifier 'MAX_UNSIGNED'
            reg->node[i].state ^= ((MAX_UNSIGNED) 1 << target);
                                    ^
gates.c:94:30: error: use of undeclared identifier 'MAX_UNSIGNED'
          if(reg->node[i].state & ((MAX_UNSIGNED) 1 << control1))
                                    ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
Args: /var/services/homes/akale/llvm523/llvm_backend/build_523/Debug+Asserts/bin/llc -soft-float -march=cse523 -O3 gates.c.bc -o gates.c.S -debug 
/var/services/homes/akale/llvm523/llvm_backend/build_523/Debug+Asserts/bin/llc: gates.c.bc: error: Could not open input file: No such file or directory
Assembler messages:
Error: can't open gates.c.S for reading: No such file or directory
In file included from matrix.c:27:
./matrix.h:35:3: error: unknown type name 'COMPLEX_FLOAT'
  COMPLEX_FLOAT *t;
  ^
In file included from matrix.c:29:
./lq_complex.h:30:8: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_conj(COMPLEX_FLOAT a);
       ^
./lq_complex.h:30:35: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_conj(COMPLEX_FLOAT a);
                                  ^
./lq_complex.h:32:28: error: unknown type name 'COMPLEX_FLOAT'
extern float quantum_prob (COMPLEX_FLOAT a);
                           ^
./lq_complex.h:33:8: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_cexp(float phi);
       ^
./lq_complex.h:38:14: error: unknown type name 'COMPLEX_FLOAT'
quantum_real(COMPLEX_FLOAT a)
             ^
./lq_complex.h:47:14: error: unknown type name 'COMPLEX_FLOAT'
quantum_imag(COMPLEX_FLOAT a)
             ^
./lq_complex.h:56:21: error: unknown type name 'COMPLEX_FLOAT'
quantum_prob_inline(COMPLEX_FLOAT a)
                    ^
matrix.c:54:36: error: use of undeclared identifier 'COMPLEX_FLOAT'
  m.t = calloc(cols * rows, sizeof(COMPLEX_FLOAT));
                                   ^
matrix.c:66:25: error: use of undeclared identifier 'COMPLEX_FLOAT'
  quantum_memman(sizeof(COMPLEX_FLOAT) * cols * rows);
                        ^
matrix.c:83:26: error: use of undeclared identifier 'COMPLEX_FLOAT'
  quantum_memman(-sizeof(COMPLEX_FLOAT) * m->cols * m->rows);
                         ^
11 errors generated.
Args: /var/services/homes/akale/llvm523/llvm_backend/build_523/Debug+Asserts/bin/llc -soft-float -march=cse523 -O3 matrix.c.bc -o matrix.c.S -debug 
/var/services/homes/akale/llvm523/llvm_backend/build_523/Debug+Asserts/bin/llc: matrix.c.bc: error: Could not open input file: No such file or directory
Assembler messages:
Error: can't open matrix.c.S for reading: No such file or directory
In file included from measure.c:38:
In file included from ./qureg.h:31:
./matrix.h:35:3: error: unknown type name 'COMPLEX_FLOAT'
  COMPLEX_FLOAT *t;
  ^
In file included from measure.c:38:
./qureg.h:37:3: error: unknown type name 'COMPLEX_FLOAT'
  COMPLEX_FLOAT amplitude; /* alpha_j */
  ^
./qureg.h:38:3: error: unknown type name 'MAX_UNSIGNED'
  MAX_UNSIGNED state;      /* j */
  ^
./qureg.h:57:38: error: unknown type name 'MAX_UNSIGNED'
extern quantum_reg quantum_new_qureg(MAX_UNSIGNED initval, int width);
                                     ^
./qureg.h:75:8: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_dot_product(quantum_reg *reg1, quantum_reg *reg2);
       ^
./qureg.h:80:16: error: unknown type name 'MAX_UNSIGNED'
quantum_hash64(MAX_UNSIGNED key, int width)
               ^
./qureg.h:95:19: error: unknown type name 'MAX_UNSIGNED'
quantum_get_state(MAX_UNSIGNED a, quantum_reg reg)
                  ^
./qureg.h:117:18: error: unknown type name 'MAX_UNSIGNED'
quantum_add_hash(MAX_UNSIGNED a, int pos, quantum_reg *reg)
                 ^
In file included from measure.c:39:
./lq_complex.h:30:8: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_conj(COMPLEX_FLOAT a);
       ^
./lq_complex.h:30:35: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_conj(COMPLEX_FLOAT a);
                                  ^
./lq_complex.h:32:28: error: unknown type name 'COMPLEX_FLOAT'
extern float quantum_prob (COMPLEX_FLOAT a);
                           ^
./lq_complex.h:33:8: error: unknown type name 'COMPLEX_FLOAT'
extern COMPLEX_FLOAT quantum_cexp(float phi);
       ^
./lq_complex.h:38:14: error: unknown type name 'COMPLEX_FLOAT'
quantum_real(COMPLEX_FLOAT a)
             ^
./lq_complex.h:47:14: error: unknown type name 'COMPLEX_FLOAT'
quantum_imag(COMPLEX_FLOAT a)
             ^
./lq_complex.h:56:21: error: unknown type name 'COMPLEX_FLOAT'
quantum_prob_inline(COMPLEX_FLOAT a)
                    ^
In file included from measure.c:41:
./objcode.h:56:8: error: unknown type name 'MAX_UNSIGNED'
extern MAX_UNSIGNED quantum_char2mu(unsigned char *buf);
       ^
measure.c:61:1: error: unknown type name 'MAX_UNSIGNED'
MAX_UNSIGNED
^
