; ModuleID = 'd_plaq4.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct._IO_FILE = type opaque
%struct.site = type { i16, i16, i16, i16, i8, i32, %struct.double_prn, i32, [4 x %struct.su3_matrix], [4 x %struct.anti_hermitmat], [4 x double], %struct.su3_vector, %struct.su3_vector, %struct.su3_vector, %struct.su3_vector, %struct.su3_vector, %struct.su3_vector, [4 x %struct.su3_vector], %struct.su3_matrix, %struct.su3_matrix }
%struct.double_prn = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, double }
%struct.anti_hermitmat = type { %struct.complex, %struct.complex, %struct.complex, double, double, double, double }
%struct.complex = type { double, double }
%struct.su3_vector = type { [3 x %struct.complex] }
%struct.su3_matrix = type { [3 x [3 x %struct.complex]] }
%struct.msg_tag = type { i32, i32, i8*, i32 }

@sites_on_node = external global i32
@stdout = external constant %struct._IO_FILE*
@lattice = external global %struct.site*
@gen_pt = external global [16 x i8**]
@nx = external global i32
@ny = external global i32
@nz = external global i32
@nt = external global i32
@str = private unnamed_addr constant [31 x i8] c"plaquette: can't malloc su3mat\00"

; Function Attrs: nounwind uwtable
define void @d_plaquette(double* nocapture %ss_plaq, double* nocapture %st_plaq) #0 {
entry:
  %mtmp = alloca %struct.su3_matrix, align 8
  %ss_sum = alloca double, align 8
  %st_sum = alloca double, align 8
  %0 = bitcast %struct.su3_matrix* %mtmp to i8*
  call void @llvm.lifetime.start(i64 144, i8* %0) #1
  store double 0.000000e+00, double* %st_sum, align 8, !tbaa !1
  store double 0.000000e+00, double* %ss_sum, align 8, !tbaa !1
  %1 = load i32* @sites_on_node, align 4, !tbaa !5
  %conv = sext i32 %1 to i64
  %call = call i8* @calloc(i64 %conv, i64 144) #1
  %2 = bitcast i8* %call to %struct.su3_matrix*
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %if.then, label %for.body9.lr.ph

if.then:                                          ; preds = %entry
  %puts = call i32 @puts(i8* getelementptr inbounds ([31 x i8]* @str, i64 0, i64 0))
  %3 = load %struct._IO_FILE** @stdout, align 8, !tbaa !7
  %call3 = call i32 @fflush(%struct._IO_FILE* %3) #1
  call void @terminate(i32 1) #1
  br label %for.body9.lr.ph

for.body9.lr.ph:                                  ; preds = %if.then, %entry, %for.inc62
  %indvars.iv118 = phi i64 [ %indvars.iv.next119, %for.inc62 ], [ 1, %entry ], [ 1, %if.then ]
  %indvars.iv116 = phi i32 [ %indvars.iv.next117, %for.inc62 ], [ 1, %entry ], [ 1, %if.then ]
  %4 = mul i64 %indvars.iv118, 144
  %5 = add i64 %4, 112
  %6 = trunc i64 %indvars.iv118 to i32
  %cmp44 = icmp eq i32 %6, 3
  br label %for.body9

for.body9:                                        ; preds = %for.end58, %for.body9.lr.ph
  %indvars.iv112 = phi i64 [ 0, %for.body9.lr.ph ], [ %indvars.iv.next113, %for.end58 ]
  %7 = mul i64 %indvars.iv112, 144
  %8 = add i64 %7, 112
  %9 = load i8*** getelementptr inbounds ([16 x i8**]* @gen_pt, i64 0, i64 0), align 8, !tbaa !7
  %10 = trunc i64 %8 to i32
  %call13 = call %struct.msg_tag* @start_gather(i32 %10, i32 144, i32 %6, i32 3, i8** %9) #1
  %11 = load i8*** getelementptr inbounds ([16 x i8**]* @gen_pt, i64 0, i64 1), align 8, !tbaa !7
  %12 = trunc i64 %indvars.iv112 to i32
  %13 = trunc i64 %5 to i32
  %call23 = call %struct.msg_tag* @start_gather(i32 %13, i32 144, i32 %12, i32 3, i8** %11) #1
  %14 = load i32* @sites_on_node, align 4, !tbaa !5
  %cmp25100 = icmp sgt i32 %14, 0
  br i1 %cmp25100, label %for.body27.lr.ph, label %for.end

for.body27.lr.ph:                                 ; preds = %for.body9
  %15 = load %struct.site** @lattice, align 8, !tbaa !7
  br label %for.body27

for.body27:                                       ; preds = %for.body27.lr.ph, %for.body27
  %indvars.iv = phi i64 [ 0, %for.body27.lr.ph ], [ %indvars.iv.next, %for.body27 ]
  %s.0101 = phi %struct.site* [ %15, %for.body27.lr.ph ], [ %incdec.ptr, %for.body27 ]
  %arrayidx30 = getelementptr inbounds %struct.site* %s.0101, i64 0, i32 8, i64 %indvars.iv118
  %arrayidx33 = getelementptr inbounds %struct.site* %s.0101, i64 0, i32 8, i64 %indvars.iv112
  %arrayidx35 = getelementptr inbounds %struct.su3_matrix* %2, i64 %indvars.iv
  call void @mult_su3_an(%struct.su3_matrix* %arrayidx33, %struct.su3_matrix* %arrayidx30, %struct.su3_matrix* %arrayidx35) #1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %incdec.ptr = getelementptr inbounds %struct.site* %s.0101, i64 1
  %16 = load i32* @sites_on_node, align 4, !tbaa !5
  %17 = trunc i64 %indvars.iv.next to i32
  %cmp25 = icmp slt i32 %17, %16
  br i1 %cmp25, label %for.body27, label %for.end

for.end:                                          ; preds = %for.body27, %for.body9
  call void @wait_gather(%struct.msg_tag* %call13) #1
  call void @wait_gather(%struct.msg_tag* %call23) #1
  %18 = load i32* @sites_on_node, align 4, !tbaa !5
  %cmp37103 = icmp sgt i32 %18, 0
  br i1 %cmp37103, label %for.body39.lr.ph, label %for.end58

for.body39.lr.ph:                                 ; preds = %for.end
  br i1 %cmp44, label %for.inc55.us, label %for.inc55

for.inc55.us:                                     ; preds = %for.body39.lr.ph, %for.inc55.us
  %indvars.iv110 = phi i64 [ %indvars.iv.next111, %for.inc55.us ], [ 0, %for.body39.lr.ph ]
  %arrayidx41.us = getelementptr inbounds %struct.su3_matrix* %2, i64 %indvars.iv110
  %19 = load i8*** getelementptr inbounds ([16 x i8**]* @gen_pt, i64 0, i64 0), align 8, !tbaa !7
  %arrayidx43.us = getelementptr inbounds i8** %19, i64 %indvars.iv110
  %20 = load i8** %arrayidx43.us, align 8, !tbaa !7
  %21 = bitcast i8* %20 to %struct.su3_matrix*
  call void @mult_su3_nn(%struct.su3_matrix* %arrayidx41.us, %struct.su3_matrix* %21, %struct.su3_matrix* %mtmp) #1
  %22 = load i8*** getelementptr inbounds ([16 x i8**]* @gen_pt, i64 0, i64 1), align 8, !tbaa !7
  %arrayidx48.us = getelementptr inbounds i8** %22, i64 %indvars.iv110
  %23 = load i8** %arrayidx48.us, align 8, !tbaa !7
  %24 = bitcast i8* %23 to %struct.su3_matrix*
  %call49.us = call double @realtrace_su3(%struct.su3_matrix* %24, %struct.su3_matrix* %mtmp) #1
  %25 = load double* %st_sum, align 8, !tbaa !1
  %add.us = fadd double %call49.us, %25
  store double %add.us, double* %st_sum, align 8, !tbaa !1
  %indvars.iv.next111 = add nuw nsw i64 %indvars.iv110, 1
  %26 = load i32* @sites_on_node, align 4, !tbaa !5
  %27 = trunc i64 %indvars.iv.next111 to i32
  %cmp37.us = icmp slt i32 %27, %26
  br i1 %cmp37.us, label %for.inc55.us, label %for.end58

for.inc55:                                        ; preds = %for.body39.lr.ph, %for.inc55
  %indvars.iv108 = phi i64 [ %indvars.iv.next109, %for.inc55 ], [ 0, %for.body39.lr.ph ]
  %arrayidx41 = getelementptr inbounds %struct.su3_matrix* %2, i64 %indvars.iv108
  %28 = load i8*** getelementptr inbounds ([16 x i8**]* @gen_pt, i64 0, i64 0), align 8, !tbaa !7
  %arrayidx43 = getelementptr inbounds i8** %28, i64 %indvars.iv108
  %29 = load i8** %arrayidx43, align 8, !tbaa !7
  %30 = bitcast i8* %29 to %struct.su3_matrix*
  call void @mult_su3_nn(%struct.su3_matrix* %arrayidx41, %struct.su3_matrix* %30, %struct.su3_matrix* %mtmp) #1
  %31 = load i8*** getelementptr inbounds ([16 x i8**]* @gen_pt, i64 0, i64 1), align 8, !tbaa !7
  %arrayidx48 = getelementptr inbounds i8** %31, i64 %indvars.iv108
  %32 = load i8** %arrayidx48, align 8, !tbaa !7
  %33 = bitcast i8* %32 to %struct.su3_matrix*
  %call49 = call double @realtrace_su3(%struct.su3_matrix* %33, %struct.su3_matrix* %mtmp) #1
  %34 = load double* %ss_sum, align 8, !tbaa !1
  %add53 = fadd double %call49, %34
  store double %add53, double* %ss_sum, align 8, !tbaa !1
  %indvars.iv.next109 = add nuw nsw i64 %indvars.iv108, 1
  %35 = load i32* @sites_on_node, align 4, !tbaa !5
  %36 = trunc i64 %indvars.iv.next109 to i32
  %cmp37 = icmp slt i32 %36, %35
  br i1 %cmp37, label %for.inc55, label %for.end58

for.end58:                                        ; preds = %for.inc55, %for.inc55.us, %for.end
  call void @cleanup_gather(%struct.msg_tag* %call13) #1
  call void @cleanup_gather(%struct.msg_tag* %call23) #1
  %indvars.iv.next113 = add nuw nsw i64 %indvars.iv112, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next113 to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %indvars.iv116
  br i1 %exitcond, label %for.inc62, label %for.body9

for.inc62:                                        ; preds = %for.end58
  %indvars.iv.next119 = add nuw nsw i64 %indvars.iv118, 1
  %indvars.iv.next117 = add nuw nsw i32 %indvars.iv116, 1
  %exitcond122 = icmp eq i64 %indvars.iv.next119, 4
  br i1 %exitcond122, label %for.end64, label %for.body9.lr.ph

for.end64:                                        ; preds = %for.inc62
  call void @g_doublesum(double* %ss_sum) #1
  call void @g_doublesum(double* %st_sum) #1
  %37 = load double* %ss_sum, align 8, !tbaa !1
  %38 = load i32* @nx, align 4, !tbaa !5
  %mul = mul nsw i32 %38, 3
  %39 = load i32* @ny, align 4, !tbaa !5
  %mul65 = mul nsw i32 %mul, %39
  %40 = load i32* @nz, align 4, !tbaa !5
  %mul66 = mul nsw i32 %mul65, %40
  %41 = load i32* @nt, align 4, !tbaa !5
  %mul67 = mul nsw i32 %mul66, %41
  %conv68 = sitofp i32 %mul67 to double
  %div = fdiv double %37, %conv68
  store double %div, double* %ss_plaq, align 8, !tbaa !1
  %42 = load double* %st_sum, align 8, !tbaa !1
  %div74 = fdiv double %42, %conv68
  store double %div74, double* %st_plaq, align 8, !tbaa !1
  call void @free(i8* %call)
  call void @llvm.lifetime.end(i64 144, i8* %0) #1
  ret void
}

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #1

; Function Attrs: nounwind
declare noalias i8* @calloc(i64, i64) #2

; Function Attrs: nounwind
declare i32 @fflush(%struct._IO_FILE* nocapture) #2

declare void @terminate(i32) #3

declare %struct.msg_tag* @start_gather(i32, i32, i32, i32, i8**) #3

declare void @mult_su3_an(%struct.su3_matrix*, %struct.su3_matrix*, %struct.su3_matrix*) #3

declare void @wait_gather(%struct.msg_tag*) #3

declare void @mult_su3_nn(%struct.su3_matrix*, %struct.su3_matrix*, %struct.su3_matrix*) #3

declare double @realtrace_su3(%struct.su3_matrix*, %struct.su3_matrix*) #3

declare void @cleanup_gather(%struct.msg_tag*) #3

declare void @g_doublesum(double*) #3

; Function Attrs: nounwind
declare void @free(i8* nocapture) #2

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #1

; Function Attrs: nounwind
declare i32 @puts(i8* nocapture readonly) #1

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind }
attributes #2 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5 (trunk)"}
!1 = metadata !{metadata !2, metadata !2, i64 0}
!2 = metadata !{metadata !"double", metadata !3, i64 0}
!3 = metadata !{metadata !"omnipotent char", metadata !4, i64 0}
!4 = metadata !{metadata !"Simple C/C++ TBAA"}
!5 = metadata !{metadata !6, metadata !6, i64 0}
!6 = metadata !{metadata !"int", metadata !3, i64 0}
!7 = metadata !{metadata !8, metadata !8, i64 0}
!8 = metadata !{metadata !"any pointer", metadata !3, i64 0}
