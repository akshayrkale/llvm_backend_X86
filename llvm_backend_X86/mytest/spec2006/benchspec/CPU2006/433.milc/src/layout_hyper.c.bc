; ModuleID = 'layout_hyper.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@.str = private unnamed_addr constant [32 x i8] c"LAYOUT = Hypercubes, options = \00", align 1
@.str1 = private unnamed_addr constant [11 x i8] c"EVENFIRST,\00", align 1
@nx = external global i32
@squaresize = common global [4 x i32] zeroinitializer, align 16
@ny = external global i32
@nz = external global i32
@nt = external global i32
@nsquares = common global [4 x i32] zeroinitializer, align 16
@sites_on_node = external global i32
@odd_sites_on_node = external global i32
@even_sites_on_node = external global i32
@str = private unnamed_addr constant [34 x i8] c"SORRY, CAN'T LAY OUT THIS LATTICE\00"
@str5 = private unnamed_addr constant [60 x i8] c"LAYOUT: Can't lay out this lattice, not enough factors of 2\00"

; Function Attrs: nounwind uwtable
define void @setup_layout() #0 {
entry:
  %call = tail call i32 (...)* @mynode() #4
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = tail call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([32 x i8]* @.str, i64 0, i64 0)) #4
  %call2 = tail call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([11 x i8]* @.str1, i64 0, i64 0)) #4
  %putchar = tail call i32 @putchar(i32 10) #4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %0 = load i32* @nx, align 4, !tbaa !1
  store i32 %0, i32* getelementptr inbounds ([4 x i32]* @squaresize, i64 0, i64 0), align 16, !tbaa !1
  %1 = load i32* @ny, align 4, !tbaa !1
  store i32 %1, i32* getelementptr inbounds ([4 x i32]* @squaresize, i64 0, i64 1), align 4, !tbaa !1
  %2 = load i32* @nz, align 4, !tbaa !1
  store i32 %2, i32* getelementptr inbounds ([4 x i32]* @squaresize, i64 0, i64 2), align 8, !tbaa !1
  %3 = load i32* @nt, align 4, !tbaa !1
  store i32 %3, i32* getelementptr inbounds ([4 x i32]* @squaresize, i64 0, i64 3), align 4, !tbaa !1
  store <4 x i32> <i32 1, i32 1, i32 1, i32 1>, <4 x i32>* bitcast ([4 x i32]* @nsquares to <4 x i32>*), align 16, !tbaa !1
  %call4104 = tail call i32 (...)* @numnodes() #4
  %cmp5105 = icmp sgt i32 %call4104, 1
  br i1 %cmp5105, label %for.cond.preheader, label %while.end

for.cond.preheader:                               ; preds = %if.end, %if.end51
  %i.0106 = phi i32 [ %mul, %if.end51 ], [ 1, %if.end ]
  %4 = load i32* getelementptr inbounds ([4 x i32]* @squaresize, i64 0, i64 0), align 16, !tbaa !1
  %cmp7 = icmp sgt i32 %4, 1
  %rem90 = and i32 %4, 1
  %cmp10 = icmp eq i32 %rem90, 0
  %or.cond = and i1 %cmp7, %cmp10
  %j.1 = select i1 %or.cond, i32 %4, i32 1
  %5 = load i32* getelementptr inbounds ([4 x i32]* @squaresize, i64 0, i64 1), align 4, !tbaa !1
  %cmp7.1 = icmp sgt i32 %5, %j.1
  %rem90.1 = and i32 %5, 1
  %cmp10.1 = icmp eq i32 %rem90.1, 0
  %or.cond.1 = and i1 %cmp7.1, %cmp10.1
  %j.1.1 = select i1 %or.cond.1, i32 %5, i32 %j.1
  %6 = load i32* getelementptr inbounds ([4 x i32]* @squaresize, i64 0, i64 2), align 8, !tbaa !1
  %cmp7.2 = icmp sgt i32 %6, %j.1.1
  %rem90.2 = and i32 %6, 1
  %cmp10.2 = icmp eq i32 %rem90.2, 0
  %or.cond.2 = and i1 %cmp7.2, %cmp10.2
  %j.1.2 = select i1 %or.cond.2, i32 %6, i32 %j.1.1
  %7 = load i32* getelementptr inbounds ([4 x i32]* @squaresize, i64 0, i64 3), align 4, !tbaa !1
  %cmp7.3 = icmp sgt i32 %7, %j.1.2
  %rem90.3 = and i32 %7, 1
  %cmp10.3 = icmp eq i32 %rem90.3, 0
  %or.cond.3 = and i1 %cmp7.3, %cmp10.3
  %j.1.3 = select i1 %or.cond.3, i32 %7, i32 %j.1.2
  br label %for.body17

for.body17:                                       ; preds = %for.inc27.for.body17_crit_edge, %for.cond.preheader
  %8 = phi i32 [ %4, %for.cond.preheader ], [ %.pre, %for.inc27.for.body17_crit_edge ]
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc27.for.body17_crit_edge ]
  %cmp20 = icmp eq i32 %8, %j.1.3
  br i1 %cmp20, label %land.lhs.true21, label %for.inc27

land.lhs.true21:                                  ; preds = %for.body17
  %arrayidx23 = getelementptr inbounds [4 x i32]* @nsquares, i64 0, i64 %indvars.iv
  %9 = load i32* %arrayidx23, align 4, !tbaa !1
  %cmp24 = icmp sgt i32 %9, 1
  br i1 %cmp24, label %for.end29, label %for.inc27

for.inc27:                                        ; preds = %for.body17, %land.lhs.true21
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %10 = trunc i64 %indvars.iv.next to i32
  %cmp16 = icmp slt i32 %10, 4
  br i1 %cmp16, label %for.inc27.for.body17_crit_edge, label %for.body34

for.inc27.for.body17_crit_edge:                   ; preds = %for.inc27
  %arrayidx19.phi.trans.insert = getelementptr inbounds [4 x i32]* @squaresize, i64 0, i64 %indvars.iv.next
  %.pre = load i32* %arrayidx19.phi.trans.insert, align 4, !tbaa !1
  br label %for.body17

for.end29:                                        ; preds = %land.lhs.true21
  %11 = trunc i64 %indvars.iv to i32
  %cmp30 = icmp sgt i32 %11, 3
  br i1 %cmp30, label %for.body34, label %if.end51

for.cond32:                                       ; preds = %for.body34
  %12 = trunc i64 %indvars.iv.next111 to i32
  %cmp33 = icmp slt i32 %12, 4
  br i1 %cmp33, label %for.cond32.for.body34_crit_edge, label %if.then45

for.cond32.for.body34_crit_edge:                  ; preds = %for.cond32
  %arrayidx36.phi.trans.insert = getelementptr inbounds [4 x i32]* @squaresize, i64 0, i64 %indvars.iv.next111
  %.pre112 = load i32* %arrayidx36.phi.trans.insert, align 4, !tbaa !1
  br label %for.body34

for.body34:                                       ; preds = %for.end29, %for.inc27, %for.cond32.for.body34_crit_edge
  %13 = phi i32 [ %.pre112, %for.cond32.for.body34_crit_edge ], [ %4, %for.inc27 ], [ %4, %for.end29 ]
  %indvars.iv110 = phi i64 [ %indvars.iv.next111, %for.cond32.for.body34_crit_edge ], [ 0, %for.inc27 ], [ 0, %for.end29 ]
  %cmp37 = icmp eq i32 %13, %j.1.3
  %indvars.iv.next111 = add nuw nsw i64 %indvars.iv110, 1
  br i1 %cmp37, label %if.end43, label %for.cond32

if.end43:                                         ; preds = %for.body34
  %14 = trunc i64 %indvars.iv110 to i32
  %cmp44 = icmp sgt i32 %14, 3
  br i1 %cmp44, label %if.then45, label %if.end51

if.then45:                                        ; preds = %for.cond32, %if.end43
  %dir.299 = phi i64 [ %indvars.iv110, %if.end43 ], [ %indvars.iv.next111, %for.cond32 ]
  %call46 = tail call i32 (...)* @mynode() #4
  %cmp47 = icmp eq i32 %call46, 0
  br i1 %cmp47, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then45
  %puts89 = tail call i32 @puts(i8* getelementptr inbounds ([60 x i8]* @str5, i64 0, i64 0))
  br label %if.end50

if.end50:                                         ; preds = %if.then48, %if.then45
  tail call void @terminate(i32 1) #4
  br label %if.end51

if.end51:                                         ; preds = %for.end29, %if.end50, %if.end43
  %dir.393 = phi i64 [ %dir.299, %if.end50 ], [ %indvars.iv110, %if.end43 ], [ %indvars.iv, %for.end29 ]
  %mul = shl nsw i32 %i.0106, 1
  %sext = shl i64 %dir.393, 32
  %idxprom52 = ashr exact i64 %sext, 32
  %arrayidx53 = getelementptr inbounds [4 x i32]* @squaresize, i64 0, i64 %idxprom52
  %15 = load i32* %arrayidx53, align 4, !tbaa !1
  %div = sdiv i32 %15, 2
  store i32 %div, i32* %arrayidx53, align 4, !tbaa !1
  %arrayidx55 = getelementptr inbounds [4 x i32]* @nsquares, i64 0, i64 %idxprom52
  %16 = load i32* %arrayidx55, align 4, !tbaa !1
  %mul56 = shl nsw i32 %16, 1
  store i32 %mul56, i32* %arrayidx55, align 4, !tbaa !1
  %call4 = tail call i32 (...)* @numnodes() #4
  %cmp5 = icmp slt i32 %mul, %call4
  br i1 %cmp5, label %for.cond.preheader, label %while.end

while.end:                                        ; preds = %if.end51, %if.end
  %17 = load i64* bitcast ([4 x i32]* @squaresize to i64*), align 16
  %18 = trunc i64 %17 to i32
  %19 = lshr i64 %17, 32
  %20 = trunc i64 %19 to i32
  %mul57 = mul nsw i32 %20, %18
  %21 = load i64* bitcast (i32* getelementptr inbounds ([4 x i32]* @squaresize, i64 0, i64 2) to i64*), align 8
  %22 = trunc i64 %21 to i32
  %mul58 = mul nsw i32 %mul57, %22
  %23 = lshr i64 %21, 32
  %24 = trunc i64 %23 to i32
  %mul59 = mul nsw i32 %mul58, %24
  store i32 %mul59, i32* @sites_on_node, align 4, !tbaa !1
  %call60 = tail call i32 (...)* @mynode() #4
  %cmp61 = icmp eq i32 %call60, 0
  br i1 %cmp61, label %if.then62, label %if.end68

if.then62:                                        ; preds = %while.end
  %25 = load i32* @sites_on_node, align 4, !tbaa !1
  %rem6388 = and i32 %25, 1
  %cmp64 = icmp eq i32 %rem6388, 0
  br i1 %cmp64, label %if.end68, label %if.then65

if.then65:                                        ; preds = %if.then62
  %puts = tail call i32 @puts(i8* getelementptr inbounds ([34 x i8]* @str, i64 0, i64 0))
  tail call void @terminate(i32 0) #4
  br label %if.end68

if.end68:                                         ; preds = %if.then62, %if.then65, %while.end
  %26 = load i32* @sites_on_node, align 4, !tbaa !1
  %div69 = sdiv i32 %26, 2
  store i32 %div69, i32* @odd_sites_on_node, align 4, !tbaa !1
  store i32 %div69, i32* @even_sites_on_node, align 4, !tbaa !1
  ret void
}

declare i32 @mynode(...) #1

; Function Attrs: nounwind
declare i32 @printf(i8* nocapture readonly, ...) #2

declare i32 @numnodes(...) #1

declare void @terminate(i32) #1

; Function Attrs: nounwind readonly uwtable
define i32 @node_number(i32 %x, i32 %y, i32 %z, i32 %t) #3 {
entry:
  %0 = load i64* bitcast ([4 x i32]* @squaresize to i64*), align 16
  %1 = trunc i64 %0 to i32
  %div = sdiv i32 %x, %1
  %2 = lshr i64 %0, 32
  %3 = trunc i64 %2 to i32
  %div1 = sdiv i32 %y, %3
  %4 = load i64* bitcast (i32* getelementptr inbounds ([4 x i32]* @squaresize, i64 0, i64 2) to i64*), align 8
  %5 = trunc i64 %4 to i32
  %div2 = sdiv i32 %z, %5
  %6 = lshr i64 %4, 32
  %7 = trunc i64 %6 to i32
  %div3 = sdiv i32 %t, %7
  %8 = load i64* bitcast ([4 x i32]* @nsquares to i64*), align 16
  %9 = trunc i64 %8 to i32
  %10 = lshr i64 %8, 32
  %11 = trunc i64 %10 to i32
  %12 = load i32* getelementptr inbounds ([4 x i32]* @nsquares, i64 0, i64 2), align 8, !tbaa !1
  %mul = mul nsw i32 %12, %div3
  %add = add nsw i32 %mul, %div2
  %mul4 = mul nsw i32 %add, %11
  %add5 = add nsw i32 %mul4, %div1
  %mul6 = mul nsw i32 %add5, %9
  %add7 = add nsw i32 %mul6, %div
  ret i32 %add7
}

; Function Attrs: nounwind readonly uwtable
define i32 @node_index(i32 %x, i32 %y, i32 %z, i32 %t) #3 {
entry:
  %0 = load i64* bitcast ([4 x i32]* @squaresize to i64*), align 16
  %1 = trunc i64 %0 to i32
  %rem = srem i32 %x, %1
  %2 = lshr i64 %0, 32
  %3 = trunc i64 %2 to i32
  %rem1 = srem i32 %y, %3
  %4 = load i64* bitcast (i32* getelementptr inbounds ([4 x i32]* @squaresize, i64 0, i64 2) to i64*), align 8
  %5 = trunc i64 %4 to i32
  %rem2 = srem i32 %z, %5
  %6 = lshr i64 %4, 32
  %7 = trunc i64 %6 to i32
  %rem3 = srem i32 %t, %7
  %mul = mul nsw i32 %rem3, %5
  %add = add nsw i32 %mul, %rem2
  %mul4 = mul nsw i32 %add, %3
  %add5 = add nsw i32 %mul4, %rem1
  %mul6 = mul nsw i32 %add5, %1
  %add7 = add nsw i32 %mul6, %rem
  %add8 = add nsw i32 %y, %x
  %add9 = add nsw i32 %add8, %z
  %add10 = add nsw i32 %add9, %t
  %rem1118 = and i32 %add10, 1
  %cmp = icmp eq i32 %rem1118, 0
  br i1 %cmp, label %return, label %if.else

if.else:                                          ; preds = %entry
  %8 = load i32* @sites_on_node, align 4, !tbaa !1
  %add12 = add nsw i32 %8, %add7
  br label %return

return:                                           ; preds = %entry, %if.else
  %retval.0.in = phi i32 [ %add12, %if.else ], [ %add7, %entry ]
  %retval.0 = sdiv i32 %retval.0.in, 2
  ret i32 %retval.0
}

; Function Attrs: nounwind readonly uwtable
define i32 @num_sites(i32 %node) #3 {
entry:
  %0 = load i32* @sites_on_node, align 4, !tbaa !1
  ret i32 %0
}

; Function Attrs: nounwind
declare i32 @puts(i8* nocapture readonly) #4

; Function Attrs: nounwind
declare i32 @putchar(i32) #4

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5 (trunk)"}
!1 = metadata !{metadata !2, metadata !2, i64 0}
!2 = metadata !{metadata !"int", metadata !3, i64 0}
!3 = metadata !{metadata !"omnipotent char", metadata !4, i64 0}
!4 = metadata !{metadata !"Simple C/C++ TBAA"}
