; ModuleID = 'sbitmap.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.varray_head_tag = type { i64, i64, i64, i8*, %union.varray_data_tag }
%union.varray_data_tag = type { [1 x %struct.const_equiv_data] }
%struct.const_equiv_data = type { %struct.rtx_def*, i32 }
%struct.rtx_def = type { i32, [1 x %union.rtunion_def] }
%union.rtunion_def = type { i64 }
%struct.basic_block_def = type { %struct.rtx_def*, %struct.rtx_def*, %union.tree_node*, %union.tree_node*, %struct.edge_def*, %struct.edge_def*, %struct.bitmap_head_def*, %struct.bitmap_head_def*, %struct.bitmap_head_def*, %struct.bitmap_head_def*, i8*, i32, i32, i64, i32, i32 }
%union.tree_node = type opaque
%struct.edge_def = type { %struct.edge_def*, %struct.edge_def*, %struct.basic_block_def*, %struct.basic_block_def*, %struct.rtx_def*, i8*, i32, i32, i64 }
%struct.bitmap_head_def = type { %struct.bitmap_element_def*, %struct.bitmap_element_def*, i32 }
%struct.bitmap_element_def = type { %struct.bitmap_element_def*, %struct.bitmap_element_def*, i32, [2 x i64] }
%struct._IO_FILE = type opaque
%struct.simple_bitmap_def = type { i32, i32, i32, [1 x i64] }

@basic_block_info = external global %struct.varray_head_tag*
@entry_exit_blocks = external global [2 x %struct.basic_block_def]
@.str = private unnamed_addr constant [3 x i8] c"  \00", align 1
@.str2 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@stderr = external constant %struct._IO_FILE*
@.str4 = private unnamed_addr constant [21 x i8] c"n_bits = %d, set = {\00", align 1
@.str5 = private unnamed_addr constant [4 x i8] c"%d \00", align 1
@.str6 = private unnamed_addr constant [3 x i8] c"}\0A\00", align 1
@.str7 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str8 = private unnamed_addr constant [7 x i8] c"%s %d\0A\00", align 1

; Function Attrs: nounwind uwtable
define noalias %struct.simple_bitmap_def* @sbitmap_alloc(i32 %n_elms) #0 {
entry:
  %sub = add i32 %n_elms, 63
  %div = lshr i32 %sub, 6
  %mul = shl nuw nsw i32 %div, 3
  %sub4 = add i32 %mul, 16
  %conv6 = zext i32 %sub4 to i64
  %call = tail call noalias i8* @xmalloc(i64 %conv6) #2
  %0 = bitcast i8* %call to %struct.simple_bitmap_def*
  %n_bits = bitcast i8* %call to i32*
  store i32 %n_elms, i32* %n_bits, align 4, !tbaa !1
  %size7 = getelementptr inbounds i8* %call, i64 4
  %1 = bitcast i8* %size7 to i32*
  store i32 %div, i32* %1, align 4, !tbaa !6
  %bytes8 = getelementptr inbounds i8* %call, i64 8
  %2 = bitcast i8* %bytes8 to i32*
  store i32 %mul, i32* %2, align 4, !tbaa !7
  ret %struct.simple_bitmap_def* %0
}

declare noalias i8* @xmalloc(i64) #1

; Function Attrs: nounwind uwtable
define %struct.simple_bitmap_def** @sbitmap_vector_alloc(i32 %n_vecs, i32 %n_elms) #0 {
entry:
  %sub = add i32 %n_elms, 63
  %div = lshr i32 %sub, 6
  %mul = shl nuw nsw i32 %div, 3
  %sub4 = add i32 %mul, 16
  %mul7 = shl i32 %n_vecs, 3
  %mul13 = mul i32 %sub4, %n_vecs
  %add14 = add i32 %mul13, %mul7
  %conv15 = zext i32 %add14 to i64
  %call = tail call noalias i8* @xmalloc(i64 %conv15) #2
  %0 = bitcast i8* %call to %struct.simple_bitmap_def**
  %cmp38 = icmp eq i32 %n_vecs, 0
  br i1 %cmp38, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
  %offset.039 = phi i32 [ %add19, %for.body ], [ %mul7, %entry ]
  %idx.ext = zext i32 %offset.039 to i64
  %add.ptr = getelementptr inbounds i8* %call, i64 %idx.ext
  %1 = bitcast i8* %add.ptr to %struct.simple_bitmap_def*
  %arrayidx = getelementptr inbounds %struct.simple_bitmap_def** %0, i64 %indvars.iv
  store %struct.simple_bitmap_def* %1, %struct.simple_bitmap_def** %arrayidx, align 8, !tbaa !8
  %n_bits = bitcast i8* %add.ptr to i32*
  store i32 %n_elms, i32* %n_bits, align 4, !tbaa !1
  %add.ptr.sum37 = or i64 %idx.ext, 4
  %size17 = getelementptr inbounds i8* %call, i64 %add.ptr.sum37
  %2 = bitcast i8* %size17 to i32*
  store i32 %div, i32* %2, align 4, !tbaa !6
  %add.ptr.sum = add i64 %idx.ext, 8
  %bytes18 = getelementptr inbounds i8* %call, i64 %add.ptr.sum
  %3 = bitcast i8* %bytes18 to i32*
  store i32 %mul, i32* %3, align 4, !tbaa !7
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %add19 = add i32 %offset.039, %sub4
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %n_vecs
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  ret %struct.simple_bitmap_def** %0
}

; Function Attrs: nounwind uwtable
define void @sbitmap_copy(%struct.simple_bitmap_def* nocapture %dst, %struct.simple_bitmap_def* nocapture readonly %src) #0 {
entry:
  %elms = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3
  %0 = bitcast [1 x i64]* %elms to i8*
  %elms1 = getelementptr inbounds %struct.simple_bitmap_def* %src, i64 0, i32 3
  %1 = bitcast [1 x i64]* %elms1 to i8*
  %size = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 1
  %2 = load i32* %size, align 4, !tbaa !6
  %conv = zext i32 %2 to i64
  %mul = shl nuw nsw i64 %conv, 3
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 %mul, i32 8, i1 false)
  ret void
}

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: nounwind readonly uwtable
define i32 @sbitmap_equal(%struct.simple_bitmap_def* nocapture readonly %a, %struct.simple_bitmap_def* nocapture readonly %b) #3 {
entry:
  %arraydecay = getelementptr inbounds %struct.simple_bitmap_def* %a, i64 0, i32 3, i64 0
  %0 = bitcast i64* %arraydecay to i8*
  %arraydecay2 = getelementptr inbounds %struct.simple_bitmap_def* %b, i64 0, i32 3, i64 0
  %1 = bitcast i64* %arraydecay2 to i8*
  %size = getelementptr inbounds %struct.simple_bitmap_def* %a, i64 0, i32 1
  %2 = load i32* %size, align 4, !tbaa !6
  %conv = zext i32 %2 to i64
  %mul = shl nuw nsw i64 %conv, 3
  %call = tail call i32 @memcmp(i8* %0, i8* %1, i64 %mul) #2
  %lnot = icmp eq i32 %call, 0
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: nounwind readonly
declare i32 @memcmp(i8* nocapture, i8* nocapture, i64) #4

; Function Attrs: nounwind uwtable
define void @sbitmap_zero(%struct.simple_bitmap_def* nocapture %bmap) #0 {
entry:
  %arraydecay = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 3, i64 0
  %0 = bitcast i64* %arraydecay to i8*
  %bytes = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 2
  %1 = load i32* %bytes, align 4, !tbaa !7
  %conv = zext i32 %1 to i64
  tail call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 %conv, i32 1, i1 false)
  ret void
}

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #2

; Function Attrs: nounwind uwtable
define void @sbitmap_ones(%struct.simple_bitmap_def* nocapture %bmap) #0 {
entry:
  %elms = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 3
  %0 = bitcast [1 x i64]* %elms to i8*
  %bytes = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 2
  %1 = load i32* %bytes, align 4, !tbaa !7
  %conv = zext i32 %1 to i64
  tail call void @llvm.memset.p0i8.i64(i8* %0, i8 -1, i64 %conv, i32 1, i1 false)
  %n_bits = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 0
  %2 = load i32* %n_bits, align 4, !tbaa !1
  %rem = and i32 %2, 63
  %tobool = icmp eq i32 %rem, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sub = sub i32 64, %rem
  %sh_prom = zext i32 %sub to i64
  %shr = lshr i64 -1, %sh_prom
  %size = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 1
  %3 = load i32* %size, align 4, !tbaa !6
  %sub1 = add i32 %3, -1
  %idxprom = zext i32 %sub1 to i64
  %arrayidx = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 3, i64 %idxprom
  store i64 %shr, i64* %arrayidx, align 8, !tbaa !10
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @sbitmap_vector_zero(%struct.simple_bitmap_def** nocapture readonly %bmap, i32 %n_vecs) #0 {
entry:
  %cmp3 = icmp eq i32 %n_vecs, 0
  br i1 %cmp3, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds %struct.simple_bitmap_def** %bmap, i64 %indvars.iv
  %0 = load %struct.simple_bitmap_def** %arrayidx, align 8, !tbaa !8
  %arraydecay.i = getelementptr inbounds %struct.simple_bitmap_def* %0, i64 0, i32 3, i64 0
  %1 = bitcast i64* %arraydecay.i to i8*
  %bytes.i = getelementptr inbounds %struct.simple_bitmap_def* %0, i64 0, i32 2
  %2 = load i32* %bytes.i, align 4, !tbaa !7
  %conv.i = zext i32 %2 to i64
  tail call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 %conv.i, i32 1, i1 false) #2
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %n_vecs
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @sbitmap_vector_ones(%struct.simple_bitmap_def** nocapture readonly %bmap, i32 %n_vecs) #0 {
entry:
  %cmp3 = icmp eq i32 %n_vecs, 0
  br i1 %cmp3, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %sbitmap_ones.exit
  %indvars.iv = phi i64 [ %indvars.iv.next, %sbitmap_ones.exit ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds %struct.simple_bitmap_def** %bmap, i64 %indvars.iv
  %0 = load %struct.simple_bitmap_def** %arrayidx, align 8, !tbaa !8
  %elms.i = getelementptr inbounds %struct.simple_bitmap_def* %0, i64 0, i32 3
  %1 = bitcast [1 x i64]* %elms.i to i8*
  %bytes.i = getelementptr inbounds %struct.simple_bitmap_def* %0, i64 0, i32 2
  %2 = load i32* %bytes.i, align 4, !tbaa !7
  %conv.i = zext i32 %2 to i64
  tail call void @llvm.memset.p0i8.i64(i8* %1, i8 -1, i64 %conv.i, i32 1, i1 false) #2
  %n_bits.i = getelementptr inbounds %struct.simple_bitmap_def* %0, i64 0, i32 0
  %3 = load i32* %n_bits.i, align 4, !tbaa !1
  %rem.i = and i32 %3, 63
  %tobool.i = icmp eq i32 %rem.i, 0
  br i1 %tobool.i, label %sbitmap_ones.exit, label %if.then.i

if.then.i:                                        ; preds = %for.body
  %sub.i = sub i32 64, %rem.i
  %sh_prom.i = zext i32 %sub.i to i64
  %shr.i = lshr i64 -1, %sh_prom.i
  %size.i = getelementptr inbounds %struct.simple_bitmap_def* %0, i64 0, i32 1
  %4 = load i32* %size.i, align 4, !tbaa !6
  %sub1.i = add i32 %4, -1
  %idxprom.i = zext i32 %sub1.i to i64
  %arrayidx.i = getelementptr inbounds %struct.simple_bitmap_def* %0, i64 0, i32 3, i64 %idxprom.i
  store i64 %shr.i, i64* %arrayidx.i, align 8, !tbaa !10
  br label %sbitmap_ones.exit

sbitmap_ones.exit:                                ; preds = %for.body, %if.then.i
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %n_vecs
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %sbitmap_ones.exit, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @sbitmap_union_of_diff(%struct.simple_bitmap_def* nocapture %dst, %struct.simple_bitmap_def* nocapture readonly %a, %struct.simple_bitmap_def* nocapture readonly %b, %struct.simple_bitmap_def* nocapture readonly %c) #0 {
entry:
  %size = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 1
  %0 = load i32* %size, align 4, !tbaa !6
  %cmp16 = icmp eq i32 %0, 0
  br i1 %cmp16, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %arraydecay6 = getelementptr inbounds %struct.simple_bitmap_def* %c, i64 0, i32 3, i64 0
  %arraydecay4 = getelementptr inbounds %struct.simple_bitmap_def* %b, i64 0, i32 3, i64 0
  %arraydecay2 = getelementptr inbounds %struct.simple_bitmap_def* %a, i64 0, i32 3, i64 0
  %arraydecay = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 0
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %i.022 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc ]
  %changed.021 = phi i32 [ 0, %for.body.lr.ph ], [ %changed.1, %for.inc ]
  %cp.020 = phi i64* [ %arraydecay6, %for.body.lr.ph ], [ %incdec.ptr8, %for.inc ]
  %bp.019 = phi i64* [ %arraydecay4, %for.body.lr.ph ], [ %incdec.ptr7, %for.inc ]
  %ap.018 = phi i64* [ %arraydecay2, %for.body.lr.ph ], [ %incdec.ptr, %for.inc ]
  %dstp.017 = phi i64* [ %arraydecay, %for.body.lr.ph ], [ %incdec.ptr10, %for.inc ]
  %incdec.ptr = getelementptr inbounds i64* %ap.018, i64 1
  %1 = load i64* %ap.018, align 8, !tbaa !10
  %incdec.ptr7 = getelementptr inbounds i64* %bp.019, i64 1
  %2 = load i64* %bp.019, align 8, !tbaa !10
  %incdec.ptr8 = getelementptr inbounds i64* %cp.020, i64 1
  %3 = load i64* %cp.020, align 8, !tbaa !10
  %neg = xor i64 %3, -1
  %and = and i64 %2, %neg
  %or = or i64 %and, %1
  %4 = load i64* %dstp.017, align 8, !tbaa !10
  %cmp9 = icmp eq i64 %4, %or
  br i1 %cmp9, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  store i64 %or, i64* %dstp.017, align 8, !tbaa !10
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %changed.1 = phi i32 [ 1, %if.then ], [ %changed.021, %for.body ]
  %inc = add i32 %i.022, 1
  %incdec.ptr10 = getelementptr inbounds i64* %dstp.017, i64 1
  %cmp = icmp ult i32 %inc, %0
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.inc, %entry
  %changed.0.lcssa = phi i32 [ 0, %entry ], [ %changed.1, %for.inc ]
  ret i32 %changed.0.lcssa
}

; Function Attrs: nounwind uwtable
define void @sbitmap_not(%struct.simple_bitmap_def* nocapture %dst, %struct.simple_bitmap_def* nocapture readonly %src) #0 {
entry:
  %size = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 1
  %0 = load i32* %size, align 4, !tbaa !6
  %cmp6 = icmp eq i32 %0, 0
  br i1 %cmp6, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %arraydecay2 = getelementptr inbounds %struct.simple_bitmap_def* %src, i64 0, i32 3, i64 0
  %arraydecay = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 0
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %srcp.09 = phi i64* [ %arraydecay2, %for.body.lr.ph ], [ %incdec.ptr, %for.body ]
  %dstp.08 = phi i64* [ %arraydecay, %for.body.lr.ph ], [ %incdec.ptr3, %for.body ]
  %i.07 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.body ]
  %incdec.ptr = getelementptr inbounds i64* %srcp.09, i64 1
  %1 = load i64* %srcp.09, align 8, !tbaa !10
  %neg = xor i64 %1, -1
  %incdec.ptr3 = getelementptr inbounds i64* %dstp.08, i64 1
  store i64 %neg, i64* %dstp.08, align 8, !tbaa !10
  %inc = add i32 %i.07, 1
  %cmp = icmp ult i32 %inc, %0
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @sbitmap_difference(%struct.simple_bitmap_def* nocapture %dst, %struct.simple_bitmap_def* nocapture readonly %a, %struct.simple_bitmap_def* nocapture readonly %b) #0 {
entry:
  %size = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 1
  %0 = load i32* %size, align 4, !tbaa !6
  %cmp9 = icmp eq i32 %0, 0
  br i1 %cmp9, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %arraydecay4 = getelementptr inbounds %struct.simple_bitmap_def* %b, i64 0, i32 3, i64 0
  %arraydecay2 = getelementptr inbounds %struct.simple_bitmap_def* %a, i64 0, i32 3, i64 0
  %arraydecay = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 0
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %bp.013 = phi i64* [ %arraydecay4, %for.body.lr.ph ], [ %incdec.ptr5, %for.body ]
  %ap.012 = phi i64* [ %arraydecay2, %for.body.lr.ph ], [ %incdec.ptr, %for.body ]
  %dstp.011 = phi i64* [ %arraydecay, %for.body.lr.ph ], [ %incdec.ptr6, %for.body ]
  %i.010 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.body ]
  %incdec.ptr = getelementptr inbounds i64* %ap.012, i64 1
  %1 = load i64* %ap.012, align 8, !tbaa !10
  %incdec.ptr5 = getelementptr inbounds i64* %bp.013, i64 1
  %2 = load i64* %bp.013, align 8, !tbaa !10
  %neg = xor i64 %2, -1
  %and = and i64 %1, %neg
  %incdec.ptr6 = getelementptr inbounds i64* %dstp.011, i64 1
  store i64 %and, i64* %dstp.011, align 8, !tbaa !10
  %inc = add i32 %i.010, 1
  %cmp = icmp ult i32 %inc, %0
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @sbitmap_a_and_b(%struct.simple_bitmap_def* nocapture %dst, %struct.simple_bitmap_def* nocapture readonly %a, %struct.simple_bitmap_def* nocapture readonly %b) #0 {
entry:
  %size = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 1
  %0 = load i32* %size, align 4, !tbaa !6
  %cmp13 = icmp eq i32 %0, 0
  br i1 %cmp13, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %arraydecay4 = getelementptr inbounds %struct.simple_bitmap_def* %b, i64 0, i32 3, i64 0
  %arraydecay2 = getelementptr inbounds %struct.simple_bitmap_def* %a, i64 0, i32 3, i64 0
  %arraydecay = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 0
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %i.018 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc ]
  %changed.017 = phi i32 [ 0, %for.body.lr.ph ], [ %changed.1, %for.inc ]
  %bp.016 = phi i64* [ %arraydecay4, %for.body.lr.ph ], [ %incdec.ptr5, %for.inc ]
  %ap.015 = phi i64* [ %arraydecay2, %for.body.lr.ph ], [ %incdec.ptr, %for.inc ]
  %dstp.014 = phi i64* [ %arraydecay, %for.body.lr.ph ], [ %incdec.ptr7, %for.inc ]
  %incdec.ptr = getelementptr inbounds i64* %ap.015, i64 1
  %1 = load i64* %ap.015, align 8, !tbaa !10
  %incdec.ptr5 = getelementptr inbounds i64* %bp.016, i64 1
  %2 = load i64* %bp.016, align 8, !tbaa !10
  %and = and i64 %2, %1
  %3 = load i64* %dstp.014, align 8, !tbaa !10
  %cmp6 = icmp eq i64 %3, %and
  br i1 %cmp6, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  store i64 %and, i64* %dstp.014, align 8, !tbaa !10
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %changed.1 = phi i32 [ 1, %if.then ], [ %changed.017, %for.body ]
  %inc = add i32 %i.018, 1
  %incdec.ptr7 = getelementptr inbounds i64* %dstp.014, i64 1
  %cmp = icmp ult i32 %inc, %0
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.inc, %entry
  %changed.0.lcssa = phi i32 [ 0, %entry ], [ %changed.1, %for.inc ]
  ret i32 %changed.0.lcssa
}

; Function Attrs: nounwind uwtable
define i32 @sbitmap_a_xor_b(%struct.simple_bitmap_def* nocapture %dst, %struct.simple_bitmap_def* nocapture readonly %a, %struct.simple_bitmap_def* nocapture readonly %b) #0 {
entry:
  %size = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 1
  %0 = load i32* %size, align 4, !tbaa !6
  %cmp13 = icmp eq i32 %0, 0
  br i1 %cmp13, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %arraydecay4 = getelementptr inbounds %struct.simple_bitmap_def* %b, i64 0, i32 3, i64 0
  %arraydecay2 = getelementptr inbounds %struct.simple_bitmap_def* %a, i64 0, i32 3, i64 0
  %arraydecay = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 0
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %i.018 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc ]
  %changed.017 = phi i32 [ 0, %for.body.lr.ph ], [ %changed.1, %for.inc ]
  %bp.016 = phi i64* [ %arraydecay4, %for.body.lr.ph ], [ %incdec.ptr5, %for.inc ]
  %ap.015 = phi i64* [ %arraydecay2, %for.body.lr.ph ], [ %incdec.ptr, %for.inc ]
  %dstp.014 = phi i64* [ %arraydecay, %for.body.lr.ph ], [ %incdec.ptr7, %for.inc ]
  %incdec.ptr = getelementptr inbounds i64* %ap.015, i64 1
  %1 = load i64* %ap.015, align 8, !tbaa !10
  %incdec.ptr5 = getelementptr inbounds i64* %bp.016, i64 1
  %2 = load i64* %bp.016, align 8, !tbaa !10
  %xor = xor i64 %2, %1
  %3 = load i64* %dstp.014, align 8, !tbaa !10
  %cmp6 = icmp eq i64 %3, %xor
  br i1 %cmp6, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  store i64 %xor, i64* %dstp.014, align 8, !tbaa !10
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %changed.1 = phi i32 [ 1, %if.then ], [ %changed.017, %for.body ]
  %inc = add i32 %i.018, 1
  %incdec.ptr7 = getelementptr inbounds i64* %dstp.014, i64 1
  %cmp = icmp ult i32 %inc, %0
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.inc, %entry
  %changed.0.lcssa = phi i32 [ 0, %entry ], [ %changed.1, %for.inc ]
  ret i32 %changed.0.lcssa
}

; Function Attrs: nounwind uwtable
define i32 @sbitmap_a_or_b(%struct.simple_bitmap_def* nocapture %dst, %struct.simple_bitmap_def* nocapture readonly %a, %struct.simple_bitmap_def* nocapture readonly %b) #0 {
entry:
  %size = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 1
  %0 = load i32* %size, align 4, !tbaa !6
  %cmp13 = icmp eq i32 %0, 0
  br i1 %cmp13, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %arraydecay4 = getelementptr inbounds %struct.simple_bitmap_def* %b, i64 0, i32 3, i64 0
  %arraydecay2 = getelementptr inbounds %struct.simple_bitmap_def* %a, i64 0, i32 3, i64 0
  %arraydecay = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 0
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %i.018 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc ]
  %changed.017 = phi i32 [ 0, %for.body.lr.ph ], [ %changed.1, %for.inc ]
  %bp.016 = phi i64* [ %arraydecay4, %for.body.lr.ph ], [ %incdec.ptr5, %for.inc ]
  %ap.015 = phi i64* [ %arraydecay2, %for.body.lr.ph ], [ %incdec.ptr, %for.inc ]
  %dstp.014 = phi i64* [ %arraydecay, %for.body.lr.ph ], [ %incdec.ptr7, %for.inc ]
  %incdec.ptr = getelementptr inbounds i64* %ap.015, i64 1
  %1 = load i64* %ap.015, align 8, !tbaa !10
  %incdec.ptr5 = getelementptr inbounds i64* %bp.016, i64 1
  %2 = load i64* %bp.016, align 8, !tbaa !10
  %or = or i64 %2, %1
  %3 = load i64* %dstp.014, align 8, !tbaa !10
  %cmp6 = icmp eq i64 %3, %or
  br i1 %cmp6, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  store i64 %or, i64* %dstp.014, align 8, !tbaa !10
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %changed.1 = phi i32 [ 1, %if.then ], [ %changed.017, %for.body ]
  %inc = add i32 %i.018, 1
  %incdec.ptr7 = getelementptr inbounds i64* %dstp.014, i64 1
  %cmp = icmp ult i32 %inc, %0
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.inc, %entry
  %changed.0.lcssa = phi i32 [ 0, %entry ], [ %changed.1, %for.inc ]
  ret i32 %changed.0.lcssa
}

; Function Attrs: nounwind readonly uwtable
define i32 @sbitmap_a_subset_b_p(%struct.simple_bitmap_def* nocapture readonly %a, %struct.simple_bitmap_def* nocapture readonly %b) #3 {
entry:
  %size = getelementptr inbounds %struct.simple_bitmap_def* %a, i64 0, i32 1
  %0 = load i32* %size, align 4, !tbaa !6
  %cmp10 = icmp eq i32 %0, 0
  br i1 %cmp10, label %return, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %arraydecay2 = getelementptr inbounds %struct.simple_bitmap_def* %b, i64 0, i32 3, i64 0
  %arraydecay = getelementptr inbounds %struct.simple_bitmap_def* %a, i64 0, i32 3, i64 0
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %bp.013 = phi i64* [ %arraydecay2, %for.body.lr.ph ], [ %incdec.ptr4, %for.inc ]
  %ap.012 = phi i64* [ %arraydecay, %for.body.lr.ph ], [ %incdec.ptr, %for.inc ]
  %i.011 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc ]
  %1 = load i64* %ap.012, align 8, !tbaa !10
  %2 = load i64* %bp.013, align 8, !tbaa !10
  %or = or i64 %2, %1
  %cmp3 = icmp eq i64 %or, %2
  br i1 %cmp3, label %for.inc, label %return

for.inc:                                          ; preds = %for.body
  %inc = add i32 %i.011, 1
  %incdec.ptr = getelementptr inbounds i64* %ap.012, i64 1
  %incdec.ptr4 = getelementptr inbounds i64* %bp.013, i64 1
  %cmp = icmp ult i32 %inc, %0
  br i1 %cmp, label %for.body, label %return

return:                                           ; preds = %for.body, %for.inc, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %for.body ], [ 1, %for.inc ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @sbitmap_a_or_b_and_c(%struct.simple_bitmap_def* nocapture %dst, %struct.simple_bitmap_def* nocapture readonly %a, %struct.simple_bitmap_def* nocapture readonly %b, %struct.simple_bitmap_def* nocapture readonly %c) #0 {
entry:
  %size = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 1
  %0 = load i32* %size, align 4, !tbaa !6
  %cmp16 = icmp eq i32 %0, 0
  br i1 %cmp16, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %arraydecay6 = getelementptr inbounds %struct.simple_bitmap_def* %c, i64 0, i32 3, i64 0
  %arraydecay4 = getelementptr inbounds %struct.simple_bitmap_def* %b, i64 0, i32 3, i64 0
  %arraydecay2 = getelementptr inbounds %struct.simple_bitmap_def* %a, i64 0, i32 3, i64 0
  %arraydecay = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 0
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %i.022 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc ]
  %changed.021 = phi i32 [ 0, %for.body.lr.ph ], [ %changed.1, %for.inc ]
  %cp.020 = phi i64* [ %arraydecay6, %for.body.lr.ph ], [ %incdec.ptr8, %for.inc ]
  %bp.019 = phi i64* [ %arraydecay4, %for.body.lr.ph ], [ %incdec.ptr7, %for.inc ]
  %ap.018 = phi i64* [ %arraydecay2, %for.body.lr.ph ], [ %incdec.ptr, %for.inc ]
  %dstp.017 = phi i64* [ %arraydecay, %for.body.lr.ph ], [ %incdec.ptr10, %for.inc ]
  %incdec.ptr = getelementptr inbounds i64* %ap.018, i64 1
  %1 = load i64* %ap.018, align 8, !tbaa !10
  %incdec.ptr7 = getelementptr inbounds i64* %bp.019, i64 1
  %2 = load i64* %bp.019, align 8, !tbaa !10
  %incdec.ptr8 = getelementptr inbounds i64* %cp.020, i64 1
  %3 = load i64* %cp.020, align 8, !tbaa !10
  %and = and i64 %3, %2
  %or = or i64 %and, %1
  %4 = load i64* %dstp.017, align 8, !tbaa !10
  %cmp9 = icmp eq i64 %4, %or
  br i1 %cmp9, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  store i64 %or, i64* %dstp.017, align 8, !tbaa !10
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %changed.1 = phi i32 [ 1, %if.then ], [ %changed.021, %for.body ]
  %inc = add i32 %i.022, 1
  %incdec.ptr10 = getelementptr inbounds i64* %dstp.017, i64 1
  %cmp = icmp ult i32 %inc, %0
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.inc, %entry
  %changed.0.lcssa = phi i32 [ 0, %entry ], [ %changed.1, %for.inc ]
  ret i32 %changed.0.lcssa
}

; Function Attrs: nounwind uwtable
define i32 @sbitmap_a_and_b_or_c(%struct.simple_bitmap_def* nocapture %dst, %struct.simple_bitmap_def* nocapture readonly %a, %struct.simple_bitmap_def* nocapture readonly %b, %struct.simple_bitmap_def* nocapture readonly %c) #0 {
entry:
  %size = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 1
  %0 = load i32* %size, align 4, !tbaa !6
  %cmp16 = icmp eq i32 %0, 0
  br i1 %cmp16, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %arraydecay6 = getelementptr inbounds %struct.simple_bitmap_def* %c, i64 0, i32 3, i64 0
  %arraydecay4 = getelementptr inbounds %struct.simple_bitmap_def* %b, i64 0, i32 3, i64 0
  %arraydecay2 = getelementptr inbounds %struct.simple_bitmap_def* %a, i64 0, i32 3, i64 0
  %arraydecay = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 0
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %i.022 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc ]
  %changed.021 = phi i32 [ 0, %for.body.lr.ph ], [ %changed.1, %for.inc ]
  %cp.020 = phi i64* [ %arraydecay6, %for.body.lr.ph ], [ %incdec.ptr8, %for.inc ]
  %bp.019 = phi i64* [ %arraydecay4, %for.body.lr.ph ], [ %incdec.ptr7, %for.inc ]
  %ap.018 = phi i64* [ %arraydecay2, %for.body.lr.ph ], [ %incdec.ptr, %for.inc ]
  %dstp.017 = phi i64* [ %arraydecay, %for.body.lr.ph ], [ %incdec.ptr10, %for.inc ]
  %incdec.ptr = getelementptr inbounds i64* %ap.018, i64 1
  %1 = load i64* %ap.018, align 8, !tbaa !10
  %incdec.ptr7 = getelementptr inbounds i64* %bp.019, i64 1
  %2 = load i64* %bp.019, align 8, !tbaa !10
  %incdec.ptr8 = getelementptr inbounds i64* %cp.020, i64 1
  %3 = load i64* %cp.020, align 8, !tbaa !10
  %or = or i64 %3, %2
  %and = and i64 %or, %1
  %4 = load i64* %dstp.017, align 8, !tbaa !10
  %cmp9 = icmp eq i64 %4, %and
  br i1 %cmp9, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  store i64 %and, i64* %dstp.017, align 8, !tbaa !10
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %changed.1 = phi i32 [ 1, %if.then ], [ %changed.021, %for.body ]
  %inc = add i32 %i.022, 1
  %incdec.ptr10 = getelementptr inbounds i64* %dstp.017, i64 1
  %cmp = icmp ult i32 %inc, %0
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.inc, %entry
  %changed.0.lcssa = phi i32 [ 0, %entry ], [ %changed.1, %for.inc ]
  ret i32 %changed.0.lcssa
}

; Function Attrs: nounwind uwtable
define void @sbitmap_intersection_of_succs(%struct.simple_bitmap_def* nocapture %dst, %struct.simple_bitmap_def** nocapture readonly %src, i32 %bb) #0 {
entry:
  %idxprom = sext i32 %bb to i64
  %0 = load %struct.varray_head_tag** @basic_block_info, align 8, !tbaa !8
  %data = getelementptr inbounds %struct.varray_head_tag* %0, i64 0, i32 4
  %bb1 = bitcast %union.varray_data_tag* %data to [1 x %struct.basic_block_def*]*
  %arrayidx = getelementptr inbounds [1 x %struct.basic_block_def*]* %bb1, i64 0, i64 %idxprom
  %1 = load %struct.basic_block_def** %arrayidx, align 8, !tbaa !8
  %size = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 1
  %2 = load i32* %size, align 4, !tbaa !6
  %succ = getelementptr inbounds %struct.basic_block_def* %1, i64 0, i32 5
  %e.058 = load %struct.edge_def** %succ, align 8
  %cond59 = icmp eq %struct.edge_def* %e.058, null
  br i1 %cond59, label %if.then7, label %for.body

for.cond:                                         ; preds = %for.body
  %succ_next = getelementptr inbounds %struct.edge_def* %e.060, i64 0, i32 1
  %e.0 = load %struct.edge_def** %succ_next, align 8
  %cond = icmp eq %struct.edge_def* %e.0, null
  br i1 %cond, label %if.then7, label %for.body

for.body:                                         ; preds = %entry, %for.cond
  %e.060 = phi %struct.edge_def* [ %e.0, %for.cond ], [ %e.058, %entry ]
  %dest = getelementptr inbounds %struct.edge_def* %e.060, i64 0, i32 3
  %3 = load %struct.basic_block_def** %dest, align 8, !tbaa !12
  %cmp2 = icmp eq %struct.basic_block_def* %3, getelementptr inbounds ([2 x %struct.basic_block_def]* @entry_exit_blocks, i64 0, i64 1)
  br i1 %cmp2, label %for.cond, label %for.cond9.preheader

for.cond9.preheader:                              ; preds = %for.body
  %index = getelementptr inbounds %struct.basic_block_def* %3, i64 0, i32 11
  %4 = load i32* %index, align 4, !tbaa !14
  %idxprom4 = sext i32 %4 to i64
  %arrayidx5 = getelementptr inbounds %struct.simple_bitmap_def** %src, i64 %idxprom4
  %5 = load %struct.simple_bitmap_def** %arrayidx5, align 8, !tbaa !8
  %elms.i = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3
  %6 = bitcast [1 x i64]* %elms.i to i8*
  %elms1.i = getelementptr inbounds %struct.simple_bitmap_def* %5, i64 0, i32 3
  %7 = bitcast [1 x i64]* %elms1.i to i8*
  %conv.i = zext i32 %2 to i64
  %mul.i = shl nuw nsw i64 %conv.i, 3
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 %mul.i, i32 8, i1 false) #2
  %e.1.in54 = getelementptr inbounds %struct.edge_def* %e.060, i64 0, i32 1
  %e.155 = load %struct.edge_def** %e.1.in54, align 8
  %cmp1056 = icmp eq %struct.edge_def* %e.155, null
  br i1 %cmp1056, label %if.end31, label %for.body11.lr.ph

for.body11.lr.ph:                                 ; preds = %for.cond9.preheader
  %arraydecay21 = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 0
  %cmp2350 = icmp eq i32 %2, 0
  br i1 %cmp2350, label %for.cond9.backedge, label %for.body11.us

for.body11.us:                                    ; preds = %for.body11.lr.ph, %for.cond9.backedge.us
  %e.157.us = phi %struct.edge_def* [ %e.1.us, %for.cond9.backedge.us ], [ %e.155, %for.body11.lr.ph ]
  %dest12.us = getelementptr inbounds %struct.edge_def* %e.157.us, i64 0, i32 3
  %8 = load %struct.basic_block_def** %dest12.us, align 8, !tbaa !12
  %cmp13.us = icmp eq %struct.basic_block_def* %8, getelementptr inbounds ([2 x %struct.basic_block_def]* @entry_exit_blocks, i64 0, i64 1)
  br i1 %cmp13.us, label %for.cond9.backedge.us, label %for.body24.lr.ph.us

for.body24.us:                                    ; preds = %for.body24.us, %for.body24.lr.ph.us
  %r.053.us = phi i64* [ %arraydecay21, %for.body24.lr.ph.us ], [ %incdec.ptr25.us, %for.body24.us ]
  %p.052.us = phi i64* [ %arraydecay.us, %for.body24.lr.ph.us ], [ %incdec.ptr.us, %for.body24.us ]
  %i.051.us = phi i32 [ 0, %for.body24.lr.ph.us ], [ %inc.us, %for.body24.us ]
  %incdec.ptr.us = getelementptr inbounds i64* %p.052.us, i64 1
  %9 = load i64* %p.052.us, align 8, !tbaa !10
  %incdec.ptr25.us = getelementptr inbounds i64* %r.053.us, i64 1
  %10 = load i64* %r.053.us, align 8, !tbaa !10
  %and.us = and i64 %10, %9
  store i64 %and.us, i64* %r.053.us, align 8, !tbaa !10
  %inc.us = add i32 %i.051.us, 1
  %exitcond = icmp eq i32 %inc.us, %2
  br i1 %exitcond, label %for.cond9.backedge.us, label %for.body24.us

for.cond9.backedge.us:                            ; preds = %for.body24.us, %for.body11.us
  %e.1.in.us = getelementptr inbounds %struct.edge_def* %e.157.us, i64 0, i32 1
  %e.1.us = load %struct.edge_def** %e.1.in.us, align 8
  %cmp10.us = icmp eq %struct.edge_def* %e.1.us, null
  br i1 %cmp10.us, label %if.end31, label %for.body11.us

for.body24.lr.ph.us:                              ; preds = %for.body11.us
  %index17.us = getelementptr inbounds %struct.basic_block_def* %8, i64 0, i32 11
  %11 = load i32* %index17.us, align 4, !tbaa !14
  %idxprom18.us = sext i32 %11 to i64
  %arrayidx19.us = getelementptr inbounds %struct.simple_bitmap_def** %src, i64 %idxprom18.us
  %12 = load %struct.simple_bitmap_def** %arrayidx19.us, align 8, !tbaa !8
  %arraydecay.us = getelementptr inbounds %struct.simple_bitmap_def* %12, i64 0, i32 3, i64 0
  br label %for.body24.us

if.then7:                                         ; preds = %for.cond, %entry
  %elms.i46.pre = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3
  %.pre = bitcast [1 x i64]* %elms.i46.pre to i8*
  %bytes.i = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 2
  %13 = load i32* %bytes.i, align 4, !tbaa !7
  %conv.i47 = zext i32 %13 to i64
  tail call void @llvm.memset.p0i8.i64(i8* %.pre, i8 -1, i64 %conv.i47, i32 1, i1 false) #2
  %n_bits.i = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 0
  %14 = load i32* %n_bits.i, align 4, !tbaa !1
  %rem.i = and i32 %14, 63
  %tobool.i = icmp eq i32 %rem.i, 0
  br i1 %tobool.i, label %if.end31, label %if.then.i

if.then.i:                                        ; preds = %if.then7
  %sub.i = sub i32 64, %rem.i
  %sh_prom.i = zext i32 %sub.i to i64
  %shr.i = lshr i64 -1, %sh_prom.i
  %sub1.i = add i32 %2, -1
  %idxprom.i = zext i32 %sub1.i to i64
  %arrayidx.i = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 %idxprom.i
  store i64 %shr.i, i64* %arrayidx.i, align 8, !tbaa !10
  br label %if.end31

for.cond9.backedge:                               ; preds = %for.body11.lr.ph, %for.cond9.backedge
  %e.157 = phi %struct.edge_def* [ %e.1, %for.cond9.backedge ], [ %e.155, %for.body11.lr.ph ]
  %e.1.in = getelementptr inbounds %struct.edge_def* %e.157, i64 0, i32 1
  %e.1 = load %struct.edge_def** %e.1.in, align 8
  %cmp10 = icmp eq %struct.edge_def* %e.1, null
  br i1 %cmp10, label %if.end31, label %for.cond9.backedge

if.end31:                                         ; preds = %for.cond9.backedge.us, %for.cond9.backedge, %for.cond9.preheader, %if.then.i, %if.then7
  ret void
}

; Function Attrs: nounwind uwtable
define void @sbitmap_intersection_of_preds(%struct.simple_bitmap_def* nocapture %dst, %struct.simple_bitmap_def** nocapture readonly %src, i32 %bb) #0 {
entry:
  %idxprom = sext i32 %bb to i64
  %0 = load %struct.varray_head_tag** @basic_block_info, align 8, !tbaa !8
  %data = getelementptr inbounds %struct.varray_head_tag* %0, i64 0, i32 4
  %bb1 = bitcast %union.varray_data_tag* %data to [1 x %struct.basic_block_def*]*
  %arrayidx = getelementptr inbounds [1 x %struct.basic_block_def*]* %bb1, i64 0, i64 %idxprom
  %1 = load %struct.basic_block_def** %arrayidx, align 8, !tbaa !8
  %size = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 1
  %2 = load i32* %size, align 4, !tbaa !6
  %pred = getelementptr inbounds %struct.basic_block_def* %1, i64 0, i32 4
  %e.059 = load %struct.edge_def** %pred, align 8
  %cond60 = icmp eq %struct.edge_def* %e.059, null
  br i1 %cond60, label %if.then8, label %for.body

for.cond:                                         ; preds = %for.body
  %pred_next = getelementptr inbounds %struct.edge_def* %e.061, i64 0, i32 0
  %e.0 = load %struct.edge_def** %pred_next, align 8
  %cond = icmp eq %struct.edge_def* %e.0, null
  br i1 %cond, label %if.then8, label %for.body

for.body:                                         ; preds = %entry, %for.cond
  %e.061 = phi %struct.edge_def* [ %e.0, %for.cond ], [ %e.059, %entry ]
  %src2 = getelementptr inbounds %struct.edge_def* %e.061, i64 0, i32 2
  %3 = load %struct.basic_block_def** %src2, align 8, !tbaa !16
  %cmp3 = icmp eq %struct.basic_block_def* %3, getelementptr inbounds ([2 x %struct.basic_block_def]* @entry_exit_blocks, i64 0, i64 0)
  br i1 %cmp3, label %for.cond, label %for.cond10.preheader

for.cond10.preheader:                             ; preds = %for.body
  %index = getelementptr inbounds %struct.basic_block_def* %3, i64 0, i32 11
  %4 = load i32* %index, align 4, !tbaa !14
  %idxprom5 = sext i32 %4 to i64
  %arrayidx6 = getelementptr inbounds %struct.simple_bitmap_def** %src, i64 %idxprom5
  %5 = load %struct.simple_bitmap_def** %arrayidx6, align 8, !tbaa !8
  %elms.i = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3
  %6 = bitcast [1 x i64]* %elms.i to i8*
  %elms1.i = getelementptr inbounds %struct.simple_bitmap_def* %5, i64 0, i32 3
  %7 = bitcast [1 x i64]* %elms1.i to i8*
  %conv.i = zext i32 %2 to i64
  %mul.i = shl nuw nsw i64 %conv.i, 3
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 %mul.i, i32 8, i1 false) #2
  %e.1.in55 = getelementptr inbounds %struct.edge_def* %e.061, i64 0, i32 0
  %e.156 = load %struct.edge_def** %e.1.in55, align 8
  %cmp1157 = icmp eq %struct.edge_def* %e.156, null
  br i1 %cmp1157, label %if.end32, label %for.body12.lr.ph

for.body12.lr.ph:                                 ; preds = %for.cond10.preheader
  %arraydecay22 = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 0
  %cmp2451 = icmp eq i32 %2, 0
  br i1 %cmp2451, label %for.cond10.backedge, label %for.body12.us

for.body12.us:                                    ; preds = %for.body12.lr.ph, %for.cond10.backedge.us
  %e.158.us = phi %struct.edge_def* [ %e.1.us, %for.cond10.backedge.us ], [ %e.156, %for.body12.lr.ph ]
  %src13.us = getelementptr inbounds %struct.edge_def* %e.158.us, i64 0, i32 2
  %8 = load %struct.basic_block_def** %src13.us, align 8, !tbaa !16
  %cmp14.us = icmp eq %struct.basic_block_def* %8, getelementptr inbounds ([2 x %struct.basic_block_def]* @entry_exit_blocks, i64 0, i64 0)
  br i1 %cmp14.us, label %for.cond10.backedge.us, label %for.body25.lr.ph.us

for.body25.us:                                    ; preds = %for.body25.us, %for.body25.lr.ph.us
  %r.054.us = phi i64* [ %arraydecay22, %for.body25.lr.ph.us ], [ %incdec.ptr26.us, %for.body25.us ]
  %p.053.us = phi i64* [ %arraydecay.us, %for.body25.lr.ph.us ], [ %incdec.ptr.us, %for.body25.us ]
  %i.052.us = phi i32 [ 0, %for.body25.lr.ph.us ], [ %inc.us, %for.body25.us ]
  %incdec.ptr.us = getelementptr inbounds i64* %p.053.us, i64 1
  %9 = load i64* %p.053.us, align 8, !tbaa !10
  %incdec.ptr26.us = getelementptr inbounds i64* %r.054.us, i64 1
  %10 = load i64* %r.054.us, align 8, !tbaa !10
  %and.us = and i64 %10, %9
  store i64 %and.us, i64* %r.054.us, align 8, !tbaa !10
  %inc.us = add i32 %i.052.us, 1
  %exitcond = icmp eq i32 %inc.us, %2
  br i1 %exitcond, label %for.cond10.backedge.us, label %for.body25.us

for.cond10.backedge.us:                           ; preds = %for.body25.us, %for.body12.us
  %e.1.in.us = getelementptr inbounds %struct.edge_def* %e.158.us, i64 0, i32 0
  %e.1.us = load %struct.edge_def** %e.1.in.us, align 8
  %cmp11.us = icmp eq %struct.edge_def* %e.1.us, null
  br i1 %cmp11.us, label %if.end32, label %for.body12.us

for.body25.lr.ph.us:                              ; preds = %for.body12.us
  %index18.us = getelementptr inbounds %struct.basic_block_def* %8, i64 0, i32 11
  %11 = load i32* %index18.us, align 4, !tbaa !14
  %idxprom19.us = sext i32 %11 to i64
  %arrayidx20.us = getelementptr inbounds %struct.simple_bitmap_def** %src, i64 %idxprom19.us
  %12 = load %struct.simple_bitmap_def** %arrayidx20.us, align 8, !tbaa !8
  %arraydecay.us = getelementptr inbounds %struct.simple_bitmap_def* %12, i64 0, i32 3, i64 0
  br label %for.body25.us

if.then8:                                         ; preds = %for.cond, %entry
  %elms.i47.pre = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3
  %.pre = bitcast [1 x i64]* %elms.i47.pre to i8*
  %bytes.i = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 2
  %13 = load i32* %bytes.i, align 4, !tbaa !7
  %conv.i48 = zext i32 %13 to i64
  tail call void @llvm.memset.p0i8.i64(i8* %.pre, i8 -1, i64 %conv.i48, i32 1, i1 false) #2
  %n_bits.i = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 0
  %14 = load i32* %n_bits.i, align 4, !tbaa !1
  %rem.i = and i32 %14, 63
  %tobool.i = icmp eq i32 %rem.i, 0
  br i1 %tobool.i, label %if.end32, label %if.then.i

if.then.i:                                        ; preds = %if.then8
  %sub.i = sub i32 64, %rem.i
  %sh_prom.i = zext i32 %sub.i to i64
  %shr.i = lshr i64 -1, %sh_prom.i
  %sub1.i = add i32 %2, -1
  %idxprom.i = zext i32 %sub1.i to i64
  %arrayidx.i = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 %idxprom.i
  store i64 %shr.i, i64* %arrayidx.i, align 8, !tbaa !10
  br label %if.end32

for.cond10.backedge:                              ; preds = %for.body12.lr.ph, %for.cond10.backedge
  %e.158 = phi %struct.edge_def* [ %e.1, %for.cond10.backedge ], [ %e.156, %for.body12.lr.ph ]
  %e.1.in = getelementptr inbounds %struct.edge_def* %e.158, i64 0, i32 0
  %e.1 = load %struct.edge_def** %e.1.in, align 8
  %cmp11 = icmp eq %struct.edge_def* %e.1, null
  br i1 %cmp11, label %if.end32, label %for.cond10.backedge

if.end32:                                         ; preds = %for.cond10.backedge.us, %for.cond10.backedge, %for.cond10.preheader, %if.then.i, %if.then8
  ret void
}

; Function Attrs: nounwind uwtable
define void @sbitmap_union_of_succs(%struct.simple_bitmap_def* nocapture %dst, %struct.simple_bitmap_def** nocapture readonly %src, i32 %bb) #0 {
entry:
  %idxprom = sext i32 %bb to i64
  %0 = load %struct.varray_head_tag** @basic_block_info, align 8, !tbaa !8
  %data = getelementptr inbounds %struct.varray_head_tag* %0, i64 0, i32 4
  %bb1 = bitcast %union.varray_data_tag* %data to [1 x %struct.basic_block_def*]*
  %arrayidx = getelementptr inbounds [1 x %struct.basic_block_def*]* %bb1, i64 0, i64 %idxprom
  %1 = load %struct.basic_block_def** %arrayidx, align 8, !tbaa !8
  %size = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 1
  %2 = load i32* %size, align 4, !tbaa !6
  %succ = getelementptr inbounds %struct.basic_block_def* %1, i64 0, i32 5
  %e.056 = load %struct.edge_def** %succ, align 8
  %cond57 = icmp eq %struct.edge_def* %e.056, null
  br i1 %cond57, label %if.then7, label %for.body

for.cond:                                         ; preds = %for.body
  %succ_next = getelementptr inbounds %struct.edge_def* %e.058, i64 0, i32 1
  %e.0 = load %struct.edge_def** %succ_next, align 8
  %cond = icmp eq %struct.edge_def* %e.0, null
  br i1 %cond, label %if.then7, label %for.body

for.body:                                         ; preds = %entry, %for.cond
  %e.058 = phi %struct.edge_def* [ %e.0, %for.cond ], [ %e.056, %entry ]
  %dest = getelementptr inbounds %struct.edge_def* %e.058, i64 0, i32 3
  %3 = load %struct.basic_block_def** %dest, align 8, !tbaa !12
  %cmp2 = icmp eq %struct.basic_block_def* %3, getelementptr inbounds ([2 x %struct.basic_block_def]* @entry_exit_blocks, i64 0, i64 1)
  br i1 %cmp2, label %for.cond, label %for.cond9.preheader

for.cond9.preheader:                              ; preds = %for.body
  %index = getelementptr inbounds %struct.basic_block_def* %3, i64 0, i32 11
  %4 = load i32* %index, align 4, !tbaa !14
  %idxprom4 = sext i32 %4 to i64
  %arrayidx5 = getelementptr inbounds %struct.simple_bitmap_def** %src, i64 %idxprom4
  %5 = load %struct.simple_bitmap_def** %arrayidx5, align 8, !tbaa !8
  %elms.i = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3
  %6 = bitcast [1 x i64]* %elms.i to i8*
  %elms1.i = getelementptr inbounds %struct.simple_bitmap_def* %5, i64 0, i32 3
  %7 = bitcast [1 x i64]* %elms1.i to i8*
  %conv.i = zext i32 %2 to i64
  %mul.i = shl nuw nsw i64 %conv.i, 3
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 %mul.i, i32 8, i1 false) #2
  %e.1.in52 = getelementptr inbounds %struct.edge_def* %e.058, i64 0, i32 1
  %e.153 = load %struct.edge_def** %e.1.in52, align 8
  %cmp1054 = icmp eq %struct.edge_def* %e.153, null
  br i1 %cmp1054, label %if.end31, label %for.body11.lr.ph

for.body11.lr.ph:                                 ; preds = %for.cond9.preheader
  %arraydecay21 = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 0
  %cmp2348 = icmp eq i32 %2, 0
  br i1 %cmp2348, label %for.cond9.backedge, label %for.body11.us

for.body11.us:                                    ; preds = %for.body11.lr.ph, %for.cond9.backedge.us
  %e.155.us = phi %struct.edge_def* [ %e.1.us, %for.cond9.backedge.us ], [ %e.153, %for.body11.lr.ph ]
  %dest12.us = getelementptr inbounds %struct.edge_def* %e.155.us, i64 0, i32 3
  %8 = load %struct.basic_block_def** %dest12.us, align 8, !tbaa !12
  %cmp13.us = icmp eq %struct.basic_block_def* %8, getelementptr inbounds ([2 x %struct.basic_block_def]* @entry_exit_blocks, i64 0, i64 1)
  br i1 %cmp13.us, label %for.cond9.backedge.us, label %for.body24.lr.ph.us

for.body24.us:                                    ; preds = %for.body24.us, %for.body24.lr.ph.us
  %r.051.us = phi i64* [ %arraydecay21, %for.body24.lr.ph.us ], [ %incdec.ptr25.us, %for.body24.us ]
  %p.050.us = phi i64* [ %arraydecay.us, %for.body24.lr.ph.us ], [ %incdec.ptr.us, %for.body24.us ]
  %i.049.us = phi i32 [ 0, %for.body24.lr.ph.us ], [ %inc.us, %for.body24.us ]
  %incdec.ptr.us = getelementptr inbounds i64* %p.050.us, i64 1
  %9 = load i64* %p.050.us, align 8, !tbaa !10
  %incdec.ptr25.us = getelementptr inbounds i64* %r.051.us, i64 1
  %10 = load i64* %r.051.us, align 8, !tbaa !10
  %or.us = or i64 %10, %9
  store i64 %or.us, i64* %r.051.us, align 8, !tbaa !10
  %inc.us = add i32 %i.049.us, 1
  %exitcond = icmp eq i32 %inc.us, %2
  br i1 %exitcond, label %for.cond9.backedge.us, label %for.body24.us

for.cond9.backedge.us:                            ; preds = %for.body24.us, %for.body11.us
  %e.1.in.us = getelementptr inbounds %struct.edge_def* %e.155.us, i64 0, i32 1
  %e.1.us = load %struct.edge_def** %e.1.in.us, align 8
  %cmp10.us = icmp eq %struct.edge_def* %e.1.us, null
  br i1 %cmp10.us, label %if.end31, label %for.body11.us

for.body24.lr.ph.us:                              ; preds = %for.body11.us
  %index17.us = getelementptr inbounds %struct.basic_block_def* %8, i64 0, i32 11
  %11 = load i32* %index17.us, align 4, !tbaa !14
  %idxprom18.us = sext i32 %11 to i64
  %arrayidx19.us = getelementptr inbounds %struct.simple_bitmap_def** %src, i64 %idxprom18.us
  %12 = load %struct.simple_bitmap_def** %arrayidx19.us, align 8, !tbaa !8
  %arraydecay.us = getelementptr inbounds %struct.simple_bitmap_def* %12, i64 0, i32 3, i64 0
  br label %for.body24.us

if.then7:                                         ; preds = %for.cond, %entry
  %arraydecay.i = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 0
  %13 = bitcast i64* %arraydecay.i to i8*
  %bytes.i = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 2
  %14 = load i32* %bytes.i, align 4, !tbaa !7
  %conv.i46 = zext i32 %14 to i64
  tail call void @llvm.memset.p0i8.i64(i8* %13, i8 0, i64 %conv.i46, i32 1, i1 false) #2
  br label %if.end31

for.cond9.backedge:                               ; preds = %for.body11.lr.ph, %for.cond9.backedge
  %e.155 = phi %struct.edge_def* [ %e.1, %for.cond9.backedge ], [ %e.153, %for.body11.lr.ph ]
  %e.1.in = getelementptr inbounds %struct.edge_def* %e.155, i64 0, i32 1
  %e.1 = load %struct.edge_def** %e.1.in, align 8
  %cmp10 = icmp eq %struct.edge_def* %e.1, null
  br i1 %cmp10, label %if.end31, label %for.cond9.backedge

if.end31:                                         ; preds = %for.cond9.backedge.us, %for.cond9.backedge, %for.cond9.preheader, %if.then7
  ret void
}

; Function Attrs: nounwind uwtable
define void @sbitmap_union_of_preds(%struct.simple_bitmap_def* nocapture %dst, %struct.simple_bitmap_def** nocapture readonly %src, i32 %bb) #0 {
entry:
  %idxprom = sext i32 %bb to i64
  %0 = load %struct.varray_head_tag** @basic_block_info, align 8, !tbaa !8
  %data = getelementptr inbounds %struct.varray_head_tag* %0, i64 0, i32 4
  %bb1 = bitcast %union.varray_data_tag* %data to [1 x %struct.basic_block_def*]*
  %arrayidx = getelementptr inbounds [1 x %struct.basic_block_def*]* %bb1, i64 0, i64 %idxprom
  %1 = load %struct.basic_block_def** %arrayidx, align 8, !tbaa !8
  %size = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 1
  %2 = load i32* %size, align 4, !tbaa !6
  %pred = getelementptr inbounds %struct.basic_block_def* %1, i64 0, i32 4
  %e.057 = load %struct.edge_def** %pred, align 8
  %cond58 = icmp eq %struct.edge_def* %e.057, null
  br i1 %cond58, label %if.then8, label %for.body

for.cond:                                         ; preds = %for.body
  %pred_next = getelementptr inbounds %struct.edge_def* %e.059, i64 0, i32 0
  %e.0 = load %struct.edge_def** %pred_next, align 8
  %cond = icmp eq %struct.edge_def* %e.0, null
  br i1 %cond, label %if.then8, label %for.body

for.body:                                         ; preds = %entry, %for.cond
  %e.059 = phi %struct.edge_def* [ %e.0, %for.cond ], [ %e.057, %entry ]
  %src2 = getelementptr inbounds %struct.edge_def* %e.059, i64 0, i32 2
  %3 = load %struct.basic_block_def** %src2, align 8, !tbaa !16
  %cmp3 = icmp eq %struct.basic_block_def* %3, getelementptr inbounds ([2 x %struct.basic_block_def]* @entry_exit_blocks, i64 0, i64 0)
  br i1 %cmp3, label %for.cond, label %for.cond10.preheader

for.cond10.preheader:                             ; preds = %for.body
  %index = getelementptr inbounds %struct.basic_block_def* %3, i64 0, i32 11
  %4 = load i32* %index, align 4, !tbaa !14
  %idxprom5 = sext i32 %4 to i64
  %arrayidx6 = getelementptr inbounds %struct.simple_bitmap_def** %src, i64 %idxprom5
  %5 = load %struct.simple_bitmap_def** %arrayidx6, align 8, !tbaa !8
  %elms.i = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3
  %6 = bitcast [1 x i64]* %elms.i to i8*
  %elms1.i = getelementptr inbounds %struct.simple_bitmap_def* %5, i64 0, i32 3
  %7 = bitcast [1 x i64]* %elms1.i to i8*
  %conv.i = zext i32 %2 to i64
  %mul.i = shl nuw nsw i64 %conv.i, 3
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 %mul.i, i32 8, i1 false) #2
  %e.1.in53 = getelementptr inbounds %struct.edge_def* %e.059, i64 0, i32 0
  %e.154 = load %struct.edge_def** %e.1.in53, align 8
  %cmp1155 = icmp eq %struct.edge_def* %e.154, null
  br i1 %cmp1155, label %if.end32, label %for.body12.lr.ph

for.body12.lr.ph:                                 ; preds = %for.cond10.preheader
  %arraydecay22 = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 0
  %cmp2449 = icmp eq i32 %2, 0
  br i1 %cmp2449, label %for.cond10.backedge, label %for.body12.us

for.body12.us:                                    ; preds = %for.body12.lr.ph, %for.cond10.backedge.us
  %e.156.us = phi %struct.edge_def* [ %e.1.us, %for.cond10.backedge.us ], [ %e.154, %for.body12.lr.ph ]
  %src13.us = getelementptr inbounds %struct.edge_def* %e.156.us, i64 0, i32 2
  %8 = load %struct.basic_block_def** %src13.us, align 8, !tbaa !16
  %cmp14.us = icmp eq %struct.basic_block_def* %8, getelementptr inbounds ([2 x %struct.basic_block_def]* @entry_exit_blocks, i64 0, i64 0)
  br i1 %cmp14.us, label %for.cond10.backedge.us, label %for.body25.lr.ph.us

for.body25.us:                                    ; preds = %for.body25.us, %for.body25.lr.ph.us
  %r.052.us = phi i64* [ %arraydecay22, %for.body25.lr.ph.us ], [ %incdec.ptr26.us, %for.body25.us ]
  %p.051.us = phi i64* [ %arraydecay.us, %for.body25.lr.ph.us ], [ %incdec.ptr.us, %for.body25.us ]
  %i.050.us = phi i32 [ 0, %for.body25.lr.ph.us ], [ %inc.us, %for.body25.us ]
  %incdec.ptr.us = getelementptr inbounds i64* %p.051.us, i64 1
  %9 = load i64* %p.051.us, align 8, !tbaa !10
  %incdec.ptr26.us = getelementptr inbounds i64* %r.052.us, i64 1
  %10 = load i64* %r.052.us, align 8, !tbaa !10
  %or.us = or i64 %10, %9
  store i64 %or.us, i64* %r.052.us, align 8, !tbaa !10
  %inc.us = add i32 %i.050.us, 1
  %exitcond = icmp eq i32 %inc.us, %2
  br i1 %exitcond, label %for.cond10.backedge.us, label %for.body25.us

for.cond10.backedge.us:                           ; preds = %for.body25.us, %for.body12.us
  %e.1.in.us = getelementptr inbounds %struct.edge_def* %e.156.us, i64 0, i32 0
  %e.1.us = load %struct.edge_def** %e.1.in.us, align 8
  %cmp11.us = icmp eq %struct.edge_def* %e.1.us, null
  br i1 %cmp11.us, label %if.end32, label %for.body12.us

for.body25.lr.ph.us:                              ; preds = %for.body12.us
  %index18.us = getelementptr inbounds %struct.basic_block_def* %8, i64 0, i32 11
  %11 = load i32* %index18.us, align 4, !tbaa !14
  %idxprom19.us = sext i32 %11 to i64
  %arrayidx20.us = getelementptr inbounds %struct.simple_bitmap_def** %src, i64 %idxprom19.us
  %12 = load %struct.simple_bitmap_def** %arrayidx20.us, align 8, !tbaa !8
  %arraydecay.us = getelementptr inbounds %struct.simple_bitmap_def* %12, i64 0, i32 3, i64 0
  br label %for.body25.us

if.then8:                                         ; preds = %for.cond, %entry
  %arraydecay.i = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 3, i64 0
  %13 = bitcast i64* %arraydecay.i to i8*
  %bytes.i = getelementptr inbounds %struct.simple_bitmap_def* %dst, i64 0, i32 2
  %14 = load i32* %bytes.i, align 4, !tbaa !7
  %conv.i47 = zext i32 %14 to i64
  tail call void @llvm.memset.p0i8.i64(i8* %13, i8 0, i64 %conv.i47, i32 1, i1 false) #2
  br label %if.end32

for.cond10.backedge:                              ; preds = %for.body12.lr.ph, %for.cond10.backedge
  %e.156 = phi %struct.edge_def* [ %e.1, %for.cond10.backedge ], [ %e.154, %for.body12.lr.ph ]
  %e.1.in = getelementptr inbounds %struct.edge_def* %e.156, i64 0, i32 0
  %e.1 = load %struct.edge_def** %e.1.in, align 8
  %cmp11 = icmp eq %struct.edge_def* %e.1, null
  br i1 %cmp11, label %if.end32, label %for.cond10.backedge

if.end32:                                         ; preds = %for.cond10.backedge.us, %for.cond10.backedge, %for.cond10.preheader, %if.then8
  ret void
}

; Function Attrs: nounwind readonly uwtable
define i32 @sbitmap_first_set_bit(%struct.simple_bitmap_def* nocapture readonly %bmap) #3 {
entry:
  %size = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 1
  %0 = load i32* %size, align 4, !tbaa !6
  %cmp25 = icmp eq i32 %0, 0
  br i1 %cmp25, label %return, label %for.body

for.body:                                         ; preds = %entry, %for.inc9
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc9 ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 3, i64 %indvars.iv
  %1 = load i64* %arrayidx, align 8, !tbaa !10
  %cmp1 = icmp eq i64 %1, 0
  br i1 %cmp1, label %for.inc9, label %for.body4

for.body4:                                        ; preds = %for.body, %for.inc
  %bit_num_.1 = phi i32 [ %inc, %for.inc ], [ 0, %for.body ]
  %sh_prom = zext i32 %bit_num_.1 to i64
  %shl = shl i64 1, %sh_prom
  %and = and i64 %shl, %1
  %cmp5 = icmp eq i64 %and, 0
  br i1 %cmp5, label %for.inc, label %if.then6

if.then6:                                         ; preds = %for.body4
  %2 = trunc i64 %indvars.iv to i32
  %mul = shl i32 %2, 6
  %add = add i32 %bit_num_.1, %mul
  br label %return

for.inc:                                          ; preds = %for.body4
  %inc = add i32 %bit_num_.1, 1
  %cmp3.old = icmp ult i32 %inc, 64
  br i1 %cmp3.old, label %for.body4, label %for.inc9

for.inc9:                                         ; preds = %for.inc, %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %3 = trunc i64 %indvars.iv.next to i32
  %cmp = icmp ult i32 %3, %0
  br i1 %cmp, label %for.body, label %return

return:                                           ; preds = %for.inc9, %entry, %if.then6
  %retval.0 = phi i32 [ %add, %if.then6 ], [ -1, %entry ], [ -1, %for.inc9 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind readonly uwtable
define i32 @sbitmap_last_set_bit(%struct.simple_bitmap_def* nocapture readonly %bmap) #3 {
entry:
  %size = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 1
  %0 = load i32* %size, align 4, !tbaa !6
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0.in = phi i32 [ %0, %entry ], [ %i.0, %for.body ]
  %i.0 = add i32 %i.0.in, -1
  %cmp = icmp sgt i32 %i.0, -1
  br i1 %cmp, label %for.body, label %return

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 3, i64 %idxprom
  %1 = load i64* %arrayidx, align 8, !tbaa !10
  %cmp1 = icmp eq i64 %1, 0
  br i1 %cmp1, label %for.cond, label %if.then

if.then:                                          ; preds = %for.body
  %mul = shl i32 %i.0.in, 6
  br label %while.body

while.body:                                       ; preds = %while.body, %if.then
  %index.0.in = phi i32 [ %mul, %if.then ], [ %index.0, %while.body ]
  %mask.0 = phi i64 [ -9223372036854775808, %if.then ], [ %shr, %while.body ]
  %index.0 = add i32 %index.0.in, -1
  %and = and i64 %mask.0, %1
  %cmp3 = icmp eq i64 %and, 0
  %shr = lshr i64 %mask.0, 1
  br i1 %cmp3, label %while.body, label %return

return:                                           ; preds = %for.cond, %while.body
  %retval.0 = phi i32 [ %index.0, %while.body ], [ -1, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @dump_sbitmap(%struct._IO_FILE* nocapture %file, %struct.simple_bitmap_def* nocapture readonly %bmap) #0 {
entry:
  %size = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 1
  %0 = load i32* %size, align 4, !tbaa !6
  %n_bits = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 0
  %1 = load i32* %n_bits, align 4, !tbaa !1
  %2 = tail call i64 @fwrite(i8* getelementptr inbounds ([3 x i8]* @.str, i64 0, i64 0), i64 2, i64 1, %struct._IO_FILE* %file)
  %cmp41 = icmp ne i32 %0, 0
  %cmp142 = icmp ne i32 %1, 0
  %or.cond43 = and i1 %cmp41, %cmp142
  br i1 %or.cond43, label %for.cond2.preheader, label %for.end16

for.cond2.preheader:                              ; preds = %entry, %for.inc14
  %indvars.iv46 = phi i64 [ %indvars.iv.next47, %for.inc14 ], [ 0, %entry ]
  %n.044 = phi i32 [ %n.1.lcssa, %for.inc14 ], [ 0, %entry ]
  %cmp537 = icmp ult i32 %n.044, %1
  br i1 %cmp537, label %for.body7.lr.ph, label %for.inc14

for.body7.lr.ph:                                  ; preds = %for.cond2.preheader
  %arrayidx = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 3, i64 %indvars.iv46
  %3 = sub i32 %n.044, %1
  %4 = icmp ugt i32 %3, -64
  %umax = select i1 %4, i32 %3, i32 -64
  %5 = sub i32 0, %umax
  br label %for.body7

for.body7:                                        ; preds = %if.end, %for.body7.lr.ph
  %indvars.iv = phi i64 [ 0, %for.body7.lr.ph ], [ %indvars.iv.next, %if.end ]
  %n.140 = phi i32 [ %n.044, %for.body7.lr.ph ], [ %inc13, %if.end ]
  %cmp8 = icmp ne i32 %n.140, 0
  %rem = urem i32 %n.140, 10
  %cmp9 = icmp eq i32 %rem, 0
  %or.cond36 = and i1 %cmp8, %cmp9
  br i1 %or.cond36, label %if.then, label %if.end

if.then:                                          ; preds = %for.body7
  %fputc34 = tail call i32 @fputc(i32 32, %struct._IO_FILE* %file)
  br label %if.end

if.end:                                           ; preds = %for.body7, %if.then
  %6 = load i64* %arrayidx, align 8, !tbaa !10
  %shl = shl i64 1, %indvars.iv
  %and = and i64 %6, %shl
  %cmp11 = icmp ne i64 %and, 0
  %conv = zext i1 %cmp11 to i32
  %call12 = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %file, i8* getelementptr inbounds ([3 x i8]* @.str2, i64 0, i64 0), i32 %conv) #2
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %inc13 = add i32 %n.140, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %5
  br i1 %exitcond, label %for.cond2.for.inc14_crit_edge, label %for.body7

for.cond2.for.inc14_crit_edge:                    ; preds = %if.end
  %7 = sub i32 %n.044, %umax
  br label %for.inc14

for.inc14:                                        ; preds = %for.cond2.for.inc14_crit_edge, %for.cond2.preheader
  %n.1.lcssa = phi i32 [ %7, %for.cond2.for.inc14_crit_edge ], [ %n.044, %for.cond2.preheader ]
  %indvars.iv.next47 = add nuw nsw i64 %indvars.iv46, 1
  %8 = trunc i64 %indvars.iv.next47 to i32
  %cmp = icmp ult i32 %8, %0
  %cmp1 = icmp ult i32 %n.1.lcssa, %1
  %or.cond = and i1 %cmp, %cmp1
  br i1 %or.cond, label %for.cond2.preheader, label %for.end16

for.end16:                                        ; preds = %for.inc14, %entry
  %fputc = tail call i32 @fputc(i32 10, %struct._IO_FILE* %file)
  ret void
}

; Function Attrs: nounwind
declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #5

; Function Attrs: nounwind uwtable
define void @debug_sbitmap(%struct.simple_bitmap_def* nocapture readonly %bmap) #0 {
entry:
  %0 = load %struct._IO_FILE** @stderr, align 8, !tbaa !8
  %n_bits = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 0
  %1 = load i32* %n_bits, align 4, !tbaa !1
  %call = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %0, i8* getelementptr inbounds ([21 x i8]* @.str4, i64 0, i64 0), i32 %1) #6
  %2 = load i32* %n_bits, align 4, !tbaa !1
  %cmp23 = icmp eq i32 %2, 0
  br i1 %cmp23, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %3 = phi i32 [ %6, %for.inc ], [ %2, %entry ]
  %pos.026 = phi i32 [ %pos.2, %for.inc ], [ 30, %entry ]
  %i.024 = phi i32 [ %inc, %for.inc ], [ 0, %entry ]
  %div = lshr i32 %i.024, 6
  %idxprom = zext i32 %div to i64
  %arrayidx = getelementptr inbounds %struct.simple_bitmap_def* %bmap, i64 0, i32 3, i64 %idxprom
  %4 = load i64* %arrayidx, align 8, !tbaa !10
  %rem = and i32 %i.024, 63
  %sh_prom = zext i32 %rem to i64
  %5 = shl i64 1, %sh_prom
  %and22 = and i64 %4, %5
  %tobool = icmp eq i64 %and22, 0
  br i1 %tobool, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %cmp2 = icmp ugt i32 %pos.026, 70
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %fputc = tail call i32 @fputc(i32 10, %struct._IO_FILE* %0) #7
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %pos.1 = phi i32 [ 0, %if.then3 ], [ %pos.026, %if.then ]
  %call5 = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %0, i8* getelementptr inbounds ([4 x i8]* @.str5, i64 0, i64 0), i32 %i.024) #6
  %cmp6 = icmp ugt i32 %i.024, 9
  %add = select i1 %cmp6, i32 2, i32 1
  %cmp7 = icmp ugt i32 %i.024, 99
  %conv8 = zext i1 %cmp7 to i32
  %add9 = add nsw i32 %add, %conv8
  %add10 = add i32 %add9, %pos.1
  %.pre = load i32* %n_bits, align 4, !tbaa !1
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end
  %6 = phi i32 [ %.pre, %if.end ], [ %3, %for.body ]
  %pos.2 = phi i32 [ %add10, %if.end ], [ %pos.026, %for.body ]
  %inc = add i32 %i.024, 1
  %cmp = icmp ult i32 %inc, %6
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.inc, %entry
  %7 = tail call i64 @fwrite(i8* getelementptr inbounds ([3 x i8]* @.str6, i64 0, i64 0), i64 2, i64 1, %struct._IO_FILE* %0) #7
  ret void
}

; Function Attrs: nounwind uwtable
define void @dump_sbitmap_vector(%struct._IO_FILE* nocapture %file, i8* %title, i8* %subtitle, %struct.simple_bitmap_def** nocapture readonly %bmaps, i32 %n_maps) #0 {
entry:
  %call = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %file, i8* getelementptr inbounds ([4 x i8]* @.str7, i64 0, i64 0), i8* %title) #2
  %cmp8 = icmp sgt i32 %n_maps, 0
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
  %0 = trunc i64 %indvars.iv to i32
  %call1 = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %file, i8* getelementptr inbounds ([7 x i8]* @.str8, i64 0, i64 0), i8* %subtitle, i32 %0) #2
  %arrayidx = getelementptr inbounds %struct.simple_bitmap_def** %bmaps, i64 %indvars.iv
  %1 = load %struct.simple_bitmap_def** %arrayidx, align 8, !tbaa !8
  tail call void @dump_sbitmap(%struct._IO_FILE* %file, %struct.simple_bitmap_def* %1)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %n_maps
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  %fputc = tail call i32 @fputc(i32 10, %struct._IO_FILE* %file)
  ret void
}

; Function Attrs: nounwind
declare i64 @fwrite(i8* nocapture, i64, i64, %struct._IO_FILE* nocapture) #2

; Function Attrs: nounwind
declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #2

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind }
attributes #3 = { nounwind readonly uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { cold nounwind }
attributes #7 = { cold }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5 (trunk)"}
!1 = metadata !{metadata !2, metadata !3, i64 0}
!2 = metadata !{metadata !"simple_bitmap_def", metadata !3, i64 0, metadata !3, i64 4, metadata !3, i64 8, metadata !4, i64 16}
!3 = metadata !{metadata !"int", metadata !4, i64 0}
!4 = metadata !{metadata !"omnipotent char", metadata !5, i64 0}
!5 = metadata !{metadata !"Simple C/C++ TBAA"}
!6 = metadata !{metadata !2, metadata !3, i64 4}
!7 = metadata !{metadata !2, metadata !3, i64 8}
!8 = metadata !{metadata !9, metadata !9, i64 0}
!9 = metadata !{metadata !"any pointer", metadata !4, i64 0}
!10 = metadata !{metadata !11, metadata !11, i64 0}
!11 = metadata !{metadata !"long long", metadata !4, i64 0}
!12 = metadata !{metadata !13, metadata !9, i64 24}
!13 = metadata !{metadata !"edge_def", metadata !9, i64 0, metadata !9, i64 8, metadata !9, i64 16, metadata !9, i64 24, metadata !9, i64 32, metadata !9, i64 40, metadata !3, i64 48, metadata !3, i64 52, metadata !11, i64 56}
!14 = metadata !{metadata !15, metadata !3, i64 88}
!15 = metadata !{metadata !"basic_block_def", metadata !9, i64 0, metadata !9, i64 8, metadata !9, i64 16, metadata !9, i64 24, metadata !9, i64 32, metadata !9, i64 40, metadata !9, i64 48, metadata !9, i64 56, metadata !9, i64 64, metadata !9, i64 72, metadata !9, i64 80, metadata !3, i64 88, metadata !3, i64 92, metadata !11, i64 96, metadata !3, i64 104, metadata !3, i64 108}
!16 = metadata !{metadata !13, metadata !9, i64 16}
