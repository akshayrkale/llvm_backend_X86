; ModuleID = 'diagnostic.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.diagnostic_context = type { %struct.output_buffer, i8*, [1 x %struct.__va_list_tag]*, i8*, i32, i32, void (%struct.output_buffer*, %struct.diagnostic_context*)*, void (%struct.output_buffer*, %struct.diagnostic_context*)*, i8* }
%struct.output_buffer = type { %struct.output_state, %struct._IO_FILE*, %struct.obstack, i32, [128 x i8], i32 (%struct.output_buffer*)* }
%struct.output_state = type { i8*, i32, i32, i32, i8, i8, i32, i8*, [1 x %struct.__va_list_tag]*, [7 x i32] }
%struct._IO_FILE = type opaque
%struct.obstack = type { i64, %struct._obstack_chunk*, i8*, i8*, i8*, i64, i32, %struct._obstack_chunk* (i8*, i64)*, void (i8*, %struct._obstack_chunk*)*, i8*, i8 }
%struct._obstack_chunk = type { i8*, %struct._obstack_chunk*, [4 x i8] }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%union.tree_node = type { %struct.tree_decl }
%struct.tree_decl = type { %struct.tree_common, i8*, i32, i32, %union.tree_node*, i48, %union.anon, %union.tree_node*, %union.tree_node*, %union.tree_node*, %union.tree_node*, %union.tree_node*, %union.tree_node*, %union.tree_node*, %union.tree_node*, %union.tree_node*, %union.tree_node*, %struct.rtx_def*, %struct.rtx_def*, %union.anon.1, %union.tree_node*, %union.tree_node*, %union.tree_node*, i64, %struct.lang_decl* }
%struct.tree_common = type { %union.tree_node*, %union.tree_node*, i32 }
%union.anon = type { i64 }
%struct.rtx_def = type opaque
%union.anon.1 = type { %struct.function* }
%struct.function = type opaque
%struct.lang_decl = type opaque
%struct.file_stack = type { i8*, %struct.file_stack*, i32, i32 }

@global_diagnostic_context = internal global %struct.diagnostic_context zeroinitializer, align 8
@global_dc = global %struct.diagnostic_context* @global_diagnostic_context, align 8
@diagnostic_buffer = global %struct.output_buffer* getelementptr inbounds (%struct.diagnostic_context* @global_diagnostic_context, i64 0, i32 0), align 8
@print_error_function = global void (%struct.diagnostic_context*, i8*)* @default_print_error_function, align 8
@last_error_tick = internal unnamed_addr global i32 0, align 4
@input_file_stack_tick = external global i32
@last_error_function = internal unnamed_addr global %union.tree_node* null, align 8
@current_function_decl = external global %union.tree_node*
@stderr = external constant %struct._IO_FILE*
@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str1 = private unnamed_addr constant [17 x i8] c"%s:%d: warning: \00", align 1
@.str2 = private unnamed_addr constant [8 x i8] c"%s:%d: \00", align 1
@.str3 = private unnamed_addr constant [14 x i8] c"%s: warning: \00", align 1
@progname = external global i8*
@.str4 = private unnamed_addr constant [5 x i8] c"%s: \00", align 1
@inhibit_warnings = external global i32
@in_system_header = external global i32
@warn_system_headers = external global i32
@warnings_are_errors = external global i32
@count_error.warning_message = internal unnamed_addr global i1 false
@.str5 = private unnamed_addr constant [38 x i8] c"%s: warnings being treated as errors\0A\00", align 1
@.str6 = private unnamed_addr constant [9 x i8] c"%s: %s: \00", align 1
@input_filename = external global i8*
@lineno = external global i32
@flag_pedantic_errors = external global i32
@.str7 = private unnamed_addr constant [25 x i8] c"sorry, not implemented: \00", align 1
@quiet_flag = external global i32
@rtl_dump_and_exit = external global i32
@.str8 = private unnamed_addr constant [4 x i8] c"%s \00", align 1
@.str9 = private unnamed_addr constant [4 x i8] c" %s\00", align 1
@decl_printable_name = external global i8* (%union.tree_node*, i32)*
@.str10 = private unnamed_addr constant [14 x i8] c"At top level:\00", align 1
@.str11 = private unnamed_addr constant [25 x i8] c"In member function `%s':\00", align 1
@.str12 = private unnamed_addr constant [18 x i8] c"In function `%s':\00", align 1
@.str13 = private unnamed_addr constant [25 x i8] c"compilation terminated.\0A\00", align 1
@internal_error_function = internal unnamed_addr global void (i8*, [1 x %struct.__va_list_tag]*)* null, align 8
@diagnostic_lock = internal unnamed_addr global i32 0, align 4
@.str14 = private unnamed_addr constant [48 x i8] c"%s:%d: confused by earlier errors, bailing out\0A\00", align 1
@.str15 = private unnamed_addr constant [421 x i8] c"It is possible that you may be trying to use SPEC's version of gcc \0Awithout first defining the appropriate flags.  Please check the flags \0Athat are in the config files from recently-published results on your \0Aplatform, and check that you are using an up-to-date compiler.  If\0Ayou still need help, please contact SPEC, reporting your hw/os \0Aplatform, your compiler version, and your compilation flags.\0AContact SPEC at %s\0A\00", align 1
@.str16 = private unnamed_addr constant [27 x i8] c"<URL:http://www.spec.org/>\00", align 1
@.str17 = private unnamed_addr constant [40 x i8] c"Internal compiler error in %s, at %s:%d\00", align 1
@input_file_stack = external global %struct.file_stack*
@.str18 = private unnamed_addr constant [28 x i8] c"In file included from %s:%d\00", align 1
@.str19 = private unnamed_addr constant [30 x i8] c",\0A                 from %s:%d\00", align 1
@.str20 = private unnamed_addr constant [3 x i8] c":\0A\00", align 1
@warn_deprecated_decl = external global i32
@tree_code_type = external global [256 x i8]
@.str21 = private unnamed_addr constant [39 x i8] c"`%s' is deprecated (declared at %s:%d)\00", align 1
@.str22 = private unnamed_addr constant [19 x i8] c"`%s' is deprecated\00", align 1
@.str23 = private unnamed_addr constant [39 x i8] c"type is deprecated (declared at %s:%d)\00", align 1
@.str24 = private unnamed_addr constant [19 x i8] c"type is deprecated\00", align 1
@.str25 = private unnamed_addr constant [63 x i8] c"Internal compiler error: Error reporting routines re-entered.\0A\00", align 1
@.str26 = private unnamed_addr constant [13 x i8] c"diagnostic.c\00", align 1
@__FUNCTION__.format_with_decl = private unnamed_addr constant [17 x i8] c"format_with_decl\00", align 1
@.str27 = private unnamed_addr constant [14 x i8] c"((anonymous))\00", align 1
@_sch_istable = external constant [256 x i16]
@__FUNCTION__.output_format = private unnamed_addr constant [14 x i8] c"output_format\00", align 1
@.str28 = private unnamed_addr constant [3 x i8] c"%x\00", align 1
@.str29 = private unnamed_addr constant [4 x i8] c"%lx\00", align 1
@.str30 = private unnamed_addr constant [3 x i8] c"%u\00", align 1
@.str31 = private unnamed_addr constant [4 x i8] c"%lu\00", align 1
@.str32 = private unnamed_addr constant [3 x i8] c"%o\00", align 1
@.str33 = private unnamed_addr constant [4 x i8] c"%lo\00", align 1
@.str34 = private unnamed_addr constant [4 x i8] c"%ld\00", align 1

; Function Attrs: nounwind uwtable
define void @default_print_error_function(%struct.diagnostic_context* %context, i8* %file) #0 {
entry:
  %os = alloca %struct.output_state, align 8
  %0 = load %union.tree_node** @last_error_function, align 8, !tbaa !1
  %1 = load %union.tree_node** @current_function_decl, align 8, !tbaa !1
  %cmp.i = icmp eq %union.tree_node* %0, %1
  br i1 %cmp.i, label %if.end12, label %if.then

if.then:                                          ; preds = %entry
  %tobool1 = icmp eq i8* %file, null
  br i1 %tobool1, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.then
  %call2 = tail call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([5 x i8]* @.str4, i64 0, i64 0), i8* %file)
  br label %cond.end

cond.end:                                         ; preds = %if.then, %cond.true
  %cond = phi i8* [ %call2, %cond.true ], [ null, %if.then ]
  %os.0..sroa_cast = bitcast %struct.output_state* %os to i8*
  call void @llvm.lifetime.start(i64 80, i8* %os.0..sroa_cast)
  %2 = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0
  %3 = bitcast %struct.diagnostic_context* %context to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %os.0..sroa_cast, i8* %3, i64 80, i32 8, i1 false), !tbaa.struct !5
  %prefix1.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 0, i32 0
  store i8* %cond, i8** %prefix1.i, align 8, !tbaa !11
  %ideal_maximum_length.i.i.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 0, i32 2
  %4 = load i32* %ideal_maximum_length.i.i.i, align 4, !tbaa !16
  %cmp.i.i.i = icmp sgt i32 %4, 0
  br i1 %cmp.i.i.i, label %lor.lhs.false.i.i, label %if.then.i.i22

lor.lhs.false.i.i:                                ; preds = %cond.end
  %prefixing_rule.i.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 0, i32 6
  %5 = load i32* %prefixing_rule.i.i, align 4, !tbaa !17
  %switch.i.i = icmp ult i32 %5, 2
  br i1 %switch.i.i, label %if.then.i.i22, label %if.else.i.i23

if.then.i.i22:                                    ; preds = %lor.lhs.false.i.i, %cond.end
  %maximum_length.i.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 0, i32 1
  store i32 %4, i32* %maximum_length.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

if.else.i.i23:                                    ; preds = %lor.lhs.false.i.i
  %tobool8.i.i = icmp eq i8* %cond, null
  br i1 %tobool8.i.i, label %cond.end.i.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %if.else.i.i23
  %call11.i.i = tail call i64 @strlen(i8* %cond) #2
  %phitmp.i.i = trunc i64 %call11.i.i to i32
  br label %cond.end.i.i

cond.end.i.i:                                     ; preds = %cond.true.i.i, %if.else.i.i23
  %cond.i.i = phi i32 [ %phitmp.i.i, %cond.true.i.i ], [ 0, %if.else.i.i23 ]
  %sub.i.i = sub nsw i32 %4, %cond.i.i
  %cmp14.i.i = icmp slt i32 %sub.i.i, 32
  br i1 %cmp14.i.i, label %if.then16.i.i, label %if.else21.i.i

if.then16.i.i:                                    ; preds = %cond.end.i.i
  %add.i.i = add nsw i32 %4, 32
  %maximum_length20.i.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 0, i32 1
  store i32 %add.i.i, i32* %maximum_length20.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

if.else21.i.i:                                    ; preds = %cond.end.i.i
  %maximum_length25.i.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 0, i32 1
  store i32 %4, i32* %maximum_length25.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

output_set_prefix.exit:                           ; preds = %if.then.i.i22, %if.then16.i.i, %if.else21.i.i
  %emitted_prefix_p.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 0, i32 4
  store i8 0, i8* %emitted_prefix_p.i, align 1, !tbaa !19
  %indent_skip.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 0, i32 3
  store i32 0, i32* %indent_skip.i, align 4, !tbaa !20
  %6 = load %union.tree_node** @current_function_decl, align 8, !tbaa !1
  %cmp = icmp eq %union.tree_node* %6, null
  br i1 %cmp, label %if.then3, label %if.else

if.then3:                                         ; preds = %output_set_prefix.exit
  tail call void @output_add_string(%struct.output_buffer* %2, i8* getelementptr inbounds ([14 x i8]* @.str10, i64 0, i64 0))
  br label %if.end10

if.else:                                          ; preds = %output_set_prefix.exit
  %type = getelementptr inbounds %union.tree_node* %6, i64 0, i32 0, i32 0, i32 1
  %7 = load %union.tree_node** %type, align 8, !tbaa !21
  %code = getelementptr inbounds %union.tree_node* %7, i64 0, i32 0, i32 0, i32 2
  %bf.load = load i32* %code, align 8
  %bf.clear = and i32 %bf.load, 255
  %cmp5 = icmp eq i32 %bf.clear, 16
  %8 = load i8* (%union.tree_node*, i32)** @decl_printable_name, align 8, !tbaa !1
  %call7 = tail call i8* %8(%union.tree_node* %6, i32 2) #2
  br i1 %cmp5, label %if.then6, label %if.else8

if.then6:                                         ; preds = %if.else
  tail call void (%struct.output_buffer*, i8*, ...)* @output_printf(%struct.output_buffer* %2, i8* getelementptr inbounds ([25 x i8]* @.str11, i64 0, i64 0), i8* %call7)
  br label %if.end10

if.else8:                                         ; preds = %if.else
  tail call void (%struct.output_buffer*, i8*, ...)* @output_printf(%struct.output_buffer* %2, i8* getelementptr inbounds ([18 x i8]* @.str12, i64 0, i64 0), i8* %call7)
  br label %if.end10

if.end10:                                         ; preds = %if.then6, %if.else8, %if.then3
  %next_free.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 2, i32 3
  %9 = load i8** %next_free.i, align 8, !tbaa !23
  %add.ptr.i = getelementptr inbounds i8* %9, i64 1
  %chunk_limit.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 2, i32 4
  %10 = load i8** %chunk_limit.i, align 8, !tbaa !24
  %cmp.i24 = icmp ugt i8* %add.ptr.i, %10
  %obstack.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 2
  br i1 %cmp.i24, label %if.then.i, label %output_add_newline.exit

if.then.i:                                        ; preds = %if.end10
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i, i32 1) #2
  %.pre.i = load i8** %next_free.i, align 8, !tbaa !23
  br label %output_add_newline.exit

output_add_newline.exit:                          ; preds = %if.end10, %if.then.i
  %11 = phi i8* [ %.pre.i, %if.then.i ], [ %9, %if.end10 ]
  %incdec.ptr.i = getelementptr inbounds i8* %11, i64 1
  store i8* %incdec.ptr.i, i8** %next_free.i, align 8, !tbaa !23
  store i8 10, i8* %11, align 1, !tbaa !10
  %line_length.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 3
  store i32 0, i32* %line_length.i, align 4, !tbaa !25
  %12 = load %union.tree_node** @current_function_decl, align 8, !tbaa !1
  store %union.tree_node* %12, %union.tree_node** @last_error_function, align 8, !tbaa !1
  %13 = load i8** %next_free.i, align 8, !tbaa !23
  %add.ptr.i.i = getelementptr inbounds i8* %13, i64 1
  %14 = load i8** %chunk_limit.i, align 8, !tbaa !24
  %cmp.i.i = icmp ugt i8* %add.ptr.i.i, %14
  br i1 %cmp.i.i, label %if.then.i.i, label %output_finalize_message.exit.i

if.then.i.i:                                      ; preds = %output_add_newline.exit
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i, i32 1) #2
  %.pre.i.i = load i8** %next_free.i, align 8, !tbaa !23
  br label %output_finalize_message.exit.i

output_finalize_message.exit.i:                   ; preds = %if.then.i.i, %output_add_newline.exit
  %15 = phi i8* [ %.pre.i.i, %if.then.i.i ], [ %13, %output_add_newline.exit ]
  %incdec.ptr.i.i = getelementptr inbounds i8* %15, i64 1
  store i8* %incdec.ptr.i.i, i8** %next_free.i, align 8, !tbaa !23
  store i8 0, i8* %15, align 1, !tbaa !10
  %object_base.i.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 2, i32 2
  %16 = load i8** %object_base.i.i, align 8, !tbaa !26
  %stream.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 1
  %17 = load %struct._IO_FILE** %stream.i, align 8, !tbaa !27
  %call1.i = tail call i32 @fputs(i8* %16, %struct._IO_FILE* %17) #2
  %18 = load i8** %object_base.i.i, align 8, !tbaa !26
  %chunk.i.i = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 2, i32 1
  %19 = load %struct._obstack_chunk** %chunk.i.i, align 8, !tbaa !28
  %20 = bitcast %struct._obstack_chunk* %19 to i8*
  %cmp.i6.i = icmp ugt i8* %18, %20
  br i1 %cmp.i6.i, label %land.lhs.true.i.i, label %if.else.i.i

land.lhs.true.i.i:                                ; preds = %output_finalize_message.exit.i
  %21 = load i8** %chunk_limit.i, align 8, !tbaa !24
  %cmp2.i.i = icmp ult i8* %18, %21
  br i1 %cmp2.i.i, label %if.then.i9.i, label %if.else.i.i

if.then.i9.i:                                     ; preds = %land.lhs.true.i.i
  store i8* %18, i8** %object_base.i.i, align 8, !tbaa !26
  store i8* %18, i8** %next_free.i, align 8, !tbaa !23
  br label %output_buffer_to_stream.exit

if.else.i.i:                                      ; preds = %land.lhs.true.i.i, %output_finalize_message.exit.i
  tail call void @obstack_free(%struct.obstack* %obstack.i, i8* %18) #2
  br label %output_buffer_to_stream.exit

output_buffer_to_stream.exit:                     ; preds = %if.then.i9.i, %if.else.i.i
  store i32 0, i32* %line_length.i, align 4, !tbaa !25
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %os.0..sroa_cast, i64 80, i32 8, i1 false), !tbaa.struct !5
  tail call void @free(i8* %cond)
  call void @llvm.lifetime.end(i64 80, i8* %os.0..sroa_cast)
  br label %if.end12

if.end12:                                         ; preds = %entry, %output_buffer_to_stream.exit
  ret void
}

; Function Attrs: nounwind readonly uwtable
define i32 @error_module_changed() #1 {
entry:
  %0 = load i32* @last_error_tick, align 4, !tbaa !6
  %1 = load i32* @input_file_stack_tick, align 4, !tbaa !6
  %cmp = icmp ne i32 %0, %1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define void @record_last_error_module() #0 {
entry:
  %0 = load i32* @input_file_stack_tick, align 4, !tbaa !6
  store i32 %0, i32* @last_error_tick, align 4, !tbaa !6
  ret void
}

; Function Attrs: nounwind readonly uwtable
define i32 @error_function_changed() #1 {
entry:
  %0 = load %union.tree_node** @last_error_function, align 8, !tbaa !1
  %1 = load %union.tree_node** @current_function_decl, align 8, !tbaa !1
  %cmp = icmp ne %union.tree_node* %0, %1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define void @record_last_error_function() #0 {
entry:
  %0 = load %union.tree_node** @current_function_decl, align 8, !tbaa !1
  store %union.tree_node* %0, %union.tree_node** @last_error_function, align 8, !tbaa !1
  ret void
}

; Function Attrs: nounwind uwtable
define void @diagnostic_initialize(%struct.diagnostic_context* %context) #0 {
entry:
  %0 = bitcast %struct.diagnostic_context* %context to i8*
  tail call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 376, i32 8, i1 false)
  %obstack = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 2
  %call = tail call i32 @_obstack_begin(%struct.obstack* %obstack, i32 0, i32 0, i8* (i64)* @xmalloc, void (i8*)* @free) #2
  %1 = load %struct._IO_FILE** @stderr, align 8, !tbaa !1
  %stream = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 1
  store %struct._IO_FILE* %1, %struct._IO_FILE** %stream, align 8, !tbaa !27
  %prefixing_rule = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 0, i32 0, i32 6
  store i32 0, i32* %prefixing_rule, align 4, !tbaa !17
  %begin_diagnostic = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 6
  store void (%struct.output_buffer*, %struct.diagnostic_context*)* @default_diagnostic_starter, void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic, align 8, !tbaa !29
  %end_diagnostic = getelementptr inbounds %struct.diagnostic_context* %context, i64 0, i32 7
  store void (%struct.output_buffer*, %struct.diagnostic_context*)* @default_diagnostic_finalizer, void (%struct.output_buffer*, %struct.diagnostic_context*)** %end_diagnostic, align 8, !tbaa !31
  ret void
}

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #2

declare i32 @_obstack_begin(%struct.obstack*, i32, i32, i8* (i64)*, void (i8*)*) #3

declare noalias i8* @xmalloc(i64) #3

; Function Attrs: nounwind
declare void @free(i8* nocapture) #4

; Function Attrs: nounwind uwtable
define internal void @default_diagnostic_starter(%struct.output_buffer* nocapture %buffer, %struct.diagnostic_context* nocapture readonly %dc) #0 {
entry:
  %file = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 3
  %0 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %1 = getelementptr inbounds %struct.diagnostic_context* %0, i64 0, i32 0
  tail call void @report_problematic_module(%struct.output_buffer* %1) #2
  %2 = load void (%struct.diagnostic_context*, i8*)** @print_error_function, align 8, !tbaa !1
  %3 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %4 = load i8** @input_filename, align 8, !tbaa !1
  tail call void %2(%struct.diagnostic_context* %3, i8* %4) #2
  %5 = load i8** %file, align 8, !tbaa !32
  %line = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 4
  %6 = load i32* %line, align 4, !tbaa !33
  %warn = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 5
  %7 = load i32* %warn, align 4, !tbaa !34
  %tobool.i = icmp eq i8* %5, null
  %tobool1.i = icmp ne i32 %7, 0
  br i1 %tobool.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  br i1 %tobool1.i, label %if.then2.i, label %if.else.i

if.then2.i:                                       ; preds = %if.then.i
  %call.i = tail call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([17 x i8]* @.str1, i64 0, i64 0), i8* %5, i32 %6) #2
  br label %context_as_prefix.exit

if.else.i:                                        ; preds = %if.then.i
  %call3.i = tail call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([8 x i8]* @.str2, i64 0, i64 0), i8* %5, i32 %6) #2
  br label %context_as_prefix.exit

if.else4.i:                                       ; preds = %entry
  %8 = load i8** @progname, align 8, !tbaa !1
  br i1 %tobool1.i, label %if.then6.i, label %if.else8.i

if.then6.i:                                       ; preds = %if.else4.i
  %call7.i = tail call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([14 x i8]* @.str3, i64 0, i64 0), i8* %8) #2
  br label %context_as_prefix.exit

if.else8.i:                                       ; preds = %if.else4.i
  %call9.i = tail call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([5 x i8]* @.str4, i64 0, i64 0), i8* %8) #2
  br label %context_as_prefix.exit

context_as_prefix.exit:                           ; preds = %if.then2.i, %if.else.i, %if.then6.i, %if.else8.i
  %retval.0.i = phi i8* [ %call.i, %if.then2.i ], [ %call3.i, %if.else.i ], [ %call7.i, %if.then6.i ], [ %call9.i, %if.else8.i ]
  %prefix1.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 0
  store i8* %retval.0.i, i8** %prefix1.i, align 8, !tbaa !11
  %ideal_maximum_length.i.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 2
  %9 = load i32* %ideal_maximum_length.i.i.i, align 4, !tbaa !16
  %cmp.i.i.i = icmp sgt i32 %9, 0
  br i1 %cmp.i.i.i, label %lor.lhs.false.i.i, label %if.then.i.i

lor.lhs.false.i.i:                                ; preds = %context_as_prefix.exit
  %prefixing_rule.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 6
  %10 = load i32* %prefixing_rule.i.i, align 4, !tbaa !17
  %switch.i.i = icmp ult i32 %10, 2
  br i1 %switch.i.i, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %lor.lhs.false.i.i, %context_as_prefix.exit
  %maximum_length.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  store i32 %9, i32* %maximum_length.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

if.else.i.i:                                      ; preds = %lor.lhs.false.i.i
  %tobool8.i.i = icmp eq i8* %retval.0.i, null
  br i1 %tobool8.i.i, label %cond.end.i.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %if.else.i.i
  %call11.i.i = tail call i64 @strlen(i8* %retval.0.i) #2
  %phitmp.i.i = trunc i64 %call11.i.i to i32
  br label %cond.end.i.i

cond.end.i.i:                                     ; preds = %cond.true.i.i, %if.else.i.i
  %cond.i.i = phi i32 [ %phitmp.i.i, %cond.true.i.i ], [ 0, %if.else.i.i ]
  %sub.i.i = sub nsw i32 %9, %cond.i.i
  %cmp14.i.i = icmp slt i32 %sub.i.i, 32
  br i1 %cmp14.i.i, label %if.then16.i.i, label %if.else21.i.i

if.then16.i.i:                                    ; preds = %cond.end.i.i
  %add.i.i = add nsw i32 %9, 32
  %maximum_length20.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  store i32 %add.i.i, i32* %maximum_length20.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

if.else21.i.i:                                    ; preds = %cond.end.i.i
  %maximum_length25.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  store i32 %9, i32* %maximum_length25.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

output_set_prefix.exit:                           ; preds = %if.then.i.i, %if.then16.i.i, %if.else21.i.i
  %emitted_prefix_p.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 4
  store i8 0, i8* %emitted_prefix_p.i, align 1, !tbaa !19
  %indent_skip.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 3
  store i32 0, i32* %indent_skip.i, align 4, !tbaa !20
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @default_diagnostic_finalizer(%struct.output_buffer* nocapture %buffer, %struct.diagnostic_context* nocapture readnone %dc) #0 {
entry:
  %prefix.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 0
  %0 = load i8** %prefix.i, align 8, !tbaa !11
  %cmp.i = icmp eq i8* %0, null
  br i1 %cmp.i, label %output_destroy_prefix.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  tail call void @free(i8* %0) #2
  store i8* null, i8** %prefix.i, align 8, !tbaa !11
  br label %output_destroy_prefix.exit

output_destroy_prefix.exit:                       ; preds = %entry, %if.then.i
  ret void
}

; Function Attrs: nounwind readonly uwtable
define i32 @output_is_line_wrapping(%struct.output_buffer* nocapture readonly %buffer) #1 {
entry:
  %ideal_maximum_length = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 2
  %0 = load i32* %ideal_maximum_length, align 4, !tbaa !16
  %cmp = icmp sgt i32 %0, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind readonly uwtable
define i8* @output_get_prefix(%struct.output_buffer* nocapture readonly %buffer) #1 {
entry:
  %prefix = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 0
  %0 = load i8** %prefix, align 8, !tbaa !11
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define void @output_set_maximum_length(%struct.output_buffer* nocapture %buffer, i32 %length) #0 {
entry:
  %ideal_maximum_length = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 2
  store i32 %length, i32* %ideal_maximum_length, align 4, !tbaa !16
  %cmp.i.i = icmp sgt i32 %length, 0
  br i1 %cmp.i.i, label %lor.lhs.false.i, label %if.then.i

lor.lhs.false.i:                                  ; preds = %entry
  %prefixing_rule.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 6
  %0 = load i32* %prefixing_rule.i, align 4, !tbaa !17
  %switch.i = icmp ult i32 %0, 2
  br i1 %switch.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.lhs.false.i, %entry
  %maximum_length.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  store i32 %length, i32* %maximum_length.i, align 4, !tbaa !18
  br label %set_real_maximum_length.exit

if.else.i:                                        ; preds = %lor.lhs.false.i
  %prefix.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 0
  %1 = load i8** %prefix.i, align 8, !tbaa !11
  %tobool8.i = icmp eq i8* %1, null
  br i1 %tobool8.i, label %cond.end.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.else.i
  %call11.i = tail call i64 @strlen(i8* %1) #2
  %phitmp.i = trunc i64 %call11.i to i32
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.true.i, %if.else.i
  %cond.i = phi i32 [ %phitmp.i, %cond.true.i ], [ 0, %if.else.i ]
  %sub.i = sub nsw i32 %length, %cond.i
  %cmp14.i = icmp slt i32 %sub.i, 32
  br i1 %cmp14.i, label %if.then16.i, label %if.else21.i

if.then16.i:                                      ; preds = %cond.end.i
  %add.i = add nsw i32 %length, 32
  %maximum_length20.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  store i32 %add.i, i32* %maximum_length20.i, align 4, !tbaa !18
  br label %set_real_maximum_length.exit

if.else21.i:                                      ; preds = %cond.end.i
  %maximum_length25.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  store i32 %length, i32* %maximum_length25.i, align 4, !tbaa !18
  br label %set_real_maximum_length.exit

set_real_maximum_length.exit:                     ; preds = %if.then.i, %if.then16.i, %if.else21.i
  ret void
}

; Function Attrs: nounwind uwtable
define void @output_set_prefix(%struct.output_buffer* nocapture %buffer, i8* %prefix) #0 {
entry:
  %prefix1 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 0
  store i8* %prefix, i8** %prefix1, align 8, !tbaa !11
  %ideal_maximum_length.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 2
  %0 = load i32* %ideal_maximum_length.i.i, align 4, !tbaa !16
  %cmp.i.i = icmp sgt i32 %0, 0
  br i1 %cmp.i.i, label %lor.lhs.false.i, label %if.then.i

lor.lhs.false.i:                                  ; preds = %entry
  %prefixing_rule.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 6
  %1 = load i32* %prefixing_rule.i, align 4, !tbaa !17
  %switch.i = icmp ult i32 %1, 2
  br i1 %switch.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.lhs.false.i, %entry
  %maximum_length.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  store i32 %0, i32* %maximum_length.i, align 4, !tbaa !18
  br label %set_real_maximum_length.exit

if.else.i:                                        ; preds = %lor.lhs.false.i
  %tobool8.i = icmp eq i8* %prefix, null
  br i1 %tobool8.i, label %cond.end.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.else.i
  %call11.i = tail call i64 @strlen(i8* %prefix) #2
  %phitmp.i = trunc i64 %call11.i to i32
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.true.i, %if.else.i
  %cond.i = phi i32 [ %phitmp.i, %cond.true.i ], [ 0, %if.else.i ]
  %sub.i = sub nsw i32 %0, %cond.i
  %cmp14.i = icmp slt i32 %sub.i, 32
  br i1 %cmp14.i, label %if.then16.i, label %if.else21.i

if.then16.i:                                      ; preds = %cond.end.i
  %add.i = add nsw i32 %0, 32
  %maximum_length20.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  store i32 %add.i, i32* %maximum_length20.i, align 4, !tbaa !18
  br label %set_real_maximum_length.exit

if.else21.i:                                      ; preds = %cond.end.i
  %maximum_length25.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  store i32 %0, i32* %maximum_length25.i, align 4, !tbaa !18
  br label %set_real_maximum_length.exit

set_real_maximum_length.exit:                     ; preds = %if.then.i, %if.then16.i, %if.else21.i
  %emitted_prefix_p = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 4
  store i8 0, i8* %emitted_prefix_p, align 1, !tbaa !19
  %indent_skip = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 3
  store i32 0, i32* %indent_skip, align 4, !tbaa !20
  ret void
}

; Function Attrs: nounwind readonly uwtable
define i8* @output_last_position(%struct.output_buffer* nocapture readonly %buffer) #1 {
entry:
  %object_base = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 2
  %0 = load i8** %object_base, align 8, !tbaa !26
  %next_free = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %1 = load i8** %next_free, align 8, !tbaa !23
  %cmp = icmp eq i8* %0, %1
  %add.ptr = getelementptr inbounds i8* %1, i64 -1
  %.add.ptr = select i1 %cmp, i8* null, i8* %add.ptr
  ret i8* %.add.ptr
}

; Function Attrs: nounwind uwtable
define void @output_destroy_prefix(%struct.output_buffer* nocapture %buffer) #0 {
entry:
  %prefix = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 0
  %0 = load i8** %prefix, align 8, !tbaa !11
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @free(i8* %0)
  store i8* null, i8** %prefix, align 8, !tbaa !11
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @output_clear_message_text(%struct.output_buffer* %buffer) #0 {
entry:
  %obstack = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  %object_base = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 2
  %0 = load i8** %object_base, align 8, !tbaa !26
  %chunk = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 1
  %1 = load %struct._obstack_chunk** %chunk, align 8, !tbaa !28
  %2 = bitcast %struct._obstack_chunk* %1 to i8*
  %cmp = icmp ugt i8* %0, %2
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %chunk_limit = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %3 = load i8** %chunk_limit, align 8, !tbaa !24
  %cmp2 = icmp ult i8* %0, %3
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  store i8* %0, i8** %object_base, align 8, !tbaa !26
  %next_free = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  store i8* %0, i8** %next_free, align 8, !tbaa !23
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  tail call void @obstack_free(%struct.obstack* %obstack, i8* %0) #2
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %line_length = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  store i32 0, i32* %line_length, align 4, !tbaa !25
  ret void
}

declare void @obstack_free(%struct.obstack*, i8*) #3

; Function Attrs: nounwind uwtable
define void @init_output_buffer(%struct.output_buffer* %buffer, i8* %prefix, i32 %maximum_length) #0 {
entry:
  %0 = bitcast %struct.output_buffer* %buffer to i8*
  tail call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 320, i32 8, i1 false)
  %obstack = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  %call = tail call i32 @_obstack_begin(%struct.obstack* %obstack, i32 0, i32 0, i8* (i64)* @xmalloc, void (i8*)* @free) #2
  %1 = load %struct._IO_FILE** @stderr, align 8, !tbaa !1
  %stream = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 1
  store %struct._IO_FILE* %1, %struct._IO_FILE** %stream, align 8, !tbaa !27
  %ideal_maximum_length = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 2
  store i32 %maximum_length, i32* %ideal_maximum_length, align 4, !tbaa !16
  %2 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %prefixing_rule = getelementptr inbounds %struct.diagnostic_context* %2, i64 0, i32 0, i32 0, i32 6
  %3 = load i32* %prefixing_rule, align 4, !tbaa !17
  %prefixing_rule3 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 6
  store i32 %3, i32* %prefixing_rule3, align 4, !tbaa !17
  %prefix1.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 0
  store i8* %prefix, i8** %prefix1.i, align 8, !tbaa !11
  %cmp.i.i.i = icmp slt i32 %maximum_length, 1
  %switch.i.i = icmp ult i32 %3, 2
  %or.cond = or i1 %cmp.i.i.i, %switch.i.i
  br i1 %or.cond, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %entry
  %maximum_length.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  store i32 %maximum_length, i32* %maximum_length.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

if.else.i.i:                                      ; preds = %entry
  %tobool8.i.i = icmp eq i8* %prefix, null
  br i1 %tobool8.i.i, label %cond.end.i.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %if.else.i.i
  %call11.i.i = tail call i64 @strlen(i8* %prefix) #2
  %phitmp.i.i = trunc i64 %call11.i.i to i32
  br label %cond.end.i.i

cond.end.i.i:                                     ; preds = %cond.true.i.i, %if.else.i.i
  %cond.i.i = phi i32 [ %phitmp.i.i, %cond.true.i.i ], [ 0, %if.else.i.i ]
  %sub.i.i = sub nsw i32 %maximum_length, %cond.i.i
  %cmp14.i.i = icmp slt i32 %sub.i.i, 32
  br i1 %cmp14.i.i, label %if.then16.i.i, label %if.else21.i.i

if.then16.i.i:                                    ; preds = %cond.end.i.i
  %add.i.i = add nsw i32 %maximum_length, 32
  %maximum_length20.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  store i32 %add.i.i, i32* %maximum_length20.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

if.else21.i.i:                                    ; preds = %cond.end.i.i
  %maximum_length25.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  store i32 %maximum_length, i32* %maximum_length25.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

output_set_prefix.exit:                           ; preds = %if.then.i.i, %if.then16.i.i, %if.else21.i.i
  %indent_skip.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 3
  %line_length = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  store i32 0, i32* %line_length, align 4, !tbaa !25
  %cursor.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 7
  %4 = bitcast i8** %cursor.i to i8*
  tail call void @llvm.memset.p0i8.i64(i8* %4, i8 0, i64 16, i32 8, i1 false) #2
  %5 = bitcast i32* %indent_skip.i to i8*
  call void @llvm.memset.p0i8.i64(i8* %5, i8 0, i64 5, i32 4, i1 false)
  ret void
}

; Function Attrs: nounwind uwtable
define void @output_clear(%struct.output_buffer* %buffer) #0 {
entry:
  %obstack.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  %object_base.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 2
  %0 = load i8** %object_base.i, align 8, !tbaa !26
  %chunk.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 1
  %1 = load %struct._obstack_chunk** %chunk.i, align 8, !tbaa !28
  %2 = bitcast %struct._obstack_chunk* %1 to i8*
  %cmp.i = icmp ugt i8* %0, %2
  br i1 %cmp.i, label %land.lhs.true.i, label %if.else.i

land.lhs.true.i:                                  ; preds = %entry
  %chunk_limit.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %3 = load i8** %chunk_limit.i, align 8, !tbaa !24
  %cmp2.i = icmp ult i8* %0, %3
  br i1 %cmp2.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %land.lhs.true.i
  store i8* %0, i8** %object_base.i, align 8, !tbaa !26
  %next_free.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  store i8* %0, i8** %next_free.i, align 8, !tbaa !23
  br label %output_clear_message_text.exit

if.else.i:                                        ; preds = %land.lhs.true.i, %entry
  tail call void @obstack_free(%struct.obstack* %obstack.i, i8* %0) #2
  br label %output_clear_message_text.exit

output_clear_message_text.exit:                   ; preds = %if.then.i, %if.else.i
  %line_length.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  store i32 0, i32* %line_length.i, align 4, !tbaa !25
  %cursor.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 7
  %emitted_prefix_p.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 4
  store i8 0, i8* %emitted_prefix_p.i, align 1, !tbaa !19
  %indent_skip.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 3
  store i32 0, i32* %indent_skip.i, align 4, !tbaa !20
  %4 = bitcast i8** %cursor.i to i8*
  tail call void @llvm.memset.p0i8.i64(i8* %4, i8 0, i64 16, i32 8, i1 false) #2
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @output_finalize_message(%struct.output_buffer* %buffer) #0 {
entry:
  %next_free = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %0 = load i8** %next_free, align 8, !tbaa !23
  %add.ptr = getelementptr inbounds i8* %0, i64 1
  %chunk_limit = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %1 = load i8** %chunk_limit, align 8, !tbaa !24
  %cmp = icmp ugt i8* %add.ptr, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %obstack = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  tail call void @_obstack_newchunk(%struct.obstack* %obstack, i32 1) #2
  %.pre = load i8** %next_free, align 8, !tbaa !23
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = phi i8* [ %.pre, %if.then ], [ %0, %entry ]
  %incdec.ptr = getelementptr inbounds i8* %2, i64 1
  store i8* %incdec.ptr, i8** %next_free, align 8, !tbaa !23
  store i8 0, i8* %2, align 1, !tbaa !10
  %object_base = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 2
  %3 = load i8** %object_base, align 8, !tbaa !26
  ret i8* %3
}

declare void @_obstack_newchunk(%struct.obstack*, i32) #3

; Function Attrs: nounwind uwtable
define void @flush_diagnostic_buffer() #0 {
entry:
  %0 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %next_free.i.i = getelementptr inbounds %struct.output_buffer* %0, i64 0, i32 2, i32 3
  %1 = load i8** %next_free.i.i, align 8, !tbaa !23
  %add.ptr.i.i = getelementptr inbounds i8* %1, i64 1
  %chunk_limit.i.i = getelementptr inbounds %struct.output_buffer* %0, i64 0, i32 2, i32 4
  %2 = load i8** %chunk_limit.i.i, align 8, !tbaa !24
  %cmp.i.i = icmp ugt i8* %add.ptr.i.i, %2
  %obstack.i.i = getelementptr inbounds %struct.output_buffer* %0, i64 0, i32 2
  br i1 %cmp.i.i, label %if.then.i.i, label %output_finalize_message.exit.i

if.then.i.i:                                      ; preds = %entry
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i.i, i32 1) #2
  %.pre.i.i = load i8** %next_free.i.i, align 8, !tbaa !23
  br label %output_finalize_message.exit.i

output_finalize_message.exit.i:                   ; preds = %if.then.i.i, %entry
  %3 = phi i8* [ %.pre.i.i, %if.then.i.i ], [ %1, %entry ]
  %incdec.ptr.i.i = getelementptr inbounds i8* %3, i64 1
  store i8* %incdec.ptr.i.i, i8** %next_free.i.i, align 8, !tbaa !23
  store i8 0, i8* %3, align 1, !tbaa !10
  %object_base.i.i = getelementptr inbounds %struct.output_buffer* %0, i64 0, i32 2, i32 2
  %4 = load i8** %object_base.i.i, align 8, !tbaa !26
  %stream.i = getelementptr inbounds %struct.output_buffer* %0, i64 0, i32 1
  %5 = load %struct._IO_FILE** %stream.i, align 8, !tbaa !27
  %call1.i = tail call i32 @fputs(i8* %4, %struct._IO_FILE* %5) #2
  %6 = load i8** %object_base.i.i, align 8, !tbaa !26
  %chunk.i.i = getelementptr inbounds %struct.output_buffer* %0, i64 0, i32 2, i32 1
  %7 = load %struct._obstack_chunk** %chunk.i.i, align 8, !tbaa !28
  %8 = bitcast %struct._obstack_chunk* %7 to i8*
  %cmp.i6.i = icmp ugt i8* %6, %8
  br i1 %cmp.i6.i, label %land.lhs.true.i.i, label %if.else.i.i

land.lhs.true.i.i:                                ; preds = %output_finalize_message.exit.i
  %9 = load i8** %chunk_limit.i.i, align 8, !tbaa !24
  %cmp2.i.i = icmp ult i8* %6, %9
  br i1 %cmp2.i.i, label %if.then.i9.i, label %if.else.i.i

if.then.i9.i:                                     ; preds = %land.lhs.true.i.i
  store i8* %6, i8** %object_base.i.i, align 8, !tbaa !26
  store i8* %6, i8** %next_free.i.i, align 8, !tbaa !23
  br label %output_buffer_to_stream.exit

if.else.i.i:                                      ; preds = %land.lhs.true.i.i, %output_finalize_message.exit.i
  tail call void @obstack_free(%struct.obstack* %obstack.i.i, i8* %6) #2
  br label %output_buffer_to_stream.exit

output_buffer_to_stream.exit:                     ; preds = %if.then.i9.i, %if.else.i.i
  %line_length.i.i = getelementptr inbounds %struct.output_buffer* %0, i64 0, i32 3
  store i32 0, i32* %line_length.i.i, align 4, !tbaa !25
  %10 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %stream = getelementptr inbounds %struct.output_buffer* %10, i64 0, i32 1
  %11 = load %struct._IO_FILE** %stream, align 8, !tbaa !27
  %call = tail call i32 @fflush(%struct._IO_FILE* %11) #2
  ret void
}

; Function Attrs: nounwind
declare i32 @fflush(%struct._IO_FILE* nocapture) #4

; Function Attrs: nounwind readonly uwtable
define i32 @output_space_left(%struct.output_buffer* nocapture readonly %buffer) #1 {
entry:
  %maximum_length = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  %0 = load i32* %maximum_length, align 4, !tbaa !18
  %line_length = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  %1 = load i32* %line_length, align 4, !tbaa !25
  %sub = sub nsw i32 %0, %1
  ret i32 %sub
}

; Function Attrs: nounwind uwtable
define void @output_emit_prefix(%struct.output_buffer* %buffer) #0 {
entry:
  %prefix = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 0
  %0 = load i8** %prefix, align 8, !tbaa !11
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.end12, label %if.then

if.then:                                          ; preds = %entry
  %prefixing_rule = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 6
  %1 = load i32* %prefixing_rule, align 4, !tbaa !17
  switch i32 %1, label %if.end12 [
    i32 2, label %sw.bb5
    i32 0, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.then
  %emitted_prefix_p = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 4
  %2 = load i8* %emitted_prefix_p, align 1, !tbaa !19, !range !35
  %tobool = icmp eq i8 %2, 0
  %indent_skip = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 3
  %3 = load i32* %indent_skip, align 4, !tbaa !20
  br i1 %tobool, label %if.end, label %if.then3

if.then3:                                         ; preds = %sw.bb
  %cmp3.i = icmp sgt i32 %3, 0
  br i1 %cmp3.i, label %for.body.lr.ph.i, label %if.end12

for.body.lr.ph.i:                                 ; preds = %if.then3
  %ideal_maximum_length.i.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 2
  %maximum_length.i.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  %line_length.i14.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  %next_free.i.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %chunk_limit.i.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %obstack.i.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  br label %for.body.i

for.body.i:                                       ; preds = %output_add_character.exit.i, %for.body.lr.ph.i
  %i.04.i = phi i32 [ 0, %for.body.lr.ph.i ], [ %inc.i, %output_add_character.exit.i ]
  %4 = load i32* %ideal_maximum_length.i.i.i, align 4, !tbaa !16
  %cmp.i.i.i = icmp sgt i32 %4, 0
  br i1 %cmp.i.i.i, label %land.lhs.true.i.i, label %if.end.i.i

land.lhs.true.i.i:                                ; preds = %for.body.i
  %5 = load i32* %maximum_length.i.i.i, align 4, !tbaa !18
  %6 = load i32* %line_length.i14.i.i, align 4, !tbaa !25
  %sub.i.i.i = sub nsw i32 %5, %6
  %cmp.i.i = icmp slt i32 %sub.i.i.i, 1
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i
  %7 = load i8** %next_free.i.i.i, align 8, !tbaa !23
  %add.ptr.i.i.i = getelementptr inbounds i8* %7, i64 1
  %8 = load i8** %chunk_limit.i.i.i, align 8, !tbaa !24
  %cmp.i13.i.i = icmp ugt i8* %add.ptr.i.i.i, %8
  br i1 %cmp.i13.i.i, label %if.then.i.i.i, label %output_add_newline.exit.i.i

if.then.i.i.i:                                    ; preds = %if.then.i.i
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i.i.i, i32 1) #2
  %.pre.i.i.i = load i8** %next_free.i.i.i, align 8, !tbaa !23
  br label %output_add_newline.exit.i.i

output_add_newline.exit.i.i:                      ; preds = %if.then.i.i.i, %if.then.i.i
  %9 = phi i8* [ %.pre.i.i.i, %if.then.i.i.i ], [ %7, %if.then.i.i ]
  %incdec.ptr.i.i.i = getelementptr inbounds i8* %9, i64 1
  store i8* %incdec.ptr.i.i.i, i8** %next_free.i.i.i, align 8, !tbaa !23
  store i8 10, i8* %9, align 1, !tbaa !10
  store i32 0, i32* %line_length.i14.i.i, align 4, !tbaa !25
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %output_add_newline.exit.i.i, %land.lhs.true.i.i, %for.body.i
  %10 = load i8** %next_free.i.i.i, align 8, !tbaa !23
  %add.ptr.i.i = getelementptr inbounds i8* %10, i64 1
  %11 = load i8** %chunk_limit.i.i.i, align 8, !tbaa !24
  %cmp2.i.i = icmp ugt i8* %add.ptr.i.i, %11
  br i1 %cmp2.i.i, label %if.then3.i.i, label %output_add_character.exit.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i.i.i, i32 1) #2
  %.pre.i.i = load i8** %next_free.i.i.i, align 8, !tbaa !23
  br label %output_add_character.exit.i

output_add_character.exit.i:                      ; preds = %if.then3.i.i, %if.end.i.i
  %12 = phi i8* [ %.pre.i.i, %if.then3.i.i ], [ %10, %if.end.i.i ]
  %incdec.ptr.i.i = getelementptr inbounds i8* %12, i64 1
  store i8* %incdec.ptr.i.i, i8** %next_free.i.i.i, align 8, !tbaa !23
  store i8 32, i8* %12, align 1, !tbaa !10
  %13 = load i32* %line_length.i14.i.i, align 4, !tbaa !25
  %inc.i.i = add nsw i32 %13, 1
  store i32 %inc.i.i, i32* %line_length.i14.i.i, align 4, !tbaa !25
  %inc.i = add nsw i32 %i.04.i, 1
  %exitcond.i = icmp eq i32 %inc.i, %3
  br i1 %exitcond.i, label %if.end12, label %for.body.i

if.end:                                           ; preds = %sw.bb
  %add = add nsw i32 %3, 3
  store i32 %add, i32* %indent_skip, align 4, !tbaa !20
  br label %sw.bb5

sw.bb5:                                           ; preds = %if.then, %if.end
  %call = tail call i64 @strlen(i8* %0) #2
  %conv = trunc i64 %call to i32
  %next_free.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %14 = load i8** %next_free.i, align 8, !tbaa !23
  %sext = shl i64 %call, 32
  %idx.ext.i = ashr exact i64 %sext, 32
  %add.ptr.i = getelementptr inbounds i8* %14, i64 %idx.ext.i
  %chunk_limit.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %15 = load i8** %chunk_limit.i, align 8, !tbaa !24
  %cmp.i = icmp ugt i8* %add.ptr.i, %15
  br i1 %cmp.i, label %if.then.i, label %output_append_r.exit

if.then.i:                                        ; preds = %sw.bb5
  %obstack.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i, i32 %conv) #2
  %.pre.i = load i8** %next_free.i, align 8, !tbaa !23
  br label %output_append_r.exit

output_append_r.exit:                             ; preds = %sw.bb5, %if.then.i
  %16 = phi i8* [ %.pre.i, %if.then.i ], [ %14, %sw.bb5 ]
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %16, i8* %0, i64 %idx.ext.i, i32 1, i1 false) #2
  %17 = load i8** %next_free.i, align 8, !tbaa !23
  %add.ptr4.i = getelementptr inbounds i8* %17, i64 %idx.ext.i
  store i8* %add.ptr4.i, i8** %next_free.i, align 8, !tbaa !23
  %line_length.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  %18 = load i32* %line_length.i, align 4, !tbaa !25
  %add.i = add nsw i32 %18, %conv
  store i32 %add.i, i32* %line_length.i, align 4, !tbaa !25
  %emitted_prefix_p11 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 4
  store i8 1, i8* %emitted_prefix_p11, align 1, !tbaa !19
  br label %if.end12

if.end12:                                         ; preds = %output_add_character.exit.i, %if.then3, %entry, %output_append_r.exit, %if.then
  ret void
}

; Function Attrs: nounwind readonly
declare i64 @strlen(i8* nocapture) #5

; Function Attrs: nounwind uwtable
define void @output_add_newline(%struct.output_buffer* %buffer) #0 {
entry:
  %next_free = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %0 = load i8** %next_free, align 8, !tbaa !23
  %add.ptr = getelementptr inbounds i8* %0, i64 1
  %chunk_limit = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %1 = load i8** %chunk_limit, align 8, !tbaa !24
  %cmp = icmp ugt i8* %add.ptr, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %obstack = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  tail call void @_obstack_newchunk(%struct.obstack* %obstack, i32 1) #2
  %.pre = load i8** %next_free, align 8, !tbaa !23
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = phi i8* [ %.pre, %if.then ], [ %0, %entry ]
  %incdec.ptr = getelementptr inbounds i8* %2, i64 1
  store i8* %incdec.ptr, i8** %next_free, align 8, !tbaa !23
  store i8 10, i8* %2, align 1, !tbaa !10
  %line_length = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  store i32 0, i32* %line_length, align 4, !tbaa !25
  ret void
}

; Function Attrs: nounwind uwtable
define void @output_add_character(%struct.output_buffer* %buffer, i32 %c) #0 {
entry:
  %ideal_maximum_length.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 2
  %0 = load i32* %ideal_maximum_length.i, align 4, !tbaa !16
  %cmp.i = icmp sgt i32 %0, 0
  br i1 %cmp.i, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %maximum_length.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  %1 = load i32* %maximum_length.i, align 4, !tbaa !18
  %line_length.i14 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  %2 = load i32* %line_length.i14, align 4, !tbaa !25
  %sub.i = sub nsw i32 %1, %2
  %cmp = icmp slt i32 %sub.i, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %next_free.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %3 = load i8** %next_free.i, align 8, !tbaa !23
  %add.ptr.i = getelementptr inbounds i8* %3, i64 1
  %chunk_limit.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %4 = load i8** %chunk_limit.i, align 8, !tbaa !24
  %cmp.i13 = icmp ugt i8* %add.ptr.i, %4
  br i1 %cmp.i13, label %if.then.i, label %output_add_newline.exit

if.then.i:                                        ; preds = %if.then
  %obstack.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i, i32 1) #2
  %.pre.i = load i8** %next_free.i, align 8, !tbaa !23
  br label %output_add_newline.exit

output_add_newline.exit:                          ; preds = %if.then, %if.then.i
  %5 = phi i8* [ %.pre.i, %if.then.i ], [ %3, %if.then ]
  %incdec.ptr.i = getelementptr inbounds i8* %5, i64 1
  store i8* %incdec.ptr.i, i8** %next_free.i, align 8, !tbaa !23
  store i8 10, i8* %5, align 1, !tbaa !10
  store i32 0, i32* %line_length.i14, align 4, !tbaa !25
  br label %if.end

if.end:                                           ; preds = %entry, %output_add_newline.exit, %land.lhs.true
  %next_free = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %6 = load i8** %next_free, align 8, !tbaa !23
  %add.ptr = getelementptr inbounds i8* %6, i64 1
  %chunk_limit = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %7 = load i8** %chunk_limit, align 8, !tbaa !24
  %cmp2 = icmp ugt i8* %add.ptr, %7
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %obstack = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  tail call void @_obstack_newchunk(%struct.obstack* %obstack, i32 1) #2
  %.pre = load i8** %next_free, align 8, !tbaa !23
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %8 = phi i8* [ %.pre, %if.then3 ], [ %6, %if.end ]
  %conv = trunc i32 %c to i8
  %incdec.ptr = getelementptr inbounds i8* %8, i64 1
  store i8* %incdec.ptr, i8** %next_free, align 8, !tbaa !23
  store i8 %conv, i8* %8, align 1, !tbaa !10
  %line_length = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  %9 = load i32* %line_length, align 4, !tbaa !25
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %line_length, align 4, !tbaa !25
  ret void
}

; Function Attrs: nounwind uwtable
define void @output_add_space(%struct.output_buffer* %buffer) #0 {
entry:
  %ideal_maximum_length.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 2
  %0 = load i32* %ideal_maximum_length.i, align 4, !tbaa !16
  %cmp.i = icmp sgt i32 %0, 0
  br i1 %cmp.i, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %maximum_length.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  %1 = load i32* %maximum_length.i, align 4, !tbaa !18
  %line_length.i14 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  %2 = load i32* %line_length.i14, align 4, !tbaa !25
  %sub.i = sub nsw i32 %1, %2
  %cmp = icmp slt i32 %sub.i, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %next_free.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %3 = load i8** %next_free.i, align 8, !tbaa !23
  %add.ptr.i = getelementptr inbounds i8* %3, i64 1
  %chunk_limit.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %4 = load i8** %chunk_limit.i, align 8, !tbaa !24
  %cmp.i13 = icmp ugt i8* %add.ptr.i, %4
  br i1 %cmp.i13, label %if.then.i, label %output_add_newline.exit

if.then.i:                                        ; preds = %if.then
  %obstack.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i, i32 1) #2
  %.pre.i = load i8** %next_free.i, align 8, !tbaa !23
  br label %output_add_newline.exit

output_add_newline.exit:                          ; preds = %if.then, %if.then.i
  %5 = phi i8* [ %.pre.i, %if.then.i ], [ %3, %if.then ]
  %incdec.ptr.i = getelementptr inbounds i8* %5, i64 1
  store i8* %incdec.ptr.i, i8** %next_free.i, align 8, !tbaa !23
  store i8 10, i8* %5, align 1, !tbaa !10
  store i32 0, i32* %line_length.i14, align 4, !tbaa !25
  br label %return

if.end:                                           ; preds = %entry, %land.lhs.true
  %next_free = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %6 = load i8** %next_free, align 8, !tbaa !23
  %add.ptr = getelementptr inbounds i8* %6, i64 1
  %chunk_limit = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %7 = load i8** %chunk_limit, align 8, !tbaa !24
  %cmp2 = icmp ugt i8* %add.ptr, %7
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %obstack = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  tail call void @_obstack_newchunk(%struct.obstack* %obstack, i32 1) #2
  %.pre = load i8** %next_free, align 8, !tbaa !23
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %8 = phi i8* [ %.pre, %if.then3 ], [ %6, %if.end ]
  %incdec.ptr = getelementptr inbounds i8* %8, i64 1
  store i8* %incdec.ptr, i8** %next_free, align 8, !tbaa !23
  store i8 32, i8* %8, align 1, !tbaa !10
  %line_length = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  %9 = load i32* %line_length, align 4, !tbaa !25
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %line_length, align 4, !tbaa !25
  br label %return

return:                                           ; preds = %if.end4, %output_add_newline.exit
  ret void
}

; Function Attrs: nounwind uwtable
define void @output_decimal(%struct.output_buffer* %buffer, i32 %i) #0 {
entry:
  %arraydecay = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 4, i64 0
  %call = tail call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([3 x i8]* @.str, i64 0, i64 0), i32 %i) #2
  tail call void @output_add_string(%struct.output_buffer* %buffer, i8* %arraydecay)
  ret void
}

; Function Attrs: nounwind
declare i32 @sprintf(i8* nocapture, i8* nocapture readonly, ...) #4

; Function Attrs: nounwind uwtable
define void @output_add_string(%struct.output_buffer* %buffer, i8* %str) #0 {
entry:
  %tobool = icmp eq i8* %str, null
  br i1 %tobool, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %call = tail call i64 @strlen(i8* %str) #2
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %entry ]
  %add.ptr = getelementptr inbounds i8* %str, i64 %cond
  %ideal_maximum_length.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 2
  %0 = load i32* %ideal_maximum_length.i.i, align 4, !tbaa !16
  %cmp.i.i = icmp sgt i32 %0, 0
  br i1 %cmp.i.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %cond.end
  tail call fastcc void @wrap_text(%struct.output_buffer* %buffer, i8* %str, i8* %add.ptr) #2
  br label %maybe_wrap_text.exit

if.else.i:                                        ; preds = %cond.end
  %line_length.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  %1 = load i32* %line_length.i.i, align 4, !tbaa !25
  %cmp.i2.i = icmp eq i32 %1, 0
  br i1 %cmp.i2.i, label %if.then.i.i, label %if.end5.i.i

if.then.i.i:                                      ; preds = %if.else.i
  tail call void @output_emit_prefix(%struct.output_buffer* %buffer) #2
  %2 = load i32* %ideal_maximum_length.i.i, align 4, !tbaa !16
  %cmp.i.i.i = icmp slt i32 %2, 1
  %cmp216.i.i = icmp eq i64 %cond, 0
  %or.cond.i.i = or i1 %cmp.i.i.i, %cmp216.i.i
  br i1 %or.cond.i.i, label %if.end5.i.i, label %land.rhs.i.i

while.cond.i.i:                                   ; preds = %land.rhs.i.i
  %cmp2.i.i = icmp eq i8* %incdec.ptr.i.i, %add.ptr
  br i1 %cmp2.i.i, label %if.end5.i.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %if.then.i.i, %while.cond.i.i
  %start.addr.017.i.i = phi i8* [ %incdec.ptr.i.i, %while.cond.i.i ], [ %str, %if.then.i.i ]
  %3 = load i8* %start.addr.017.i.i, align 1, !tbaa !10
  %cmp3.i.i = icmp eq i8 %3, 32
  %incdec.ptr.i.i = getelementptr inbounds i8* %start.addr.017.i.i, i64 1
  br i1 %cmp3.i.i, label %while.cond.i.i, label %if.end5.i.i

if.end5.i.i:                                      ; preds = %land.rhs.i.i, %while.cond.i.i, %if.then.i.i, %if.else.i
  %start.addr.1.i.i = phi i8* [ %str, %if.then.i.i ], [ %str, %if.else.i ], [ %start.addr.017.i.i, %land.rhs.i.i ], [ %add.ptr, %while.cond.i.i ]
  %sub.ptr.lhs.cast.i.i = ptrtoint i8* %add.ptr to i64
  %sub.ptr.rhs.cast.i.i = ptrtoint i8* %start.addr.1.i.i to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %conv6.i.i = trunc i64 %sub.ptr.sub.i.i to i32
  %next_free.i.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %4 = load i8** %next_free.i.i.i, align 8, !tbaa !23
  %sext.i.i = shl i64 %sub.ptr.sub.i.i, 32
  %idx.ext.i.i.i = ashr exact i64 %sext.i.i, 32
  %add.ptr.i.i.i = getelementptr inbounds i8* %4, i64 %idx.ext.i.i.i
  %chunk_limit.i.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %5 = load i8** %chunk_limit.i.i.i, align 8, !tbaa !24
  %cmp.i15.i.i = icmp ugt i8* %add.ptr.i.i.i, %5
  br i1 %cmp.i15.i.i, label %if.then.i.i.i, label %output_append.exit.i

if.then.i.i.i:                                    ; preds = %if.end5.i.i
  %obstack.i.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i.i.i, i32 %conv6.i.i) #2
  %.pre.i.i.i = load i8** %next_free.i.i.i, align 8, !tbaa !23
  br label %output_append.exit.i

output_append.exit.i:                             ; preds = %if.then.i.i.i, %if.end5.i.i
  %6 = phi i8* [ %.pre.i.i.i, %if.then.i.i.i ], [ %4, %if.end5.i.i ]
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %start.addr.1.i.i, i64 %idx.ext.i.i.i, i32 1, i1 false) #2
  %7 = load i8** %next_free.i.i.i, align 8, !tbaa !23
  %add.ptr4.i.i.i = getelementptr inbounds i8* %7, i64 %idx.ext.i.i.i
  store i8* %add.ptr4.i.i.i, i8** %next_free.i.i.i, align 8, !tbaa !23
  %8 = load i32* %line_length.i.i, align 4, !tbaa !25
  %add.i.i.i = add nsw i32 %8, %conv6.i.i
  store i32 %add.i.i.i, i32* %line_length.i.i, align 4, !tbaa !25
  br label %maybe_wrap_text.exit

maybe_wrap_text.exit:                             ; preds = %if.then.i, %output_append.exit.i
  ret void
}

; Function Attrs: nounwind uwtable
define void @output_append(%struct.output_buffer* %buffer, i8* %start, i8* %end) #0 {
entry:
  %line_length = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  %0 = load i32* %line_length, align 4, !tbaa !25
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  tail call void @output_emit_prefix(%struct.output_buffer* %buffer)
  %ideal_maximum_length.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 2
  %1 = load i32* %ideal_maximum_length.i, align 4, !tbaa !16
  %cmp.i = icmp slt i32 %1, 1
  %cmp216 = icmp eq i8* %start, %end
  %or.cond = or i1 %cmp.i, %cmp216
  br i1 %or.cond, label %if.end5, label %land.rhs

while.cond:                                       ; preds = %land.rhs
  %cmp2 = icmp eq i8* %incdec.ptr, %end
  br i1 %cmp2, label %if.end5, label %land.rhs

land.rhs:                                         ; preds = %if.then, %while.cond
  %start.addr.017 = phi i8* [ %incdec.ptr, %while.cond ], [ %start, %if.then ]
  %2 = load i8* %start.addr.017, align 1, !tbaa !10
  %cmp3 = icmp eq i8 %2, 32
  %incdec.ptr = getelementptr inbounds i8* %start.addr.017, i64 1
  br i1 %cmp3, label %while.cond, label %if.end5

if.end5:                                          ; preds = %land.rhs, %while.cond, %if.then, %entry
  %start.addr.1 = phi i8* [ %start, %if.then ], [ %start, %entry ], [ %start.addr.017, %land.rhs ], [ %end, %while.cond ]
  %sub.ptr.lhs.cast = ptrtoint i8* %end to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %start.addr.1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv6 = trunc i64 %sub.ptr.sub to i32
  %next_free.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %3 = load i8** %next_free.i, align 8, !tbaa !23
  %sext = shl i64 %sub.ptr.sub, 32
  %idx.ext.i = ashr exact i64 %sext, 32
  %add.ptr.i = getelementptr inbounds i8* %3, i64 %idx.ext.i
  %chunk_limit.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %4 = load i8** %chunk_limit.i, align 8, !tbaa !24
  %cmp.i15 = icmp ugt i8* %add.ptr.i, %4
  br i1 %cmp.i15, label %if.then.i, label %output_append_r.exit

if.then.i:                                        ; preds = %if.end5
  %obstack.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i, i32 %conv6) #2
  %.pre.i = load i8** %next_free.i, align 8, !tbaa !23
  br label %output_append_r.exit

output_append_r.exit:                             ; preds = %if.end5, %if.then.i
  %5 = phi i8* [ %.pre.i, %if.then.i ], [ %3, %if.end5 ]
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %start.addr.1, i64 %idx.ext.i, i32 1, i1 false) #2
  %6 = load i8** %next_free.i, align 8, !tbaa !23
  %add.ptr4.i = getelementptr inbounds i8* %6, i64 %idx.ext.i
  store i8* %add.ptr4.i, i8** %next_free.i, align 8, !tbaa !23
  %7 = load i32* %line_length, align 4, !tbaa !25
  %add.i = add nsw i32 %7, %conv6
  store i32 %add.i, i32* %line_length, align 4, !tbaa !25
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @context_as_prefix(i8* %file, i32 %line, i32 %warn) #0 {
entry:
  %tobool = icmp eq i8* %file, null
  %tobool1 = icmp ne i32 %warn, 0
  br i1 %tobool, label %if.else4, label %if.then

if.then:                                          ; preds = %entry
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %call = tail call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([17 x i8]* @.str1, i64 0, i64 0), i8* %file, i32 %line)
  br label %return

if.else:                                          ; preds = %if.then
  %call3 = tail call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([8 x i8]* @.str2, i64 0, i64 0), i8* %file, i32 %line)
  br label %return

if.else4:                                         ; preds = %entry
  %0 = load i8** @progname, align 8, !tbaa !1
  br i1 %tobool1, label %if.then6, label %if.else8

if.then6:                                         ; preds = %if.else4
  %call7 = tail call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([14 x i8]* @.str3, i64 0, i64 0), i8* %0)
  br label %return

if.else8:                                         ; preds = %if.else4
  %call9 = tail call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([5 x i8]* @.str4, i64 0, i64 0), i8* %0)
  br label %return

return:                                           ; preds = %if.else8, %if.then6, %if.else, %if.then2
  %retval.0 = phi i8* [ %call, %if.then2 ], [ %call3, %if.else ], [ %call7, %if.then6 ], [ %call9, %if.else8 ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @build_message_string(i8* %msg, ...) #0 {
entry:
  %str.i = alloca i8*, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag]* %ap, i64 0, i64 0
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %0 = bitcast i8** %str.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #2
  %call.i = call i32 @vasprintf(i8** %str.i, i8* %msg, %struct.__va_list_tag* %arraydecay) #2
  %1 = load i8** %str.i, align 8, !tbaa !1
  call void @llvm.lifetime.end(i64 8, i8* %0) #2
  call void @llvm.va_end(i8* %arraydecay1)
  ret i8* %1
}

; Function Attrs: nounwind uwtable
define i8* @file_name_as_prefix(i8* %f) #0 {
entry:
  %call = tail call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([5 x i8]* @.str4, i64 0, i64 0), i8* %f)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define void @output_printf(%struct.output_buffer* %buffer, i8* %msgid, ...) #0 {
entry:
  %str.i.i = alloca i8*, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %format_args = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 8
  %0 = load [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !36
  store [1 x %struct.__va_list_tag]* %ap, [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !36
  %arraydecay.i = getelementptr inbounds [1 x %struct.__va_list_tag]* %ap, i64 0, i64 0
  %1 = bitcast i8** %str.i.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #2
  %call.i.i = call i32 @vasprintf(i8** %str.i.i, i8* %msgid, %struct.__va_list_tag* %arraydecay.i) #2
  %2 = load i8** %str.i.i, align 8, !tbaa !1
  call void @llvm.lifetime.end(i64 8, i8* %1) #2
  %call1.i = call i64 @strlen(i8* %2) #2
  %add.ptr.i = getelementptr inbounds i8* %2, i64 %call1.i
  call fastcc void @wrap_text(%struct.output_buffer* %buffer, i8* %2, i8* %add.ptr.i) #2
  call void @free(i8* %2) #2
  store [1 x %struct.__va_list_tag]* %0, [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !36
  call void @llvm.va_end(i8* %arraydecay1)
  ret void
}

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #2

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #2

; Function Attrs: nounwind uwtable
define i32 @count_error(i32 %warningp) #0 {
entry:
  %tobool = icmp eq i32 %warningp, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %0 = load i32* @inhibit_warnings, align 4, !tbaa !6
  %tobool1 = icmp eq i32 %0, 0
  br i1 %tobool1, label %land.lhs.true2, label %return

land.lhs.true2:                                   ; preds = %land.lhs.true
  %1 = load i32* @in_system_header, align 4, !tbaa !6
  %tobool3 = icmp eq i32 %1, 0
  %2 = load i32* @warn_system_headers, align 4
  %tobool5 = icmp ne i32 %2, 0
  %or.cond = or i1 %tobool3, %tobool5
  br i1 %or.cond, label %if.end, label %return

if.end:                                           ; preds = %land.lhs.true2
  %3 = load i32* @warnings_are_errors, align 4
  %tobool8 = icmp eq i32 %3, 0
  br i1 %tobool8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end
  %4 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.diagnostic_context* %4, i64 0, i32 0, i32 0, i32 9, i64 4
  %5 = load i32* %arrayidx, align 4, !tbaa !6
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %arrayidx, align 4, !tbaa !6
  br label %return

if.else:                                          ; preds = %if.end
  %.b = load i1* @count_error.warning_message, align 1
  br i1 %.b, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.else
  %6 = load i8** @progname, align 8, !tbaa !1
  tail call void (i8*, ...)* @verbatim(i8* getelementptr inbounds ([38 x i8]* @.str5, i64 0, i64 0), i8* %6)
  store i1 true, i1* @count_error.warning_message, align 1
  br label %if.end14

if.end14:                                         ; preds = %entry, %if.else, %if.then13
  %7 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %arrayidx17 = getelementptr inbounds %struct.diagnostic_context* %7, i64 0, i32 0, i32 0, i32 9, i64 3
  %8 = load i32* %arrayidx17, align 4, !tbaa !6
  %inc18 = add nsw i32 %8, 1
  store i32 %inc18, i32* %arrayidx17, align 4, !tbaa !6
  br label %return

return:                                           ; preds = %if.then9, %if.end14, %land.lhs.true2, %land.lhs.true
  %retval.0 = phi i32 [ 0, %land.lhs.true ], [ 0, %land.lhs.true2 ], [ 1, %if.end14 ], [ 1, %if.then9 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @verbatim(i8* %msgid, ...) #0 {
entry:
  %os.i = alloca %struct.output_state, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %0 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %os.0..sroa_cast.i = bitcast %struct.output_state* %os.i to i8*
  call void @llvm.lifetime.start(i64 80, i8* %os.0..sroa_cast.i)
  %1 = bitcast %struct.output_buffer* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %os.0..sroa_cast.i, i8* %1, i64 80, i32 8, i1 false) #2, !tbaa.struct !5
  %prefix.i = getelementptr inbounds %struct.output_buffer* %0, i64 0, i32 0, i32 0
  store i8* null, i8** %prefix.i, align 8, !tbaa !11
  %prefixing_rule.i = getelementptr inbounds %struct.output_buffer* %0, i64 0, i32 0, i32 6
  store i32 1, i32* %prefixing_rule.i, align 4, !tbaa !17
  %cursor.i = getelementptr inbounds %struct.output_buffer* %0, i64 0, i32 0, i32 7
  store i8* %msgid, i8** %cursor.i, align 8, !tbaa !37
  %format_args.i = getelementptr inbounds %struct.output_buffer* %0, i64 0, i32 0, i32 8
  store [1 x %struct.__va_list_tag]* %ap, [1 x %struct.__va_list_tag]** %format_args.i, align 8, !tbaa !36
  %ideal_maximum_length.i.i = getelementptr inbounds %struct.output_buffer* %0, i64 0, i32 0, i32 2
  store i32 0, i32* %ideal_maximum_length.i.i, align 4, !tbaa !16
  %maximum_length.i.i.i = getelementptr inbounds %struct.output_buffer* %0, i64 0, i32 0, i32 1
  store i32 0, i32* %maximum_length.i.i.i, align 4, !tbaa !18
  call fastcc void @output_format(%struct.output_buffer* %0) #2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %os.0..sroa_cast.i, i64 80, i32 8, i1 false) #2, !tbaa.struct !5
  call void @llvm.lifetime.end(i64 80, i8* %os.0..sroa_cast.i)
  %2 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %next_free.i.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 2, i32 3
  %3 = load i8** %next_free.i.i, align 8, !tbaa !23
  %add.ptr.i.i = getelementptr inbounds i8* %3, i64 1
  %chunk_limit.i.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 2, i32 4
  %4 = load i8** %chunk_limit.i.i, align 8, !tbaa !24
  %cmp.i.i = icmp ugt i8* %add.ptr.i.i, %4
  %obstack.i.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 2
  br i1 %cmp.i.i, label %if.then.i.i, label %output_finalize_message.exit.i

if.then.i.i:                                      ; preds = %entry
  call void @_obstack_newchunk(%struct.obstack* %obstack.i.i, i32 1) #2
  %.pre.i.i = load i8** %next_free.i.i, align 8, !tbaa !23
  br label %output_finalize_message.exit.i

output_finalize_message.exit.i:                   ; preds = %if.then.i.i, %entry
  %5 = phi i8* [ %.pre.i.i, %if.then.i.i ], [ %3, %entry ]
  %incdec.ptr.i.i = getelementptr inbounds i8* %5, i64 1
  store i8* %incdec.ptr.i.i, i8** %next_free.i.i, align 8, !tbaa !23
  store i8 0, i8* %5, align 1, !tbaa !10
  %object_base.i.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 2, i32 2
  %6 = load i8** %object_base.i.i, align 8, !tbaa !26
  %stream.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 1
  %7 = load %struct._IO_FILE** %stream.i, align 8, !tbaa !27
  %call1.i = call i32 @fputs(i8* %6, %struct._IO_FILE* %7) #2
  %8 = load i8** %object_base.i.i, align 8, !tbaa !26
  %chunk.i.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 2, i32 1
  %9 = load %struct._obstack_chunk** %chunk.i.i, align 8, !tbaa !28
  %10 = bitcast %struct._obstack_chunk* %9 to i8*
  %cmp.i6.i = icmp ugt i8* %8, %10
  br i1 %cmp.i6.i, label %land.lhs.true.i.i, label %if.else.i.i

land.lhs.true.i.i:                                ; preds = %output_finalize_message.exit.i
  %11 = load i8** %chunk_limit.i.i, align 8, !tbaa !24
  %cmp2.i.i = icmp ult i8* %8, %11
  br i1 %cmp2.i.i, label %if.then.i9.i, label %if.else.i.i

if.then.i9.i:                                     ; preds = %land.lhs.true.i.i
  store i8* %8, i8** %object_base.i.i, align 8, !tbaa !26
  store i8* %8, i8** %next_free.i.i, align 8, !tbaa !23
  br label %output_buffer_to_stream.exit

if.else.i.i:                                      ; preds = %land.lhs.true.i.i, %output_finalize_message.exit.i
  call void @obstack_free(%struct.obstack* %obstack.i.i, i8* %8) #2
  br label %output_buffer_to_stream.exit

output_buffer_to_stream.exit:                     ; preds = %if.then.i9.i, %if.else.i.i
  %line_length.i.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 3
  store i32 0, i32* %line_length.i.i, align 4, !tbaa !25
  call void @llvm.va_end(i8* %arraydecay1)
  ret void
}

; Function Attrs: nounwind uwtable
define void @fnotice(%struct._IO_FILE* nocapture %file, i8* nocapture readonly %msgid, ...) #0 {
entry:
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag]* %ap, i64 0, i64 0
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %call = call i32 @vfprintf(%struct._IO_FILE* %file, i8* %msgid, %struct.__va_list_tag* %arraydecay) #2
  call void @llvm.va_end(i8* %arraydecay1)
  ret void
}

; Function Attrs: nounwind
declare i32 @vfprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, %struct.__va_list_tag*) #4

; Function Attrs: noreturn nounwind uwtable
define void @fatal_io_error(i8* %msgid, ...) #6 {
entry:
  %os = alloca %struct.output_state, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %os.0..sroa_cast = bitcast %struct.output_state* %os to i8*
  call void @llvm.lifetime.start(i64 80, i8* %os.0..sroa_cast)
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %0 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %1 = bitcast %struct.output_buffer* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %os.0..sroa_cast, i8* %1, i64 80, i32 8, i1 false), !tbaa.struct !5
  %2 = load i8** @progname, align 8, !tbaa !1
  %call = call i32* @__errno_location() #9
  %3 = load i32* %call, align 4, !tbaa !6
  %call2 = call i8* @xstrerror(i32 %3) #2
  call void (%struct.output_buffer*, i8*, ...)* @output_printf(%struct.output_buffer* %0, i8* getelementptr inbounds ([9 x i8]* @.str6, i64 0, i64 0), i8* %2, i8* %call2)
  %4 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %format_args = getelementptr inbounds %struct.output_buffer* %4, i64 0, i32 0, i32 8
  store [1 x %struct.__va_list_tag]* %ap, [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !36
  %5 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %cursor = getelementptr inbounds %struct.output_buffer* %5, i64 0, i32 0, i32 7
  store i8* %msgid, i8** %cursor, align 8, !tbaa !37
  %6 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  call fastcc void @output_format(%struct.output_buffer* %6)
  %7 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %8 = getelementptr inbounds %struct.diagnostic_context* %7, i64 0, i32 0
  call fastcc void @diagnostic_finish(%struct.output_buffer* %8)
  %9 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %10 = bitcast %struct.output_buffer* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %os.0..sroa_cast, i64 80, i32 8, i1 false), !tbaa.struct !5
  call void @llvm.va_end(i8* %arraydecay1)
  call void @exit(i32 1) #10
  unreachable
}

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #2

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #2

declare i8* @xstrerror(i32) #3

; Function Attrs: nounwind readnone
declare i32* @__errno_location() #7

; Function Attrs: nounwind uwtable
define internal fastcc void @output_format(%struct.output_buffer* %buffer) #0 {
entry:
  %cursor = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 7
  %0 = load i8** %cursor, align 8, !tbaa !37
  %1 = load i8* %0, align 1, !tbaa !10
  %tobool311 = icmp eq i8 %1, 0
  br i1 %tobool311, label %for.end, label %while.cond.preheader.lr.ph

while.cond.preheader.lr.ph:                       ; preds = %entry
  %format_decoder = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 5
  %format_args = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 8
  %ideal_maximum_length.i.i270 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 2
  %maximum_length.i.i272 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  %line_length.i14.i273 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  %next_free.i.i277 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %chunk_limit.i.i279 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %obstack.i.i282 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  %arraydecay.i301 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 4, i64 0
  br label %while.cond.preheader

while.cond.preheader:                             ; preds = %while.cond.preheader.lr.ph, %for.inc
  %2 = phi i8 [ %1, %while.cond.preheader.lr.ph ], [ %109, %for.inc ]
  %3 = phi i8* [ %0, %while.cond.preheader.lr.ph ], [ %incdec.ptr216, %for.inc ]
  br label %while.cond

while.cond:                                       ; preds = %while.cond.preheader, %while.body
  %4 = phi i8 [ %.pre, %while.body ], [ %2, %while.cond.preheader ]
  %p.0 = phi i8* [ %incdec.ptr, %while.body ], [ %3, %while.cond.preheader ]
  switch i8 %4, label %while.body [
    i8 0, label %while.end
    i8 37, label %while.end
  ]

while.body:                                       ; preds = %while.cond
  %incdec.ptr = getelementptr inbounds i8* %p.0, i64 1
  %.pre = load i8* %incdec.ptr, align 1, !tbaa !10
  br label %while.cond

while.end:                                        ; preds = %while.cond, %while.cond
  tail call fastcc void @wrap_text(%struct.output_buffer* %buffer, i8* %3, i8* %p.0)
  store i8* %p.0, i8** %cursor, align 8, !tbaa !37
  %5 = load i8* %p.0, align 1, !tbaa !10
  %tobool12 = icmp eq i8 %5, 0
  br i1 %tobool12, label %for.end, label %if.end

if.end:                                           ; preds = %while.end
  %incdec.ptr15 = getelementptr inbounds i8* %p.0, i64 1
  store i8* %incdec.ptr15, i8** %cursor, align 8, !tbaa !37
  %6 = load i8* %incdec.ptr15, align 1, !tbaa !10
  %cmp17 = icmp eq i8 %6, 108
  br i1 %cmp17, label %if.then19, label %if.end23

if.then19:                                        ; preds = %if.end
  %incdec.ptr22 = getelementptr inbounds i8* %p.0, i64 2
  store i8* %incdec.ptr22, i8** %cursor, align 8, !tbaa !37
  %.pre312 = load i8* %incdec.ptr22, align 1, !tbaa !10
  br label %if.end23

if.end23:                                         ; preds = %if.then19, %if.end
  %7 = phi i8 [ %.pre312, %if.then19 ], [ %6, %if.end ]
  %8 = phi i8* [ %incdec.ptr22, %if.then19 ], [ %incdec.ptr15, %if.end ]
  %long_integer.0 = phi i32 [ 1, %if.then19 ], [ 0, %if.end ]
  %conv26 = sext i8 %7 to i32
  switch i32 %conv26, label %sw.default [
    i32 99, label %sw.bb
    i32 100, label %sw.bb27
    i32 105, label %sw.bb27
    i32 111, label %sw.bb57
    i32 115, label %sw.bb88
    i32 117, label %sw.bb102
    i32 120, label %sw.bb133
    i32 37, label %sw.bb164
    i32 46, label %sw.bb165
  ]

sw.bb:                                            ; preds = %if.end23
  %9 = load [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !38
  %gp_offset_p = getelementptr inbounds [1 x %struct.__va_list_tag]* %9, i64 0, i64 0, i32 0
  %gp_offset = load i32* %gp_offset_p, align 4
  %fits_in_gp = icmp ult i32 %gp_offset, 41
  br i1 %fits_in_gp, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %sw.bb
  %10 = getelementptr inbounds [1 x %struct.__va_list_tag]* %9, i64 0, i64 0, i32 3
  %reg_save_area = load i8** %10, align 8
  %11 = sext i32 %gp_offset to i64
  %12 = getelementptr i8* %reg_save_area, i64 %11
  %13 = add i32 %gp_offset, 8
  store i32 %13, i32* %gp_offset_p, align 4
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %sw.bb
  %overflow_arg_area_p = getelementptr inbounds [1 x %struct.__va_list_tag]* %9, i64 0, i64 0, i32 2
  %overflow_arg_area = load i8** %overflow_arg_area_p, align 8
  %overflow_arg_area.next = getelementptr i8* %overflow_arg_area, i64 8
  store i8* %overflow_arg_area.next, i8** %overflow_arg_area_p, align 8
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %vaarg.addr.in = phi i8* [ %12, %vaarg.in_reg ], [ %overflow_arg_area, %vaarg.in_mem ]
  %vaarg.addr = bitcast i8* %vaarg.addr.in to i32*
  %14 = load i32* %vaarg.addr, align 4
  %15 = load i32* %ideal_maximum_length.i.i270, align 4, !tbaa !16
  %cmp.i.i271 = icmp sgt i32 %15, 0
  br i1 %cmp.i.i271, label %land.lhs.true.i276, label %if.end.i291

land.lhs.true.i276:                               ; preds = %vaarg.end
  %16 = load i32* %maximum_length.i.i272, align 4, !tbaa !18
  %17 = load i32* %line_length.i14.i273, align 4, !tbaa !25
  %sub.i.i274 = sub nsw i32 %16, %17
  %cmp.i275 = icmp slt i32 %sub.i.i274, 1
  br i1 %cmp.i275, label %if.then.i281, label %if.end.i291

if.then.i281:                                     ; preds = %land.lhs.true.i276
  %18 = load i8** %next_free.i.i277, align 8, !tbaa !23
  %add.ptr.i.i278 = getelementptr inbounds i8* %18, i64 1
  %19 = load i8** %chunk_limit.i.i279, align 8, !tbaa !24
  %cmp.i13.i280 = icmp ugt i8* %add.ptr.i.i278, %19
  br i1 %cmp.i13.i280, label %if.then.i.i284, label %output_add_newline.exit.i286

if.then.i.i284:                                   ; preds = %if.then.i281
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i.i282, i32 1) #2
  %.pre.i.i283 = load i8** %next_free.i.i277, align 8, !tbaa !23
  br label %output_add_newline.exit.i286

output_add_newline.exit.i286:                     ; preds = %if.then.i.i284, %if.then.i281
  %20 = phi i8* [ %.pre.i.i283, %if.then.i.i284 ], [ %18, %if.then.i281 ]
  %incdec.ptr.i.i285 = getelementptr inbounds i8* %20, i64 1
  store i8* %incdec.ptr.i.i285, i8** %next_free.i.i277, align 8, !tbaa !23
  store i8 10, i8* %20, align 1, !tbaa !10
  store i32 0, i32* %line_length.i14.i273, align 4, !tbaa !25
  br label %if.end.i291

if.end.i291:                                      ; preds = %output_add_newline.exit.i286, %land.lhs.true.i276, %vaarg.end
  %21 = load i8** %next_free.i.i277, align 8, !tbaa !23
  %add.ptr.i288 = getelementptr inbounds i8* %21, i64 1
  %22 = load i8** %chunk_limit.i.i279, align 8, !tbaa !24
  %cmp2.i290 = icmp ugt i8* %add.ptr.i288, %22
  br i1 %cmp2.i290, label %if.then3.i294, label %output_add_character.exit298

if.then3.i294:                                    ; preds = %if.end.i291
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i.i282, i32 1) #2
  %.pre.i293 = load i8** %next_free.i.i277, align 8, !tbaa !23
  br label %output_add_character.exit298

output_add_character.exit298:                     ; preds = %if.end.i291, %if.then3.i294
  %23 = phi i8* [ %.pre.i293, %if.then3.i294 ], [ %21, %if.end.i291 ]
  %conv.i = trunc i32 %14 to i8
  %incdec.ptr.i295 = getelementptr inbounds i8* %23, i64 1
  store i8* %incdec.ptr.i295, i8** %next_free.i.i277, align 8, !tbaa !23
  store i8 %conv.i, i8* %23, align 1, !tbaa !10
  %24 = load i32* %line_length.i14.i273, align 4, !tbaa !25
  %inc.i297 = add nsw i32 %24, 1
  store i32 %inc.i297, i32* %line_length.i14.i273, align 4, !tbaa !25
  br label %for.inc

sw.bb27:                                          ; preds = %if.end23, %if.end23
  %tobool28 = icmp eq i32 %long_integer.0, 0
  %25 = load [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !38
  %gp_offset_p32 = getelementptr inbounds [1 x %struct.__va_list_tag]* %25, i64 0, i64 0, i32 0
  %gp_offset33 = load i32* %gp_offset_p32, align 4
  %fits_in_gp34 = icmp ult i32 %gp_offset33, 41
  br i1 %tobool28, label %if.else, label %if.then29

if.then29:                                        ; preds = %sw.bb27
  br i1 %fits_in_gp34, label %vaarg.in_reg35, label %vaarg.in_mem37

vaarg.in_reg35:                                   ; preds = %if.then29
  %26 = getelementptr inbounds [1 x %struct.__va_list_tag]* %25, i64 0, i64 0, i32 3
  %reg_save_area36 = load i8** %26, align 8
  %27 = sext i32 %gp_offset33 to i64
  %28 = getelementptr i8* %reg_save_area36, i64 %27
  %29 = add i32 %gp_offset33, 8
  store i32 %29, i32* %gp_offset_p32, align 4
  br label %vaarg.end41

vaarg.in_mem37:                                   ; preds = %if.then29
  %overflow_arg_area_p38 = getelementptr inbounds [1 x %struct.__va_list_tag]* %25, i64 0, i64 0, i32 2
  %overflow_arg_area39 = load i8** %overflow_arg_area_p38, align 8
  %overflow_arg_area.next40 = getelementptr i8* %overflow_arg_area39, i64 8
  store i8* %overflow_arg_area.next40, i8** %overflow_arg_area_p38, align 8
  br label %vaarg.end41

vaarg.end41:                                      ; preds = %vaarg.in_mem37, %vaarg.in_reg35
  %vaarg.addr42.in = phi i8* [ %28, %vaarg.in_reg35 ], [ %overflow_arg_area39, %vaarg.in_mem37 ]
  %vaarg.addr42 = bitcast i8* %vaarg.addr42.in to i64*
  %30 = load i64* %vaarg.addr42, align 8
  %call.i300 = tail call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay.i301, i8* getelementptr inbounds ([4 x i8]* @.str34, i64 0, i64 0), i64 %30) #2
  tail call void @output_add_string(%struct.output_buffer* %buffer, i8* %arraydecay.i301) #2
  br label %for.inc

if.else:                                          ; preds = %sw.bb27
  br i1 %fits_in_gp34, label %vaarg.in_reg48, label %vaarg.in_mem50

vaarg.in_reg48:                                   ; preds = %if.else
  %31 = getelementptr inbounds [1 x %struct.__va_list_tag]* %25, i64 0, i64 0, i32 3
  %reg_save_area49 = load i8** %31, align 8
  %32 = sext i32 %gp_offset33 to i64
  %33 = getelementptr i8* %reg_save_area49, i64 %32
  %34 = add i32 %gp_offset33, 8
  store i32 %34, i32* %gp_offset_p32, align 4
  br label %vaarg.end54

vaarg.in_mem50:                                   ; preds = %if.else
  %overflow_arg_area_p51 = getelementptr inbounds [1 x %struct.__va_list_tag]* %25, i64 0, i64 0, i32 2
  %overflow_arg_area52 = load i8** %overflow_arg_area_p51, align 8
  %overflow_arg_area.next53 = getelementptr i8* %overflow_arg_area52, i64 8
  store i8* %overflow_arg_area.next53, i8** %overflow_arg_area_p51, align 8
  br label %vaarg.end54

vaarg.end54:                                      ; preds = %vaarg.in_mem50, %vaarg.in_reg48
  %vaarg.addr55.in = phi i8* [ %33, %vaarg.in_reg48 ], [ %overflow_arg_area52, %vaarg.in_mem50 ]
  %vaarg.addr55 = bitcast i8* %vaarg.addr55.in to i32*
  %35 = load i32* %vaarg.addr55, align 4
  %call.i302 = tail call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay.i301, i8* getelementptr inbounds ([3 x i8]* @.str, i64 0, i64 0), i32 %35) #2
  tail call void @output_add_string(%struct.output_buffer* %buffer, i8* %arraydecay.i301) #2
  br label %for.inc

sw.bb57:                                          ; preds = %if.end23
  %tobool58 = icmp eq i32 %long_integer.0, 0
  %36 = load [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !38
  %gp_offset_p62 = getelementptr inbounds [1 x %struct.__va_list_tag]* %36, i64 0, i64 0, i32 0
  %gp_offset63 = load i32* %gp_offset_p62, align 4
  %fits_in_gp64 = icmp ult i32 %gp_offset63, 41
  br i1 %tobool58, label %if.else73, label %if.then59

if.then59:                                        ; preds = %sw.bb57
  br i1 %fits_in_gp64, label %vaarg.in_reg65, label %vaarg.in_mem67

vaarg.in_reg65:                                   ; preds = %if.then59
  %37 = getelementptr inbounds [1 x %struct.__va_list_tag]* %36, i64 0, i64 0, i32 3
  %reg_save_area66 = load i8** %37, align 8
  %38 = sext i32 %gp_offset63 to i64
  %39 = getelementptr i8* %reg_save_area66, i64 %38
  %40 = add i32 %gp_offset63, 8
  store i32 %40, i32* %gp_offset_p62, align 4
  br label %vaarg.end71

vaarg.in_mem67:                                   ; preds = %if.then59
  %overflow_arg_area_p68 = getelementptr inbounds [1 x %struct.__va_list_tag]* %36, i64 0, i64 0, i32 2
  %overflow_arg_area69 = load i8** %overflow_arg_area_p68, align 8
  %overflow_arg_area.next70 = getelementptr i8* %overflow_arg_area69, i64 8
  store i8* %overflow_arg_area.next70, i8** %overflow_arg_area_p68, align 8
  br label %vaarg.end71

vaarg.end71:                                      ; preds = %vaarg.in_mem67, %vaarg.in_reg65
  %vaarg.addr72.in = phi i8* [ %39, %vaarg.in_reg65 ], [ %overflow_arg_area69, %vaarg.in_mem67 ]
  %vaarg.addr72 = bitcast i8* %vaarg.addr72.in to i64*
  %41 = load i64* %vaarg.addr72, align 8
  %call.i304 = tail call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay.i301, i8* getelementptr inbounds ([4 x i8]* @.str33, i64 0, i64 0), i64 %41) #2
  tail call void @output_add_string(%struct.output_buffer* %buffer, i8* %arraydecay.i301) #2
  br label %for.inc

if.else73:                                        ; preds = %sw.bb57
  br i1 %fits_in_gp64, label %vaarg.in_reg79, label %vaarg.in_mem81

vaarg.in_reg79:                                   ; preds = %if.else73
  %42 = getelementptr inbounds [1 x %struct.__va_list_tag]* %36, i64 0, i64 0, i32 3
  %reg_save_area80 = load i8** %42, align 8
  %43 = sext i32 %gp_offset63 to i64
  %44 = getelementptr i8* %reg_save_area80, i64 %43
  %45 = add i32 %gp_offset63, 8
  store i32 %45, i32* %gp_offset_p62, align 4
  br label %vaarg.end85

vaarg.in_mem81:                                   ; preds = %if.else73
  %overflow_arg_area_p82 = getelementptr inbounds [1 x %struct.__va_list_tag]* %36, i64 0, i64 0, i32 2
  %overflow_arg_area83 = load i8** %overflow_arg_area_p82, align 8
  %overflow_arg_area.next84 = getelementptr i8* %overflow_arg_area83, i64 8
  store i8* %overflow_arg_area.next84, i8** %overflow_arg_area_p82, align 8
  br label %vaarg.end85

vaarg.end85:                                      ; preds = %vaarg.in_mem81, %vaarg.in_reg79
  %vaarg.addr86.in = phi i8* [ %44, %vaarg.in_reg79 ], [ %overflow_arg_area83, %vaarg.in_mem81 ]
  %vaarg.addr86 = bitcast i8* %vaarg.addr86.in to i32*
  %46 = load i32* %vaarg.addr86, align 4
  %call.i306 = tail call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay.i301, i8* getelementptr inbounds ([3 x i8]* @.str32, i64 0, i64 0), i32 %46) #2
  tail call void @output_add_string(%struct.output_buffer* %buffer, i8* %arraydecay.i301) #2
  br label %for.inc

sw.bb88:                                          ; preds = %if.end23
  %47 = load [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !38
  %gp_offset_p91 = getelementptr inbounds [1 x %struct.__va_list_tag]* %47, i64 0, i64 0, i32 0
  %gp_offset92 = load i32* %gp_offset_p91, align 4
  %fits_in_gp93 = icmp ult i32 %gp_offset92, 41
  br i1 %fits_in_gp93, label %vaarg.in_reg94, label %vaarg.in_mem96

vaarg.in_reg94:                                   ; preds = %sw.bb88
  %48 = getelementptr inbounds [1 x %struct.__va_list_tag]* %47, i64 0, i64 0, i32 3
  %reg_save_area95 = load i8** %48, align 8
  %49 = sext i32 %gp_offset92 to i64
  %50 = getelementptr i8* %reg_save_area95, i64 %49
  %51 = add i32 %gp_offset92, 8
  store i32 %51, i32* %gp_offset_p91, align 4
  br label %vaarg.end100

vaarg.in_mem96:                                   ; preds = %sw.bb88
  %overflow_arg_area_p97 = getelementptr inbounds [1 x %struct.__va_list_tag]* %47, i64 0, i64 0, i32 2
  %overflow_arg_area98 = load i8** %overflow_arg_area_p97, align 8
  %overflow_arg_area.next99 = getelementptr i8* %overflow_arg_area98, i64 8
  store i8* %overflow_arg_area.next99, i8** %overflow_arg_area_p97, align 8
  br label %vaarg.end100

vaarg.end100:                                     ; preds = %vaarg.in_mem96, %vaarg.in_reg94
  %vaarg.addr101.in = phi i8* [ %50, %vaarg.in_reg94 ], [ %overflow_arg_area98, %vaarg.in_mem96 ]
  %vaarg.addr101 = bitcast i8* %vaarg.addr101.in to i8**
  %52 = load i8** %vaarg.addr101, align 8
  tail call void @output_add_string(%struct.output_buffer* %buffer, i8* %52)
  br label %for.inc

sw.bb102:                                         ; preds = %if.end23
  %tobool103 = icmp eq i32 %long_integer.0, 0
  %53 = load [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !38
  %gp_offset_p107 = getelementptr inbounds [1 x %struct.__va_list_tag]* %53, i64 0, i64 0, i32 0
  %gp_offset108 = load i32* %gp_offset_p107, align 4
  %fits_in_gp109 = icmp ult i32 %gp_offset108, 41
  br i1 %tobool103, label %if.else118, label %if.then104

if.then104:                                       ; preds = %sw.bb102
  br i1 %fits_in_gp109, label %vaarg.in_reg110, label %vaarg.in_mem112

vaarg.in_reg110:                                  ; preds = %if.then104
  %54 = getelementptr inbounds [1 x %struct.__va_list_tag]* %53, i64 0, i64 0, i32 3
  %reg_save_area111 = load i8** %54, align 8
  %55 = sext i32 %gp_offset108 to i64
  %56 = getelementptr i8* %reg_save_area111, i64 %55
  %57 = add i32 %gp_offset108, 8
  store i32 %57, i32* %gp_offset_p107, align 4
  br label %vaarg.end116

vaarg.in_mem112:                                  ; preds = %if.then104
  %overflow_arg_area_p113 = getelementptr inbounds [1 x %struct.__va_list_tag]* %53, i64 0, i64 0, i32 2
  %overflow_arg_area114 = load i8** %overflow_arg_area_p113, align 8
  %overflow_arg_area.next115 = getelementptr i8* %overflow_arg_area114, i64 8
  store i8* %overflow_arg_area.next115, i8** %overflow_arg_area_p113, align 8
  br label %vaarg.end116

vaarg.end116:                                     ; preds = %vaarg.in_mem112, %vaarg.in_reg110
  %vaarg.addr117.in = phi i8* [ %56, %vaarg.in_reg110 ], [ %overflow_arg_area114, %vaarg.in_mem112 ]
  %vaarg.addr117 = bitcast i8* %vaarg.addr117.in to i64*
  %58 = load i64* %vaarg.addr117, align 8
  %call.i308 = tail call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay.i301, i8* getelementptr inbounds ([4 x i8]* @.str31, i64 0, i64 0), i64 %58) #2
  tail call void @output_add_string(%struct.output_buffer* %buffer, i8* %arraydecay.i301) #2
  br label %for.inc

if.else118:                                       ; preds = %sw.bb102
  br i1 %fits_in_gp109, label %vaarg.in_reg124, label %vaarg.in_mem126

vaarg.in_reg124:                                  ; preds = %if.else118
  %59 = getelementptr inbounds [1 x %struct.__va_list_tag]* %53, i64 0, i64 0, i32 3
  %reg_save_area125 = load i8** %59, align 8
  %60 = sext i32 %gp_offset108 to i64
  %61 = getelementptr i8* %reg_save_area125, i64 %60
  %62 = add i32 %gp_offset108, 8
  store i32 %62, i32* %gp_offset_p107, align 4
  br label %vaarg.end130

vaarg.in_mem126:                                  ; preds = %if.else118
  %overflow_arg_area_p127 = getelementptr inbounds [1 x %struct.__va_list_tag]* %53, i64 0, i64 0, i32 2
  %overflow_arg_area128 = load i8** %overflow_arg_area_p127, align 8
  %overflow_arg_area.next129 = getelementptr i8* %overflow_arg_area128, i64 8
  store i8* %overflow_arg_area.next129, i8** %overflow_arg_area_p127, align 8
  br label %vaarg.end130

vaarg.end130:                                     ; preds = %vaarg.in_mem126, %vaarg.in_reg124
  %vaarg.addr131.in = phi i8* [ %61, %vaarg.in_reg124 ], [ %overflow_arg_area128, %vaarg.in_mem126 ]
  %vaarg.addr131 = bitcast i8* %vaarg.addr131.in to i32*
  %63 = load i32* %vaarg.addr131, align 4
  %call.i310 = tail call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay.i301, i8* getelementptr inbounds ([3 x i8]* @.str30, i64 0, i64 0), i32 %63) #2
  tail call void @output_add_string(%struct.output_buffer* %buffer, i8* %arraydecay.i301) #2
  br label %for.inc

sw.bb133:                                         ; preds = %if.end23
  %tobool134 = icmp eq i32 %long_integer.0, 0
  %64 = load [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !38
  %gp_offset_p138 = getelementptr inbounds [1 x %struct.__va_list_tag]* %64, i64 0, i64 0, i32 0
  %gp_offset139 = load i32* %gp_offset_p138, align 4
  %fits_in_gp140 = icmp ult i32 %gp_offset139, 41
  br i1 %tobool134, label %if.else149, label %if.then135

if.then135:                                       ; preds = %sw.bb133
  br i1 %fits_in_gp140, label %vaarg.in_reg141, label %vaarg.in_mem143

vaarg.in_reg141:                                  ; preds = %if.then135
  %65 = getelementptr inbounds [1 x %struct.__va_list_tag]* %64, i64 0, i64 0, i32 3
  %reg_save_area142 = load i8** %65, align 8
  %66 = sext i32 %gp_offset139 to i64
  %67 = getelementptr i8* %reg_save_area142, i64 %66
  %68 = add i32 %gp_offset139, 8
  store i32 %68, i32* %gp_offset_p138, align 4
  br label %vaarg.end147

vaarg.in_mem143:                                  ; preds = %if.then135
  %overflow_arg_area_p144 = getelementptr inbounds [1 x %struct.__va_list_tag]* %64, i64 0, i64 0, i32 2
  %overflow_arg_area145 = load i8** %overflow_arg_area_p144, align 8
  %overflow_arg_area.next146 = getelementptr i8* %overflow_arg_area145, i64 8
  store i8* %overflow_arg_area.next146, i8** %overflow_arg_area_p144, align 8
  br label %vaarg.end147

vaarg.end147:                                     ; preds = %vaarg.in_mem143, %vaarg.in_reg141
  %vaarg.addr148.in = phi i8* [ %67, %vaarg.in_reg141 ], [ %overflow_arg_area145, %vaarg.in_mem143 ]
  %vaarg.addr148 = bitcast i8* %vaarg.addr148.in to i64*
  %69 = load i64* %vaarg.addr148, align 8
  %call.i269 = tail call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay.i301, i8* getelementptr inbounds ([4 x i8]* @.str29, i64 0, i64 0), i64 %69) #2
  tail call void @output_add_string(%struct.output_buffer* %buffer, i8* %arraydecay.i301) #2
  br label %for.inc

if.else149:                                       ; preds = %sw.bb133
  br i1 %fits_in_gp140, label %vaarg.in_reg155, label %vaarg.in_mem157

vaarg.in_reg155:                                  ; preds = %if.else149
  %70 = getelementptr inbounds [1 x %struct.__va_list_tag]* %64, i64 0, i64 0, i32 3
  %reg_save_area156 = load i8** %70, align 8
  %71 = sext i32 %gp_offset139 to i64
  %72 = getelementptr i8* %reg_save_area156, i64 %71
  %73 = add i32 %gp_offset139, 8
  store i32 %73, i32* %gp_offset_p138, align 4
  br label %vaarg.end161

vaarg.in_mem157:                                  ; preds = %if.else149
  %overflow_arg_area_p158 = getelementptr inbounds [1 x %struct.__va_list_tag]* %64, i64 0, i64 0, i32 2
  %overflow_arg_area159 = load i8** %overflow_arg_area_p158, align 8
  %overflow_arg_area.next160 = getelementptr i8* %overflow_arg_area159, i64 8
  store i8* %overflow_arg_area.next160, i8** %overflow_arg_area_p158, align 8
  br label %vaarg.end161

vaarg.end161:                                     ; preds = %vaarg.in_mem157, %vaarg.in_reg155
  %vaarg.addr162.in = phi i8* [ %72, %vaarg.in_reg155 ], [ %overflow_arg_area159, %vaarg.in_mem157 ]
  %vaarg.addr162 = bitcast i8* %vaarg.addr162.in to i32*
  %74 = load i32* %vaarg.addr162, align 4
  %call.i = tail call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay.i301, i8* getelementptr inbounds ([3 x i8]* @.str28, i64 0, i64 0), i32 %74) #2
  tail call void @output_add_string(%struct.output_buffer* %buffer, i8* %arraydecay.i301) #2
  br label %for.inc

sw.bb164:                                         ; preds = %if.end23
  %75 = load i32* %ideal_maximum_length.i.i270, align 4, !tbaa !16
  %cmp.i.i256 = icmp sgt i32 %75, 0
  br i1 %cmp.i.i256, label %land.lhs.true.i, label %if.end.i

land.lhs.true.i:                                  ; preds = %sw.bb164
  %76 = load i32* %maximum_length.i.i272, align 4, !tbaa !18
  %77 = load i32* %line_length.i14.i273, align 4, !tbaa !25
  %sub.i.i = sub nsw i32 %76, %77
  %cmp.i257 = icmp slt i32 %sub.i.i, 1
  br i1 %cmp.i257, label %if.then.i261, label %if.end.i

if.then.i261:                                     ; preds = %land.lhs.true.i
  %78 = load i8** %next_free.i.i277, align 8, !tbaa !23
  %add.ptr.i.i259 = getelementptr inbounds i8* %78, i64 1
  %79 = load i8** %chunk_limit.i.i279, align 8, !tbaa !24
  %cmp.i13.i = icmp ugt i8* %add.ptr.i.i259, %79
  br i1 %cmp.i13.i, label %if.then.i.i264, label %output_add_newline.exit.i

if.then.i.i264:                                   ; preds = %if.then.i261
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i.i282, i32 1) #2
  %.pre.i.i263 = load i8** %next_free.i.i277, align 8, !tbaa !23
  br label %output_add_newline.exit.i

output_add_newline.exit.i:                        ; preds = %if.then.i.i264, %if.then.i261
  %80 = phi i8* [ %.pre.i.i263, %if.then.i.i264 ], [ %78, %if.then.i261 ]
  %incdec.ptr.i.i = getelementptr inbounds i8* %80, i64 1
  store i8* %incdec.ptr.i.i, i8** %next_free.i.i277, align 8, !tbaa !23
  store i8 10, i8* %80, align 1, !tbaa !10
  store i32 0, i32* %line_length.i14.i273, align 4, !tbaa !25
  br label %if.end.i

if.end.i:                                         ; preds = %output_add_newline.exit.i, %land.lhs.true.i, %sw.bb164
  %81 = load i8** %next_free.i.i277, align 8, !tbaa !23
  %add.ptr.i = getelementptr inbounds i8* %81, i64 1
  %82 = load i8** %chunk_limit.i.i279, align 8, !tbaa !24
  %cmp2.i265 = icmp ugt i8* %add.ptr.i, %82
  br i1 %cmp2.i265, label %if.then3.i, label %output_add_character.exit

if.then3.i:                                       ; preds = %if.end.i
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i.i282, i32 1) #2
  %.pre.i = load i8** %next_free.i.i277, align 8, !tbaa !23
  br label %output_add_character.exit

output_add_character.exit:                        ; preds = %if.end.i, %if.then3.i
  %83 = phi i8* [ %.pre.i, %if.then3.i ], [ %81, %if.end.i ]
  %incdec.ptr.i266 = getelementptr inbounds i8* %83, i64 1
  store i8* %incdec.ptr.i266, i8** %next_free.i.i277, align 8, !tbaa !23
  store i8 37, i8* %83, align 1, !tbaa !10
  %84 = load i32* %line_length.i14.i273, align 4, !tbaa !25
  %inc.i = add nsw i32 %84, 1
  store i32 %inc.i, i32* %line_length.i14.i273, align 4, !tbaa !25
  br label %for.inc

sw.bb165:                                         ; preds = %if.end23
  %incdec.ptr168 = getelementptr inbounds i8* %8, i64 1
  store i8* %incdec.ptr168, i8** %cursor, align 8, !tbaa !37
  %85 = load i8* %incdec.ptr168, align 1, !tbaa !10
  %cmp170 = icmp eq i8 %85, 42
  br i1 %cmp170, label %if.else173, label %if.then172

if.then172:                                       ; preds = %sw.bb165
  tail call void @fancy_abort(i8* getelementptr inbounds ([13 x i8]* @.str26, i64 0, i64 0), i32 723, i8* getelementptr inbounds ([14 x i8]* @__FUNCTION__.output_format, i64 0, i64 0)) #11
  unreachable

if.else173:                                       ; preds = %sw.bb165
  %incdec.ptr176 = getelementptr inbounds i8* %8, i64 2
  store i8* %incdec.ptr176, i8** %cursor, align 8, !tbaa !37
  %86 = load i8* %incdec.ptr176, align 1, !tbaa !10
  %cmp178 = icmp eq i8 %86, 115
  br i1 %cmp178, label %if.end182, label %if.then180

if.then180:                                       ; preds = %if.else173
  tail call void @fancy_abort(i8* getelementptr inbounds ([13 x i8]* @.str26, i64 0, i64 0), i32 725, i8* getelementptr inbounds ([14 x i8]* @__FUNCTION__.output_format, i64 0, i64 0)) #11
  unreachable

if.end182:                                        ; preds = %if.else173
  %87 = load [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !38
  %gp_offset_p185 = getelementptr inbounds [1 x %struct.__va_list_tag]* %87, i64 0, i64 0, i32 0
  %gp_offset186 = load i32* %gp_offset_p185, align 4
  %fits_in_gp187 = icmp ult i32 %gp_offset186, 41
  br i1 %fits_in_gp187, label %vaarg.in_reg188, label %vaarg.in_mem190

vaarg.in_reg188:                                  ; preds = %if.end182
  %88 = getelementptr inbounds [1 x %struct.__va_list_tag]* %87, i64 0, i64 0, i32 3
  %reg_save_area189 = load i8** %88, align 8
  %89 = sext i32 %gp_offset186 to i64
  %90 = getelementptr i8* %reg_save_area189, i64 %89
  %91 = add i32 %gp_offset186, 8
  store i32 %91, i32* %gp_offset_p185, align 4
  br label %vaarg.end194

vaarg.in_mem190:                                  ; preds = %if.end182
  %overflow_arg_area_p191 = getelementptr inbounds [1 x %struct.__va_list_tag]* %87, i64 0, i64 0, i32 2
  %overflow_arg_area192 = load i8** %overflow_arg_area_p191, align 8
  %overflow_arg_area.next193 = getelementptr i8* %overflow_arg_area192, i64 8
  store i8* %overflow_arg_area.next193, i8** %overflow_arg_area_p191, align 8
  br label %vaarg.end194

vaarg.end194:                                     ; preds = %vaarg.in_mem190, %vaarg.in_reg188
  %vaarg.addr195.in = phi i8* [ %90, %vaarg.in_reg188 ], [ %overflow_arg_area192, %vaarg.in_mem190 ]
  %vaarg.addr195 = bitcast i8* %vaarg.addr195.in to i32*
  %92 = load i32* %vaarg.addr195, align 4
  %93 = load [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !38
  %gp_offset_p198 = getelementptr inbounds [1 x %struct.__va_list_tag]* %93, i64 0, i64 0, i32 0
  %gp_offset199 = load i32* %gp_offset_p198, align 4
  %fits_in_gp200 = icmp ult i32 %gp_offset199, 41
  br i1 %fits_in_gp200, label %vaarg.in_reg201, label %vaarg.in_mem203

vaarg.in_reg201:                                  ; preds = %vaarg.end194
  %94 = getelementptr inbounds [1 x %struct.__va_list_tag]* %93, i64 0, i64 0, i32 3
  %reg_save_area202 = load i8** %94, align 8
  %95 = sext i32 %gp_offset199 to i64
  %96 = getelementptr i8* %reg_save_area202, i64 %95
  %97 = add i32 %gp_offset199, 8
  store i32 %97, i32* %gp_offset_p198, align 4
  br label %vaarg.end207

vaarg.in_mem203:                                  ; preds = %vaarg.end194
  %overflow_arg_area_p204 = getelementptr inbounds [1 x %struct.__va_list_tag]* %93, i64 0, i64 0, i32 2
  %overflow_arg_area205 = load i8** %overflow_arg_area_p204, align 8
  %overflow_arg_area.next206 = getelementptr i8* %overflow_arg_area205, i64 8
  store i8* %overflow_arg_area.next206, i8** %overflow_arg_area_p204, align 8
  br label %vaarg.end207

vaarg.end207:                                     ; preds = %vaarg.in_mem203, %vaarg.in_reg201
  %vaarg.addr208.in = phi i8* [ %96, %vaarg.in_reg201 ], [ %overflow_arg_area205, %vaarg.in_mem203 ]
  %vaarg.addr208 = bitcast i8* %vaarg.addr208.in to i8**
  %98 = load i8** %vaarg.addr208, align 8
  %idx.ext = sext i32 %92 to i64
  %add.ptr = getelementptr inbounds i8* %98, i64 %idx.ext
  %99 = load i32* %line_length.i14.i273, align 4, !tbaa !25
  %cmp.i = icmp eq i32 %99, 0
  br i1 %cmp.i, label %if.then.i, label %if.end5.i

if.then.i:                                        ; preds = %vaarg.end207
  tail call void @output_emit_prefix(%struct.output_buffer* %buffer) #2
  %100 = load i32* %ideal_maximum_length.i.i270, align 4, !tbaa !16
  %cmp.i.i = icmp slt i32 %100, 1
  %cmp216.i = icmp eq i32 %92, 0
  %or.cond.i = or i1 %cmp.i.i, %cmp216.i
  br i1 %or.cond.i, label %if.end5.i, label %land.rhs.i

while.cond.i:                                     ; preds = %land.rhs.i
  %cmp2.i = icmp eq i8* %incdec.ptr.i, %add.ptr
  br i1 %cmp2.i, label %if.end5.i, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then.i, %while.cond.i
  %start.addr.017.i = phi i8* [ %incdec.ptr.i, %while.cond.i ], [ %98, %if.then.i ]
  %101 = load i8* %start.addr.017.i, align 1, !tbaa !10
  %cmp3.i = icmp eq i8 %101, 32
  %incdec.ptr.i = getelementptr inbounds i8* %start.addr.017.i, i64 1
  br i1 %cmp3.i, label %while.cond.i, label %if.end5.i

if.end5.i:                                        ; preds = %land.rhs.i, %while.cond.i, %if.then.i, %vaarg.end207
  %start.addr.1.i = phi i8* [ %98, %if.then.i ], [ %98, %vaarg.end207 ], [ %start.addr.017.i, %land.rhs.i ], [ %add.ptr, %while.cond.i ]
  %sub.ptr.lhs.cast.i = ptrtoint i8* %add.ptr to i64
  %sub.ptr.rhs.cast.i = ptrtoint i8* %start.addr.1.i to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv6.i = trunc i64 %sub.ptr.sub.i to i32
  %102 = load i8** %next_free.i.i277, align 8, !tbaa !23
  %sext.i = shl i64 %sub.ptr.sub.i, 32
  %idx.ext.i.i = ashr exact i64 %sext.i, 32
  %add.ptr.i.i = getelementptr inbounds i8* %102, i64 %idx.ext.i.i
  %103 = load i8** %chunk_limit.i.i279, align 8, !tbaa !24
  %cmp.i15.i = icmp ugt i8* %add.ptr.i.i, %103
  br i1 %cmp.i15.i, label %if.then.i.i, label %output_append.exit

if.then.i.i:                                      ; preds = %if.end5.i
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i.i282, i32 %conv6.i) #2
  %.pre.i.i = load i8** %next_free.i.i277, align 8, !tbaa !23
  br label %output_append.exit

output_append.exit:                               ; preds = %if.end5.i, %if.then.i.i
  %104 = phi i8* [ %.pre.i.i, %if.then.i.i ], [ %102, %if.end5.i ]
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %104, i8* %start.addr.1.i, i64 %idx.ext.i.i, i32 1, i1 false) #2
  %105 = load i8** %next_free.i.i277, align 8, !tbaa !23
  %add.ptr4.i.i = getelementptr inbounds i8* %105, i64 %idx.ext.i.i
  store i8* %add.ptr4.i.i, i8** %next_free.i.i277, align 8, !tbaa !23
  %106 = load i32* %line_length.i14.i273, align 4, !tbaa !25
  %add.i.i = add nsw i32 %106, %conv6.i
  store i32 %add.i.i, i32* %line_length.i14.i273, align 4, !tbaa !25
  br label %for.inc

sw.default:                                       ; preds = %if.end23
  %107 = load i32 (%struct.output_buffer*)** %format_decoder, align 8, !tbaa !39
  %tobool209 = icmp eq i32 (%struct.output_buffer*)* %107, null
  br i1 %tobool209, label %if.then212, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.default
  %call = tail call i32 %107(%struct.output_buffer* %buffer) #2
  %tobool211 = icmp eq i32 %call, 0
  br i1 %tobool211, label %if.then212, label %for.inc

if.then212:                                       ; preds = %lor.lhs.false, %sw.default
  tail call void @fancy_abort(i8* getelementptr inbounds ([13 x i8]* @.str26, i64 0, i64 0), i32 737, i8* getelementptr inbounds ([14 x i8]* @__FUNCTION__.output_format, i64 0, i64 0)) #11
  unreachable

for.inc:                                          ; preds = %lor.lhs.false, %output_add_character.exit298, %vaarg.end100, %output_add_character.exit, %output_append.exit, %vaarg.end54, %vaarg.end41, %vaarg.end85, %vaarg.end71, %vaarg.end130, %vaarg.end116, %vaarg.end161, %vaarg.end147
  %108 = load i8** %cursor, align 8, !tbaa !37
  %incdec.ptr216 = getelementptr inbounds i8* %108, i64 1
  store i8* %incdec.ptr216, i8** %cursor, align 8, !tbaa !37
  %109 = load i8* %incdec.ptr216, align 1, !tbaa !10
  %tobool = icmp eq i8 %109, 0
  br i1 %tobool, label %for.end, label %while.cond.preheader

for.end:                                          ; preds = %for.inc, %while.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @diagnostic_finish(%struct.output_buffer* %buffer) #0 {
entry:
  %next_free.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %0 = load i8** %next_free.i.i, align 8, !tbaa !23
  %add.ptr.i.i = getelementptr inbounds i8* %0, i64 1
  %chunk_limit.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %1 = load i8** %chunk_limit.i.i, align 8, !tbaa !24
  %cmp.i.i = icmp ugt i8* %add.ptr.i.i, %1
  %obstack.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  br i1 %cmp.i.i, label %if.then.i.i, label %output_finalize_message.exit.i

if.then.i.i:                                      ; preds = %entry
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i.i, i32 1) #2
  %.pre.i.i = load i8** %next_free.i.i, align 8, !tbaa !23
  br label %output_finalize_message.exit.i

output_finalize_message.exit.i:                   ; preds = %if.then.i.i, %entry
  %2 = phi i8* [ %.pre.i.i, %if.then.i.i ], [ %0, %entry ]
  %incdec.ptr.i.i = getelementptr inbounds i8* %2, i64 1
  store i8* %incdec.ptr.i.i, i8** %next_free.i.i, align 8, !tbaa !23
  store i8 0, i8* %2, align 1, !tbaa !10
  %object_base.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 2
  %3 = load i8** %object_base.i.i, align 8, !tbaa !26
  %stream.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 1
  %4 = load %struct._IO_FILE** %stream.i, align 8, !tbaa !27
  %call1.i = tail call i32 @fputs(i8* %3, %struct._IO_FILE* %4) #2
  %5 = load i8** %object_base.i.i, align 8, !tbaa !26
  %chunk.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 1
  %6 = load %struct._obstack_chunk** %chunk.i.i, align 8, !tbaa !28
  %7 = bitcast %struct._obstack_chunk* %6 to i8*
  %cmp.i6.i = icmp ugt i8* %5, %7
  br i1 %cmp.i6.i, label %land.lhs.true.i.i, label %if.else.i.i

land.lhs.true.i.i:                                ; preds = %output_finalize_message.exit.i
  %8 = load i8** %chunk_limit.i.i, align 8, !tbaa !24
  %cmp2.i.i = icmp ult i8* %5, %8
  br i1 %cmp2.i.i, label %if.then.i9.i, label %if.else.i.i

if.then.i9.i:                                     ; preds = %land.lhs.true.i.i
  store i8* %5, i8** %object_base.i.i, align 8, !tbaa !26
  store i8* %5, i8** %next_free.i.i, align 8, !tbaa !23
  br label %output_buffer_to_stream.exit

if.else.i.i:                                      ; preds = %land.lhs.true.i.i, %output_finalize_message.exit.i
  tail call void @obstack_free(%struct.obstack* %obstack.i.i, i8* %5) #2
  br label %output_buffer_to_stream.exit

output_buffer_to_stream.exit:                     ; preds = %if.then.i9.i, %if.else.i.i
  %line_length.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  store i32 0, i32* %line_length.i.i, align 4, !tbaa !25
  %cursor.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 7
  %emitted_prefix_p.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 4
  store i8 0, i8* %emitted_prefix_p.i, align 1, !tbaa !19
  %indent_skip.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 3
  store i32 0, i32* %indent_skip.i, align 4, !tbaa !20
  %9 = bitcast i8** %cursor.i to i8*
  tail call void @llvm.memset.p0i8.i64(i8* %9, i8 0, i64 16, i32 8, i1 false) #2
  %10 = load %struct._IO_FILE** %stream.i, align 8, !tbaa !27
  %call = tail call i32 @fputc(i32 10, %struct._IO_FILE* %10) #2
  %11 = load %struct._IO_FILE** %stream.i, align 8, !tbaa !27
  %call2 = tail call i32 @fflush(%struct._IO_FILE* %11) #2
  ret void
}

; Function Attrs: noreturn
declare void @exit(i32) #8

; Function Attrs: nounwind uwtable
define void @pedwarn(i8* %msgid, ...) #0 {
entry:
  %dc = alloca %struct.diagnostic_context, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %0 = bitcast %struct.diagnostic_context* %dc to i8*
  call void @llvm.lifetime.start(i64 376, i8* %0) #2
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = load i8** @input_filename, align 8, !tbaa !1
  %2 = load i32* @lineno, align 4, !tbaa !6
  %3 = load i32* @flag_pedantic_errors, align 4, !tbaa !6
  %lnot = icmp eq i32 %3, 0
  %lnot.ext = zext i1 %lnot to i32
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 376, i32 8, i1 false) #2
  %message.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 1
  store i8* %msgid, i8** %message.i, align 8, !tbaa !40
  %args_ptr1.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 2
  store [1 x %struct.__va_list_tag]* %ap, [1 x %struct.__va_list_tag]** %args_ptr1.i, align 8, !tbaa !41
  %file2.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 3
  store i8* %1, i8** %file2.i, align 8, !tbaa !32
  %line3.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 4
  store i32 %2, i32* %line3.i, align 8, !tbaa !33
  %warn4.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 5
  store i32 %lnot.ext, i32* %warn4.i, align 4, !tbaa !34
  %4 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %begin_diagnostic.i = getelementptr inbounds %struct.diagnostic_context* %4, i64 0, i32 6
  %begin_diagnostic5.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 6
  %5 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  %6 = load <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %5, align 8, !tbaa !1
  %7 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic5.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  store <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*> %6, <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %7, align 8, !tbaa !1
  call void @report_diagnostic(%struct.diagnostic_context* %dc)
  call void @llvm.va_end(i8* %arraydecay1)
  call void @llvm.lifetime.end(i64 376, i8* %0) #2
  ret void
}

; Function Attrs: nounwind uwtable
define void @set_diagnostic_context(%struct.diagnostic_context* nocapture %dc, i8* %msgid, [1 x %struct.__va_list_tag]* %args_ptr, i8* %file, i32 %line, i32 %warn) #0 {
entry:
  %0 = bitcast %struct.diagnostic_context* %dc to i8*
  tail call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 376, i32 8, i1 false)
  %message = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 1
  store i8* %msgid, i8** %message, align 8, !tbaa !40
  %args_ptr1 = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 2
  store [1 x %struct.__va_list_tag]* %args_ptr, [1 x %struct.__va_list_tag]** %args_ptr1, align 8, !tbaa !41
  %file2 = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 3
  store i8* %file, i8** %file2, align 8, !tbaa !32
  %line3 = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 4
  store i32 %line, i32* %line3, align 4, !tbaa !33
  %warn4 = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 5
  store i32 %warn, i32* %warn4, align 4, !tbaa !34
  %1 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %begin_diagnostic = getelementptr inbounds %struct.diagnostic_context* %1, i64 0, i32 6
  %2 = load void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic, align 8, !tbaa !29
  %begin_diagnostic5 = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 6
  store void (%struct.output_buffer*, %struct.diagnostic_context*)* %2, void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic5, align 8, !tbaa !29
  %3 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %end_diagnostic = getelementptr inbounds %struct.diagnostic_context* %3, i64 0, i32 7
  %4 = load void (%struct.output_buffer*, %struct.diagnostic_context*)** %end_diagnostic, align 8, !tbaa !31
  %end_diagnostic6 = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 7
  store void (%struct.output_buffer*, %struct.diagnostic_context*)* %4, void (%struct.output_buffer*, %struct.diagnostic_context*)** %end_diagnostic6, align 8, !tbaa !31
  ret void
}

; Function Attrs: nounwind uwtable
define void @report_diagnostic(%struct.diagnostic_context* %dc) #0 {
entry:
  %os = alloca %struct.output_state, align 8
  %os.0..sroa_cast = bitcast %struct.output_state* %os to i8*
  call void @llvm.lifetime.start(i64 80, i8* %os.0..sroa_cast)
  %0 = load i32* @diagnostic_lock, align 4, !tbaa !6
  %inc = add nsw i32 %0, 1
  store i32 %inc, i32* @diagnostic_lock, align 4, !tbaa !6
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call fastcc void @error_recursion() #11
  unreachable

if.end:                                           ; preds = %entry
  %warn = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 5
  %1 = load i32* %warn, align 4, !tbaa !34
  %tobool.i = icmp eq i32 %1, 0
  br i1 %tobool.i, label %if.end14.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end
  %2 = load i32* @inhibit_warnings, align 4, !tbaa !6
  %tobool1.i = icmp eq i32 %2, 0
  br i1 %tobool1.i, label %land.lhs.true2.i, label %if.end6

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %3 = load i32* @in_system_header, align 4, !tbaa !6
  %tobool3.i = icmp eq i32 %3, 0
  %4 = load i32* @warn_system_headers, align 4
  %tobool5.i = icmp ne i32 %4, 0
  %or.cond.i = or i1 %tobool3.i, %tobool5.i
  br i1 %or.cond.i, label %if.end.i, label %if.end6

if.end.i:                                         ; preds = %land.lhs.true2.i
  %5 = load i32* @warnings_are_errors, align 4
  %tobool8.i = icmp eq i32 %5, 0
  br i1 %tobool8.i, label %if.then9.i, label %if.else.i

if.then9.i:                                       ; preds = %if.end.i
  %6 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %arrayidx.i = getelementptr inbounds %struct.diagnostic_context* %6, i64 0, i32 0, i32 0, i32 9, i64 4
  %7 = load i32* %arrayidx.i, align 4, !tbaa !6
  %inc.i = add nsw i32 %7, 1
  store i32 %inc.i, i32* %arrayidx.i, align 4, !tbaa !6
  br label %if.then2

if.else.i:                                        ; preds = %if.end.i
  %.b.i = load i1* @count_error.warning_message, align 1
  br i1 %.b.i, label %if.end14.i, label %if.then13.i

if.then13.i:                                      ; preds = %if.else.i
  %8 = load i8** @progname, align 8, !tbaa !1
  tail call void (i8*, ...)* @verbatim(i8* getelementptr inbounds ([38 x i8]* @.str5, i64 0, i64 0), i8* %8) #2
  store i1 true, i1* @count_error.warning_message, align 1
  br label %if.end14.i

if.end14.i:                                       ; preds = %if.end, %if.then13.i, %if.else.i
  %9 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %arrayidx17.i = getelementptr inbounds %struct.diagnostic_context* %9, i64 0, i32 0, i32 0, i32 9, i64 3
  %10 = load i32* %arrayidx17.i, align 4, !tbaa !6
  %inc18.i = add nsw i32 %10, 1
  store i32 %inc18.i, i32* %arrayidx17.i, align 4, !tbaa !6
  br label %if.then2

if.then2:                                         ; preds = %if.end14.i, %if.then9.i
  %11 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %12 = bitcast %struct.output_buffer* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %os.0..sroa_cast, i8* %12, i64 80, i32 8, i1 false), !tbaa.struct !5
  %message = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 1
  %13 = load i8** %message, align 8, !tbaa !40
  %cursor = getelementptr inbounds %struct.output_buffer* %11, i64 0, i32 0, i32 7
  store i8* %13, i8** %cursor, align 8, !tbaa !37
  %args_ptr = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 2
  %14 = load [1 x %struct.__va_list_tag]** %args_ptr, align 8, !tbaa !41
  %15 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %format_args = getelementptr inbounds %struct.output_buffer* %15, i64 0, i32 0, i32 8
  store [1 x %struct.__va_list_tag]* %14, [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !36
  %begin_diagnostic = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 6
  %16 = load void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic, align 8, !tbaa !29
  %17 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  tail call void %16(%struct.output_buffer* %17, %struct.diagnostic_context* %dc) #2
  %18 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  tail call fastcc void @output_format(%struct.output_buffer* %18)
  %end_diagnostic = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 7
  %19 = load void (%struct.output_buffer*, %struct.diagnostic_context*)** %end_diagnostic, align 8, !tbaa !31
  %20 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  tail call void %19(%struct.output_buffer* %20, %struct.diagnostic_context* %dc) #2
  %21 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %22 = getelementptr inbounds %struct.diagnostic_context* %21, i64 0, i32 0
  tail call fastcc void @diagnostic_finish(%struct.output_buffer* %22)
  %23 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %24 = bitcast %struct.output_buffer* %23 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %24, i8* %os.0..sroa_cast, i64 80, i32 8, i1 false), !tbaa.struct !5
  %.pre = load i32* @diagnostic_lock, align 4, !tbaa !6
  br label %if.end6

if.end6:                                          ; preds = %land.lhs.true2.i, %land.lhs.true.i, %if.then2
  %25 = phi i32 [ %inc, %land.lhs.true2.i ], [ %inc, %land.lhs.true.i ], [ %.pre, %if.then2 ]
  %dec = add nsw i32 %25, -1
  store i32 %dec, i32* @diagnostic_lock, align 4, !tbaa !6
  call void @llvm.lifetime.end(i64 80, i8* %os.0..sroa_cast)
  ret void
}

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #2

; Function Attrs: nounwind uwtable
define void @pedwarn_with_decl(%union.tree_node* %decl, i8* %msgid, ...) #0 {
entry:
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %in_system_header_flag = getelementptr inbounds %union.tree_node* %decl, i64 0, i32 0, i32 5
  %0 = bitcast i48* %in_system_header_flag to i64*
  %bf.load = load i64* %0, align 8
  %bf.cast = and i64 %bf.load, 65536
  %tobool = icmp eq i64 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32* @flag_pedantic_errors, align 4, !tbaa !6
  %lnot = icmp eq i32 %1, 0
  %lnot.ext = zext i1 %lnot to i32
  call fastcc void @diagnostic_for_decl(%union.tree_node* %decl, i8* %msgid, [1 x %struct.__va_list_tag]* %ap, i32 %lnot.ext)
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  call void @llvm.va_end(i8* %arraydecay1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @diagnostic_for_decl(%union.tree_node* %decl, i8* %msgid, [1 x %struct.__va_list_tag]* %args_ptr, i32 %warn) #0 {
entry:
  %os = alloca %struct.output_state, align 8
  %os.0..sroa_cast = bitcast %struct.output_state* %os to i8*
  call void @llvm.lifetime.start(i64 80, i8* %os.0..sroa_cast)
  %0 = load i32* @diagnostic_lock, align 4, !tbaa !6
  %inc = add nsw i32 %0, 1
  store i32 %inc, i32* @diagnostic_lock, align 4, !tbaa !6
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call fastcc void @error_recursion() #11
  unreachable

if.end:                                           ; preds = %entry
  %tobool.i = icmp eq i32 %warn, 0
  br i1 %tobool.i, label %if.end14.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end
  %1 = load i32* @inhibit_warnings, align 4, !tbaa !6
  %tobool1.i = icmp eq i32 %1, 0
  br i1 %tobool1.i, label %land.lhs.true2.i, label %if.end11

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %2 = load i32* @in_system_header, align 4, !tbaa !6
  %tobool3.i = icmp eq i32 %2, 0
  %3 = load i32* @warn_system_headers, align 4
  %tobool5.i = icmp ne i32 %3, 0
  %or.cond.i = or i1 %tobool3.i, %tobool5.i
  br i1 %or.cond.i, label %if.end.i, label %if.end11

if.end.i:                                         ; preds = %land.lhs.true2.i
  %4 = load i32* @warnings_are_errors, align 4
  %tobool8.i = icmp eq i32 %4, 0
  br i1 %tobool8.i, label %if.then9.i, label %if.else.i

if.then9.i:                                       ; preds = %if.end.i
  %5 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %arrayidx.i = getelementptr inbounds %struct.diagnostic_context* %5, i64 0, i32 0, i32 0, i32 9, i64 4
  %6 = load i32* %arrayidx.i, align 4, !tbaa !6
  %inc.i = add nsw i32 %6, 1
  store i32 %inc.i, i32* %arrayidx.i, align 4, !tbaa !6
  br label %if.then2

if.else.i:                                        ; preds = %if.end.i
  %.b.i = load i1* @count_error.warning_message, align 1
  br i1 %.b.i, label %if.end14.i, label %if.then13.i

if.then13.i:                                      ; preds = %if.else.i
  %7 = load i8** @progname, align 8, !tbaa !1
  tail call void (i8*, ...)* @verbatim(i8* getelementptr inbounds ([38 x i8]* @.str5, i64 0, i64 0), i8* %7) #2
  store i1 true, i1* @count_error.warning_message, align 1
  br label %if.end14.i

if.end14.i:                                       ; preds = %if.then13.i, %if.else.i, %if.end
  %8 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %arrayidx17.i = getelementptr inbounds %struct.diagnostic_context* %8, i64 0, i32 0, i32 0, i32 9, i64 3
  %9 = load i32* %arrayidx17.i, align 4, !tbaa !6
  %inc18.i = add nsw i32 %9, 1
  store i32 %inc18.i, i32* %arrayidx17.i, align 4, !tbaa !6
  br label %if.then2

if.then2:                                         ; preds = %if.end14.i, %if.then9.i
  %10 = phi %struct.diagnostic_context* [ %8, %if.end14.i ], [ %5, %if.then9.i ]
  %11 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %12 = bitcast %struct.output_buffer* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %os.0..sroa_cast, i8* %12, i64 80, i32 8, i1 false), !tbaa.struct !5
  %filename = getelementptr inbounds %union.tree_node* %decl, i64 0, i32 0, i32 1
  %13 = getelementptr inbounds %struct.diagnostic_context* %10, i64 0, i32 0
  tail call void @report_problematic_module(%struct.output_buffer* %13) #2
  %14 = load void (%struct.diagnostic_context*, i8*)** @print_error_function, align 8, !tbaa !1
  %15 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %16 = load i8** @input_filename, align 8, !tbaa !1
  tail call void %14(%struct.diagnostic_context* %15, i8* %16) #2
  %17 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %18 = load i8** %filename, align 8, !tbaa !42
  %linenum = getelementptr inbounds %union.tree_node* %decl, i64 0, i32 0, i32 2
  %19 = load i32* %linenum, align 4, !tbaa !45
  %tobool.i17 = icmp eq i8* %18, null
  %tobool1.i18 = icmp ne i32 %warn, 0
  br i1 %tobool.i17, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %if.then2
  br i1 %tobool1.i18, label %if.then2.i, label %if.else.i19

if.then2.i:                                       ; preds = %if.then.i
  %call.i = tail call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([17 x i8]* @.str1, i64 0, i64 0), i8* %18, i32 %19) #2
  br label %context_as_prefix.exit

if.else.i19:                                      ; preds = %if.then.i
  %call3.i = tail call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([8 x i8]* @.str2, i64 0, i64 0), i8* %18, i32 %19) #2
  br label %context_as_prefix.exit

if.else4.i:                                       ; preds = %if.then2
  %20 = load i8** @progname, align 8, !tbaa !1
  br i1 %tobool1.i18, label %if.then6.i, label %if.else8.i

if.then6.i:                                       ; preds = %if.else4.i
  %call7.i = tail call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([14 x i8]* @.str3, i64 0, i64 0), i8* %20) #2
  br label %context_as_prefix.exit

if.else8.i:                                       ; preds = %if.else4.i
  %call9.i = tail call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([5 x i8]* @.str4, i64 0, i64 0), i8* %20) #2
  br label %context_as_prefix.exit

context_as_prefix.exit:                           ; preds = %if.then2.i, %if.else.i19, %if.then6.i, %if.else8.i
  %retval.0.i20 = phi i8* [ %call.i, %if.then2.i ], [ %call3.i, %if.else.i19 ], [ %call7.i, %if.then6.i ], [ %call9.i, %if.else8.i ]
  %prefix1.i = getelementptr inbounds %struct.output_buffer* %17, i64 0, i32 0, i32 0
  store i8* %retval.0.i20, i8** %prefix1.i, align 8, !tbaa !11
  %ideal_maximum_length.i.i.i = getelementptr inbounds %struct.output_buffer* %17, i64 0, i32 0, i32 2
  %21 = load i32* %ideal_maximum_length.i.i.i, align 4, !tbaa !16
  %cmp.i.i.i = icmp sgt i32 %21, 0
  br i1 %cmp.i.i.i, label %lor.lhs.false.i.i, label %if.then.i.i

lor.lhs.false.i.i:                                ; preds = %context_as_prefix.exit
  %prefixing_rule.i.i = getelementptr inbounds %struct.output_buffer* %17, i64 0, i32 0, i32 6
  %22 = load i32* %prefixing_rule.i.i, align 4, !tbaa !17
  %switch.i.i = icmp ult i32 %22, 2
  br i1 %switch.i.i, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %lor.lhs.false.i.i, %context_as_prefix.exit
  %maximum_length.i.i = getelementptr inbounds %struct.output_buffer* %17, i64 0, i32 0, i32 1
  store i32 %21, i32* %maximum_length.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

if.else.i.i:                                      ; preds = %lor.lhs.false.i.i
  %tobool8.i.i = icmp eq i8* %retval.0.i20, null
  br i1 %tobool8.i.i, label %cond.end.i.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %if.else.i.i
  %call11.i.i = tail call i64 @strlen(i8* %retval.0.i20) #2
  %phitmp.i.i = trunc i64 %call11.i.i to i32
  br label %cond.end.i.i

cond.end.i.i:                                     ; preds = %cond.true.i.i, %if.else.i.i
  %cond.i.i = phi i32 [ %phitmp.i.i, %cond.true.i.i ], [ 0, %if.else.i.i ]
  %sub.i.i = sub nsw i32 %21, %cond.i.i
  %cmp14.i.i = icmp slt i32 %sub.i.i, 32
  br i1 %cmp14.i.i, label %if.then16.i.i, label %if.else21.i.i

if.then16.i.i:                                    ; preds = %cond.end.i.i
  %add.i.i = add nsw i32 %21, 32
  %maximum_length20.i.i = getelementptr inbounds %struct.output_buffer* %17, i64 0, i32 0, i32 1
  store i32 %add.i.i, i32* %maximum_length20.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

if.else21.i.i:                                    ; preds = %cond.end.i.i
  %maximum_length25.i.i = getelementptr inbounds %struct.output_buffer* %17, i64 0, i32 0, i32 1
  store i32 %21, i32* %maximum_length25.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

output_set_prefix.exit:                           ; preds = %if.then.i.i, %if.then16.i.i, %if.else21.i.i
  %emitted_prefix_p.i = getelementptr inbounds %struct.output_buffer* %17, i64 0, i32 0, i32 4
  store i8 0, i8* %emitted_prefix_p.i, align 1, !tbaa !19
  %indent_skip.i = getelementptr inbounds %struct.output_buffer* %17, i64 0, i32 0, i32 3
  store i32 0, i32* %indent_skip.i, align 4, !tbaa !20
  %23 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %format_args = getelementptr inbounds %struct.output_buffer* %23, i64 0, i32 0, i32 8
  store [1 x %struct.__va_list_tag]* %args_ptr, [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !36
  %24 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %cursor = getelementptr inbounds %struct.output_buffer* %24, i64 0, i32 0, i32 7
  store i8* %msgid, i8** %cursor, align 8, !tbaa !37
  %25 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %cursor.i = getelementptr inbounds %struct.output_buffer* %25, i64 0, i32 0, i32 7
  %26 = load i8** %cursor.i, align 8, !tbaa !37
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.inc.i, %output_set_prefix.exit
  %p.0.i = phi i8* [ %26, %output_set_prefix.exit ], [ %incdec.ptr13.i, %for.inc.i ]
  %27 = load i8* %p.0.i, align 1, !tbaa !10
  switch i8 %27, label %for.inc.i [
    i8 0, label %for.end.i
    i8 37, label %if.then.i21
  ]

if.then.i21:                                      ; preds = %for.cond.i
  %add.ptr.i = getelementptr inbounds i8* %p.0.i, i64 1
  %28 = load i8* %add.ptr.i, align 1, !tbaa !10
  switch i8 %28, label %if.then10.i [
    i8 37, label %for.inc.i
    i8 115, label %for.end.i
  ]

if.then10.i:                                      ; preds = %if.then.i21
  tail call void @fancy_abort(i8* getelementptr inbounds ([13 x i8]* @.str26, i64 0, i64 0), i32 858, i8* getelementptr inbounds ([17 x i8]* @__FUNCTION__.format_with_decl, i64 0, i64 0)) #10
  unreachable

for.inc.i:                                        ; preds = %if.then.i21, %for.cond.i
  %p.1.i = phi i8* [ %p.0.i, %for.cond.i ], [ %add.ptr.i, %if.then.i21 ]
  %incdec.ptr13.i = getelementptr inbounds i8* %p.1.i, i64 1
  br label %for.cond.i

for.end.i:                                        ; preds = %if.then.i21, %for.cond.i
  %ideal_maximum_length.i.i.i22 = getelementptr inbounds %struct.output_buffer* %25, i64 0, i32 0, i32 2
  %29 = load i32* %ideal_maximum_length.i.i.i22, align 4, !tbaa !16
  %cmp.i.i.i23 = icmp sgt i32 %29, 0
  br i1 %cmp.i.i.i23, label %if.then.i.i24, label %if.else.i.i25

if.then.i.i24:                                    ; preds = %for.end.i
  tail call fastcc void @wrap_text(%struct.output_buffer* %25, i8* %26, i8* %p.0.i) #2
  br label %maybe_wrap_text.exit.i

if.else.i.i25:                                    ; preds = %for.end.i
  %line_length.i.i.i = getelementptr inbounds %struct.output_buffer* %25, i64 0, i32 3
  %30 = load i32* %line_length.i.i.i, align 4, !tbaa !25
  %cmp.i2.i.i = icmp eq i32 %30, 0
  br i1 %cmp.i2.i.i, label %if.then.i.i.i, label %if.end5.i.i.i

if.then.i.i.i:                                    ; preds = %if.else.i.i25
  tail call void @output_emit_prefix(%struct.output_buffer* %25) #2
  %31 = load i32* %ideal_maximum_length.i.i.i22, align 4, !tbaa !16
  %cmp.i.i.i.i = icmp slt i32 %31, 1
  %cmp216.i.i.i = icmp eq i8* %26, %p.0.i
  %or.cond.i.i.i = or i1 %cmp.i.i.i.i, %cmp216.i.i.i
  br i1 %or.cond.i.i.i, label %if.end5.i.i.i, label %land.rhs.i.i.i

while.cond.i.i.i:                                 ; preds = %land.rhs.i.i.i
  %cmp2.i.i.i = icmp eq i8* %incdec.ptr.i.i.i, %p.0.i
  br i1 %cmp2.i.i.i, label %if.end5.i.i.i, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %if.then.i.i.i, %while.cond.i.i.i
  %start.addr.017.i.i.i = phi i8* [ %incdec.ptr.i.i.i, %while.cond.i.i.i ], [ %26, %if.then.i.i.i ]
  %32 = load i8* %start.addr.017.i.i.i, align 1, !tbaa !10
  %cmp3.i.i.i = icmp eq i8 %32, 32
  %incdec.ptr.i.i.i = getelementptr inbounds i8* %start.addr.017.i.i.i, i64 1
  br i1 %cmp3.i.i.i, label %while.cond.i.i.i, label %if.end5.i.i.i

if.end5.i.i.i:                                    ; preds = %land.rhs.i.i.i, %while.cond.i.i.i, %if.then.i.i.i, %if.else.i.i25
  %start.addr.1.i.i.i = phi i8* [ %26, %if.then.i.i.i ], [ %26, %if.else.i.i25 ], [ %start.addr.017.i.i.i, %land.rhs.i.i.i ], [ %p.0.i, %while.cond.i.i.i ]
  %sub.ptr.lhs.cast.i.i.i = ptrtoint i8* %p.0.i to i64
  %sub.ptr.rhs.cast.i.i.i = ptrtoint i8* %start.addr.1.i.i.i to i64
  %sub.ptr.sub.i.i.i = sub i64 %sub.ptr.lhs.cast.i.i.i, %sub.ptr.rhs.cast.i.i.i
  %conv6.i.i.i = trunc i64 %sub.ptr.sub.i.i.i to i32
  %next_free.i.i.i.i = getelementptr inbounds %struct.output_buffer* %25, i64 0, i32 2, i32 3
  %33 = load i8** %next_free.i.i.i.i, align 8, !tbaa !23
  %sext.i.i.i = shl i64 %sub.ptr.sub.i.i.i, 32
  %idx.ext.i.i.i.i = ashr exact i64 %sext.i.i.i, 32
  %add.ptr.i.i.i.i = getelementptr inbounds i8* %33, i64 %idx.ext.i.i.i.i
  %chunk_limit.i.i.i.i = getelementptr inbounds %struct.output_buffer* %25, i64 0, i32 2, i32 4
  %34 = load i8** %chunk_limit.i.i.i.i, align 8, !tbaa !24
  %cmp.i15.i.i.i = icmp ugt i8* %add.ptr.i.i.i.i, %34
  br i1 %cmp.i15.i.i.i, label %if.then.i.i.i.i, label %output_append.exit.i.i

if.then.i.i.i.i:                                  ; preds = %if.end5.i.i.i
  %obstack.i.i.i.i = getelementptr inbounds %struct.output_buffer* %25, i64 0, i32 2
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i.i.i.i, i32 %conv6.i.i.i) #2
  %.pre.i.i.i.i = load i8** %next_free.i.i.i.i, align 8, !tbaa !23
  br label %output_append.exit.i.i

output_append.exit.i.i:                           ; preds = %if.then.i.i.i.i, %if.end5.i.i.i
  %35 = phi i8* [ %.pre.i.i.i.i, %if.then.i.i.i.i ], [ %33, %if.end5.i.i.i ]
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %35, i8* %start.addr.1.i.i.i, i64 %idx.ext.i.i.i.i, i32 1, i1 false) #2
  %36 = load i8** %next_free.i.i.i.i, align 8, !tbaa !23
  %add.ptr4.i.i.i.i = getelementptr inbounds i8* %36, i64 %idx.ext.i.i.i.i
  store i8* %add.ptr4.i.i.i.i, i8** %next_free.i.i.i.i, align 8, !tbaa !23
  %37 = load i32* %line_length.i.i.i, align 4, !tbaa !25
  %add.i.i.i.i = add nsw i32 %37, %conv6.i.i.i
  store i32 %add.i.i.i.i, i32* %line_length.i.i.i, align 4, !tbaa !25
  br label %maybe_wrap_text.exit.i

maybe_wrap_text.exit.i:                           ; preds = %output_append.exit.i.i, %if.then.i.i24
  %38 = load i8* %p.0.i, align 1, !tbaa !10
  %cmp17.i = icmp eq i8 %38, 37
  br i1 %cmp17.i, label %if.then19.i, label %if.end32.i

if.then19.i:                                      ; preds = %maybe_wrap_text.exit.i
  %name.i = getelementptr inbounds %union.tree_node* %decl, i64 0, i32 0, i32 8
  %39 = load %union.tree_node** %name.i, align 8, !tbaa !46
  %tobool21.i = icmp eq %union.tree_node* %39, null
  br i1 %tobool21.i, label %cond.end.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.then19.i
  %40 = load i8* (%union.tree_node*, i32)** @decl_printable_name, align 8, !tbaa !1
  %call.i26 = tail call i8* %40(%union.tree_node* %decl, i32 2) #2
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.true.i, %if.then19.i
  %cond.i = phi i8* [ %call.i26, %cond.true.i ], [ getelementptr inbounds ([14 x i8]* @.str27, i64 0, i64 0), %if.then19.i ]
  tail call void @output_add_string(%struct.output_buffer* %25, i8* %cond.i) #2
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.body.i, %cond.end.i
  %p.2.i = phi i8* [ %p.0.i, %cond.end.i ], [ %incdec.ptr23.i, %while.body.i ]
  %41 = load i8* %p.2.i, align 1, !tbaa !10
  %tobool22.i = icmp eq i8 %41, 0
  br i1 %tobool22.i, label %format_with_decl.exit, label %while.body.i

while.body.i:                                     ; preds = %while.cond.i
  %incdec.ptr23.i = getelementptr inbounds i8* %p.2.i, i64 1
  %idxprom.i = zext i8 %41 to i64
  %arrayidx.i27 = getelementptr inbounds [256 x i16]* @_sch_istable, i64 0, i64 %idxprom.i
  %42 = load i16* %arrayidx.i27, align 2, !tbaa !47
  %and28.i = and i16 %42, 136
  %tobool29.i = icmp eq i16 %and28.i, 0
  br i1 %tobool29.i, label %while.cond.i, label %while.body.if.end32.loopexit_crit_edge.i

while.body.if.end32.loopexit_crit_edge.i:         ; preds = %while.body.i
  %.pre.pre.i = load i8* %incdec.ptr23.i, align 1, !tbaa !10
  br label %if.end32.i

if.end32.i:                                       ; preds = %while.body.if.end32.loopexit_crit_edge.i, %maybe_wrap_text.exit.i
  %43 = phi i8 [ %38, %maybe_wrap_text.exit.i ], [ %.pre.pre.i, %while.body.if.end32.loopexit_crit_edge.i ]
  %p.3.i = phi i8* [ %p.0.i, %maybe_wrap_text.exit.i ], [ %incdec.ptr23.i, %while.body.if.end32.loopexit_crit_edge.i ]
  %tobool33.i = icmp eq i8 %43, 0
  br i1 %tobool33.i, label %format_with_decl.exit, label %if.then34.i

if.then34.i:                                      ; preds = %if.end32.i
  store i8* %p.3.i, i8** %cursor.i, align 8, !tbaa !37
  tail call fastcc void @output_format(%struct.output_buffer* %25) #2
  br label %format_with_decl.exit

format_with_decl.exit:                            ; preds = %while.cond.i, %if.end32.i, %if.then34.i
  %44 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %45 = getelementptr inbounds %struct.diagnostic_context* %44, i64 0, i32 0
  tail call fastcc void @diagnostic_finish(%struct.output_buffer* %45)
  %46 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %prefix.i = getelementptr inbounds %struct.output_buffer* %46, i64 0, i32 0, i32 0
  %47 = load i8** %prefix.i, align 8, !tbaa !11
  %cmp.i = icmp eq i8* %47, null
  br i1 %cmp.i, label %output_destroy_prefix.exit, label %if.then.i28

if.then.i28:                                      ; preds = %format_with_decl.exit
  tail call void @free(i8* %47) #2
  store i8* null, i8** %prefix.i, align 8, !tbaa !11
  %.pre = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  br label %output_destroy_prefix.exit

output_destroy_prefix.exit:                       ; preds = %format_with_decl.exit, %if.then.i28
  %48 = phi %struct.output_buffer* [ %46, %format_with_decl.exit ], [ %.pre, %if.then.i28 ]
  %49 = bitcast %struct.output_buffer* %48 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %49, i8* %os.0..sroa_cast, i64 80, i32 8, i1 false), !tbaa.struct !5
  %.pre39 = load i32* @diagnostic_lock, align 4, !tbaa !6
  br label %if.end11

if.end11:                                         ; preds = %land.lhs.true2.i, %land.lhs.true.i, %output_destroy_prefix.exit
  %50 = phi i32 [ %inc, %land.lhs.true2.i ], [ %inc, %land.lhs.true.i ], [ %.pre39, %output_destroy_prefix.exit ]
  %dec = add nsw i32 %50, -1
  store i32 %dec, i32* @diagnostic_lock, align 4, !tbaa !6
  call void @llvm.lifetime.end(i64 80, i8* %os.0..sroa_cast)
  ret void
}

; Function Attrs: nounwind uwtable
define void @pedwarn_with_file_and_line(i8* %file, i32 %line, i8* %msgid, ...) #0 {
entry:
  %dc = alloca %struct.diagnostic_context, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %0 = bitcast %struct.diagnostic_context* %dc to i8*
  call void @llvm.lifetime.start(i64 376, i8* %0) #2
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = load i32* @flag_pedantic_errors, align 4, !tbaa !6
  %lnot = icmp eq i32 %1, 0
  %lnot.ext = zext i1 %lnot to i32
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 376, i32 8, i1 false) #2
  %message.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 1
  store i8* %msgid, i8** %message.i, align 8, !tbaa !40
  %args_ptr1.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 2
  store [1 x %struct.__va_list_tag]* %ap, [1 x %struct.__va_list_tag]** %args_ptr1.i, align 8, !tbaa !41
  %file2.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 3
  store i8* %file, i8** %file2.i, align 8, !tbaa !32
  %line3.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 4
  store i32 %line, i32* %line3.i, align 8, !tbaa !33
  %warn4.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 5
  store i32 %lnot.ext, i32* %warn4.i, align 4, !tbaa !34
  %2 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %begin_diagnostic.i = getelementptr inbounds %struct.diagnostic_context* %2, i64 0, i32 6
  %begin_diagnostic5.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 6
  %3 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  %4 = load <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %3, align 8, !tbaa !1
  %5 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic5.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  store <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*> %4, <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %5, align 8, !tbaa !1
  call void @report_diagnostic(%struct.diagnostic_context* %dc)
  call void @llvm.va_end(i8* %arraydecay1)
  call void @llvm.lifetime.end(i64 376, i8* %0) #2
  ret void
}

; Function Attrs: nounwind uwtable
define void @sorry(i8* %msgid, ...) #0 {
entry:
  %os = alloca %struct.output_state, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %os.0..sroa_cast = bitcast %struct.output_state* %os to i8*
  call void @llvm.lifetime.start(i64 80, i8* %os.0..sroa_cast)
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %0 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.diagnostic_context* %0, i64 0, i32 0, i32 0, i32 9, i64 2
  %1 = load i32* %arrayidx, align 4, !tbaa !6
  %inc = add nsw i32 %1, 1
  store i32 %inc, i32* %arrayidx, align 4, !tbaa !6
  %2 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %3 = bitcast %struct.output_buffer* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %os.0..sroa_cast, i8* %3, i64 80, i32 8, i1 false), !tbaa.struct !5
  %4 = load i8** @input_filename, align 8, !tbaa !1
  %tobool.i = icmp eq i8* %4, null
  br i1 %tobool.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %5 = load i32* @lineno, align 4, !tbaa !6
  %call3.i = call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([8 x i8]* @.str2, i64 0, i64 0), i8* %4, i32 %5) #2
  br label %context_as_prefix.exit

if.else4.i:                                       ; preds = %entry
  %6 = load i8** @progname, align 8, !tbaa !1
  %call9.i = call i8* (i8*, ...)* @build_message_string(i8* getelementptr inbounds ([5 x i8]* @.str4, i64 0, i64 0), i8* %6) #2
  br label %context_as_prefix.exit

context_as_prefix.exit:                           ; preds = %if.then.i, %if.else4.i
  %retval.0.i = phi i8* [ %call3.i, %if.then.i ], [ %call9.i, %if.else4.i ]
  %prefix1.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 0, i32 0
  store i8* %retval.0.i, i8** %prefix1.i, align 8, !tbaa !11
  %ideal_maximum_length.i.i.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 0, i32 2
  %7 = load i32* %ideal_maximum_length.i.i.i, align 4, !tbaa !16
  %cmp.i.i.i = icmp sgt i32 %7, 0
  br i1 %cmp.i.i.i, label %lor.lhs.false.i.i, label %if.then.i.i

lor.lhs.false.i.i:                                ; preds = %context_as_prefix.exit
  %prefixing_rule.i.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 0, i32 6
  %8 = load i32* %prefixing_rule.i.i, align 4, !tbaa !17
  %switch.i.i = icmp ult i32 %8, 2
  br i1 %switch.i.i, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %lor.lhs.false.i.i, %context_as_prefix.exit
  %maximum_length.i.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 0, i32 1
  store i32 %7, i32* %maximum_length.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

if.else.i.i:                                      ; preds = %lor.lhs.false.i.i
  %tobool8.i.i = icmp eq i8* %retval.0.i, null
  br i1 %tobool8.i.i, label %cond.end.i.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %if.else.i.i
  %call11.i.i = call i64 @strlen(i8* %retval.0.i) #2
  %phitmp.i.i = trunc i64 %call11.i.i to i32
  br label %cond.end.i.i

cond.end.i.i:                                     ; preds = %cond.true.i.i, %if.else.i.i
  %cond.i.i = phi i32 [ %phitmp.i.i, %cond.true.i.i ], [ 0, %if.else.i.i ]
  %sub.i.i = sub nsw i32 %7, %cond.i.i
  %cmp14.i.i = icmp slt i32 %sub.i.i, 32
  br i1 %cmp14.i.i, label %if.then16.i.i, label %if.else21.i.i

if.then16.i.i:                                    ; preds = %cond.end.i.i
  %add.i.i = add nsw i32 %7, 32
  %maximum_length20.i.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 0, i32 1
  store i32 %add.i.i, i32* %maximum_length20.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

if.else21.i.i:                                    ; preds = %cond.end.i.i
  %maximum_length25.i.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 0, i32 1
  store i32 %7, i32* %maximum_length25.i.i, align 4, !tbaa !18
  br label %output_set_prefix.exit

output_set_prefix.exit:                           ; preds = %if.then.i.i, %if.then16.i.i, %if.else21.i.i
  %emitted_prefix_p.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 0, i32 4
  store i8 0, i8* %emitted_prefix_p.i, align 1, !tbaa !19
  %indent_skip.i = getelementptr inbounds %struct.output_buffer* %2, i64 0, i32 0, i32 3
  store i32 0, i32* %indent_skip.i, align 4, !tbaa !20
  %9 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  call void (%struct.output_buffer*, i8*, ...)* @output_printf(%struct.output_buffer* %9, i8* getelementptr inbounds ([25 x i8]* @.str7, i64 0, i64 0))
  %10 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %format_args = getelementptr inbounds %struct.output_buffer* %10, i64 0, i32 0, i32 8
  store [1 x %struct.__va_list_tag]* %ap, [1 x %struct.__va_list_tag]** %format_args, align 8, !tbaa !36
  %11 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %cursor = getelementptr inbounds %struct.output_buffer* %11, i64 0, i32 0, i32 7
  store i8* %msgid, i8** %cursor, align 8, !tbaa !37
  %12 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  call fastcc void @output_format(%struct.output_buffer* %12)
  %13 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %14 = getelementptr inbounds %struct.diagnostic_context* %13, i64 0, i32 0
  call fastcc void @diagnostic_finish(%struct.output_buffer* %14)
  %15 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %16 = bitcast %struct.output_buffer* %15 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %16, i8* %os.0..sroa_cast, i64 80, i32 8, i1 false), !tbaa.struct !5
  call void @llvm.va_end(i8* %arraydecay1)
  call void @llvm.lifetime.end(i64 80, i8* %os.0..sroa_cast)
  ret void
}

; Function Attrs: nounwind uwtable
define void @announce_function(%union.tree_node* %decl) #0 {
entry:
  %0 = load i32* @quiet_flag, align 4, !tbaa !6
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %1 = load i32* @rtl_dump_and_exit, align 4, !tbaa !6
  %tobool1 = icmp eq i32 %1, 0
  br i1 %tobool1, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.then
  %name = getelementptr inbounds %union.tree_node* %decl, i64 0, i32 0, i32 8
  %2 = load %union.tree_node** %name, align 8, !tbaa !46
  %id = getelementptr inbounds %union.tree_node* %2, i64 0, i32 0, i32 1
  %3 = getelementptr inbounds i8** %id, i64 1
  %4 = load i8** %3, align 8, !tbaa !49
  tail call void (i8*, ...)* @verbatim(i8* getelementptr inbounds ([4 x i8]* @.str8, i64 0, i64 0), i8* %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  %5 = load i8* (%union.tree_node*, i32)** @decl_printable_name, align 8, !tbaa !1
  %call = tail call i8* %5(%union.tree_node* %decl, i32 2) #2
  tail call void (i8*, ...)* @verbatim(i8* getelementptr inbounds ([4 x i8]* @.str9, i64 0, i64 0), i8* %call)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  %6 = load %struct._IO_FILE** @stderr, align 8, !tbaa !1
  %call4 = tail call i32 @fflush(%struct._IO_FILE* %6) #2
  %7 = load %struct.output_buffer** @diagnostic_buffer, align 8, !tbaa !1
  %need_newline_p = getelementptr inbounds %struct.output_buffer* %7, i64 0, i32 0, i32 5
  store i8 1, i8* %need_newline_p, align 1, !tbaa !52
  %8 = load %union.tree_node** @current_function_decl, align 8, !tbaa !1
  store %union.tree_node* %8, %union.tree_node** @last_error_function, align 8, !tbaa !1
  br label %if.end5

if.end5:                                          ; preds = %entry, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define void @report_error_function(i8* nocapture readnone %file) #0 {
entry:
  %0 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %1 = getelementptr inbounds %struct.diagnostic_context* %0, i64 0, i32 0
  tail call void @report_problematic_module(%struct.output_buffer* %1)
  %2 = load void (%struct.diagnostic_context*, i8*)** @print_error_function, align 8, !tbaa !1
  %3 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %4 = load i8** @input_filename, align 8, !tbaa !1
  tail call void %2(%struct.diagnostic_context* %3, i8* %4) #2
  ret void
}

; Function Attrs: nounwind uwtable
define void @report_problematic_module(%struct.output_buffer* %buffer) #0 {
entry:
  %need_newline_p = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 5
  %0 = load i8* %need_newline_p, align 1, !tbaa !52, !range !35
  %tobool = icmp eq i8 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %next_free.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %1 = load i8** %next_free.i, align 8, !tbaa !23
  %add.ptr.i = getelementptr inbounds i8* %1, i64 1
  %chunk_limit.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %2 = load i8** %chunk_limit.i, align 8, !tbaa !24
  %cmp.i = icmp ugt i8* %add.ptr.i, %2
  br i1 %cmp.i, label %if.then.i, label %output_add_newline.exit

if.then.i:                                        ; preds = %if.then
  %obstack.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i, i32 1) #2
  %.pre.i = load i8** %next_free.i, align 8, !tbaa !23
  br label %output_add_newline.exit

output_add_newline.exit:                          ; preds = %if.then, %if.then.i
  %3 = phi i8* [ %.pre.i, %if.then.i ], [ %1, %if.then ]
  %incdec.ptr.i = getelementptr inbounds i8* %3, i64 1
  store i8* %incdec.ptr.i, i8** %next_free.i, align 8, !tbaa !23
  store i8 10, i8* %3, align 1, !tbaa !10
  %line_length.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  store i32 0, i32* %line_length.i, align 4, !tbaa !25
  store i8 0, i8* %need_newline_p, align 1, !tbaa !52
  br label %if.end

if.end:                                           ; preds = %entry, %output_add_newline.exit
  %4 = load %struct.file_stack** @input_file_stack, align 8, !tbaa !1
  %tobool3 = icmp eq %struct.file_stack* %4, null
  br i1 %tobool3, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %next = getelementptr inbounds %struct.file_stack* %4, i64 0, i32 1
  %5 = load %struct.file_stack** %next, align 8, !tbaa !53
  %cmp = icmp eq %struct.file_stack* %5, null
  br i1 %cmp, label %if.end16, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load i32* @last_error_tick, align 4, !tbaa !6
  %7 = load i32* @input_file_stack_tick, align 4, !tbaa !6
  %cmp.i25 = icmp eq i32 %6, %7
  br i1 %cmp.i25, label %if.end16, label %for.body

for.body:                                         ; preds = %land.lhs.true4, %for.cond.backedge.for.body_crit_edge
  %8 = phi %struct.file_stack* [ %.pre30, %for.cond.backedge.for.body_crit_edge ], [ %5, %land.lhs.true4 ]
  %p.029 = phi %struct.file_stack* [ %p.0, %for.cond.backedge.for.body_crit_edge ], [ %5, %land.lhs.true4 ]
  %cmp10 = icmp eq %struct.file_stack* %p.029, %8
  %name = getelementptr inbounds %struct.file_stack* %p.029, i64 0, i32 0
  %9 = load i8** %name, align 8, !tbaa !55
  %line = getelementptr inbounds %struct.file_stack* %p.029, i64 0, i32 2
  %10 = load i32* %line, align 4, !tbaa !56
  br i1 %cmp10, label %if.then11, label %if.else

if.then11:                                        ; preds = %for.body
  tail call void (%struct.output_buffer*, i8*, ...)* @output_verbatim(%struct.output_buffer* %buffer, i8* getelementptr inbounds ([28 x i8]* @.str18, i64 0, i64 0), i8* %9, i32 %10)
  br label %for.cond.backedge

for.cond.backedge:                                ; preds = %if.then11, %if.else
  %p.0.in = getelementptr inbounds %struct.file_stack* %p.029, i64 0, i32 1
  %p.0 = load %struct.file_stack** %p.0.in, align 8
  %tobool8 = icmp eq %struct.file_stack* %p.0, null
  br i1 %tobool8, label %for.end, label %for.cond.backedge.for.body_crit_edge

for.cond.backedge.for.body_crit_edge:             ; preds = %for.cond.backedge
  %.pre = load %struct.file_stack** @input_file_stack, align 8, !tbaa !1
  %next9.phi.trans.insert = getelementptr inbounds %struct.file_stack* %.pre, i64 0, i32 1
  %.pre30 = load %struct.file_stack** %next9.phi.trans.insert, align 8, !tbaa !53
  br label %for.body

if.else:                                          ; preds = %for.body
  tail call void (%struct.output_buffer*, i8*, ...)* @output_verbatim(%struct.output_buffer* %buffer, i8* getelementptr inbounds ([30 x i8]* @.str19, i64 0, i64 0), i8* %9, i32 %10)
  br label %for.cond.backedge

for.end:                                          ; preds = %for.cond.backedge
  tail call void (%struct.output_buffer*, i8*, ...)* @output_verbatim(%struct.output_buffer* %buffer, i8* getelementptr inbounds ([3 x i8]* @.str20, i64 0, i64 0))
  %11 = load i32* @input_file_stack_tick, align 4, !tbaa !6
  store i32 %11, i32* @last_error_tick, align 4, !tbaa !6
  br label %if.end16

if.end16:                                         ; preds = %land.lhs.true4, %land.lhs.true, %if.end, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define void @error_with_file_and_line(i8* %file, i32 %line, i8* %msgid, ...) #0 {
entry:
  %dc = alloca %struct.diagnostic_context, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %0 = bitcast %struct.diagnostic_context* %dc to i8*
  call void @llvm.lifetime.start(i64 376, i8* %0) #2
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 376, i32 8, i1 false) #2
  %message.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 1
  store i8* %msgid, i8** %message.i, align 8, !tbaa !40
  %args_ptr1.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 2
  store [1 x %struct.__va_list_tag]* %ap, [1 x %struct.__va_list_tag]** %args_ptr1.i, align 8, !tbaa !41
  %file2.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 3
  store i8* %file, i8** %file2.i, align 8, !tbaa !32
  %line3.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 4
  store i32 %line, i32* %line3.i, align 8, !tbaa !33
  %warn4.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 5
  store i32 0, i32* %warn4.i, align 4, !tbaa !34
  %1 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %begin_diagnostic.i = getelementptr inbounds %struct.diagnostic_context* %1, i64 0, i32 6
  %begin_diagnostic5.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 6
  %2 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  %3 = load <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %2, align 8, !tbaa !1
  %4 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic5.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  store <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*> %3, <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %4, align 8, !tbaa !1
  call void @report_diagnostic(%struct.diagnostic_context* %dc)
  call void @llvm.va_end(i8* %arraydecay1)
  call void @llvm.lifetime.end(i64 376, i8* %0) #2
  ret void
}

; Function Attrs: nounwind uwtable
define void @error_with_decl(%union.tree_node* %decl, i8* %msgid, ...) #0 {
entry:
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  call fastcc void @diagnostic_for_decl(%union.tree_node* %decl, i8* %msgid, [1 x %struct.__va_list_tag]* %ap, i32 0)
  call void @llvm.va_end(i8* %arraydecay1)
  ret void
}

; Function Attrs: nounwind uwtable
define void @error(i8* %msgid, ...) #0 {
entry:
  %dc = alloca %struct.diagnostic_context, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %0 = bitcast %struct.diagnostic_context* %dc to i8*
  call void @llvm.lifetime.start(i64 376, i8* %0) #2
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = load i8** @input_filename, align 8, !tbaa !1
  %2 = load i32* @lineno, align 4, !tbaa !6
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 376, i32 8, i1 false) #2
  %message.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 1
  store i8* %msgid, i8** %message.i, align 8, !tbaa !40
  %args_ptr1.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 2
  store [1 x %struct.__va_list_tag]* %ap, [1 x %struct.__va_list_tag]** %args_ptr1.i, align 8, !tbaa !41
  %file2.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 3
  store i8* %1, i8** %file2.i, align 8, !tbaa !32
  %line3.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 4
  store i32 %2, i32* %line3.i, align 8, !tbaa !33
  %warn4.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 5
  store i32 0, i32* %warn4.i, align 4, !tbaa !34
  %3 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %begin_diagnostic.i = getelementptr inbounds %struct.diagnostic_context* %3, i64 0, i32 6
  %begin_diagnostic5.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 6
  %4 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  %5 = load <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %4, align 8, !tbaa !1
  %6 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic5.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  store <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*> %5, <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %6, align 8, !tbaa !1
  call void @report_diagnostic(%struct.diagnostic_context* %dc)
  call void @llvm.va_end(i8* %arraydecay1)
  call void @llvm.lifetime.end(i64 376, i8* %0) #2
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define void @fatal_error(i8* %msgid, ...) #6 {
entry:
  %dc = alloca %struct.diagnostic_context, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %0 = bitcast %struct.diagnostic_context* %dc to i8*
  call void @llvm.lifetime.start(i64 376, i8* %0) #2
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = load i8** @input_filename, align 8, !tbaa !1
  %2 = load i32* @lineno, align 4, !tbaa !6
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 376, i32 8, i1 false) #2
  %message.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 1
  store i8* %msgid, i8** %message.i, align 8, !tbaa !40
  %args_ptr1.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 2
  store [1 x %struct.__va_list_tag]* %ap, [1 x %struct.__va_list_tag]** %args_ptr1.i, align 8, !tbaa !41
  %file2.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 3
  store i8* %1, i8** %file2.i, align 8, !tbaa !32
  %line3.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 4
  store i32 %2, i32* %line3.i, align 8, !tbaa !33
  %warn4.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 5
  store i32 0, i32* %warn4.i, align 4, !tbaa !34
  %3 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %begin_diagnostic.i = getelementptr inbounds %struct.diagnostic_context* %3, i64 0, i32 6
  %begin_diagnostic5.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 6
  %4 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  %5 = load <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %4, align 8, !tbaa !1
  %6 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic5.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  store <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*> %5, <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %6, align 8, !tbaa !1
  call void @report_diagnostic(%struct.diagnostic_context* %dc)
  call void @llvm.va_end(i8* %arraydecay1)
  %7 = load %struct._IO_FILE** @stderr, align 8, !tbaa !1
  call void (%struct._IO_FILE*, i8*, ...)* @fnotice(%struct._IO_FILE* %7, i8* getelementptr inbounds ([25 x i8]* @.str13, i64 0, i64 0))
  call void @exit(i32 1) #10
  unreachable
}

; Function Attrs: nounwind uwtable
define void @set_internal_error_function(void (i8*, [1 x %struct.__va_list_tag]*)* %f) #0 {
entry:
  store void (i8*, [1 x %struct.__va_list_tag]*)* %f, void (i8*, [1 x %struct.__va_list_tag]*)** @internal_error_function, align 8, !tbaa !1
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define void @internal_error(i8* %msgid, ...) #6 {
entry:
  %dc = alloca %struct.diagnostic_context, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %0 = bitcast %struct.diagnostic_context* %dc to i8*
  call void @llvm.lifetime.start(i64 376, i8* %0) #2
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = load i32* @diagnostic_lock, align 4, !tbaa !6
  %tobool = icmp eq i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call fastcc void @error_recursion() #11
  unreachable

if.end:                                           ; preds = %entry
  %2 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.diagnostic_context* %2, i64 0, i32 0, i32 0, i32 9, i64 3
  %3 = load i32* %arrayidx, align 4, !tbaa !6
  %cmp = icmp sgt i32 %3, 0
  br i1 %cmp, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %arrayidx4 = getelementptr inbounds %struct.diagnostic_context* %2, i64 0, i32 0, i32 0, i32 9, i64 2
  %4 = load i32* %arrayidx4, align 4, !tbaa !6
  %cmp5 = icmp sgt i32 %4, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %lor.lhs.false, %if.end
  %5 = load %struct._IO_FILE** @stderr, align 8, !tbaa !1
  %6 = load i8** @input_filename, align 8, !tbaa !1
  %7 = load i32* @lineno, align 4, !tbaa !6
  call void (%struct._IO_FILE*, i8*, ...)* @fnotice(%struct._IO_FILE* %5, i8* getelementptr inbounds ([48 x i8]* @.str14, i64 0, i64 0), i8* %6, i32 %7)
  call void @exit(i32 1) #10
  unreachable

if.end7:                                          ; preds = %lor.lhs.false
  %8 = load void (i8*, [1 x %struct.__va_list_tag]*)** @internal_error_function, align 8, !tbaa !1
  %cmp8 = icmp eq void (i8*, [1 x %struct.__va_list_tag]*)* %8, null
  br i1 %cmp8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end7
  call void %8(i8* %msgid, [1 x %struct.__va_list_tag]* %ap) #2
  %.pre = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  br label %if.end10

if.end10:                                         ; preds = %if.end7, %if.then9
  %9 = phi %struct.diagnostic_context* [ %2, %if.end7 ], [ %.pre, %if.then9 ]
  %10 = load i8** @input_filename, align 8, !tbaa !1
  %11 = load i32* @lineno, align 4, !tbaa !6
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 376, i32 8, i1 false) #2
  %message.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 1
  store i8* %msgid, i8** %message.i, align 8, !tbaa !40
  %args_ptr1.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 2
  store [1 x %struct.__va_list_tag]* %ap, [1 x %struct.__va_list_tag]** %args_ptr1.i, align 8, !tbaa !41
  %file2.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 3
  store i8* %10, i8** %file2.i, align 8, !tbaa !32
  %line3.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 4
  store i32 %11, i32* %line3.i, align 8, !tbaa !33
  %warn4.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 5
  store i32 0, i32* %warn4.i, align 4, !tbaa !34
  %begin_diagnostic.i = getelementptr inbounds %struct.diagnostic_context* %9, i64 0, i32 6
  %begin_diagnostic5.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 6
  %12 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  %13 = load <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %12, align 8, !tbaa !1
  %14 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic5.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  store <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*> %13, <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %14, align 8, !tbaa !1
  call void @report_diagnostic(%struct.diagnostic_context* %dc)
  call void @llvm.va_end(i8* %arraydecay1)
  %15 = load %struct._IO_FILE** @stderr, align 8, !tbaa !1
  call void (%struct._IO_FILE*, i8*, ...)* @fnotice(%struct._IO_FILE* %15, i8* getelementptr inbounds ([421 x i8]* @.str15, i64 0, i64 0), i8* getelementptr inbounds ([27 x i8]* @.str16, i64 0, i64 0))
  call void @exit(i32 1) #10
  unreachable
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @error_recursion() #6 {
entry:
  %0 = load i32* @diagnostic_lock, align 4, !tbaa !6
  %cmp = icmp slt i32 %0, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %2 = getelementptr inbounds %struct.diagnostic_context* %1, i64 0, i32 0
  tail call fastcc void @diagnostic_finish(%struct.output_buffer* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load %struct._IO_FILE** @stderr, align 8, !tbaa !1
  tail call void (%struct._IO_FILE*, i8*, ...)* @fnotice(%struct._IO_FILE* %3, i8* getelementptr inbounds ([63 x i8]* @.str25, i64 0, i64 0))
  tail call void (%struct._IO_FILE*, i8*, ...)* @fnotice(%struct._IO_FILE* %3, i8* getelementptr inbounds ([421 x i8]* @.str15, i64 0, i64 0), i8* getelementptr inbounds ([27 x i8]* @.str16, i64 0, i64 0))
  tail call void @exit(i32 1) #10
  unreachable
}

; Function Attrs: nounwind uwtable
define void @warning_with_file_and_line(i8* %file, i32 %line, i8* %msgid, ...) #0 {
entry:
  %dc = alloca %struct.diagnostic_context, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %0 = bitcast %struct.diagnostic_context* %dc to i8*
  call void @llvm.lifetime.start(i64 376, i8* %0) #2
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 376, i32 8, i1 false) #2
  %message.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 1
  store i8* %msgid, i8** %message.i, align 8, !tbaa !40
  %args_ptr1.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 2
  store [1 x %struct.__va_list_tag]* %ap, [1 x %struct.__va_list_tag]** %args_ptr1.i, align 8, !tbaa !41
  %file2.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 3
  store i8* %file, i8** %file2.i, align 8, !tbaa !32
  %line3.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 4
  store i32 %line, i32* %line3.i, align 8, !tbaa !33
  %warn4.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 5
  store i32 1, i32* %warn4.i, align 4, !tbaa !34
  %1 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %begin_diagnostic.i = getelementptr inbounds %struct.diagnostic_context* %1, i64 0, i32 6
  %begin_diagnostic5.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 6
  %2 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  %3 = load <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %2, align 8, !tbaa !1
  %4 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic5.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  store <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*> %3, <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %4, align 8, !tbaa !1
  call void @report_diagnostic(%struct.diagnostic_context* %dc)
  call void @llvm.va_end(i8* %arraydecay1)
  call void @llvm.lifetime.end(i64 376, i8* %0) #2
  ret void
}

; Function Attrs: nounwind uwtable
define void @warning_with_decl(%union.tree_node* %decl, i8* %msgid, ...) #0 {
entry:
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  call fastcc void @diagnostic_for_decl(%union.tree_node* %decl, i8* %msgid, [1 x %struct.__va_list_tag]* %ap, i32 1)
  call void @llvm.va_end(i8* %arraydecay1)
  ret void
}

; Function Attrs: nounwind uwtable
define void @warning(i8* %msgid, ...) #0 {
entry:
  %dc = alloca %struct.diagnostic_context, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %0 = bitcast %struct.diagnostic_context* %dc to i8*
  call void @llvm.lifetime.start(i64 376, i8* %0) #2
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = load i8** @input_filename, align 8, !tbaa !1
  %2 = load i32* @lineno, align 4, !tbaa !6
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 376, i32 8, i1 false) #2
  %message.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 1
  store i8* %msgid, i8** %message.i, align 8, !tbaa !40
  %args_ptr1.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 2
  store [1 x %struct.__va_list_tag]* %ap, [1 x %struct.__va_list_tag]** %args_ptr1.i, align 8, !tbaa !41
  %file2.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 3
  store i8* %1, i8** %file2.i, align 8, !tbaa !32
  %line3.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 4
  store i32 %2, i32* %line3.i, align 8, !tbaa !33
  %warn4.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 5
  store i32 1, i32* %warn4.i, align 4, !tbaa !34
  %3 = load %struct.diagnostic_context** @global_dc, align 8, !tbaa !1
  %begin_diagnostic.i = getelementptr inbounds %struct.diagnostic_context* %3, i64 0, i32 6
  %begin_diagnostic5.i = getelementptr inbounds %struct.diagnostic_context* %dc, i64 0, i32 6
  %4 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  %5 = load <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %4, align 8, !tbaa !1
  %6 = bitcast void (%struct.output_buffer*, %struct.diagnostic_context*)** %begin_diagnostic5.i to <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>*
  store <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*> %5, <2 x void (%struct.output_buffer*, %struct.diagnostic_context*)*>* %6, align 8, !tbaa !1
  call void @report_diagnostic(%struct.diagnostic_context* %dc)
  call void @llvm.va_end(i8* %arraydecay1)
  call void @llvm.lifetime.end(i64 376, i8* %0) #2
  ret void
}

; Function Attrs: nounwind uwtable
define void @output_verbatim(%struct.output_buffer* %buffer, i8* %msgid, ...) #0 {
entry:
  %os.i = alloca %struct.output_state, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %os.0..sroa_cast.i = bitcast %struct.output_state* %os.i to i8*
  call void @llvm.lifetime.start(i64 80, i8* %os.0..sroa_cast.i)
  %0 = bitcast %struct.output_buffer* %buffer to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %os.0..sroa_cast.i, i8* %0, i64 80, i32 8, i1 false) #2, !tbaa.struct !5
  %prefix.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 0
  store i8* null, i8** %prefix.i, align 8, !tbaa !11
  %prefixing_rule.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 6
  store i32 1, i32* %prefixing_rule.i, align 4, !tbaa !17
  %cursor.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 7
  store i8* %msgid, i8** %cursor.i, align 8, !tbaa !37
  %format_args.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 8
  store [1 x %struct.__va_list_tag]* %ap, [1 x %struct.__va_list_tag]** %format_args.i, align 8, !tbaa !36
  %ideal_maximum_length.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 2
  store i32 0, i32* %ideal_maximum_length.i.i, align 4, !tbaa !16
  %maximum_length.i.i.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  store i32 0, i32* %maximum_length.i.i.i, align 4, !tbaa !18
  call fastcc void @output_format(%struct.output_buffer* %buffer) #2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %os.0..sroa_cast.i, i64 80, i32 8, i1 false) #2, !tbaa.struct !5
  call void @llvm.lifetime.end(i64 80, i8* %os.0..sroa_cast.i)
  call void @llvm.va_end(i8* %arraydecay1)
  ret void
}

; Function Attrs: nounwind readonly uwtable
define i8* @trim_filename(i8* readonly %name) #1 {
entry:
  %0 = load i8* %name, align 1, !tbaa !10
  %cmp83 = icmp eq i8 %0, 46
  br i1 %cmp83, label %land.lhs.true, label %while.cond29.preheader

while.cond:                                       ; preds = %land.rhs
  %1 = load i8* %add.ptr, align 1, !tbaa !10
  %cmp = icmp eq i8 %1, 46
  br i1 %cmp, label %land.lhs.true, label %while.cond29.preheader

while.cond29.preheader:                           ; preds = %while.cond, %entry
  %2 = phi i8 [ %0, %entry ], [ %1, %while.cond ]
  %p.0.lcssa = phi i8* [ %name, %entry ], [ %add.ptr, %while.cond ]
  %cmp3278 = icmp eq i8 %2, 100
  br i1 %cmp3278, label %while.body43, label %while.cond46

land.lhs.true:                                    ; preds = %entry, %while.cond
  %p.084 = phi i8* [ %add.ptr, %while.cond ], [ %name, %entry ]
  %arrayidx2 = getelementptr inbounds i8* %p.084, i64 1
  %3 = load i8* %arrayidx2, align 1, !tbaa !10
  %cmp4 = icmp eq i8 %3, 46
  br i1 %cmp4, label %land.rhs, label %while.cond46

land.rhs:                                         ; preds = %land.lhs.true
  %arrayidx6 = getelementptr inbounds i8* %p.084, i64 2
  %4 = load i8* %arrayidx6, align 1, !tbaa !10
  %cmp8 = icmp eq i8 %4, 47
  %add.ptr = getelementptr inbounds i8* %p.084, i64 3
  br i1 %cmp8, label %while.cond, label %while.cond46

while.body43:                                     ; preds = %while.cond29.preheader, %while.body43
  %q.182 = phi i8* [ %incdec.ptr44, %while.body43 ], [ getelementptr inbounds ([13 x i8]* @.str26, i64 0, i64 0), %while.cond29.preheader ]
  %p.181 = phi i8* [ %incdec.ptr, %while.body43 ], [ %p.0.lcssa, %while.cond29.preheader ]
  %incdec.ptr = getelementptr inbounds i8* %p.181, i64 1
  %incdec.ptr44 = getelementptr inbounds i8* %q.182, i64 1
  %5 = load i8* %incdec.ptr, align 1, !tbaa !10
  %6 = load i8* %incdec.ptr44, align 1, !tbaa !10
  %cmp32 = icmp ne i8 %5, %6
  %cmp36 = icmp eq i8 %5, 0
  %or.cond = or i1 %cmp32, %cmp36
  %cmp40 = icmp eq i8 %6, 0
  %or.cond77 = or i1 %or.cond, %cmp40
  br i1 %or.cond77, label %while.cond46, label %while.body43

while.cond46:                                     ; preds = %while.cond29.preheader, %while.body43, %land.lhs.true, %land.rhs, %land.rhs49
  %p.2 = phi i8* [ %arrayidx50, %land.rhs49 ], [ %p.0.lcssa, %while.cond29.preheader ], [ %incdec.ptr, %while.body43 ], [ %p.084, %land.lhs.true ], [ %p.084, %land.rhs ]
  %cmp47 = icmp ugt i8* %p.2, %name
  br i1 %cmp47, label %land.rhs49, label %while.end57

land.rhs49:                                       ; preds = %while.cond46
  %arrayidx50 = getelementptr inbounds i8* %p.2, i64 -1
  %7 = load i8* %arrayidx50, align 1, !tbaa !10
  %cmp52 = icmp eq i8 %7, 47
  br i1 %cmp52, label %while.end57, label %while.cond46

while.end57:                                      ; preds = %land.rhs49, %while.cond46
  ret i8* %p.2
}

; Function Attrs: noreturn nounwind uwtable
define void @fancy_abort(i8* %file, i32 %line, i8* %function) #6 {
entry:
  %0 = load i8* %file, align 1, !tbaa !10
  %cmp83.i = icmp eq i8 %0, 46
  br i1 %cmp83.i, label %land.lhs.true.i, label %while.cond29.preheader.i

while.cond.i:                                     ; preds = %land.rhs.i
  %1 = load i8* %add.ptr.i, align 1, !tbaa !10
  %cmp.i = icmp eq i8 %1, 46
  br i1 %cmp.i, label %land.lhs.true.i, label %while.cond29.preheader.i

while.cond29.preheader.i:                         ; preds = %while.cond.i, %entry
  %2 = phi i8 [ %0, %entry ], [ %1, %while.cond.i ]
  %p.0.lcssa.i = phi i8* [ %file, %entry ], [ %add.ptr.i, %while.cond.i ]
  %cmp3278.i = icmp eq i8 %2, 100
  br i1 %cmp3278.i, label %while.body43.i, label %while.cond46.i

land.lhs.true.i:                                  ; preds = %entry, %while.cond.i
  %p.084.i = phi i8* [ %add.ptr.i, %while.cond.i ], [ %file, %entry ]
  %arrayidx2.i = getelementptr inbounds i8* %p.084.i, i64 1
  %3 = load i8* %arrayidx2.i, align 1, !tbaa !10
  %cmp4.i = icmp eq i8 %3, 46
  br i1 %cmp4.i, label %land.rhs.i, label %while.cond46.i

land.rhs.i:                                       ; preds = %land.lhs.true.i
  %arrayidx6.i = getelementptr inbounds i8* %p.084.i, i64 2
  %4 = load i8* %arrayidx6.i, align 1, !tbaa !10
  %cmp8.i = icmp eq i8 %4, 47
  %add.ptr.i = getelementptr inbounds i8* %p.084.i, i64 3
  br i1 %cmp8.i, label %while.cond.i, label %while.cond46.i

while.body43.i:                                   ; preds = %while.cond29.preheader.i, %while.body43.i
  %q.182.i = phi i8* [ %incdec.ptr44.i, %while.body43.i ], [ getelementptr inbounds ([13 x i8]* @.str26, i64 0, i64 0), %while.cond29.preheader.i ]
  %p.181.i = phi i8* [ %incdec.ptr.i, %while.body43.i ], [ %p.0.lcssa.i, %while.cond29.preheader.i ]
  %incdec.ptr.i = getelementptr inbounds i8* %p.181.i, i64 1
  %incdec.ptr44.i = getelementptr inbounds i8* %q.182.i, i64 1
  %5 = load i8* %incdec.ptr.i, align 1, !tbaa !10
  %6 = load i8* %incdec.ptr44.i, align 1, !tbaa !10
  %cmp32.i = icmp ne i8 %5, %6
  %cmp36.i = icmp eq i8 %5, 0
  %or.cond.i = or i1 %cmp32.i, %cmp36.i
  %cmp40.i = icmp eq i8 %6, 0
  %or.cond77.i = or i1 %or.cond.i, %cmp40.i
  br i1 %or.cond77.i, label %while.cond46.i, label %while.body43.i

while.cond46.i:                                   ; preds = %while.cond29.preheader.i, %while.body43.i, %land.rhs.i, %land.lhs.true.i, %land.rhs49.i
  %p.2.i = phi i8* [ %arrayidx50.i, %land.rhs49.i ], [ %p.0.lcssa.i, %while.cond29.preheader.i ], [ %incdec.ptr.i, %while.body43.i ], [ %p.084.i, %land.rhs.i ], [ %p.084.i, %land.lhs.true.i ]
  %cmp47.i = icmp ugt i8* %p.2.i, %file
  br i1 %cmp47.i, label %land.rhs49.i, label %trim_filename.exit

land.rhs49.i:                                     ; preds = %while.cond46.i
  %arrayidx50.i = getelementptr inbounds i8* %p.2.i, i64 -1
  %7 = load i8* %arrayidx50.i, align 1, !tbaa !10
  %cmp52.i = icmp eq i8 %7, 47
  br i1 %cmp52.i, label %trim_filename.exit, label %while.cond46.i

trim_filename.exit:                               ; preds = %while.cond46.i, %land.rhs49.i
  tail call void (i8*, ...)* @internal_error(i8* getelementptr inbounds ([40 x i8]* @.str17, i64 0, i64 0), i8* %function, i8* %p.2.i, i32 %line) #11
  unreachable
}

; Function Attrs: nounwind uwtable
define void @warn_deprecated_use(%union.tree_node* readonly %node) #0 {
entry:
  %cmp = icmp ne %union.tree_node* %node, null
  %0 = load i32* @warn_deprecated_decl, align 4
  %tobool = icmp ne i32 %0, 0
  %or.cond = and i1 %cmp, %tobool
  br i1 %or.cond, label %if.end, label %if.end76

if.end:                                           ; preds = %entry
  %code = getelementptr inbounds %union.tree_node* %node, i64 0, i32 0, i32 0, i32 2
  %bf.load = load i32* %code, align 8
  %bf.clear = and i32 %bf.load, 255
  %idxprom91 = zext i32 %bf.clear to i64
  %arrayidx = getelementptr inbounds [256 x i8]* @tree_code_type, i64 0, i64 %idxprom91
  %1 = load i8* %arrayidx, align 1, !tbaa !10
  switch i8 %1, label %if.end76 [
    i8 100, label %if.then3
    i8 116, label %if.then15
  ]

if.then3:                                         ; preds = %if.end
  %name = getelementptr inbounds %union.tree_node* %node, i64 0, i32 0, i32 8
  %2 = load %union.tree_node** %name, align 8, !tbaa !46
  %id = getelementptr inbounds %union.tree_node* %2, i64 0, i32 0, i32 1
  %3 = getelementptr inbounds i8** %id, i64 1
  %4 = load i8** %3, align 8, !tbaa !49
  %filename = getelementptr inbounds %union.tree_node* %node, i64 0, i32 0, i32 1
  %5 = load i8** %filename, align 8, !tbaa !42
  %linenum = getelementptr inbounds %union.tree_node* %node, i64 0, i32 0, i32 2
  %6 = load i32* %linenum, align 4, !tbaa !45
  tail call void (i8*, ...)* @warning(i8* getelementptr inbounds ([39 x i8]* @.str21, i64 0, i64 0), i8* %4, i8* %5, i32 %6)
  br label %if.end76

if.then15:                                        ; preds = %if.end
  %chain = getelementptr inbounds %union.tree_node* %node, i64 0, i32 0, i32 0, i32 0
  %7 = load %union.tree_node** %chain, align 8, !tbaa !57
  %8 = getelementptr inbounds %union.tree_node* %node, i64 0, i32 0, i32 11
  %9 = load %union.tree_node** %8, align 8, !tbaa !58
  %code20 = getelementptr inbounds %union.tree_node* %9, i64 0, i32 0, i32 0, i32 2
  %bf.load21 = load i32* %code20, align 8
  %bf.clear22 = and i32 %bf.load21, 255
  switch i32 %bf.clear22, label %if.end54.thread [
    i32 1, label %if.end54
    i32 33, label %land.lhs.true
  ]

land.lhs.true:                                    ; preds = %if.then15
  %name43 = getelementptr inbounds %union.tree_node* %9, i64 0, i32 0, i32 8
  %10 = load %union.tree_node** %name43, align 8, !tbaa !46
  %tobool44 = icmp eq %union.tree_node* %10, null
  br i1 %tobool44, label %if.end54.thread, label %if.end54

if.end54.thread:                                  ; preds = %land.lhs.true, %if.then15
  %tobool5793 = icmp eq %union.tree_node* %7, null
  br i1 %tobool5793, label %if.else72, label %if.then67

if.end54:                                         ; preds = %land.lhs.true, %if.then15
  %.pn = phi %union.tree_node* [ %9, %if.then15 ], [ %10, %land.lhs.true ]
  %id29.pn = getelementptr inbounds %union.tree_node* %.pn, i64 0, i32 0, i32 1
  %what.0.in = getelementptr inbounds i8** %id29.pn, i64 1
  %what.0 = load i8** %what.0.in, align 8
  %tobool55 = icmp eq i8* %what.0, null
  %tobool57 = icmp ne %union.tree_node* %7, null
  br i1 %tobool55, label %if.else65, label %if.then56

if.then56:                                        ; preds = %if.end54
  br i1 %tobool57, label %if.then58, label %if.else63

if.then58:                                        ; preds = %if.then56
  %filename60 = getelementptr inbounds %union.tree_node* %7, i64 0, i32 0, i32 1
  %11 = load i8** %filename60, align 8, !tbaa !42
  %linenum62 = getelementptr inbounds %union.tree_node* %7, i64 0, i32 0, i32 2
  %12 = load i32* %linenum62, align 4, !tbaa !45
  tail call void (i8*, ...)* @warning(i8* getelementptr inbounds ([39 x i8]* @.str21, i64 0, i64 0), i8* %what.0, i8* %11, i32 %12)
  br label %if.end76

if.else63:                                        ; preds = %if.then56
  tail call void (i8*, ...)* @warning(i8* getelementptr inbounds ([19 x i8]* @.str22, i64 0, i64 0), i8* %what.0)
  br label %if.end76

if.else65:                                        ; preds = %if.end54
  br i1 %tobool57, label %if.then67, label %if.else72

if.then67:                                        ; preds = %if.end54.thread, %if.else65
  %filename69 = getelementptr inbounds %union.tree_node* %7, i64 0, i32 0, i32 1
  %13 = load i8** %filename69, align 8, !tbaa !42
  %linenum71 = getelementptr inbounds %union.tree_node* %7, i64 0, i32 0, i32 2
  %14 = load i32* %linenum71, align 4, !tbaa !45
  tail call void (i8*, ...)* @warning(i8* getelementptr inbounds ([39 x i8]* @.str23, i64 0, i64 0), i8* %13, i32 %14)
  br label %if.end76

if.else72:                                        ; preds = %if.end54.thread, %if.else65
  tail call void (i8*, ...)* @warning(i8* getelementptr inbounds ([19 x i8]* @.str24, i64 0, i64 0))
  br label %if.end76

if.end76:                                         ; preds = %if.end, %if.then67, %if.else72, %if.then58, %if.else63, %entry, %if.then3
  ret void
}

; Function Attrs: nounwind
declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #4

; Function Attrs: nounwind uwtable
define internal fastcc void @wrap_text(%struct.output_buffer* %buffer, i8* %start, i8* readnone %end) #0 {
entry:
  %ideal_maximum_length.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 2
  %0 = load i32* %ideal_maximum_length.i, align 4, !tbaa !16
  %cmp.i = icmp sgt i32 %0, 0
  %cmp102 = icmp eq i8* %start, %end
  br i1 %cmp102, label %while.end32, label %while.cond1.preheader.lr.ph

while.cond1.preheader.lr.ph:                      ; preds = %entry
  %maximum_length.i = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 0, i32 1
  %line_length.i58 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 3
  %next_free.i68 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 3
  %chunk_limit.i70 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2, i32 4
  %obstack.i72 = getelementptr inbounds %struct.output_buffer* %buffer, i64 0, i32 2
  br label %while.cond1.preheader

while.cond1.preheader:                            ; preds = %while.cond1.preheader.lr.ph, %while.cond.backedge
  %start.addr.0103 = phi i8* [ %start, %while.cond1.preheader.lr.ph ], [ %start.addr.0.be, %while.cond.backedge ]
  %cmp293 = icmp eq i8* %start.addr.0103, %end
  br i1 %cmp293, label %while.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.cond1.preheader, %while.body8
  %p.094 = phi i8* [ %incdec.ptr, %while.body8 ], [ %start.addr.0103, %while.cond1.preheader ]
  %1 = load i8* %p.094, align 1, !tbaa !10
  switch i8 %1, label %while.body8 [
    i8 32, label %while.end
    i8 10, label %while.end
  ]

while.body8:                                      ; preds = %land.lhs.true
  %incdec.ptr = getelementptr inbounds i8* %p.094, i64 1
  %cmp2 = icmp eq i8* %incdec.ptr, %end
  br i1 %cmp2, label %while.end, label %land.lhs.true

while.end:                                        ; preds = %while.body8, %land.lhs.true, %land.lhs.true, %while.cond1.preheader
  %cmp2.lcssa = phi i1 [ false, %while.cond1.preheader ], [ false, %while.body8 ], [ true, %land.lhs.true ], [ true, %land.lhs.true ]
  %p.0.lcssa = phi i8* [ %end, %while.cond1.preheader ], [ %end, %while.body8 ], [ %p.094, %land.lhs.true ], [ %p.094, %land.lhs.true ]
  br i1 %cmp.i, label %land.lhs.true9, label %while.end.if.end_crit_edge

while.end.if.end_crit_edge:                       ; preds = %while.end
  %.pre = load i32* %line_length.i58, align 4, !tbaa !25
  br label %if.end

land.lhs.true9:                                   ; preds = %while.end
  %sub.ptr.lhs.cast = ptrtoint i8* %p.0.lcssa to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %start.addr.0103 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %2 = load i32* %maximum_length.i, align 4, !tbaa !18
  %3 = load i32* %line_length.i58, align 4, !tbaa !25
  %sub.i = sub nsw i32 %2, %3
  %conv11 = sext i32 %sub.i to i64
  %cmp12 = icmp slt i64 %sub.ptr.sub, %conv11
  br i1 %cmp12, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true9
  %4 = load i8** %next_free.i68, align 8, !tbaa !23
  %add.ptr.i69 = getelementptr inbounds i8* %4, i64 1
  %5 = load i8** %chunk_limit.i70, align 8, !tbaa !24
  %cmp.i71 = icmp ugt i8* %add.ptr.i69, %5
  br i1 %cmp.i71, label %if.then.i74, label %if.end.thread

if.then.i74:                                      ; preds = %if.then
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i72, i32 1) #2
  %.pre.i73 = load i8** %next_free.i68, align 8, !tbaa !23
  br label %if.end.thread

if.end.thread:                                    ; preds = %if.then.i74, %if.then
  %6 = phi i8* [ %.pre.i73, %if.then.i74 ], [ %4, %if.then ]
  %incdec.ptr.i75 = getelementptr inbounds i8* %6, i64 1
  store i8* %incdec.ptr.i75, i8** %next_free.i68, align 8, !tbaa !23
  store i8 10, i8* %6, align 1, !tbaa !10
  store i32 0, i32* %line_length.i58, align 4, !tbaa !25
  br label %if.then.i83

if.end:                                           ; preds = %while.end.if.end_crit_edge, %land.lhs.true9
  %7 = phi i32 [ %.pre, %while.end.if.end_crit_edge ], [ %3, %land.lhs.true9 ]
  %cmp.i80 = icmp eq i32 %7, 0
  br i1 %cmp.i80, label %if.then.i83, label %if.end5.i

if.then.i83:                                      ; preds = %if.end.thread, %if.end
  tail call void @output_emit_prefix(%struct.output_buffer* %buffer) #2
  %8 = load i32* %ideal_maximum_length.i, align 4, !tbaa !16
  %cmp.i.i82 = icmp slt i32 %8, 1
  %cmp216.i = icmp eq i8* %start.addr.0103, %p.0.lcssa
  %or.cond.i = or i1 %cmp.i.i82, %cmp216.i
  br i1 %or.cond.i, label %if.end5.i, label %land.rhs.i

while.cond.i:                                     ; preds = %land.rhs.i
  %cmp2.i84 = icmp eq i8* %incdec.ptr.i85, %p.0.lcssa
  br i1 %cmp2.i84, label %if.end5.i, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then.i83, %while.cond.i
  %start.addr.017.i = phi i8* [ %incdec.ptr.i85, %while.cond.i ], [ %start.addr.0103, %if.then.i83 ]
  %9 = load i8* %start.addr.017.i, align 1, !tbaa !10
  %cmp3.i = icmp eq i8 %9, 32
  %incdec.ptr.i85 = getelementptr inbounds i8* %start.addr.017.i, i64 1
  br i1 %cmp3.i, label %while.cond.i, label %if.end5.i

if.end5.i:                                        ; preds = %land.rhs.i, %while.cond.i, %if.then.i83, %if.end
  %start.addr.1.i = phi i8* [ %start.addr.0103, %if.then.i83 ], [ %start.addr.0103, %if.end ], [ %start.addr.017.i, %land.rhs.i ], [ %p.0.lcssa, %while.cond.i ]
  %sub.ptr.lhs.cast.i = ptrtoint i8* %p.0.lcssa to i64
  %sub.ptr.rhs.cast.i = ptrtoint i8* %start.addr.1.i to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv6.i = trunc i64 %sub.ptr.sub.i to i32
  %10 = load i8** %next_free.i68, align 8, !tbaa !23
  %sext.i = shl i64 %sub.ptr.sub.i, 32
  %idx.ext.i.i = ashr exact i64 %sext.i, 32
  %add.ptr.i.i87 = getelementptr inbounds i8* %10, i64 %idx.ext.i.i
  %11 = load i8** %chunk_limit.i70, align 8, !tbaa !24
  %cmp.i15.i = icmp ugt i8* %add.ptr.i.i87, %11
  br i1 %cmp.i15.i, label %if.then.i.i91, label %output_append.exit

if.then.i.i91:                                    ; preds = %if.end5.i
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i72, i32 %conv6.i) #2
  %.pre.i.i90 = load i8** %next_free.i68, align 8, !tbaa !23
  br label %output_append.exit

output_append.exit:                               ; preds = %if.end5.i, %if.then.i.i91
  %12 = phi i8* [ %.pre.i.i90, %if.then.i.i91 ], [ %10, %if.end5.i ]
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %start.addr.1.i, i64 %idx.ext.i.i, i32 1, i1 false) #2
  %13 = load i8** %next_free.i68, align 8, !tbaa !23
  %add.ptr4.i.i = getelementptr inbounds i8* %13, i64 %idx.ext.i.i
  store i8* %add.ptr4.i.i, i8** %next_free.i68, align 8, !tbaa !23
  %14 = load i32* %line_length.i58, align 4, !tbaa !25
  %add.i.i = add nsw i32 %14, %conv6.i
  store i32 %add.i.i, i32* %line_length.i58, align 4, !tbaa !25
  br i1 %cmp2.lcssa, label %land.lhs.true16, label %if.end22

land.lhs.true16:                                  ; preds = %output_append.exit
  %15 = load i8* %p.0.lcssa, align 1, !tbaa !10
  %cmp18 = icmp eq i8 %15, 32
  br i1 %cmp18, label %if.then20, label %if.end22

if.then20:                                        ; preds = %land.lhs.true16
  %16 = load i32* %ideal_maximum_length.i, align 4, !tbaa !16
  %cmp.i.i = icmp sgt i32 %16, 0
  br i1 %cmp.i.i, label %land.lhs.true.i, label %if.end.i

land.lhs.true.i:                                  ; preds = %if.then20
  %17 = load i32* %maximum_length.i, align 4, !tbaa !18
  %sub.i.i = sub nsw i32 %17, %add.i.i
  %cmp.i59 = icmp slt i32 %sub.i.i, 1
  br i1 %cmp.i59, label %if.then.i60, label %if.end.i

if.then.i60:                                      ; preds = %land.lhs.true.i
  %add.ptr4.i.i.sum109 = add i64 %idx.ext.i.i, 1
  %add.ptr.i.i = getelementptr inbounds i8* %13, i64 %add.ptr4.i.i.sum109
  %18 = load i8** %chunk_limit.i70, align 8, !tbaa !24
  %cmp.i13.i = icmp ugt i8* %add.ptr.i.i, %18
  br i1 %cmp.i13.i, label %if.then.i.i, label %output_add_newline.exit.i

if.then.i.i:                                      ; preds = %if.then.i60
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i72, i32 1) #2
  %.pre.i.i = load i8** %next_free.i68, align 8, !tbaa !23
  br label %output_add_newline.exit.i

output_add_newline.exit.i:                        ; preds = %if.then.i.i, %if.then.i60
  %19 = phi i8* [ %.pre.i.i, %if.then.i.i ], [ %add.ptr4.i.i, %if.then.i60 ]
  %incdec.ptr.i.i = getelementptr inbounds i8* %19, i64 1
  store i8* %incdec.ptr.i.i, i8** %next_free.i68, align 8, !tbaa !23
  store i8 10, i8* %19, align 1, !tbaa !10
  br label %output_add_space.exit

if.end.i:                                         ; preds = %land.lhs.true.i, %if.then20
  %add.ptr4.i.i.sum = add i64 %idx.ext.i.i, 1
  %add.ptr.i62 = getelementptr inbounds i8* %13, i64 %add.ptr4.i.i.sum
  %20 = load i8** %chunk_limit.i70, align 8, !tbaa !24
  %cmp2.i = icmp ugt i8* %add.ptr.i62, %20
  br i1 %cmp2.i, label %if.then3.i, label %if.end4.i

if.then3.i:                                       ; preds = %if.end.i
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i72, i32 1) #2
  %.pre.i65 = load i8** %next_free.i68, align 8, !tbaa !23
  br label %if.end4.i

if.end4.i:                                        ; preds = %if.then3.i, %if.end.i
  %21 = phi i8* [ %.pre.i65, %if.then3.i ], [ %add.ptr4.i.i, %if.end.i ]
  %incdec.ptr.i66 = getelementptr inbounds i8* %21, i64 1
  store i8* %incdec.ptr.i66, i8** %next_free.i68, align 8, !tbaa !23
  store i8 32, i8* %21, align 1, !tbaa !10
  %22 = load i32* %line_length.i58, align 4, !tbaa !25
  %inc.i = add nsw i32 %22, 1
  br label %output_add_space.exit

output_add_space.exit:                            ; preds = %output_add_newline.exit.i, %if.end4.i
  %storemerge = phi i32 [ %inc.i, %if.end4.i ], [ 0, %output_add_newline.exit.i ]
  store i32 %storemerge, i32* %line_length.i58, align 4, !tbaa !25
  %incdec.ptr21 = getelementptr inbounds i8* %p.0.lcssa, i64 1
  br label %if.end22

if.end22:                                         ; preds = %output_add_space.exit, %land.lhs.true16, %output_append.exit
  %start.addr.1 = phi i8* [ %incdec.ptr21, %output_add_space.exit ], [ %p.0.lcssa, %land.lhs.true16 ], [ %p.0.lcssa, %output_append.exit ]
  %cmp23 = icmp eq i8* %start.addr.1, %end
  br i1 %cmp23, label %while.end32, label %land.lhs.true25

land.lhs.true25:                                  ; preds = %if.end22
  %23 = load i8* %start.addr.1, align 1, !tbaa !10
  %cmp27 = icmp eq i8 %23, 10
  br i1 %cmp27, label %if.then29, label %while.cond.backedge

if.then29:                                        ; preds = %land.lhs.true25
  %24 = load i8** %next_free.i68, align 8, !tbaa !23
  %add.ptr.i = getelementptr inbounds i8* %24, i64 1
  %25 = load i8** %chunk_limit.i70, align 8, !tbaa !24
  %cmp.i57 = icmp ugt i8* %add.ptr.i, %25
  br i1 %cmp.i57, label %if.then.i, label %output_add_newline.exit

if.then.i:                                        ; preds = %if.then29
  tail call void @_obstack_newchunk(%struct.obstack* %obstack.i72, i32 1) #2
  %.pre.i = load i8** %next_free.i68, align 8, !tbaa !23
  br label %output_add_newline.exit

output_add_newline.exit:                          ; preds = %if.then29, %if.then.i
  %26 = phi i8* [ %.pre.i, %if.then.i ], [ %24, %if.then29 ]
  %incdec.ptr.i = getelementptr inbounds i8* %26, i64 1
  store i8* %incdec.ptr.i, i8** %next_free.i68, align 8, !tbaa !23
  store i8 10, i8* %26, align 1, !tbaa !10
  store i32 0, i32* %line_length.i58, align 4, !tbaa !25
  %incdec.ptr30 = getelementptr inbounds i8* %start.addr.1, i64 1
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %output_add_newline.exit, %land.lhs.true25
  %start.addr.0.be = phi i8* [ %incdec.ptr30, %output_add_newline.exit ], [ %start.addr.1, %land.lhs.true25 ]
  %cmp = icmp eq i8* %start.addr.0.be, %end
  br i1 %cmp, label %while.end32, label %while.cond1.preheader

while.end32:                                      ; preds = %if.end22, %while.cond.backedge, %entry
  ret void
}

declare i32 @vasprintf(i8**, i8*, %struct.__va_list_tag*) #3

; Function Attrs: nounwind
declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #4

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readonly uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind }
attributes #3 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { noreturn nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind readnone "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { noreturn "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { nounwind readnone }
attributes #10 = { noreturn nounwind }
attributes #11 = { noreturn }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5 (trunk)"}
!1 = metadata !{metadata !2, metadata !2, i64 0}
!2 = metadata !{metadata !"any pointer", metadata !3, i64 0}
!3 = metadata !{metadata !"omnipotent char", metadata !4, i64 0}
!4 = metadata !{metadata !"Simple C/C++ TBAA"}
!5 = metadata !{i64 0, i64 8, metadata !1, i64 8, i64 4, metadata !6, i64 12, i64 4, metadata !6, i64 16, i64 4, metadata !6, i64 20, i64 1, metadata !8, i64 21, i64 1, metadata !8, i64 24, i64 4, metadata !10, i64 32, i64 8, metadata !1, i64 40, i64 8, metadata !1, i64 48, i64 28, metadata !10}
!6 = metadata !{metadata !7, metadata !7, i64 0}
!7 = metadata !{metadata !"int", metadata !3, i64 0}
!8 = metadata !{metadata !9, metadata !9, i64 0}
!9 = metadata !{metadata !"_Bool", metadata !3, i64 0}
!10 = metadata !{metadata !3, metadata !3, i64 0}
!11 = metadata !{metadata !12, metadata !2, i64 0}
!12 = metadata !{metadata !"output_buffer", metadata !13, i64 0, metadata !2, i64 80, metadata !14, i64 88, metadata !7, i64 176, metadata !3, i64 180, metadata !2, i64 312}
!13 = metadata !{metadata !"", metadata !2, i64 0, metadata !7, i64 8, metadata !7, i64 12, metadata !7, i64 16, metadata !9, i64 20, metadata !9, i64 21, metadata !3, i64 24, metadata !2, i64 32, metadata !2, i64 40, metadata !3, i64 48}
!14 = metadata !{metadata !"obstack", metadata !15, i64 0, metadata !2, i64 8, metadata !2, i64 16, metadata !2, i64 24, metadata !2, i64 32, metadata !15, i64 40, metadata !7, i64 48, metadata !2, i64 56, metadata !2, i64 64, metadata !2, i64 72, metadata !7, i64 80, metadata !7, i64 80, metadata !7, i64 80}
!15 = metadata !{metadata !"long", metadata !3, i64 0}
!16 = metadata !{metadata !12, metadata !7, i64 12}
!17 = metadata !{metadata !12, metadata !3, i64 24}
!18 = metadata !{metadata !12, metadata !7, i64 8}
!19 = metadata !{metadata !12, metadata !9, i64 20}
!20 = metadata !{metadata !12, metadata !7, i64 16}
!21 = metadata !{metadata !22, metadata !2, i64 8}
!22 = metadata !{metadata !"tree_common", metadata !2, i64 0, metadata !2, i64 8, metadata !3, i64 16, metadata !7, i64 17, metadata !7, i64 17, metadata !7, i64 17, metadata !7, i64 17, metadata !7, i64 17, metadata !7, i64 17, metadata !7, i64 17, metadata !7, i64 17, metadata !7, i64 18, metadata !7, i64 18, metadata !7, i64 18, metadata !7, i64 18, metadata !7, i64 18, metadata !7, i64 18, metadata !7, i64 18, metadata !7, i64 18, metadata !7, i64 19, metadata !7, i64 19, metadata !7, i64 19, metadata !7, i64 19, metadata !7, i64 19, metadata !7, i64 19, metadata !7, i64 19, metadata !7, i64 19}
!23 = metadata !{metadata !14, metadata !2, i64 24}
!24 = metadata !{metadata !14, metadata !2, i64 32}
!25 = metadata !{metadata !12, metadata !7, i64 176}
!26 = metadata !{metadata !14, metadata !2, i64 16}
!27 = metadata !{metadata !12, metadata !2, i64 80}
!28 = metadata !{metadata !14, metadata !2, i64 8}
!29 = metadata !{metadata !30, metadata !2, i64 352}
!30 = metadata !{metadata !"diagnostic_context", metadata !12, i64 0, metadata !2, i64 320, metadata !2, i64 328, metadata !2, i64 336, metadata !7, i64 344, metadata !7, i64 348, metadata !2, i64 352, metadata !2, i64 360, metadata !2, i64 368}
!31 = metadata !{metadata !30, metadata !2, i64 360}
!32 = metadata !{metadata !30, metadata !2, i64 336}
!33 = metadata !{metadata !30, metadata !7, i64 344}
!34 = metadata !{metadata !30, metadata !7, i64 348}
!35 = metadata !{i8 0, i8 2}
!36 = metadata !{metadata !12, metadata !2, i64 40}
!37 = metadata !{metadata !12, metadata !2, i64 32}
!38 = metadata !{metadata !13, metadata !2, i64 40}
!39 = metadata !{metadata !12, metadata !2, i64 312}
!40 = metadata !{metadata !30, metadata !2, i64 320}
!41 = metadata !{metadata !30, metadata !2, i64 328}
!42 = metadata !{metadata !43, metadata !2, i64 24}
!43 = metadata !{metadata !"tree_decl", metadata !22, i64 0, metadata !2, i64 24, metadata !7, i64 32, metadata !7, i64 36, metadata !2, i64 40, metadata !3, i64 48, metadata !7, i64 49, metadata !7, i64 49, metadata !7, i64 49, metadata !7, i64 49, metadata !7, i64 49, metadata !7, i64 49, metadata !7, i64 49, metadata !7, i64 49, metadata !7, i64 50, metadata !7, i64 50, metadata !7, i64 50, metadata !7, i64 50, metadata !7, i64 50, metadata !7, i64 50, metadata !7, i64 50, metadata !7, i64 50, metadata !7, i64 51, metadata !7, i64 51, metadata !7, i64 51, metadata !7, i64 51, metadata !7, i64 51, metadata !3, i64 51, metadata !7, i64 51, metadata !7, i64 52, metadata !7, i64 52, metadata !7, i64 52, metadata !7, i64 52, metadata !7, i64 52, metadata !7, i64 52, metadata !7, i64 52, metadata !7, i64 53, metadata !7, i64 53, metadata !7, i64 53, metadata !7, i64 53, metadata !7, i64 53, metadata !3, i64 56, metadata !2, i64 64, metadata !2, i64 72, metadata !2, i64 80, metadata !2, i64 88, metadata !2, i64 96, metadata !2, i64 104, metadata !2, i64 112, metadata !2, i64 120, metadata !2, i64 128, metadata !2, i64 136, metadata !2, i64 144, metadata !2, i64 152, metadata !3, i64 160, metadata !2, i64 168, metadata !2, i64 176, metadata !2, i64 184, metadata !44, i64 192, metadata !2, i64 200}
!44 = metadata !{metadata !"long long", metadata !3, i64 0}
!45 = metadata !{metadata !43, metadata !7, i64 32}
!46 = metadata !{metadata !43, metadata !2, i64 72}
!47 = metadata !{metadata !48, metadata !48, i64 0}
!48 = metadata !{metadata !"short", metadata !3, i64 0}
!49 = metadata !{metadata !50, metadata !2, i64 32}
!50 = metadata !{metadata !"tree_identifier", metadata !22, i64 0, metadata !51, i64 24}
!51 = metadata !{metadata !"ht_identifier", metadata !7, i64 0, metadata !2, i64 8}
!52 = metadata !{metadata !12, metadata !9, i64 21}
!53 = metadata !{metadata !54, metadata !2, i64 8}
!54 = metadata !{metadata !"file_stack", metadata !2, i64 0, metadata !2, i64 8, metadata !7, i64 16, metadata !7, i64 20}
!55 = metadata !{metadata !54, metadata !2, i64 0}
!56 = metadata !{metadata !54, metadata !7, i64 16}
!57 = metadata !{metadata !22, metadata !2, i64 0}
!58 = metadata !{metadata !59, metadata !2, i64 96}
!59 = metadata !{metadata !"tree_type", metadata !22, i64 0, metadata !2, i64 24, metadata !2, i64 32, metadata !2, i64 40, metadata !2, i64 48, metadata !7, i64 56, metadata !7, i64 60, metadata !3, i64 61, metadata !7, i64 62, metadata !7, i64 62, metadata !7, i64 62, metadata !7, i64 62, metadata !7, i64 62, metadata !7, i64 62, metadata !7, i64 62, metadata !7, i64 63, metadata !7, i64 63, metadata !7, i64 63, metadata !7, i64 63, metadata !7, i64 63, metadata !7, i64 63, metadata !7, i64 63, metadata !7, i64 63, metadata !7, i64 64, metadata !2, i64 72, metadata !2, i64 80, metadata !3, i64 88, metadata !2, i64 96, metadata !2, i64 104, metadata !2, i64 112, metadata !2, i64 120, metadata !2, i64 128, metadata !2, i64 136, metadata !2, i64 144, metadata !44, i64 152, metadata !2, i64 160}
